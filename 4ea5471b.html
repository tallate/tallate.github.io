<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"tallate.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.18.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="就 ZooKeeper 来说，只明白原理是不够的，因为实际场景非常多，在不同场景下 ZooKeeper 几乎都有不同的应用模式，不过幸运的是 ZooKeeper 已经有一个比较完善的客户端 Curator，在生产环境下几乎不需要投入太多人力就可以解决大部分集群协调问题。">
<meta property="og:type" content="article">
<meta property="og:title" content="ZooKeeper 的使用">
<meta property="og:url" content="https://tallate.github.io/4ea5471b.html">
<meta property="og:site_name" content="Tallate">
<meta property="og:description" content="就 ZooKeeper 来说，只明白原理是不够的，因为实际场景非常多，在不同场景下 ZooKeeper 几乎都有不同的应用模式，不过幸运的是 ZooKeeper 已经有一个比较完善的客户端 Curator，在生产环境下几乎不需要投入太多人力就可以解决大部分集群协调问题。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2019-07-29T10:52:36.000Z">
<meta property="article:modified_time" content="2025-07-06T17:56:20.883Z">
<meta property="article:author" content="tallate">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://tallate.github.io/4ea5471b.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://tallate.github.io/4ea5471b.html","path":"/4ea5471b.html","title":"ZooKeeper 的使用"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>ZooKeeper 的使用 | Tallate</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Tallate</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">该吃吃该喝喝 啥事别往心里搁</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签<span class="badge">80</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="th fa-fw"></i>分类<span class="badge">25</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档<span class="badge">186</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BF%90%E8%A1%8C-ZooKeeper"><span class="nav-number">1.</span> <span class="nav-text">命令行运行 ZooKeeper</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8B%E8%BD%BD"><span class="nav-number">1.1.</span> <span class="nav-text">下载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%88%E5%8D%95%E6%9C%BA%EF%BC%89"><span class="nav-number">1.2.</span> <span class="nav-text">创建配置文件（单机）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%88%E9%9B%86%E7%BE%A4%EF%BC%89"><span class="nav-number">1.3.</span> <span class="nav-text">创建配置文件（集群）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5"><span class="nav-number">1.4.</span> <span class="nav-text">连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E5%91%BD%E4%BB%A4"><span class="nav-number">1.5.</span> <span class="nav-text">测试命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%81%9C%E6%AD%A2%E6%9C%8D%E5%8A%A1"><span class="nav-number">1.6.</span> <span class="nav-text">停止服务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A5%E5%BF%97"><span class="nav-number">1.7.</span> <span class="nav-text">日志</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87-Docker-%E9%83%A8%E7%BD%B2-standalone-%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.8.</span> <span class="nav-text">通过 Docker 部署 standalone 模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ZooKeeper-%E9%9B%86%E7%BE%A4"><span class="nav-number">2.</span> <span class="nav-text">ZooKeeper 集群</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E7%BE%A4%E7%9A%84%E9%83%A8%E7%BD%B2%E6%96%B9%E5%BC%8F"><span class="nav-number">2.1.</span> <span class="nav-text">集群的部署方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B4%A9%E6%BA%83%E6%81%A2%E5%A4%8D"><span class="nav-number">2.2.</span> <span class="nav-text">崩溃恢复</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A9%E5%AE%B9"><span class="nav-number">2.3.</span> <span class="nav-text">扩容</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ZooKeeper-%E5%8E%9F%E7%94%9F%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="nav-number">3.</span> <span class="nav-text">ZooKeeper 原生客户端</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Curator"><span class="nav-number">4.</span> <span class="nav-text">Curator</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Client"><span class="nav-number">4.1.</span> <span class="nav-text">Client</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86"><span class="nav-number">4.1.1.</span> <span class="nav-text">连接管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E9%87%8D%E8%AF%95"><span class="nav-number">4.1.2.</span> <span class="nav-text">连接重试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Connection-Guarantees"><span class="nav-number">4.1.3.</span> <span class="nav-text">Connection Guarantees</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Framework"><span class="nav-number">4.2.</span> <span class="nav-text">Framework</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CuratorFrameworkFactory-%E7%B1%BB"><span class="nav-number">4.2.1.</span> <span class="nav-text">CuratorFrameworkFactory 类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E7%9F%A5-Notification"><span class="nav-number">4.2.2.</span> <span class="nav-text">通知(Notification)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4-Namespace"><span class="nav-number">4.2.3.</span> <span class="nav-text">名称空间(Namespace)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Recipes"><span class="nav-number">4.3.</span> <span class="nav-text">Recipes</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%89%E4%B8%BE"><span class="nav-number">4.3.1.</span> <span class="nav-text">选举</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9B%86%E7%BE%A4%E9%A2%86%E5%AF%BC%E9%80%89%E4%B8%BE-leader-election"><span class="nav-number">4.3.2.</span> <span class="nav-text">集群领导选举(leader election)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%81%E6%9C%8D%E5%8A%A1"><span class="nav-number">4.3.3.</span> <span class="nav-text">锁服务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%9F%E5%88%97-Queue"><span class="nav-number">4.3.4.</span> <span class="nav-text">队列(Queue)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E5%8D%A1-Barrier"><span class="nav-number">4.3.5.</span> <span class="nav-text">关卡(Barrier)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%A1%E6%95%B0%E5%99%A8-Counter"><span class="nav-number">4.3.6.</span> <span class="nav-text">计数器(Counter)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Utilities-%E5%90%84%E7%A7%8D-ZooKeeper-%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="nav-number">4.4.</span> <span class="nav-text">Utilities:各种 ZooKeeper 的工具类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Path-Cache"><span class="nav-number">4.4.1.</span> <span class="nav-text">Path Cache</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Test-Server"><span class="nav-number">4.4.2.</span> <span class="nav-text">Test Server</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Test-Cluster"><span class="nav-number">4.4.3.</span> <span class="nav-text">Test Cluster</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ZKPaths-%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="nav-number">4.4.4.</span> <span class="nav-text">ZKPaths 工具类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#EnsurePath-%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="nav-number">4.4.5.</span> <span class="nav-text">EnsurePath 工具类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Notification-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86"><span class="nav-number">4.4.6.</span> <span class="nav-text">Notification 事件处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E5%B7%A5%E5%85%B7"><span class="nav-number">4.4.7.</span> <span class="nav-text">日志工具</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ZkClient"><span class="nav-number">5.</span> <span class="nav-text">ZkClient</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B8%E5%AF%B9-Curator-%E7%9A%84%E4%B8%8D%E8%B6%B3"><span class="nav-number">5.1.</span> <span class="nav-text">相对 Curator 的不足</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E6%80%A7"><span class="nav-number">5.2.</span> <span class="nav-text">特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ZkClient-API"><span class="nav-number">5.3.</span> <span class="nav-text">ZkClient API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-number">5.4.</span> <span class="nav-text">实现分布式锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">6.</span> <span class="nav-text">参考</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="nav-number">6.1.</span> <span class="nav-text">环境搭建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="nav-number">6.2.</span> <span class="nav-text">客户端</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8"><span class="nav-number">6.3.</span> <span class="nav-text">应用</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">tallate</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">186</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">80</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/4ea5471b.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tallate">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="ZooKeeper 的使用 | Tallate">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          ZooKeeper 的使用
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-07-29 18:52:36" itemprop="dateCreated datePublished" datetime="2019-07-29T18:52:36+08:00">2019-07-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-07 01:56:20" itemprop="dateModified" datetime="2025-07-07T01:56:20+08:00">2025-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/ZooKeeper/" itemprop="url" rel="index"><span itemprop="name">ZooKeeper</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>就 ZooKeeper 来说，只明白原理是不够的，因为实际场景非常多，在不同场景下 ZooKeeper 几乎都有不同的应用模式，不过幸运的是 ZooKeeper 已经有一个比较完善的客户端 Curator，在生产环境下几乎不需要投入太多人力就可以解决大部分集群协调问题。</p>
<span id="more"></span>

<h2 id="命令行运行-ZooKeeper"><a href="#命令行运行-ZooKeeper" class="headerlink" title="命令行运行 ZooKeeper"></a>命令行运行 ZooKeeper</h2><p>Zookeeper 有三种运行形式：集群模式、单机模式、伪集群模式（一台机器上配个集群）。以下实验都是在单机模式下进行。</p>
<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget http://mirrors.hust.edu.cn/apache/zookeeper/zookeeper-3.4.13/zookeeper-3.4.13.tar.gz</span><br><span class="line">tar -zxvf zookeeper-3.4.13.tar.gz</span><br><span class="line">cd zookeeper-3.4.13</span><br></pre></td></tr></table></figure>
<ul>
<li>zkCleanup　　清理 Zookeeper 历史数据，包括食物日志文件和快照数据文件</li>
<li>zkCli　　　　  Zookeeper 的一个简易客户端</li>
<li>zkEnv　　　　设置 Zookeeper 的环境变量</li>
<li>zkServer　　   Zookeeper 服务器的启动、停止、和重启脚本</li>
</ul>
<h3 id="创建配置文件（单机）"><a href="#创建配置文件（单机）" class="headerlink" title="创建配置文件（单机）"></a>创建配置文件（单机）</h3><p>在 zookeeper 根目录下创建 conf&#x2F;zoo.cfg（可以是任何其他文件名）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tickTime=2000 # 单位是毫秒，It is used to do heartbeats and the minimum session timeout will be twice the tickTime</span><br><span class="line">dataDir=/var/lib/zookeeper # the location to store the in-memory database snapshots and, unless specified otherwise, the transaction log of updates to the database</span><br><span class="line">clientPort=2181 # the port to listen for client connections</span><br></pre></td></tr></table></figure>
<p>启动实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo bin/zkServer.sh start</span><br></pre></td></tr></table></figure>
<p>可以使用 jps 命令查看进程。</p>
<h3 id="创建配置文件（集群）"><a href="#创建配置文件（集群）" class="headerlink" title="创建配置文件（集群）"></a>创建配置文件（集群）</h3><p>最少需要有三台服务器，且最好是奇数台服务器，如果只有两台，那么在丢失一台后剩余服务器无法组成<strong>majority quorum</strong>，两台服务器甚至比一台服务器还不稳定，因为存在两个<strong>single points of failure</strong>。<br>在一台机器上启动多台服务器不会产生任何<strong>冗余</strong>，完全的冗余需要每个服务器运行在单独的机器上（不是一台机器上的多台虚拟机），但是 ZooKeeper 本身的配置都是差不多的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tickTime=2000</span><br><span class="line">dataDir=/var/lib/zookeeper/data1</span><br><span class="line">clientPort=2181</span><br><span class="line">initLimit=5 # 在quorum中连接上leader的超时时间，也就是5次tick</span><br><span class="line">syncLimit=2 # how far out of date a server can be from a leader</span><br><span class="line"># 下面配置构成集群的所有服务器，对于第一个参数server.X，当服务器启动后它会在data directory下查询以myid命名的文件，从而知道自己是集群中的哪一个服务器，That file has the contains the server number, in ASCII.</span><br><span class="line"># ip表示该服务器的ip地址，如果是单机配置可以设置为localhost</span><br><span class="line"># 后面有两个端口号，每个peer使用第一个端口号连接上其他peers（比如followers可以使用这个端口号连接上leader，当一个新的leader选举出来后，follower就会在这个端口打开一个TCP连接到leader）。因为默认的leader选举也要使用TCP连接，所以多出来的后一个端口就是用于选举的。</span><br><span class="line">server.1=ip1:2888:3888</span><br><span class="line">server.2=ip2:2888:3888</span><br><span class="line">server.3=ip3:2888:3888</span><br></pre></td></tr></table></figure>
<p>然后，在 dataDir 目录下创建 myid 文件，包含一个 ASCII 字符 1。<br>其他两个节点是类似的，需要修改 dataDir 和 clientPort 两个参数，并且在各自的 dataDir 下创建 myid 文件，包含且仅包含一个数字（1、2、3）。<br>如果并非单机部署，意味着会发生主机间的通信，需要开启端口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 对客户端开放的端口</span><br><span class="line">iptables -A INPUT -p tcp --dport 2181 -j ACCEPT</span><br><span class="line">iptables -A INPUT -p tcp --dport 2182 -j ACCEPT</span><br><span class="line">iptables -A INPUT -p tcp --dport 2183 -j ACCEPT</span><br><span class="line"># 用于peers间通信的端口</span><br><span class="line">iptables -A INPUT -p tcp --dport 2888 -j ACCEPT</span><br><span class="line">iptables -A INPUT -p tcp --dport 2889 -j ACCEPT</span><br><span class="line">iptables -A INPUT -p tcp --dport 2890 -j ACCEPT</span><br><span class="line"># 用于选举的端口</span><br><span class="line">iptables -A INPUT -p tcp --dport 3888 -j ACCEPT</span><br><span class="line">iptables -A INPUT -p tcp --dport 3889 -j ACCEPT</span><br><span class="line">iptables -A INPUT -p tcp --dport 3890 -j ACCEPT</span><br></pre></td></tr></table></figure>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>如果只启动了一个服务器，整个集群不能对外提供服务（使用 zkCli 连接会报一大堆错），但是可以使用 telnet 来测试可用性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet 127.0.0.1 2181</span><br></pre></td></tr></table></figure>
<p>启动所有服务器后就可以通过 zkCli 连接了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/zkCli.sh -server 127.0.0.1:2181</span><br></pre></td></tr></table></figure>
<h3 id="测试命令"><a href="#测试命令" class="headerlink" title="测试命令"></a>测试命令</h3><ul>
<li>基本用法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">help</span><br><span class="line">ls /</span><br><span class="line"># 创建一个新的znode：/zk_test，并关联数据my_data</span><br><span class="line">create /zk_test my_data</span><br><span class="line"># 检查关联于该节点的数据</span><br><span class="line">get /zk_test</span><br></pre></td></tr></table></figure></li>
<li>三种节点类型的创建<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># create [-s] [-e] path data acl</span><br><span class="line"># 创建节点，默认是持久节点</span><br><span class="line">create /perm_test perm_data</span><br><span class="line"># -s 指定创建顺序节点</span><br><span class="line">create -s /ordered_test ordered_data</span><br><span class="line"># -e 指定临时节点</span><br><span class="line">create -e /temp_test temp_data</span><br></pre></td></tr></table></figure>
acl 用来进行权限控制</li>
<li>查看节点<br>临时节点会在客户端会话结束后被自动删除，下面退出后重新连接观察节点（根目录下已经不存在临时节点）：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">quit</span><br><span class="line">ls /</span><br></pre></td></tr></table></figure>
ls2 命令除了列出目录下的所有子节点外，还可以获取目录的其他属性：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls2 /</span><br></pre></td></tr></table></figure>
get 命令查看节点的具体信息<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get /zk_test</span><br></pre></td></tr></table></figure></li>
<li>修改该节点的数据<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># set path data [version]</span><br><span class="line">set /zk_test junk</span><br></pre></td></tr></table></figure></li>
<li>删除节点<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># delete path [version]</span><br><span class="line">delete /zk_test</span><br><span class="line">ls /</span><br></pre></td></tr></table></figure>
注意若删除节点存在子节点，那么无法删除该节点，必须先删除子节点，再删除父节点。</li>
</ul>
<h3 id="停止服务"><a href="#停止服务" class="headerlink" title="停止服务"></a>停止服务</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/zkServer.sh stop</span><br></pre></td></tr></table></figure>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p>启动 zookeeper 实例后会在当前目录下创建一个 zookeeper.out 文件，里面是 debug 信息。<br>另外还有一个 transaction log（可以在更新时降低延迟），默认放在 dataDir 目录下，也可以通过添加 dataLogDir 配置来指定。</p>
<h3 id="通过-Docker-部署-standalone-模式"><a href="#通过-Docker-部署-standalone-模式" class="headerlink" title="通过 Docker 部署 standalone 模式"></a>通过 Docker 部署 standalone 模式</h3><p>standalone.cfg:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tickTime=2000</span><br><span class="line">dataDir=/var/lib/zookeeper/</span><br><span class="line">clientPort=2181</span><br><span class="line">initLimit=5</span><br><span class="line">syncLimit=2</span><br><span class="line">server.1=127.0.0.1:2888:3888</span><br><span class="line">4lw.commands.whitelist=*</span><br></pre></td></tr></table></figure>
<p>standalone.sh:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env bash</span><br><span class="line">sudo cp standalone.cfg /opt/zookeeper/config/standalone.cfg</span><br><span class="line">sudo mkdir -p /opt/zookeeper/data</span><br><span class="line">sudo chmod 777 /opt/zookeeper/data</span><br><span class="line"></span><br><span class="line">docker run -p 2181:2181 -v /opt/zookeeper/data:/var/lib/zookeeper/ -v /opt/zookeeper/config/standalone.cfg:/conf/zoo.cfg --name standalone-zk -d zookeeper</span><br></pre></td></tr></table></figure>

<p>镜像：<a target="_blank" rel="noopener" href="https://hub.docker.com/_/zookeeper">https://hub.docker.com/_/zookeeper</a><br>部署完后连接执行命令时可能报错：<code>stat is not executed because it is not in the whitelist.</code><br>需要允许所有 4 字命令：<a target="_blank" rel="noopener" href="https://blog.csdn.net/AroudSoft/article/details/98489889">https://blog.csdn.net/AroudSoft/article/details/98489889</a></p>
<h2 id="ZooKeeper-集群"><a href="#ZooKeeper-集群" class="headerlink" title="ZooKeeper 集群"></a>ZooKeeper 集群</h2><h3 id="集群的部署方式"><a href="#集群的部署方式" class="headerlink" title="集群的部署方式"></a>集群的部署方式</h3><p>ZooKeeper 的部署方式是怎样的？集群中的机器角色都有哪些？集群最少需要几台机器？<br>单机、集群、伪集群。<br>Leader、Follower。<br>集群需要至少 3（2N + 1）台机器，保证奇数，主要是为了保证选举算法能得到大多数节点的确认。</p>
<h3 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h3><p>集群如果有 3 台机器，挂掉一台的情况下集群还能工作吗？挂掉两台呢？<br>记住一个原则：过半存活即可用，只要能得到超过半数的选票就可以最终选出一个 Leader。</p>
<h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>ZooKeeper 集群支持动态添加机器吗？这个问题讨论的是水平扩容能力，ZooKeeper 在这方面的支持不太好。如果需要添加机器，可以采取以下两种方式：</p>
<ul>
<li>全部重启：关闭所有 ZooKeeper 服务器，修改配置之后再启动，不影响之前客户端的会话。</li>
<li>逐个重启：顾名思义。这是比较常用的方式。</li>
</ul>
<h2 id="ZooKeeper-原生客户端"><a href="#ZooKeeper-原生客户端" class="headerlink" title="ZooKeeper 原生客户端"></a>ZooKeeper 原生客户端</h2><p>一般不会直接使用 ZooKeeper 原生客户端，坑太多：</p>
<ol>
<li>初始化连接的问题: 在 client 与 server 之间握手建立连接的过程中，如果握手失败，执行所有的同步方法(比如 create，getData 等)将抛出异常；</li>
<li>自动恢复(failover)的问题: 当 client 与一台 server 的连接丢失,并试图去连接另外一台 server 时，client 将回到初始连接模式；</li>
<li>session 过期的问题: 在极端情况下，出现 ZooKeeper session 过期，客户端需要自己去监听该状态并重新创建 ZooKeeper 实例；</li>
<li>对可恢复异常的处理:当在 server 端创建一个有序 ZNode，而在将节点名返回给客户端时崩溃，此时 client 端抛出可恢复的异常，用户需要自己捕获这些异常并进行重试；</li>
<li>使用场景的问题:Zookeeper 提供了一些标准的使用场景支持，但是 ZooKeeper 对这些功能的使用说明文档很少，而且很容易用错. 在一些极端场景下如何处理，zk 并没有给出详细的文档说明. 比如共享锁服务，当服务器端创建临时顺序节点成功，但是在客户端接收到节点名之前挂掉了，如果不能很好的处理这种情况，将导致死锁。</li>
</ol>
<h2 id="Curator"><a href="#Curator" class="headerlink" title="Curator"></a>Curator</h2><ol>
<li>封装 ZooKeeper client 与 ZooKeeper server 之间的连接处理，提供连接状态监控、zk 客户端实例管理等特性；</li>
<li>提供了一套 Fluent 风格的操作 API；</li>
<li>提供 ZooKeeper 各种应用场景(recipe, 比如共享锁服务, 集群领导选举机制)的抽象封装，提供对各种使用场景的支持（甚至包括 zk 自身不支持的场景）, 这些实现都遵循了 zk 的最佳实践, 并考虑了各种极端情况。</li>
</ol>
<p>下面按 Curator 的组成进行分析。</p>
<h3 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h3><p>Client 是 ZooKeeper 客户端的一个替代品，提供了一些底层处理和相关的工具方法。</p>
<h4 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h4><p>Curator 对 zk 客户端到 server 集群连接进行管理. 并在需要的情况, 重建 zk 实例, 保证与 zk 集群的可靠连接。<br>Curator 初始化之后会一直的对 zk 连接进行监听, 一旦发现连接状态发生变化, 将作出相应的处理</p>
<h4 id="连接重试"><a href="#连接重试" class="headerlink" title="连接重试"></a>连接重试</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">RetryLoop retryLoop = client.newRetryLoop();  </span><br><span class="line">while (retryLoop.shouldContinue()) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // perform your work  </span><br><span class="line">        ...  </span><br><span class="line">        // it&#x27;s important to re-get the ZK instance as there may have been an error and the instance was re-created  </span><br><span class="line">        ZooKeeper zk = client.getZookeeper();  </span><br><span class="line"> </span><br><span class="line">        retryLoop.markComplete();  </span><br><span class="line">    &#125; catch (Exception e) &#123;  </span><br><span class="line">        retryLoop.takeException(e);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RetryLoop.callWithRetry(client, new Callable() &#123;  </span><br><span class="line">      @Override  </span><br><span class="line">      public Void call() throws Exception  </span><br><span class="line">      &#123;  </span><br><span class="line">          // do your work here - it will get retried if needed  </span><br><span class="line">          return null;  </span><br><span class="line">      &#125;  </span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure>
<h4 id="Connection-Guarantees"><a href="#Connection-Guarantees" class="headerlink" title="Connection Guarantees"></a>Connection Guarantees</h4><p>Curator 是通过重连机制保证连接的可靠的：</p>
<ul>
<li>Every Curator operation properly waits until the ZooKeeper connection is established</li>
<li>Every Curator Framework operation (create, getData, etc.) is guaranteed to manage connection loss and&#x2F;or session expiration per the currently set retry policy</li>
<li>If the connection is temporarily lost, Curator will attempt to retry the operation until it succeeds per the currently set retry policy</li>
<li>All Curator recipes attempt to deal with connection issues in an appropriate way</li>
</ul>
<p>Curator 提供可插拔的重试机制，它将给捕获所有可恢复的异常配置一个重试策略, 并且内部也提供了几种标准的重试策略(比如指数补偿)<br>RetryPolicy 接口只有一个方法(以前版本有两个方法):<br>public boolean allowRetry(int retryCount, long elapsedTimeMs);<br>在开始重试之前, allowRetry 方法被调用, 其参数将指定当前重试次数, 和操作已消耗时间. 如果允许, 将继续重试, 否则抛出异常.<br>有四种内置的重试策略：<br>ExponentialBackoffRetry:重试指定的次数, 且每一次重试之间停顿的时间逐渐增加.<br>RetryNTimes:指定最大重试次数的重试策略<br>RetryOneTime:仅重试一次<br>RetryUntilElapsed:一直重试直到达到规定的时间</p>
<h3 id="Framework"><a href="#Framework" class="headerlink" title="Framework"></a>Framework</h3><p>用来简化 ZooKeeper 高级功能的使用，并增加了一些新的功能, 比如管理到 ZooKeeper 集群的连接、重试处理</p>
<h4 id="CuratorFrameworkFactory-类"><a href="#CuratorFrameworkFactory-类" class="headerlink" title="CuratorFrameworkFactory 类"></a>CuratorFrameworkFactory 类</h4><p>提供了两个方法, 一个工厂方法 newClient, 一个构建方法 build. 使用工厂方法 newClient 可以创建一个默认的实例, 而 build 构建方法可以对实例进行定制. 当 CuratorFramework 实例构建完成, 紧接着调用 start()方法, 在应用结束的时候, 需要调用 close()方法. CuratorFramework 是线程安全的. 在一个应用中可以共享同一个 zk 集群的 CuratorFramework.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">client.create().forPath(&quot;/head&quot;, new byte[0]);  </span><br><span class="line">client.delete().inBackground().forPath(&quot;/head&quot;);  </span><br><span class="line">client.create().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).forPath(&quot;/head/child&quot;, new byte[0]);  </span><br><span class="line">client.getData().watched().inBackground().forPath(&quot;/test&quot;);  </span><br></pre></td></tr></table></figure>
<p>方法说明:<br>create(): 发起一个 create 操作. 可以组合其他方法 (比如 mode 或 background) 最后以 forPath()方法结尾<br>delete(): 发起一个删除操作. 可以组合其他方法(version 或 background) 最后以 forPath()方法结尾<br>checkExists(): 发起一个检查 ZNode 是否存在的操作. 可以组合其他方法(watch 或 background) 最后以 forPath()方法结尾<br>getData(): 发起一个获取 ZNode 数据的操作. 可以组合其他方法(watch, background 或 get stat) 最后以 forPath()方法结尾<br>setData(): 发起一个设置 ZNode 数据的操作. 可以组合其他方法(version 或 background) 最后以 forPath()方法结尾<br>getChildren(): 发起一个获取 ZNode 子节点的操作. 可以组合其他方法(watch, background 或 get stat) 最后以 forPath()方法结尾<br>inTransaction(): 发起一个 ZooKeeper 事务. 可以组合 create, setData, check, 和&#x2F;或 delete 为一个操作, 然后 commit() 提交</p>
<h4 id="通知-Notification"><a href="#通知-Notification" class="headerlink" title="通知(Notification)"></a>通知(Notification)</h4><p>Curator 的相关代码已经更新了, 里面的接口已经由 ClientListener 改成 CuratorListener 了, 而且接口中去掉了 clientCloseDueToError 方法. 只有一个方法:<br>eventReceived() 当一个后台操作完成或者指定的 watch 被触发时该方法被调用<br>UnhandledErrorListener 接口用来对异常进行处理.<br>CuratorEvent(在以前版本为 ClientEvent)是对各种操作触发相关事件对象(POJO)的一个完整封装, 而事件对象的内容跟事件类型相关, 下面是对应关系:<br>CREATE    getResultCode() and getPath()<br>DELETE    getResultCode() and getPath()<br>EXISTS    getResultCode(), getPath() and getStat()<br>GET_DATA    getResultCode(), getPath(), getStat() and getData()<br>SET_DATA    getResultCode(), getPath() and getStat()<br>CHILDREN    getResultCode(), getPath(), getStat(), getChildren()<br>WATCHED    getWatchedEvent()</p>
<h4 id="名称空间-Namespace"><a href="#名称空间-Namespace" class="headerlink" title="名称空间(Namespace)"></a>名称空间(Namespace)</h4><p>因为一个 zk 集群会被多个应用共享, 为了避免各个应用的 zk patch 冲突, Curator Framework 内部会给每一个 Curator Framework 实例分配一个 namespace(可选). 这样你在 create ZNode 的时候都会自动加上这个 namespace 作为这个 node path 的 root. 使用代码如下: </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CuratorFramework client = CuratorFrameworkFactory.builder().namespace(&quot;MyApp&quot;) ... build();  </span><br><span class="line"> …  </span><br><span class="line">client.create().forPath(&quot;/test&quot;, data);  </span><br><span class="line">// node was actually written to: &quot;/MyApp/test&quot; </span><br></pre></td></tr></table></figure>

<h3 id="Recipes"><a href="#Recipes" class="headerlink" title="Recipes"></a>Recipes</h3><p>实现了通用 ZooKeeper 的 recipe, 该组件建立在 Framework 的基础之上，Curator 实现了 ZooKeeper 的所有 recipe(除了两段提交) </p>
<h4 id="选举"><a href="#选举" class="headerlink" title="选举"></a>选举</h4><h4 id="集群领导选举-leader-election"><a href="#集群领导选举-leader-election" class="headerlink" title="集群领导选举(leader election)"></a>集群领导选举(leader election)</h4><h4 id="锁服务"><a href="#锁服务" class="headerlink" title="锁服务"></a>锁服务</h4><p>共享锁: 全局同步分布式锁, 同一时间两台机器只有一台能获得同一把锁.<br>共享读写锁: 用于分布式的读写互斥处理, 同时生成两个锁:一个读锁, 一个写锁, 读锁能被多个应用持有, 而写锁只能一个独占, 当写锁未被持有时, 多个读锁持有者可以同时进行读操作<br>共享信号量: 在分布式系统中的各个 JVM 使用同一个 zk lock path, 该 path 将跟一个给定数量的租约(lease)相关联, 然后各个应用根据请求顺序获得对应的 lease, 相对来说, 这是最公平的锁服务使用方式.<br>多共享锁:内部构件多个共享锁(会跟一个 znode path 关联), 在 acquire()过程中, 执行所有共享锁的 acquire()方法, 如果中间出现一个失败, 则将释放所有已 require 的共享锁; 执行 release()方法时, 则执行内部多个共享锁的 release 方法(如果出现失败将忽略) </p>
<h4 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列(Queue)"></a>队列(Queue)</h4><p>分布式队列:采用持久顺序 zk node 来实现 FIFO 队列, 如果有多个消费者, 可以使用 LeaderSelector 来保证队列的消费者顺序<br>分布式优先队列: 优先队列的分布式版本<br>BlockingQueueConsumer: JDK 阻塞队列的分布式版本 </p>
<h4 id="关卡-Barrier"><a href="#关卡-Barrier" class="headerlink" title="关卡(Barrier)"></a>关卡(Barrier)</h4><p>分布式关卡:一堆客户端去处理一堆任务, 只有所有的客户端都执行完, 所有客户端才能继续往下处理<br>双分布式关卡:同时开始, 同时结束 </p>
<h4 id="计数器-Counter"><a href="#计数器-Counter" class="headerlink" title="计数器(Counter)"></a>计数器(Counter)</h4><p>共享计数器:所有客户端监听同一个 znode path, 并共享一个最新的 integer 计数值<br>分布式 AtomicLong(AtomicInteger): AtomicXxx 的分布式版本, 先采用乐观锁更新, 若失败再采用互斥锁更新, 可以配置重试策略来处理重试 </p>
<h3 id="Utilities-各种-ZooKeeper-的工具类"><a href="#Utilities-各种-ZooKeeper-的工具类" class="headerlink" title="Utilities:各种 ZooKeeper 的工具类"></a>Utilities:各种 ZooKeeper 的工具类</h3><h4 id="Path-Cache"><a href="#Path-Cache" class="headerlink" title="Path Cache"></a>Path Cache</h4><p>Path Cache 用于监听 ZNode 的子节点的变化, 当 add, update, remove 子节点时将改变 Path Cache state, 同时返回所有子节点的 data 和 state.<br>Curator 中采用了 PathChildrenCache 类来处理 Path Cache, 状态的变化则采用 PathChildrenCacheListener 来监听.<br>相关用法参见 TestPathChildrenCache 测试类<br>注意: 当 zk server 的数据发生变化, zk client 会出现不一致, 这个需要通过版本号来识别这种状态的变化 </p>
<h4 id="Test-Server"><a href="#Test-Server" class="headerlink" title="Test Server"></a>Test Server</h4><p>用来在测试中模拟一个本地进程内 ZooKeeper Server. </p>
<h4 id="Test-Cluster"><a href="#Test-Cluster" class="headerlink" title="Test Cluster"></a>Test Cluster</h4><p>用来在测试中模拟一个 ZooKeeper Server 集群 </p>
<h4 id="ZKPaths-工具类"><a href="#ZKPaths-工具类" class="headerlink" title="ZKPaths 工具类"></a>ZKPaths 工具类</h4><p>提供了和 ZNode 相关的 path 处理工具方法:<br>getNodeFromPath: 根据给定 path 获取 node name. i.e. “&#x2F;one&#x2F;two&#x2F;three” -&gt; “three”<br>mkdirs: 根据给定路径递归创建所有 node<br>getSortedChildren: 根据给定路径, 返回一个按序列号排序的子节点列表<br>makePath: 根据给定的 path 和子节点名, 创建一个完整 path</p>
<h4 id="EnsurePath-工具类"><a href="#EnsurePath-工具类" class="headerlink" title="EnsurePath 工具类"></a>EnsurePath 工具类</h4><p>直接看例子, 具体的说就是调用多次, 只会执行一次创建节点操作. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EnsurePath ensurePath = new EnsurePath(aFullPathToEnsure);  </span><br><span class="line">...  </span><br><span class="line">String nodePath = aFullPathToEnsure + &quot;/foo&quot;;  </span><br><span class="line">ensurePath.ensure(zk); // first time syncs and creates if needed  </span><br><span class="line">zk.create(nodePath, ...);  </span><br><span class="line">...  </span><br><span class="line">ensurePath.ensure(zk); // subsequent times are NOPs  </span><br><span class="line">zk.create(nodePath, ...);  </span><br></pre></td></tr></table></figure>
<h4 id="Notification-事件处理"><a href="#Notification-事件处理" class="headerlink" title="Notification 事件处理"></a>Notification 事件处理</h4><p>Curator 对 ZooKeeper 的事件 Watcher 进行了封装处理, 然后实现了一套监听机制. 提供了几个监听接口用来处理 ZooKeeper 连接状态的变化<br>当连接出现异常, 将通过 ConnectionStateListener 接口进行监听, 并进行相应的处理, 这些状态变化包括:<br>暂停(SUSPENDED): 当连接丢失, 将暂停所有操作, 直到连接重新建立, 如果在规定时间内无法建立连接, 将触发 LOST 通知<br>重连(RECONNECTED): 连接丢失, 执行重连时, 将触发该通知<br>丢失(LOST): 连接超时时, 将触发该通知<br>从 com.netflix.curator.framework.imps.CuratorFrameworkImpl.validateConnection(CuratorEvent)方法中我们可以知道, Curator 分别将 ZooKeeper 的 Disconnected, Expired, SyncConnected 三种状态转换成上面三种状态. </p>
<h4 id="日志工具"><a href="#日志工具" class="headerlink" title="日志工具"></a>日志工具</h4><p>Curator 内部采用 SLF4J 来输出日志<br>采用驱动器(driver)机制, 允许扩展和定制日志和跟踪处理<br>提供了一个 TracerDriver 接口, 通过实现 addTrace()和 addCount()接口来集成用户自己的跟踪框架</p>
<h2 id="ZkClient"><a href="#ZkClient" class="headerlink" title="ZkClient"></a>ZkClient</h2><h3 id="相对-Curator-的不足"><a href="#相对-Curator-的不足" class="headerlink" title="相对 Curator 的不足"></a>相对 Curator 的不足</h3><ul>
<li>文档几乎没有 </li>
<li>异常处理弱爆了(简单的抛出 RuntimeException) </li>
<li>重试处理太难用了 </li>
<li>没有提供各种使用场景的实现</li>
</ul>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ol>
<li>提供了 Zk 断链重连的特性:：这个特性似乎每个开发者都会设计，而且代码风格几乎”如出一辙”。在大部分 Zk 使用场景中，我们都要求它能够在断链的时候，重新建立连接，无论 session 失效与否。</li>
<li>Event 监听器机制：向 ZNode 节点注册 watch，每个开发者都使用过，尽管 watch 机制并不能确保数据变更的实时性。Watch-Event 属于”即发即失”，因为我们需要得到 Event 时候，再去注册一遍，这也是一个非常繁琐的事情，I0Itec-ZkClient 提供了 Event-Listener 的小技巧，可以帮助我们”解脱”。</li>
<li>Zk 异常处理：Zkr 中繁多的 Exception，以及每个 Exception 所需要关注的事情各有不同，你应该记得那一堆 try-catch 给你带来的烦恼。</li>
<li>Data 序列化:简单的 data 序列化（Serialzer&#x2F;Deserialzer）。</li>
</ol>
<h3 id="ZkClient-API"><a href="#ZkClient-API" class="headerlink" title="ZkClient API"></a>ZkClient API</h3><ol>
<li>ZkConnection 类：对 Zk API 的简单分装，提供了链接 Zk Server 和数据 CRUD 的操作；此类实现了 IZkConnection 接口，通常情况下，如果 I0Itec-Zkclient 不能满足需要的时候，我们可以重写 ZkConnection 即可。</li>
<li>ZkClient 类：核心类，也是开发者需要直接使用的类，它内部维护了 Zk 的链接管理和 Event 处理逻辑等，同时也暴露了 Zookeeper Znode 的 CRUD 方法列表。</li>
<li>IZkChildListener 接口：ZNode 子节点事件侦听器，当 ZkClient 接收到某个 path 节点变更或者子节点变更事件时，会触发 Listener。</li>
<li>IZkDataListener 接口</li>
<li>IZkStateListener 接口：当 Zk 客户端状态变更时，触发。</li>
</ol>
<h3 id="实现分布式锁"><a href="#实现分布式锁" class="headerlink" title="实现分布式锁"></a>实现分布式锁</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private ZkClient zkClient;</span><br><span class="line"></span><br><span class="line">private String path;</span><br><span class="line">private final String LOCK;</span><br><span class="line"></span><br><span class="line">public boolean lock() throws Exception &#123;</span><br><span class="line">    if (zkClient.exists(path))</span><br><span class="line">        return true;</span><br><span class="line">    else</span><br><span class="line">        return zkClient.create(path, LOCK.getBytes(), CreateMode.EPHEMERAL) == null ? true : false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean unlock() throws Exception &#123;</span><br><span class="line">    return zkClient.delete(path);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean islock() throws Exception &#123;</span><br><span class="line">    return zkClient.exists(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><ol>
<li><a target="_blank" rel="noopener" href="https://zookeeper.apache.org/doc/current/zookeeperStarted.html">ZooKeeper Getting Started Guide</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/mark_lq/article/details/52447181">ZooKeeper 单机模式和集群模式的环境搭建</a></li>
</ol>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><ol>
<li>原生客户端<br><a target="_blank" rel="noopener" href="http://www.cnblogs.com/leesf456/p/6028416.html">【分布式】Zookeeper 使用–Java API</a></li>
<li>开源客户端<br><a target="_blank" rel="noopener" href="https://zookeeper.apache.org/doc/current/zookeeperProgrammers.html">ZooKeeper Programmer’s Guide</a><br><a target="_blank" rel="noopener" href="http://www.cnblogs.com/leesf456/p/6032716.html">【分布式】Zookeeper 使用–开源客户端</a></li>
<li>Curator<br><a target="_blank" rel="noopener" href="https://curator.apache.org/">Apache Curator</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/70151fc0ef5d">Zookeeper 客户端 Curator 使用详解</a><br><a target="_blank" rel="noopener" href="http://macrochen.iteye.com/blog/1366136/">Zookeeper 开源客户端框架 Curator 简介</a><br><a target="_blank" rel="noopener" href="https://curator.apache.org/curator-recipes/index.html">Recipes</a></li>
<li>ZkClient<br><a target="_blank" rel="noopener" href="https://github.com/sgroschupf/zkclient">zkclient</a></li>
</ol>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ol>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yuyijq/p/3424473.html">Zookeeper-Zookeeper 可以干什么</a></li>
<li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/leesf456/p/6063694.html">【分布式】Zookeeper 在大型分布式系统中的应用</a></li>
<li><a target="_blank" rel="noopener" href="http://www.linkedkeeper.com/mobile/item.action?bid=64">基于 Zk 实现分布式锁</a></li>
<li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/leesf456/p/6036548.html">【分布式】Zookeeper 应用场景</a></li>
</ol>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">
    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/60ef81a3.html" rel="prev" title="ZooKeeper 的应用">
                  <i class="fa fa-angle-left"></i> ZooKeeper 的应用
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/8762395.html" rel="next" title="ES2_1索引原理">
                  ES2_1索引原理 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">tallate</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/tallate" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"version":"7.1.2","options":null,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.3.0/mermaid.min.js","integrity":"sha256-9y71g5Lz/KLsHjB8uXwnkuWDtAMDSzD/HdIbqhJfTAI="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>





  





</body>
</html>
