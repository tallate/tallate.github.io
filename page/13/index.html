<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"tallate.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.18.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Tallate">
<meta property="og:url" content="https://tallate.github.io/page/13/index.html">
<meta property="og:site_name" content="Tallate">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="tallate">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://tallate.github.io/page/13/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/13/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Tallate</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Tallate</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">该吃吃该喝喝 啥事别往心里搁</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签<span class="badge">80</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="th fa-fw"></i>分类<span class="badge">25</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档<span class="badge">187</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">tallate</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">187</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">80</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/353ec849.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tallate">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tallate">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/353ec849.html" class="post-title-link" itemprop="url">Dubbo 概述</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-09-07 18:51:58" itemprop="dateCreated datePublished" datetime="2019-09-07T18:51:58+08:00">2019-09-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-07 01:56:20" itemprop="dateModified" datetime="2025-07-07T01:56:20+08:00">2025-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Dubbo/" itemprop="url" rel="index"><span itemprop="name">Dubbo</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>

<h2 id="为什么使用-Dubbo"><a href="#为什么使用-Dubbo" class="headerlink" title="为什么使用 Dubbo"></a>为什么使用 Dubbo</h2><p>选型时一般需要考虑：</p>
<ol>
<li>业务特点及可预见的后续的发展。</li>
<li>可用性要求。</li>
<li>团队的成熟度。一个成熟的团队可以很好地 Hold 住复杂的开源框架，甚至做定制化开发。</li>
</ol>
<p>在选择使用 Dubbo 之后，又需要考虑很多细节，比如：</p>
<ol>
<li>Dubbo 底层走什么协议？如何对对象进行序列化，用了哪些序列化方式？如何处理异步转同步？</li>
<li>高并发高可用性。Dubbo 依赖了 ZooKeeper，但是万一 ZooKeeper 宕机了怎么办？<br>如果 ZooKeeper 假死，客户端对服务端的调用是否会全部下线？如果是该如何避免？<br>如何监控 Dubbo 的调用，并做到优雅的客户端无感发布？</li>
</ol>
<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><ol>
<li>模块化<br>推荐将服务接口、实体、异常等都放到 API 包内，它们都是 API 的一部分。</li>
<li>粗粒度<br>暴露的 Dubbo 接口的粒度应尽可能得粗，代表一个完整的功能，而不是其中的某一步，否则就不得不面对分布式事务问题了，而 Dubbo 当前并没有提供分布式事务支持。</li>
<li>版本<br>某露服务接口的配置最好增加版本，当有不兼容的升级（比如接口定义要加个参数）时，版本可以方便地实现平滑发布，而又不用引入多余的代码。<br>版本只需要两位即可，比如<code>&quot;1.0&quot;</code>，因为升级并不是频繁的操作，因为不兼容的升级不会那么频繁。<br>升级时，先将一半的 provider 升级到新版本，然后将所有 consumer 升级，最后将其余的 provider 升级。</li>
<li>兼容性<br>向后兼容：接口加方法、对象加字段；<br>不兼容：删除方法、删除字段、枚举类型加字段。<br>不兼容的情况下，可以通过升级版本来实现平滑发布。</li>
<li>枚举类型<br>枚举是类型安全的，但是作为 Dubbo 接口的参数 &#x2F; 返回值却不合适，因为 provider 会将枚举转换为字符串传输，接收方会尝试寻找该字符串所属的枚举 field，找不到就会直接报错。</li>
<li>序列化<br>传值没必要使用接口抽象，因为序列化需要接口实现类的元信息（包括 getter、setter），无法隐藏实现。<br>参数和返回值必须 byValue 而不是 byReference，因为 Dubbo 不支持远程对象，provider 引用的对象 consumer 就找不到了。</li>
<li>异常<br>最好直接抛异常而不是返回异常码，因为异常可以携带更多信息、语法上也更加友好。<br>provider 不要将 DAO 层的异常抛给 consumer 端，consumer 端不应该关注 provider 对服务是如何实现的。</li>
</ol>
<h2 id="开始使用-Dubbo"><a href="#开始使用-Dubbo" class="headerlink" title="开始使用 Dubbo"></a>开始使用 Dubbo</h2><h3 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h3><p>ZooKeeper 在 Dubbo 中可以作为注册中心使用。<br>下载 ZooKeeper，修改配置，配置文件位于{ZOOKEEPER_HOME}&#x2F;conf&#x2F;zoo.cfg：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dataDir = /tmp/zk/data</span><br><span class="line">clientPort = 2181</span><br><span class="line">tickTime = 2000</span><br><span class="line">initLimit = 5</span><br><span class="line">syncLimit = 2</span><br></pre></td></tr></table></figure>
<ul>
<li>dataDir：数据保存的目录</li>
<li>clientPort：监听的端口</li>
<li>tickTime：心跳检查间隔</li>
<li>initLimit：Follower 启动从 Leader 同步数据时能忍受多少个心跳的时间间隔</li>
<li>syncLimit：Leader 同步到 Follower 后，如果超过 syncLimit 个 tickTime 的时间过去，还没有收到 Follower 的响应，那么就认为该 Follower 已下线。</li>
</ul>
<p>后台启动：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/zkServer.sh start-foreground</span><br></pre></td></tr></table></figure>
<h3 id="SDK"><a href="#SDK" class="headerlink" title="SDK"></a>SDK</h3><p>SDK 是一个被 provider 和 consumer 同时依赖的 jar 包，它的作用包括：</p>
<ul>
<li>提供实体类的定义；  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>提供接口的定义；  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface UserServiceBo &#123;</span><br><span class="line">    String sayHello(String name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>在设计 SDK 时包含一些注意要点，比如：</p>
<ul>
<li>不要使用枚举，用字符串常量来替代，因为 Dubbo 反序列化时如果碰到不存在的枚举就会抛出异常，这个问题编译期无法发现，可能造成线上故障；</li>
<li>升级时不要随意修改接口定义，provider 和 consumer 接口定义不同会导致运行时故障，最佳实践是提升<code>dubbo:reference</code>和<code>dubbo:service</code>的版本号，或者直接增加一个接口。</li>
</ul>
<h3 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h3><ol>
<li>声明依赖 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;dubbo&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.6.6&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.netty&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;netty-all&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.0.35.Final&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.2.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.47&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li>Dubbo 配置文件 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">  xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot;</span><br><span class="line">  xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">    http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">    http://code.alibabatech.com/schema/dubbo</span><br><span class="line">    http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 提供方应用信息，用于计算依赖关系 --&gt;</span><br><span class="line">    &lt;dubbo:application name=&quot;dubboProvider&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 使用zookeeper注册中心暴露服务地址 --&gt;</span><br><span class="line">    &lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 用dubbo协议在20880端口暴露服务 --&gt;</span><br><span class="line">    &lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot;/&gt;</span><br><span class="line">    &lt;!-- 启用monitor模块 --&gt;</span><br><span class="line">    &lt;dubbo:monitor protocol=&quot;registry&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;userService&quot; class=&quot;com.tallate.provider.UserServiceImpl&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 声明需要暴露的服务接口 --&gt;</span><br><span class="line">    &lt;dubbo:service interface=&quot;com.tallate.UserServiceBo&quot; ref=&quot;userService&quot;</span><br><span class="line">      group=&quot;dubbo&quot; version=&quot;1.0.0&quot; timeout=&quot;3000&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></li>
<li>接口的实现 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class UserServiceImpl implements UserServiceBo &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String sayHello(String name) &#123;</span><br><span class="line">        //让当前当前线程休眠2s</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(2000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>启动<br>原生 Spring 的启动方式： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] arg) throws InterruptedException &#123;</span><br><span class="line">    ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:provider.xml&quot;);</span><br><span class="line">    //挂起当前线程，如果没有改行代码，服务提供者进程会消亡，服务消费者就发现不了提供者了</span><br><span class="line">    Thread.currentThread().join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果需要以 SpringBoot 或 Docker 方式启动可以参考官方的示例</p>
</blockquote>
</li>
</ol>
<h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><ol>
<li>声明依赖<br>同 Provider</li>
<li>Dubbo 配置文件 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">  xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot;</span><br><span class="line">  xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">    http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">    http://code.alibabatech.com/schema/dubbo</span><br><span class="line">    http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 消费方应用名，用于计算依赖关系，不是匹配条件，不要与提供方一样 --&gt;</span><br><span class="line">    &lt;dubbo:application name=&quot;dubboConsumer&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 使用multicast广播注册中心暴露发现服务地址 --&gt;</span><br><span class="line">    &lt;dubbo:registry  protocol=&quot;zookeeper&quot; address=&quot;zookeeper://127.0.0.1:2181&quot; /&gt;</span><br><span class="line">    &lt;!-- 启动monitor--&gt;</span><br><span class="line">    &lt;dubbo:monitor protocol=&quot;registry&quot; /&gt;</span><br><span class="line">    &lt;!-- 生成远程服务代理，可以和本地bean一样使用demoService --&gt;</span><br><span class="line">    &lt;dubbo:reference id=&quot;userService&quot; interface=&quot;com.tallate.UserServiceBo&quot; group=&quot;dubbo&quot; version=&quot;1.0.0&quot; timeout=&quot;3000&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里出现了一些以 dubbo 作为前缀的标签，它们是由 Dubbo 的扩展 DubboNamespaceHandler 来处理的，DubboBeanDefinitionParser 在解析完后会得到对应 BeanDefinition，然后生成对象放到 BeanFactory 中。</p>
</blockquote>
</li>
<li>启动 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(</span><br><span class="line">            new String[]&#123;&quot;classpath:consumer.xml&quot;&#125;);</span><br><span class="line"></span><br><span class="line">    final UserServiceBo demoService = (UserServiceBo) context.getBean(&quot;userService&quot;);</span><br><span class="line"></span><br><span class="line">    System.out.println(demoService.sayHello(&quot;Hello World&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="调用-Dubbo-原生-API-启动"><a href="#调用-Dubbo-原生-API-启动" class="headerlink" title="调用 Dubbo 原生 API 启动"></a>调用 Dubbo 原生 API 启动</h3><ol>
<li>Provider <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// 等价于&lt;bean id=&quot;userService&quot; class=&quot;com.test.UserServiceImpl&quot; /&gt;</span><br><span class="line">UserServiceBo userService = new UserServiceImpl();</span><br><span class="line">// 等价于&lt;dubbo:application name=&quot;dubboProvider&quot; /&gt;</span><br><span class="line">ApplicationConfig application = new ApplicationConfig();</span><br><span class="line">application.setName(&quot;dubboProvider&quot;);</span><br><span class="line"></span><br><span class="line">// 等价于&lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot; /&gt;</span><br><span class="line">RegistryConfig registry = new RegistryConfig();</span><br><span class="line">registry.setAddress(&quot;127.0.0.1:2181&quot;);</span><br><span class="line">registry.setProtocol(&quot;zookeeper&quot;);</span><br><span class="line"></span><br><span class="line">// 等价于&lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot; /&gt;</span><br><span class="line">ProtocolConfig protocol = new ProtocolConfig();</span><br><span class="line">protocol.setName(&quot;dubbo&quot;);</span><br><span class="line">protocol.setPort(20880);</span><br><span class="line"></span><br><span class="line">// 等价于&lt;dubbo:monitor protocol=&quot;registry&quot; /&gt;</span><br><span class="line">MonitorConfig monitorConfig = new MonitorConfig();</span><br><span class="line">monitorConfig.setProtocol(&quot;registry&quot;);</span><br><span class="line"></span><br><span class="line">// 等价于&lt;dubbo:service interface=&quot;com.test.UserServiceBo&quot; ref=&quot;userService&quot;</span><br><span class="line">//      group=&quot;dubbo&quot;  version=&quot;1.0.0&quot; timeout=&quot;3000&quot;/&gt;</span><br><span class="line">// 此实例很重，封装了与注册中心的连接，请自行缓存，否则可能造成内存和连接泄漏</span><br><span class="line">ServiceConfig&lt;UserServiceBo&gt; service = new ServiceConfig&lt;&gt;();</span><br><span class="line">service.setApplication(application);</span><br><span class="line">service.setMonitor(monitorConfig);</span><br><span class="line">// 多个注册中心可以用setRegistries()</span><br><span class="line">service.setRegistry(registry);</span><br><span class="line">// 多个协议可以用setProtocols()</span><br><span class="line">service.setProtocol(protocol);</span><br><span class="line">service.setInterface(UserServiceBo.class);</span><br><span class="line">service.setRef(userService);</span><br><span class="line">service.setVersion(&quot;1.0.0&quot;);</span><br><span class="line">service.setGroup(&quot;dubbo&quot;);</span><br><span class="line">service.setTimeout(3000);</span><br><span class="line">service.export();</span><br><span class="line"></span><br><span class="line">// 挂起当前线程</span><br><span class="line">Thread.currentThread().join();</span><br></pre></td></tr></table></figure></li>
<li>Consumer <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 等价于&lt;dubbo:application name=&quot;dubboConsumer&quot; /&gt;</span><br><span class="line">ApplicationConfig application = new ApplicationConfig();</span><br><span class="line">application.setName(&quot;dubboConsumer&quot;);</span><br><span class="line"></span><br><span class="line">// 等价于&lt;dubbo:registry  protocol=&quot;zookeeper&quot; address=&quot;zookeeper://127.0.0.1:2181&quot; /&gt;</span><br><span class="line">RegistryConfig registry = new RegistryConfig();</span><br><span class="line">registry.setAddress(&quot;127.0.0.1:2181&quot;);</span><br><span class="line">registry.setProtocol(&quot;zookeeper&quot;);</span><br><span class="line"></span><br><span class="line">// 等价于 &lt;dubbo:monitor protocol=&quot;registry&quot; /&gt;</span><br><span class="line">MonitorConfig monitorConfig = new MonitorConfig();</span><br><span class="line">monitorConfig.setProtocol(&quot;registry&quot;);</span><br><span class="line"></span><br><span class="line">//等价于&lt;dubbo:reference id=&quot;userService&quot; interface=&quot;com.test.UserServiceBo&quot;</span><br><span class="line">//group=&quot;dubbo&quot; version=&quot;1.0.0&quot; timeout=&quot;3000&quot; /&gt;</span><br><span class="line">// 此实例很重，封装了与注册中心的连接以及与提供者的连接，最好放缓存，否则可能造成内存和连接泄漏</span><br><span class="line">ReferenceConfig&lt;UserServiceBo&gt; reference = new ReferenceConfig&lt;&gt;();</span><br><span class="line">reference.setApplication(application);</span><br><span class="line">// 多个注册中心可以用setRegistries()</span><br><span class="line">reference.setRegistry(registry);</span><br><span class="line">reference.setInterface(UserServiceBo.class);</span><br><span class="line">reference.setVersion(&quot;1.0.0&quot;);</span><br><span class="line">reference.setGroup(&quot;dubbo&quot;);</span><br><span class="line">reference.setTimeout(3000);</span><br><span class="line">reference.setInjvm(false);</span><br><span class="line">reference.setMonitor(monitorConfig);</span><br><span class="line"></span><br><span class="line">UserServiceBo userService = reference.get();</span><br><span class="line">System.out.println(userService.sayHello(&quot;哈哈哈&quot;));</span><br><span class="line">Thread.currentThread().join();</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="泛化调用"><a href="#泛化调用" class="headerlink" title="泛化调用"></a>泛化调用</h3><p>正常情况下我们使用 Dubbo 时会将实体类和接口定义放到一个 SDK 包内，其实也可以不加入这个包、直接将要传的参数放到一个 Map 对象内，称为泛化调用，但是这种方式没有什么实践价值，在此就不赘述了。</p>
<h2 id="Dubbo-架构"><a href="#Dubbo-架构" class="headerlink" title="Dubbo 架构"></a>Dubbo 架构</h2><blockquote>
<p>Dubbo 是一个分布式服务框架，是阿里巴巴 SOA 服务化治理方案的核心框架，致力于提供高性能和透明化的 RPC 远程服务调用方案，以及 SOA 服务治理方案。简而言之，Dubbo 是个远程服务调用的分布式框架（告别 Web Service 模式中的 WSdl，以服务提供者与消费者的方式在 dubbo 上注册）。</p>
</blockquote>
<p>Apache Dubbo 是一款高性能、轻量级的开源 Java RPC 框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。<br>Dubbo 的架构基本上可以概括为 RPC+服务发现，或者可以称之为弹性 RPC 框架。</p>
<h3 id="CP-三大中心"><a href="#CP-三大中心" class="headerlink" title="CP+三大中心"></a>CP+三大中心</h3><p><img src="/imgs/Dubbo/Dubbo%E6%9E%B6%E6%9E%84.png" alt="Dubbo架构" title="Dubbo架构"></p>
<blockquote>
<p>图中的 Consumer 和 Provider 是抽象概念，只是想让看图者更直观的了解哪些类分属于客户端与服务器端，不用 Client 和 Server 的原因是 Dubbo 在很多场景下都使用 Provider、Consumer、Registry、Monitor 划分逻辑拓普节点，保持统一概念。</p>
</blockquote>
<p>Provider: 暴露服务的服务提供方，启动时会注册自己提供的服务到注册中心。<br>Consumer: 调用远程服务的服务消费方，启动时会去注册中心订阅自己需要的服务，服务注册中心异步提供 Provider 的地址列表，Consumer 根据路由规则和预设的负载均衡算法选择一个 Provider 的 IP 进行调用，调用是直连的，失败后会调用另外一个。<br>Registry: 服务注册与发现的注册中心。<br>Monitor: 统计服务的调用次调和调用时间的监控中心，Provider 和 Consumer 在内存中累计调用次数和耗时，并定时每分钟发送一次统计数据到监控中心。<br>Container: 服务运行容器。</p>
<p>大数据量传输时适合用短连接，小数据量高并发适合用长连接。从上图中可以得知，Provider 和 Consumer 均通过长连接与注册中心通信，当消费方调用服务时，会创建一个连接，然后同时会创建一个心跳发送的定时线程池，每一分钟发送一次心跳包到注册中心，通过 ping-pong 来检查连接的存活性，同时还会启动断线重连定时线程池，每两秒钟检查一次连接状态，如果断开就重连，而当注册中心断开连接后，会回调通知 Consumer 销毁连接，同理，Provider 也是通过长连接与注册中心通信。</p>
<h4 id="元数据中心"><a href="#元数据中心" class="headerlink" title="元数据中心"></a>元数据中心</h4><p>2.7 之后提供的一个新组件，容易和注册中心混淆，元数据和注册中心中的注册信息之间的区别如下：</p>
<ul>
<li><strong>元数据（Metadata）</strong>指的是服务分组、服务版本、服务名、方法列表、方法参数列表、超时时间等</li>
<li><strong>注册信息</strong>指服务分组、服务版本、服务名、地址列表等。</li>
</ul>
<p>元数据中心和注册中心包含了一些公共数据，另外，元数据中心还会存储方法列表即参数列表，注册中心存储了服务地址，其他的一些区别如下所示：</p>
<ul>
<li>| 元数据 | 注册信息</li>
<li>| - | -<br>职责 | 描述服务，定义服务的基本属性 | 存储地址列表<br>变化频繁度 | 基本不变 | 随着服务上下线而不断变更<br>数据量 | 大 | 小<br>数据交互&#x2F;存储模型 | 消费者&#x2F;提供者上报，控制台查询 | PubSub 模型，提供者上报，消费者订阅<br>主要使用场景 | 服务测试、服务 | MOCK 服务调用<br>可用性要求 | 元数据中心可用性要求不高，不影响主流程 | 注册中心可用性要求高，影响到服务调用的主流程</li>
</ul>
<h3 id="Dubbo-层次化结构"><a href="#Dubbo-层次化结构" class="headerlink" title="Dubbo 层次化结构"></a>Dubbo 层次化结构</h3><p><img src="/imgs/Dubbo/Dubbo%E6%A1%86%E6%9E%B6.png" alt="Dubbo框架" title="Dubbo框架"><br>Dubbo 的架构是分层的，使用这种方式可以使各个层之间解耦合（或者最大限度地松耦合）。从服务模型的角度来看，Dubbo 采用的是一种非常简单的模型，要么是提供方提供服务，要么是消费方消费服务。</p>
<p><img src="/imgs/Dubbo/Dubbo%E6%89%A9%E5%B1%95.jpg" alt="Dubbo扩展" title="Dubbo扩展"></p>
<ul>
<li>服务接口层（Service）：该层是与实际业务逻辑相关的，根据服务提供方和服务消费方的业务设计对应的接口和实现。</li>
</ul>
<p>RPC 是 Dubbo 的核心：</p>
<ul>
<li>配置层（Config）<br>对外配置接口，以 <strong>ServiceConfig</strong> 和 <strong>ReferenceConfig</strong> 为中心，可以直接 new 配置类，也可以通过 Spring 解析配置生成配置类。</li>
<li>服务代理层（Proxy）<br>服务接口透明代理。Proxy 层封装了所有接口的透明化代理，而在其它层都以 <strong>Invoker</strong> 为中心，只有到了暴露给用户使用时，才用 <strong>Proxy</strong> 将 <strong>Invoker</strong> 转成接口，或将接口实现转成 <strong>Invoker</strong>，也就是去掉 Proxy 层 RPC 是可以 Run 的，只是不那么透明，不那么看起来像调本地服务一样调远程服务。<br>Proxy 层封装了所有接口的透明化代理，而在其它层都以 Invoker 为中心，只有到了暴露给用户使用时，才用 Proxy 将 Invoker 转成接口，或将接口实现转成 Invoker，也就是去掉 Proxy 层 RPC 是可以 Run 的，只是不那么透明，不那么看起来像调本地服务一样调远程服务。</li>
<li>服务注册层（Registry）<br>封装服务地址的注册与发现，以服务 URL 为中心，扩展接口为 <strong>RegistryFactory</strong>、<strong>Registry</strong> 和 <strong>RegistryService</strong>。可能没有服务注册中心，此时服务提供方直接暴露服务。</li>
<li>集群层（Cluster）<br>封装多个提供者的路由及负载均衡，并桥接注册中心，以 Invoker 为中心，扩展接口为 <strong>Cluster</strong>、<strong>Directory</strong>、<strong>Router</strong> 和 <strong>LoadBalance</strong>。将多个服务提供方组合为一个服务提供方，实现对服务消费方来透明，只需要与一个服务提供方进行交互。</li>
<li>监控层（Monitor）<br>RPC 调用次数和调用时间监控，以 <strong>Statistics</strong> 为中心，扩展接口为 <strong>MonitorFactory</strong>、<strong>Monitor</strong>和 <strong>MonitorService</strong>。</li>
<li>远程调用层（Protocol）<br>封装 RPC 调用，扩展接口为 <strong>Protocol</strong>、<strong>Invoker</strong> 和 <strong>Exporter</strong>。Protocol 是服务域，它是 Invoker 暴露和引用的主功能入口，它负责 Invoker 的生命周期管理。Invoker 是实体域，它是 Dubbo 的核心模型，其它模型都向它靠扰，或转换成它，它代表一个可执行体，可向它发起 invoke 调用，它有可能是一个本地的实现，也可能是一个远程的实现，也可能一个集群实现。Protocol 是核心层，也就是只要有 Protocol + Invoker + Exporter 就可以完成非透明的 RPC 调用，然后在 Invoker 的主过程上 Filter 拦截点。</li>
</ul>
<blockquote>
<p>Registry 和 Monitor 实际上不算一层，而是一个独立的节点，只是为了全局概览，用层的方式画在一起。<br>Cluster 是外围概念，Cluster 的目的是将多个 Invoker 伪装成一个 Invoker，这样其它人只要关注 Protocol 层 Invoker 即可，加上 Cluster 或者去掉 Cluster 对其它层都不会造成影响，因为只有一个提供者时，是不需要 Cluster 的。</p>
</blockquote>
<p>Remoting 实现是 Dubbo 协议的实现，如果你选择 RMI 协议，整个 Remoting 都不会用上，Remoting 内部再划为 Transport 传输层和 Exchange 信息交换层，Transport 层只负责单向消息传输，是对 Mina、Netty、Grizzly 的抽象，它也可以扩展 UDP 传输，而 Exchange 层是在传输层之上封装了 Request-Response 语义。</p>
<ul>
<li>交换层（Exchange）：封装请求响应模式，同步转异步，以 Request 和 Response 为中心，扩展接口为<strong>Exchanger</strong>、<strong>ExchangeChannel</strong>、<strong>ExchangeClient</strong>和<strong>ExchangeServer</strong>。</li>
<li>网络传输层（Transport）：抽象 mina 和 netty 为统一接口，以 Message 为中心，扩展接口为<strong>Channel</strong>、<strong>Transporter</strong>、<strong>Client</strong>、<strong>Server</strong>和<strong>Codec</strong>。</li>
<li>数据序列化层（Serialize）：可复用的一些工具，扩展接口为<strong>Serialization</strong>、 <strong>ObjectInput</strong>、<strong>ObjectOutput</strong>和<strong>ThreadPool</strong>。</li>
</ul>
<p><img src="/imgs/Dubbo/Dubbo%E5%8C%85%E7%BB%93%E6%9E%84.png" alt="Dubbo包结构" title="Dubbo包结构"></p>
<ul>
<li>dubbo-common 公共逻辑模块，包括 Util 类和通用模型。</li>
<li>dubbo-remoting 远程通讯模块，相当于 Dubbo 协议的实现，如果 RPC 用 RMI 协议则不需要使用此包。</li>
<li>dubbo-rpc 远程调用模块，抽象各种协议，以及动态代理，只包含一对一的调用，不关心集群的管理。</li>
<li>dubbo-cluster 集群模块，将多个服务提供方伪装为一个提供方，包括：负载均衡、容错、路由等，集群的地址列表可以是静态配置的，也可以是由注册中心下发。</li>
<li>dubbo-registry 注册中心模块，基于注册中心下发地址的集群方式，以及对各种注册中心的抽象。</li>
<li>dubbo-monitor 监控模块，统计服务调用次数，调用时间的，调用链跟踪的服务。</li>
<li>dubbo-config 配置模块，是 Dubbo 对外的 API，用户通过 Config 使用 Dubbo，隐藏 Dubbo 所有细节。</li>
<li>dubbo-container 容器模块，是一个 Standalone 的容器，以简单的 Main 加载 Spring 启动，因为服务通常不需要 Tomcat&#x2F;JBoss 等 Web 容器的特性，没必要用 Web 容器去加载服务。</li>
</ul>
<h2 id="集群-Cluster"><a href="#集群-Cluster" class="headerlink" title="集群 - Cluster"></a>集群 - Cluster</h2><p>提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。</p>
<h3 id="服务目录（Directory）"><a href="#服务目录（Directory）" class="headerlink" title="服务目录（Directory）"></a>服务目录（Directory）</h3><p><strong>服务目录</strong>中存储了一些和服务提供者有关的信息，通过服务目录，服务消费者可获取到服务提供者的信息，比如 ip、端口、服务协议等。通过这些信息，服务消费者就可通过 Netty 等客户端进行远程调用。<br>服务目录与注册中心之间的区别：</p>
<ul>
<li>注册中心存储服务提供者信息，在 Dubbo 中通过 ZooKeeper 实现；</li>
<li>服务目录是 Invoker 的集合，且这个集合中的元素会随注册中心的变化而进行动态调整。</li>
</ul>
<p>服务目录会在客户端启动时初始化完成，并订阅注册中心的更新：<br><code>com.alibaba.dubbo.registry.support.FailbackRegistry#FailbackRegistry</code><br><code>com.alibaba.dubbo.registry.support.FailbackRegistry#subscribe</code></p>
<h4 id="Directory-继承结构"><a href="#Directory-继承结构" class="headerlink" title="Directory 继承结构"></a>Directory 继承结构</h4><p>Directory 接口包含了一个获取配置信息的方法 getUrl，实现该接口的类可以向外提供配置信息。Directory 有多个实现。</p>
<ul>
<li>StaticDirectory<br>获取一次 Invoker 列表后就不变了。</li>
<li>RegistryDirectory<br>实现了 NotifyListener 接口，当注册中心服务配置发生变化后，RegistryDirectory 可收到与当前服务相关的变化，然后根据配置变更信息刷新 Invoker 列表。<br>刷新 Invoker 列表代码：com.alibaba.dubbo.registry.integration.RegistryDirectory#refreshInvoker</li>
</ul>
<h3 id="路由（Router）"><a href="#路由（Router）" class="headerlink" title="路由（Router）"></a>路由（Router）</h3><p>服务目录中包含多个 Invoker，需要通过路由规则来选择调用哪个，Dubbo 提供了 3 种路由实现：<strong>条件路由 ConditionRouter</strong>、<strong>脚本路由 ScriptRouter</strong> 和<strong>标签路由 TagRouter</strong>。</p>
<h4 id="条件路由（ConditionRouter）"><a href="#条件路由（ConditionRouter）" class="headerlink" title="条件路由（ConditionRouter）"></a>条件路由（ConditionRouter）</h4><h3 id="容错方案"><a href="#容错方案" class="headerlink" title="容错方案"></a>容错方案</h3><p><img src="/imgs/Dubbo/%E9%9B%86%E7%BE%A4%E5%AE%B9%E9%94%99.png" alt="集群容错" title="集群容错"><br>Dubbo 提供多种集群的容错方案，默认情况下为 Failover。<br><code>com.alibaba.dubbo.rpc.cluster.Cluster</code></p>
<h4 id="Failover"><a href="#Failover" class="headerlink" title="Failover"></a>Failover</h4><p>失败自动切换，当出现失败，重试其它服务器 （该配置为默认配置）。通常用于读操作，但重试会带来更长时间的延迟。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--配置集群容错模式为失败自动切换 --&gt;</span><br><span class="line">&lt;dubbo:reference cluster=&quot;failover&quot; /&gt;</span><br><span class="line">&lt;!-- 调用queryOrder方法如果失败共调3次，重试2次，如果成功则只调1次 --&gt;</span><br><span class="line">&lt;dubbo:reference&gt;</span><br><span class="line">    &lt;dubbo:method name=&quot;queryOrder&quot; retries=&quot;2&quot; /&gt;</span><br><span class="line">&lt;/dubbo:reference&gt;</span><br></pre></td></tr></table></figure>
<p>通常用于幂等操作，多次调用副作用相同，譬如只读请求，Failover 使用得较多，推荐使用，但重试会带来更长延迟，应用于消费者和提供者的服务调用。</p>
<h4 id="Failfast"><a href="#Failfast" class="headerlink" title="Failfast"></a>Failfast</h4><p>快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录和修改数据，Failfast 使用得较多，但如果有机器正在重启，可能会出现调用失败，应用于消费者和提供者的服务调用。</p>
<h4 id="Failsafe"><a href="#Failsafe" class="headerlink" title="Failsafe"></a>Failsafe</h4><p>失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作，Failsafe 使用得不多，但调用信息会丢失，应用于发送统计信息到监控中心。</p>
<h4 id="Failback"><a href="#Failback" class="headerlink" title="Failback"></a>Failback</h4><p>失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作，使用得很少，不可靠，重启会丢失，应用于注册服务到注册中心。</p>
<h4 id="Forking"><a href="#Forking" class="headerlink" title="Forking"></a>Forking</h4><p>并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，使用得很少，但需要浪费更多服务资源。</p>
<h4 id="Broadcast"><a href="#Broadcast" class="headerlink" title="Broadcast"></a>Broadcast</h4><p>广播调用所有提供者，逐个调用，任意一台报错则报错 。通常用于通知所有提供者更新缓存或日志等本地资源信息，速度慢，任意一台报错则报错，使用得很少。</p>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><h4 id="Random-LoadBalance"><a href="#Random-LoadBalance" class="headerlink" title="Random LoadBalance"></a>Random LoadBalance</h4><p>随机调用（默认配置），按权重设置随机概率，在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重，使用较多，推荐使用，但重试时，可能出现瞬间压力不均。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 服务端方法基本负载均衡设置 --&gt;</span><br><span class="line">&lt;dubbo:service interface=&quot;com.service.dubbo.queryOrder&quot;&gt;</span><br><span class="line">    &lt;dubbo:method name=&quot;queryOrder&quot; loadbalance=&quot;roundrobin&quot; /&gt;</span><br><span class="line">&lt;/dubbo:service&gt;</span><br></pre></td></tr></table></figure>
<h4 id="RoundRobin-LoadBalance"><a href="#RoundRobin-LoadBalance" class="headerlink" title="RoundRobin LoadBalance"></a>RoundRobin LoadBalance</h4><p>轮循调用，按公约后的权重设置轮循比率，存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上，极端情况可能产生雪崩。</p>
<h4 id="LeastActive-LoadBalance"><a href="#LeastActive-LoadBalance" class="headerlink" title="LeastActive LoadBalance"></a>LeastActive LoadBalance</h4><p>最少活跃数调用，相同活跃数的随机，活跃数指调用前后计数差，使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差（与时间有关）会越大，但不支持权重。</p>
<h4 id="ConsistentHash-LoadBalance"><a href="#ConsistentHash-LoadBalance" class="headerlink" title="ConsistentHash LoadBalance"></a>ConsistentHash LoadBalance</h4><p>一致性 Hash，相同参数的请求总是发到同一提供者，当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。缺省只对第一个参数 Hash，如果要修改，请配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:parameter key=&quot;hash.arguments&quot; value=&quot;0,1&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>缺省用 160 份虚拟节点，如果要修改，请配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:parameter key=&quot;hash.nodes&quot; value=&quot;320&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>由于是通过哈希算法分摊调用，有可能出现调用不均匀的情况</p>
<h2 id="远程通信-Transport"><a href="#远程通信-Transport" class="headerlink" title="远程通信 - Transport"></a>远程通信 - Transport</h2><p>提供对多种基于长连接的 NIO 框架抽象封装，包括多种线程模型，序列化，以及“请求-响应”模式的信息交换方式。<br>Dubbo 支持如下网络通信框架：</p>
<ul>
<li>Mina</li>
<li>Netty</li>
<li>Grizzly</li>
</ul>
<h2 id="序列化-Serialize"><a href="#序列化-Serialize" class="headerlink" title="序列化 - Serialize"></a>序列化 - Serialize</h2><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>通过缓存加载的 Class、setAccessible(false)去掉安全校验等来提高反射效率，或者使用反射包<strong>ReflectASM</strong>。</p>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>对性能敏感，对开发体验要求不高的内部系统 thrift 或 protobuf<br>对开发体验敏感，性能有要求的内外部系统 hessian2<br>对序列化后的数据要求有良好的可读性 jackson&#x2F;gson&#x2F;xml<br>对兼容性和性能要求较高的系统 protobuf 或 kryo ，它们的性能相差不多，但是 protobuf 有个缺点就是要传输的每一个类的结构都要生成对应的 proto 文件。</p>
<h2 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h2><p>ProtocolFilterWrapper#export：如果当前 protocol 不是 registry，则调用 buildInvokerChain<br>-&gt; ProtocolFilterWrapper#buildInvokerChain<br>-&gt; ExtensionLoader#getActivateExtension(URL url, String key, String group)：获取系统自动激活的 Filter 和用户自定义的 Filter，最后合并返回</p>
<h2 id="更多功能"><a href="#更多功能" class="headerlink" title="更多功能"></a>更多功能</h2><h3 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h3><p>限流最好配置在 Provider 端，因为 Consumer 可能有很多个服务器实例，如果他们同时发起对同一 Provider 实例的请求可能会超出机器的处理能力上限。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 限制接口OrderService里的每个方法，服务提供者端的执行线程不超过10个 --&gt;</span><br><span class="line">&lt;dubbo:service interface=&quot;com.bubbo.service.OrderService&quot; executes=&quot;10&quot; /&gt;</span><br><span class="line">&lt;!-- 限制接口OrderService里的queryOrderList方法，服务提供者端的执行线程不超过10个 --&gt;</span><br><span class="line">&lt;dubbo:service interface=&quot;com.bubbo.service.OrderService&quot;&gt;</span><br><span class="line">    &lt;dubbo:method name=&quot;queryOrderList&quot; executes=&quot;10&quot; /&gt;</span><br><span class="line">&lt;/dubbo:service&gt;</span><br><span class="line">&lt;!--限制使用dubbo协议时在服务提供者端启用的连接数不超过1000个--&gt;</span><br><span class="line">&lt;dubbo:provider protocol=&quot;dubbo&quot; accepts=&quot;1000&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>上述配置限制的是线程数，即并发连接数，Consumer 和 Provider 默认通过一条共享的 TCP 长连接通信，连接成功的情况下请求线程交由 IO 线程池异步读写数据，数据被反序列化后交由业务线程池处理具体业务，也就是对应的 Impl 实现类的具体方法。</p>
<h3 id="服务隔离"><a href="#服务隔离" class="headerlink" title="服务隔离"></a>服务隔离</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--当同一个接口有多个实现时，可以通过group来隔离  --&gt;</span><br><span class="line">&lt;!--服务提供者  --&gt;</span><br><span class="line">&lt;dubbo:service group=&quot;ImplA&quot; interface=&quot;com.bubbo.service.OrderService&quot;/&gt;</span><br><span class="line">&lt;dubbo:service group=&quot;ImplB&quot; interface=&quot;com.bubbo.service.OrderService&quot;/&gt;</span><br><span class="line">&lt;!--服务调用者  --&gt;</span><br><span class="line">&lt;dubbo:reference id=&quot;MethodA&quot; group=&quot;ImplA&quot; interface=&quot;com.bubbo.service.OrderService&quot;/&gt;</span><br><span class="line">&lt;dubbo:reference id=&quot;MethodB&quot; group=&quot;ImplB&quot; interface=&quot;com.bubbo.service.OrderService&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--当一个接口出现升级，新旧实现同时存在时，可以通过版本号来隔离，通常版本号隔离也用于联调阶段，不同版本号的服务无法调用，版本号相同的服务才能调用  --&gt;</span><br><span class="line">&lt;!--服务提供者  --&gt;</span><br><span class="line">&lt;dubbo:service interface=&quot;com.bubbo.service.OrderService&quot; version=&quot;new2.0.0&quot;/&gt;</span><br><span class="line">&lt;dubbo:service interface=&quot;com.bubbo.service.OrderService&quot; version=&quot;old1.0.0&quot;/&gt;</span><br><span class="line">&lt;!--服务调用者  --&gt;</span><br><span class="line">&lt;dubbo:reference id=&quot;NewMethodA&quot; interface=&quot;com.bubbo.service.OrderService&quot; version=&quot;new2.0.0&quot;/&gt;</span><br><span class="line">&lt;dubbo:reference id=&quot;OldMethodB&quot; interface=&quot;com.bubbo.service.OrderService&quot; version=&quot;old1.0.0&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p><strong>通过版本号，也可以实现消费者和提供者服务端直接连接</strong>，因为发起调用默认使用随机调用端负载均衡模式，当有多台提供者的时候，会随机选取，通常联调阶段都会调用指定服务进行联调，直连一般用在调试，开发阶段，只需要消费者和提供者 version 相同即可。</p>
<h3 id="灰度发布"><a href="#灰度发布" class="headerlink" title="灰度发布"></a>灰度发布</h3><p>有三台服务器 A、B、C 要上线，现在三台服务器都是旧版本代码，那首先从 Ngnix 负载均衡列表里移除 A 服务器的配置，切断对 A 的访问，然后在 A 服务器不受新的代码，重新把 A 配置进 Ngnix 负载均衡列表。如果在线使用没有问题，则继续升级 B、C 服务器，否则回滚，恢复旧版本代码，这是针对三端（PC 端，微信端，移动端）跟网关系统的。<br>如果是针对子系统，譬如用户系统、订单系统等，可以通过分组 group 来实现子系统的灰度发布。服务提供者有两组，One、Two，将新版本代码 group 改为 Two，旧版本 group 还是 One，将新版本的消费者 group 改为 Two，这时请求定位到新的消费者再调用新的提供者，而且旧的消费者还是请求旧的提供者，如果线上没有问题，那就把提供者 group 为 One 的组改为 Two，并部署新代码，旧的消费者也改成 Two 并部署新代码如果有问题，那消费端和提供端都回滚到旧版本。</p>
<h3 id="异步调用"><a href="#异步调用" class="headerlink" title="异步调用"></a>异步调用</h3><p>Dubbo 默认情况下是同步调用的，就是调用后立刻返回，但如果消费端调用服务端创建文件并转化成 PDF 格式的文件这种在 IO 密集操作时，消费端同步调用需要等待对方转换结束才返回，很消耗性能，这时选择异步调用和回调调用更合适。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">async=&quot;true&quot; 异步调用，调用后不用等待，继续往下执行</span><br><span class="line">onreturn =&quot;CallBack.onreturn&quot; 返回后调用自定义的类CallBack类的onreturn方法</span><br><span class="line">onthrow=&quot;CallBack.onthrow&quot; 调用后，提供者抛出异常后，返回调用自定义的类CallBack类的onthrow方法</span><br><span class="line">--&gt;    </span><br><span class="line">&lt;!--服务调用者  --&gt;</span><br><span class="line">&lt;dubbo:reference id=&quot;tranfromPDF&quot; interface=&quot;com.bubbo.service.OrderService&quot; &gt;</span><br><span class="line">    &lt;dubbo:method name=&quot;tranPDF&quot; async=&quot;true&quot; </span><br><span class="line">    onreturn =&quot;CallBack.onreturn&quot; </span><br><span class="line">    onthrow=&quot;CallBack.onthrow&quot;/&gt;</span><br><span class="line"> &lt;/dubbo:reference&gt;</span><br></pre></td></tr></table></figure>

<p>可以在 onthrow 事件里实现服务降级的方法，譬如遇到网络抖动，调用超时返回时可在 onthrow 里 return null。</p>
<ul>
<li>调用方  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testQueryOrder() &#123;</span><br><span class="line">    // 此时调用会立即拿到null值</span><br><span class="line">    List&lt;Order&gt; list = this.orderService.queryOrderList();</span><br><span class="line">    // 拿到Future的引用，在提供方返回结果后，结果值会被设置进Future</span><br><span class="line">    Future&lt;String&gt; orderFuture = RpcContext.getContext().getFuture();</span><br><span class="line">    try &#123;</span><br><span class="line">        // 该方法是阻塞方法，在拿到值之前一直等待，直到拿到值才会被唤醒，该方法会抛出异常，可以捕获</span><br><span class="line">        String returnValue = orderFuture.get();</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; catch (ExecutionException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>回调方  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 回调接口</span><br><span class="line">interface ICallBack &#123;</span><br><span class="line">    // 第一个参数是返回值，第二个参数是原参数</span><br><span class="line">    public void onreturn(String returnValue, String initParameter);</span><br><span class="line"></span><br><span class="line">    // 第一个参数是异常，第二个参数是原参数</span><br><span class="line">    public void onthrow(Throwable ex, String initParameter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实现类</span><br><span class="line">class CallBackImpl implements ICallBack &#123;</span><br><span class="line">    public void onreturn(String returnValue, String initParameter) &#123;</span><br><span class="line">        // do something</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    public void onthrow(Throwable ex, String initParameter) &#123;</span><br><span class="line">        // do something</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="/imgs/Dubbo/%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8.png" alt="异步调用" title="异步调用"><br>调用方有一个用户线程池用于处理调用请求（比如 Tomcat 里那个线程池），请求被转发到 IO 线程池，由 IO 线程来发起对提供方的调用，此时 IO 线程会新建一个 Future 对象进 RpcContext，用户线程可以继续继续自己的业务逻辑，然后在需要的时候调用 Future 的 get 方法阻塞等待，而服务端只需要将结果返回给 IO 线程，由 IO 线程调用 notify 方法唤醒阻塞等待中的用户线程。</p>
<h3 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h3><p>服务降级用于在服务高峰期将次要服务降级，仅保留关键服务，从而降低系统负载、提升可用性。比如，订单列表正常情况下展示所有订单，但是如果是在网站开展秒杀之类的大促活动时，就可以降级展示当月的订单而不是所有，再其次，如果服务器宕机了，也最好展示兜底页而不是 504。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:service interface=&quot;com.bubbo.service.OrderService&quot; mock=&quot;com.dubbo.service.MonthOderMock&quot;/&gt;</span><br></pre></td></tr></table></figure>

<h3 id="热点缓存"><a href="#热点缓存" class="headerlink" title="热点缓存"></a>热点缓存</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--服务调用者 --&gt;</span><br><span class="line">&lt;dubbo:reference id=&quot;queryCatalog&quot; interface=&quot;com.bubbo.service.CatalogService&quot;&gt;</span><br><span class="line">    &lt;dubbo:method name=&quot;queryCatalog&quot; cache=&quot;lru&quot; /&gt;</span><br><span class="line">&lt;/dubbo:reference&gt;</span><br><span class="line">&lt;dubbo:monitor protocol=&quot;registry&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>如果查询的对象改变很少但又数据量很大的时候，如首页目录，可以避免每次都频繁调用服务端，可以设置本地缓存，加快热点数据的访问，Dubbo 的缓存类型 LRU 缓存，最近最少使用的数据会被清除，使用频繁的数据被保留，Thredlocal 缓存，当前线程的缓存，假如当前线程有多次请求，每次请求都需要相同的用户信息，那就适用，避免每次都去查询用户基本信息。</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>环境配置比较简单，就是 zk-&gt;provider-&gt;consumer，在此不再赘述。</p>
<h3 id="失败重试"><a href="#失败重试" class="headerlink" title="失败重试"></a>失败重试</h3><p>Dubbo 中的失败重试机制比较丰富，基本考虑到常用的场景<br><a target="_blank" rel="noopener" href="http://dubbo.apache.org/zh-cn/docs/user/demos/fault-tolerent-strategy.html">http://dubbo.apache.org/zh-cn/docs/user/demos/fault-tolerent-strategy.html</a><br>FailoverClusterInvoker、FailfastClusterInvoker 等，以 FailoverClusterInvoker 为例：<br>FailoverClusterInvoker.doInvoke 重试几次，把失败的添加到 invoked 列表里<br>    -&gt; AbstractClusterInvoker.select 选一个可用的调用，如果是已经被选过或因为其他条件不可用则 reselect</p>
<h3 id="负载均衡-1"><a href="#负载均衡-1" class="headerlink" title="负载均衡"></a>负载均衡</h3><p><a target="_blank" rel="noopener" href="http://dubbo.apache.org/zh-cn/docs/user/demos/loadbalance.html">http://dubbo.apache.org/zh-cn/docs/user/demos/loadbalance.html</a></p>
<h3 id="幂等"><a href="#幂等" class="headerlink" title="幂等"></a>幂等</h3><p>Dubbo 没有提供幂等性检查功能，需要自定义。</p>
<h3 id="限流-1"><a href="#限流-1" class="headerlink" title="限流"></a>限流</h3><p>Dubbo 中的限流比较简单，采用的是<strong>计数器算法</strong>，单位时间内超出阈值的流量会被直接丢弃，而且只支持 PORVIDER 端的限流，而且为了让它生效还要搞复杂的 SPI 配置。<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/7112a8d3d869">https://www.jianshu.com/p/7112a8d3d869</a><br>入口：TpsLimitFilter.invoke<br>    -&gt; TPSLimiter.isAllowable 为每个 Service 创建一个计数器 StatItem（粒度是整个 Service 有没有太大了）</p>
<h3 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h3><p>Dubbo 里的降级比较水，即调用出错就改成调用 Mock 接口，没有 Hystrix 中那么复杂的逻辑：<br><a target="_blank" rel="noopener" href="http://dubbo.apache.org/zh-cn/docs/user/demos/service-downgrade.html">http://dubbo.apache.org/zh-cn/docs/user/demos/service-downgrade.html</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/java-zhao/p/8320519.html">https://www.cnblogs.com/java-zhao/p/8320519.html</a><br>入口：ReferenceConfig.createProxy 创建代理<br>    -&gt; ProxyFactory.getProxy<br>    -&gt; InvokerInvocationHandler.invoke<br>    -&gt; MockClusterInvoker.invoke 如果配置中有 fail 开头，则在远程调用失败后调用 doMockInvoke，大概逻辑是实例化一个 XxxServiceMock 服务然后调用</p>
<h3 id="优雅停机"><a href="#优雅停机" class="headerlink" title="优雅停机"></a>优雅停机</h3><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/6e4d1ecb0815">https://www.jianshu.com/p/6e4d1ecb0815</a></p>
<h2 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h2><h3 id="说一下你们怎么用-Dubbo-的（考对-Dubbo-的应用能力）"><a href="#说一下你们怎么用-Dubbo-的（考对-Dubbo-的应用能力）" class="headerlink" title="说一下你们怎么用 Dubbo 的（考对 Dubbo 的应用能力）"></a>说一下你们怎么用 Dubbo 的（考对 Dubbo 的应用能力）</h3><h3 id="说一下-Dubbo-的工作原理"><a href="#说一下-Dubbo-的工作原理" class="headerlink" title="说一下 Dubbo 的工作原理"></a>说一下 Dubbo 的工作原理</h3><p><img src="/imgs/Dubbo/Dubbo%E6%9E%B6%E6%9E%84.png" alt="Dubbo架构" title="Dubbo架构"><br>描述 Registry、Consumer、Provider 之间的关系。</p>
<h3 id="Dubbo-负载均衡策略和集群容错策略都有哪些"><a href="#Dubbo-负载均衡策略和集群容错策略都有哪些" class="headerlink" title="Dubbo 负载均衡策略和集群容错策略都有哪些"></a>Dubbo 负载均衡策略和集群容错策略都有哪些</h3><p>负载均衡策略和集群容错策略见上面的《集群》小节。</p>
<h3 id="Dubbo-的动态代理策略"><a href="#Dubbo-的动态代理策略" class="headerlink" title="Dubbo 的动态代理策略"></a>Dubbo 的动态代理策略</h3><p>javassist，类似 CGLIB，通过继承目标类以生成代理类。</p>
<h3 id="说一下服务注册（导出）过程"><a href="#说一下服务注册（导出）过程" class="headerlink" title="说一下服务注册（导出）过程"></a>说一下服务注册（导出）过程</h3><p>分本地暴露和远程暴露两种</p>
<h3 id="说一下服务消费（引入）过程"><a href="#说一下服务消费（引入）过程" class="headerlink" title="说一下服务消费（引入）过程"></a>说一下服务消费（引入）过程</h3><h3 id="服务的运行过程中，如果-ZooKeeper-挂掉了，这时还能正常请求吗？"><a href="#服务的运行过程中，如果-ZooKeeper-挂掉了，这时还能正常请求吗？" class="headerlink" title="服务的运行过程中，如果 ZooKeeper 挂掉了，这时还能正常请求吗？"></a>服务的运行过程中，如果 ZooKeeper 挂掉了，这时还能正常请求吗？</h3><h3 id="说一下-Dubbo-协议"><a href="#说一下-Dubbo-协议" class="headerlink" title="说一下 Dubbo 协议"></a>说一下 Dubbo 协议</h3><h3 id="Dubbo-有几种容错机制"><a href="#Dubbo-有几种容错机制" class="headerlink" title="Dubbo 有几种容错机制"></a>Dubbo 有几种容错机制</h3><h3 id="dubbo-有几种服务降级机制"><a href="#dubbo-有几种服务降级机制" class="headerlink" title="dubbo 有几种服务降级机制"></a>dubbo 有几种服务降级机制</h3><h3 id="dubbo-有几种服务降级机制-1"><a href="#dubbo-有几种服务降级机制-1" class="headerlink" title="dubbo 有几种服务降级机制"></a>dubbo 有几种服务降级机制</h3><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a target="_blank" rel="noopener" href="https://github.com/apache/incubator-dubbo">apache&#x2F;incubator-dubbo</a></li>
<li><a target="_blank" rel="noopener" href="http://dubbo.apache.org/en-us/docs/user/preface/background.html">Dubbo 文档</a></li>
<li><a target="_blank" rel="noopener" href="http://dubbo.apache.org/en-us/docs/user/demos/preflight-check.html">Dubbo 实例 Demos</a><br><a target="_blank" rel="noopener" href="http://dubbo.apache.org/zh-cn/docs/user/demos/preflight-check.html">中文版</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/j3t9z7h/article/details/81437570">设计 RPC 接口时，你有考虑过这些吗？</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/wolfcode_cn/article/details/81907241">解密 Dubbo:自己动手编写 RPC 框架</a></li>
</ol>
<h3 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h3><ol>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/j3T9Z7H/article/details/82836811">研究优雅停机时的一点思考</a><br><code>kill -9</code>与<code>kill -15</code>的区别，SpringBoot 的停机机制。</li>
<li><a target="_blank" rel="noopener" href="http://www.solves.com.cn/it/cxkf/bk/2019-10-14/6046.html">一文聊透 Dubbo 优雅停机</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1543749">一文聊透 Dubbo 优雅上线</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000015276158">Spring-boot+Dubbo 应用启停源码分析</a></li>
<li><a target="_blank" rel="noopener" href="http://dubbo.apache.org/zh-cn/docs/source_code_guide/export-service.html">服务导出</a></li>
<li><a target="_blank" rel="noopener" href="http://dubbo.apache.org/zh-cn/docs/source_code_guide/refer-service.html">服务引入</a></li>
</ol>
<h3 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h3><ol>
<li><a target="_blank" rel="noopener" href="http://dubbo.apache.org/zh-cn/docs/source_code_guide/dubbo-spi.html">Dubbo SPI</a></li>
<li><a target="_blank" rel="noopener" href="http://dubbo.apache.org/zh-cn/docs/source_code_guide/adaptive-extension.html">自适应拓展机制</a></li>
</ol>
<h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><ol>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/X5fnncxzq4/article/details/80729942">【RPC 专栏】深入理解 RPC 之协议篇</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43970890/article/details/103348778">Dubbo 在跨语言和协议穿透性方向的探索：支持 HTTP&#x2F;2 gRPC</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013815546/article/details/96364814">一文详细解读 Dubbo 中的 http 协议</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.itpub.net/31556476/viewspace-2375225/">聊聊 TCP 长连接和心跳那些事</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.itpub.net/31556476/viewspace-2305549/">Dubbo 中的 URL 统一模型</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnkirito.moe/network-interfaces/">研究网卡地址注册时的一点思考</a></li>
<li><a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc5234">RFC 5234 - Augmented BNF for Syntax Specifications: ABNF</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5cac08a26fb9a068996d5fb2">服务端经典的 C10k 问题(译)</a></li>
</ol>
<h3 id="心跳机制"><a href="#心跳机制" class="headerlink" title="心跳机制"></a>心跳机制</h3><ol>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_34175509/article/details/87997148">一种心跳，两种设计</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.itpub.net/31556476/viewspace-2375225/">聊聊 TCP 长连接和心跳那些事</a></li>
</ol>
<h3 id="序列化-1"><a href="#序列化-1" class="headerlink" title="序列化"></a>序列化</h3><ol>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/X5fnncxzq4/article/details/80333364">【RPC 专栏】深入理解 RPC 之序列化篇–总结篇</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/X5fnncxzq4/article/details/80276182">【RPC 专栏】深入理解 RPC 之序列化篇 —— Kryo</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/loveqishan/article/details/89531587">如何提高使用 Java 反射的效率？</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_26525215/article/details/82943040">Java 序列化框架性能比较</a></li>
</ol>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/459b2cfd.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tallate">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tallate">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/459b2cfd.html" class="post-title-link" itemprop="url">Dubbo的网络通信</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-09-07 18:51:58" itemprop="dateCreated datePublished" datetime="2019-09-07T18:51:58+08:00">2019-09-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-07 01:56:20" itemprop="dateModified" datetime="2025-07-07T01:56:20+08:00">2025-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Dubbo/" itemprop="url" rel="index"><span itemprop="name">Dubbo</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>

<p>Dubbo 支持多种协议，如下图所示：<br><img src="/imgs/Dubbo/Protocol%E6%89%A9%E5%B1%95.png" alt="Protocol扩展" title="Protocol扩展"><br>在通信过程中，不同的服务等级一般对应着不同的服务质量，那么选择合适的协议便是一件非常重要的事情，需要根据应用的特征来选择。例如，使用 RMI 协议，一般会受到防火墙的限制，所以对于外部与内部进行通信的场景，就不要使用 RMI 协议，而是基于 HTTP 协议或者 Hessian 协议。</p>
<h3 id="Hessian-协议"><a href="#Hessian-协议" class="headerlink" title="Hessian 协议"></a>Hessian 协议</h3><ul>
<li>连接个数：多连接</li>
<li>连接方式：短连接</li>
<li>传输协议：HTTP</li>
<li>传输方式：同步传输</li>
<li>序列化：Hessian 二进制序列化</li>
<li>适用范围：传入传出参数数据包较大，提供者比消费者个数多，提供者压力较大，可传文件。</li>
<li>适用场景：页面传输，文件传输，Hessian 是 Caucho 开源的一个 RPC 框架，其通讯效率高于 WebService 和 Java 自带的序列化，Hessian 底层采用 Http 通讯，采用 Servlet 暴露服务，Dubbo 缺省内嵌 Jetty 作为服务器实现。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--定义 hessian 协议 --&gt;</span><br><span class="line">&lt;dubbo:protocol name=&quot;hessian&quot; port=&quot;8080&quot; server=&quot;jetty&quot; /&gt;</span><br><span class="line">&lt;!--设置默认协议 --&gt;</span><br><span class="line">&lt;dubbo:service protocol=&quot;hessian&quot; /&gt;</span><br><span class="line">&lt;!--设置 service 协议 --&gt;</span><br><span class="line">&lt;dubbo:service protocol=&quot;hessian&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.caucho&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;hessian&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.0.33&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="Http-协议"><a href="#Http-协议" class="headerlink" title="Http 协议"></a>Http 协议</h3><ul>
<li>连接个数：多连接</li>
<li>连接方式：短连接</li>
<li>传输协议：HTTP</li>
<li>传输方式：同步传输</li>
<li>序列化：表单序列化</li>
<li>适用范围：传入传出参数数据包大小混合，提供者比消费者个数多，可用浏览器查看，可用表单或 URL 传入参数，暂不支持传文件。</li>
<li>适用场景：需同时给应用程序和浏览器 JS 使用的服务。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--配置协议 --&gt;</span><br><span class="line">&lt;dubbo:protocol name=&quot;http&quot; port=&quot;8080&quot; /&gt;</span><br></pre></td></tr></table></figure>

<h3 id="Thrift-协议"><a href="#Thrift-协议" class="headerlink" title="Thrift 协议"></a>Thrift 协议</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.thrift&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;libthrift&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.8.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dubbo:protocol name=&quot;thrift&quot; port=&quot;3030&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>Dubbo 使用的 Thrift 和原生的 Thrift 协议不兼容，在原生协议的基础上添加了一些额外的头信息，比如 service name，magic number 等。</p>
<h3 id="Rest-协议"><a href="#Rest-协议" class="headerlink" title="Rest 协议"></a>Rest 协议</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 用rest协议在8080端口暴露服务 --&gt;</span><br><span class="line">&lt;dubbo:protocol name=&quot;rest&quot; port=&quot;8080&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 声明需要暴露的服务接口 --&gt;</span><br><span class="line">&lt;dubbo:service interface=&quot;com.service.OrderService&quot; ref=&quot;orderService&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 和本地bean一样实现服务 --&gt;</span><br><span class="line">&lt;bean id=&quot;orderService&quot; class=&quot;com.service.OrderServiceImpl&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>在代码中需要通过注解指定访问路径：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class OrderService &#123;    </span><br><span class="line">   void createOrder(Order order);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Path(&quot;orders&quot;) // 访问Url的相对路径</span><br><span class="line">public class OrderServiceImpl implements OrderService &#123;</span><br><span class="line"></span><br><span class="line">    @POST</span><br><span class="line">    @Path(&quot;create&quot;) // 访问Url的相对路径</span><br><span class="line">    // 将传递过来的JSON数据反序列化为Order对象</span><br><span class="line">    @Consumes(&#123;MediaType.APPLICATION_JSON&#125;) </span><br><span class="line">    public void createOrder(Order order) &#123;</span><br><span class="line">        // create the order...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="长连接-OR-短连接"><a href="#长连接-OR-短连接" class="headerlink" title="长连接 OR 短连接"></a>长连接 OR 短连接</h3><p>Dubbo 协议缺省每服务每提供者每消费者使用单一长连接，如果数据量较大，可以使用多个连接。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 表示该服务使用 JVM 共享长连接 --&gt;</span><br><span class="line">&lt;dubbo:service connections=&quot;0&quot;&gt; </span><br><span class="line">&lt;dubbo:reference connections=&quot;0&quot;&gt;</span><br><span class="line">&lt;!-- 表示该服务使用独立长连接 --&gt;</span><br><span class="line">&lt;dubbo:service connections=&quot;1&quot;&gt; </span><br><span class="line">&lt;dubbo:reference connections=&quot;1&quot;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="为什么要消费者比提供者个数多"><a href="#为什么要消费者比提供者个数多" class="headerlink" title="为什么要消费者比提供者个数多"></a>为什么要消费者比提供者个数多</h3><p>因为 dubbo 协议采用单一长连接，假设网络为千兆网卡 3，根据测试经验数据每条连接最多只能压满 7MByte（不同的环境可能不一样），理论上 1 个服务提供者需要 20 个服务消费者才能压满网卡。</p>
<h3 id="为什么不能传大包"><a href="#为什么不能传大包" class="headerlink" title="为什么不能传大包"></a>为什么不能传大包</h3><p>因 dubbo 协议采用单一长连接，如果每次请求的数据包大小为 500KByte，假设网络为千兆网卡 3，每条连接最大 7MByte(不同的环境可能不一样，供参考)，单个服务提供者的 TPS(每秒处理事务数)最大为：128MByte &#x2F; 500KByte &#x3D; 262。单个消费者调用单个服务提供者的 TPS(每秒处理事务数)最大为：7MByte &#x2F; 500KByte &#x3D; 14。如果能接受，可以考虑使用，否则网络将成为瓶颈。</p>
<h3 id="为什么采用异步单一长连接"><a href="#为什么采用异步单一长连接" class="headerlink" title="为什么采用异步单一长连接"></a>为什么采用异步单一长连接</h3><p>因为服务的现状大都是服务提供者少，通常只有几台机器，而服务的消费者多，可能整个网站都在访问该服务，比如 Morgan 的提供者只有 6 台提供者，却有上百台消费者，每天有 1.5 亿次调用，如果采用常规的 hessian 服务，服务提供者很容易就被压跨，通过单一连接，保证单一消费者不会压死提供者，长连接，减少连接握手验证等，并使用异步 IO，复用线程池，防止 C10K 问题（服务器无法服务 1w 左右的并发连接）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 配置协议端口和服务提供方最大连接数，防止服务被压垮 --&gt;</span><br><span class="line">&lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot; accepts=&quot;1000&quot; /&gt;</span><br><span class="line">&lt;!--配置dubbo默认协议 --&gt;</span><br><span class="line">&lt;dubbo:provider protocol=&quot;dubbo&quot; /&gt;</span><br><span class="line">&lt;!--配置dubbo设置服务协议 --&gt;</span><br><span class="line">&lt;dubbo:service protocol=&quot;dubbo&quot; /&gt;</span><br></pre></td></tr></table></figure>

<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/5582e809.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tallate">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tallate">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/5582e809.html" class="post-title-link" itemprop="url">分布式 Session 和 OAuth</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-09-02 21:20:12" itemprop="dateCreated datePublished" datetime="2019-09-02T21:20:12+08:00">2019-09-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-07 01:56:20" itemprop="dateModified" datetime="2025-07-07T01:56:20+08:00">2025-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">分布式系统</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>不论一家企业做什么领域业务，登录基本都是绕不过去的功能——任何操作都必须在已经登录的前提下才能执行，我这里主要聚焦登录中分布式 Session 的设计，然后连带提一下其他方方面面。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/5582e809.html#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/e3d5c2fc.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tallate">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tallate">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/e3d5c2fc.html" class="post-title-link" itemprop="url">Java-线程池</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-09-01 21:07:49" itemprop="dateCreated datePublished" datetime="2019-09-01T21:07:49+08:00">2019-09-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-07 01:56:20" itemprop="dateModified" datetime="2025-07-07T01:56:20+08:00">2025-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>执行异步任务最简单的方式就是通过线程来执行，因为线程本质上是操作系统的资源，应用如果不加限制地占用——最严重的情况下——将会导致系统的宕机。因此，本地线程任务主要依赖线程池来执行，线程池可以看做一种线程资源池，提供了对线程资源的调度功能。当然，提到线程就不得不提并发安全，这又是一个非常复杂的主题，水平有限，无法一一道清。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/e3d5c2fc.html#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/9d02e43e.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tallate">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tallate">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/9d02e43e.html" class="post-title-link" itemprop="url">并发的定义</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-09-01 21:07:49" itemprop="dateCreated datePublished" datetime="2019-09-01T21:07:49+08:00">2019-09-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-07 01:56:20" itemprop="dateModified" datetime="2025-07-07T01:56:20+08:00">2025-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>异步编程富有魅力，但是错误的使用不仅不会带来益处，还会使得系统变得难以维护、Bug 遍地，接下来我希望总结一下遇到的异步任务场景，减少以后遇到类似问题阻塞在设计上的时间。</p>
<blockquote>
<p>曾经经历过因三方（传统行业）接口效率过低而导致服务不可用的情况，交流发现对方根本没有考虑在系统里加入缓存、消息队列等中间件，原因竟然是希望保证高一致性。<br>实际上大部分场景中，查询操作并没有保证一致性的意义，而写操作就算不能马上被看到结果也不会对体验造成太大的影响——只要最终能成功即可，这是符合<code>BASE</code>设计原则的。这个问题后续经排查发现原因是对方因为系统设计有问题、导致频繁大规模的接口超时，重启了后问题缓解，对方就不再追究了，非常无奈。没有不能解决的技术难题，只是有时候沟通、惰性等会阻碍问题的定位。<br>并发的话题真是非常的多，从最底层的硬件到高级语言 Java 中的 JUC，从最繁琐的业务系统（现在一般是微服务架构）到比较新的人工智能（如分布式机器学习），几乎无所不包，一直想爬出坑来，但是总觉得差点意思，在此我也仅仅能根据一些现成的资料总结出一些结论。</p>
</blockquote>
<p>[x] 异步和非阻塞<br>[x] 并发和并行<br>[x] 并发模式 STM 介绍<br>[x] 并发模式 Actor 介绍</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/9d02e43e.html#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/54dfb258.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tallate">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tallate">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/54dfb258.html" class="post-title-link" itemprop="url">异地多活</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-09-01 21:07:49" itemprop="dateCreated datePublished" datetime="2019-09-01T21:07:49+08:00">2019-09-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-07 01:56:20" itemprop="dateModified" datetime="2025-07-07T01:56:20+08:00">2025-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">分布式系统</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>

<h2 id="两地三中心"><a href="#两地三中心" class="headerlink" title="两地三中心"></a>两地三中心</h2><h3 id="为什么要建设多个-IDC（数据中心）"><a href="#为什么要建设多个-IDC（数据中心）" class="headerlink" title="为什么要建设多个 IDC（数据中心）"></a>为什么要建设多个 IDC（数据中心）</h3><p>灾备。</p>
<h3 id="为什么是两地三中心（同城-跨城）"><a href="#为什么是两地三中心（同城-跨城）" class="headerlink" title="为什么是两地三中心（同城+跨城）"></a>为什么是两地三中心（同城+跨城）</h3><p>最大可能性地避免天灾人祸。<br>但距离过远、数据传输速度慢，同时会带来<strong>数据一致性</strong>问题。</p>
<blockquote>
<p>这体现了 CAP 原理：一致性（C）与高可用（A）不可兼得。</p>
</blockquote>
<h3 id="部署方式"><a href="#部署方式" class="headerlink" title="部署方式"></a>部署方式</h3><p>全量灾备例子：新浪的弹性伸缩服务（back up、单元化）<br>部分灾备例子：支付宝早期架构</p>
<h3 id="研发"><a href="#研发" class="headerlink" title="研发"></a>研发</h3><p>业务分级</p>
<ol>
<li>SLA、SLO、SLI</li>
<li>为什么要做业务分级<br>便于做灾备。</li>
</ol>
<p>SRE（现已归入 devops 体系）</p>
<ol>
<li>监控体系<br>IDC<br>网络<br>基础服务<br>应用服务<br>流量<br>安全<br>用户（agent、听云、白山云）</li>
<li>灾备</li>
<li>fire-help<br>发现（完备的监控系统、混沌工程）、恢复（回滚）、解决、复盘</li>
</ol>
<p>数据<br>实时性（有些业务一定要实时，有些不需要）</p>
<h2 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h2><ol>
<li>调研方案</li>
<li>可行性分析</li>
<li>形成多种方案<ul>
<li>进行技术选型</li>
<li>成本分析（人力、金钱）</li>
<li>风险分析</li>
<li>形成一套方案</li>
</ul>
</li>
<li>决策</li>
</ol>
<h2 id="成本预算"><a href="#成本预算" class="headerlink" title="成本预算"></a>成本预算</h2><h2 id="确定资源"><a href="#确定资源" class="headerlink" title="确定资源"></a>确定资源</h2><ol>
<li>金钱待遇</li>
<li>业务</li>
<li>职级（向谁汇报）</li>
</ol>
<h2 id="立项"><a href="#立项" class="headerlink" title="立项"></a>立项</h2><ol>
<li>计算规划</li>
<li>分配资源</li>
<li>时间节点（中期汇报、日报）</li>
<li>风险点</li>
</ol>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><ol>
<li>安排任务</li>
<li>通过按计划完成任务来提升自我的影响力</li>
</ol>
<h2 id="验收"><a href="#验收" class="headerlink" title="验收"></a>验收</h2><ol>
<li>干系方的验收<br>包括让 QA、产品经理验收。</li>
<li>非干系方的验收<br>比如让媒体报道，提升我们公司的影响力。</li>
<li>形成闭环<br>review 计划，看是否达到了预期。</li>
</ol>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/226416.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tallate">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tallate">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/226416.html" class="post-title-link" itemprop="url">使用 jq 解析 json 数据</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-09-01 10:58:55" itemprop="dateCreated datePublished" datetime="2019-09-01T10:58:55+08:00">2019-09-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-07 01:56:20" itemprop="dateModified" datetime="2025-07-07T01:56:20+08:00">2025-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>分析 Json 格式接口参数或返回值。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/226416.html#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/e0007243.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tallate">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tallate">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/e0007243.html" class="post-title-link" itemprop="url">ES1_2使用索引和文档</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-08-21 09:03:54" itemprop="dateCreated datePublished" datetime="2019-08-21T09:03:54+08:00">2019-08-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-07 01:56:20" itemprop="dateModified" datetime="2025-07-07T01:56:20+08:00">2025-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/ElasticSearch/" itemprop="url" rel="index"><span itemprop="name">ElasticSearch</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>这篇文档总结ES中的基础数据结构，并介绍如何操作它们。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/e0007243.html#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/e0007243.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tallate">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tallate">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/e0007243.html" class="post-title-link" itemprop="url">ES1_2索引</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-08-21 09:03:54" itemprop="dateCreated datePublished" datetime="2019-08-21T09:03:54+08:00">2019-08-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-07 01:56:20" itemprop="dateModified" datetime="2025-07-07T01:56:20+08:00">2025-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/ElasticSearch/" itemprop="url" rel="index"><span itemprop="name">ElasticSearch</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>这篇文档总结ES中的基础数据结构，并介绍如何操作它们。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/e0007243.html#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/7f45c5bf.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tallate">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tallate">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/7f45c5bf.html" class="post-title-link" itemprop="url">ES1_3映射</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-08-21 09:03:54" itemprop="dateCreated datePublished" datetime="2019-08-21T09:03:54+08:00">2019-08-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-07 01:56:20" itemprop="dateModified" datetime="2025-07-07T01:56:20+08:00">2025-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/ElasticSearch/" itemprop="url" rel="index"><span itemprop="name">ElasticSearch</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="常用操作-映射（Mapping）"><a href="#常用操作-映射（Mapping）" class="headerlink" title="常用操作 - 映射（Mapping）"></a>常用操作 - 映射（Mapping）</h1><h2 id="映射的定义"><a href="#映射的定义" class="headerlink" title="映射的定义"></a>映射的定义</h2><p><strong>映射</strong>就像数据库中的 schema ，描述了数据在每个字段内如何存储，包括文档可能具有的字段或 属性 、 每个字段的数据类型—比如 string, integer 或 date —以及 Lucene 是如何索引和存储这些字段的。<br>Lucene 也没有映射的概念，映射是 Elasticsearch 将复杂 JSON 文档 映射 成 Lucene 需要的扁平化数据的方式。</p>
<ul>
<li>比如下面的索引名叫 data，其中定义了 people 和 transactions 类型：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &quot;data&quot;: &#123;</span><br><span class="line">      &quot;mappings&quot;: &#123;</span><br><span class="line">         &quot;people&quot;: &#123;</span><br><span class="line">            &quot;properties&quot;: &#123;</span><br><span class="line">               &quot;name&quot;: &#123;</span><br><span class="line">                  &quot;type&quot;: &quot;string&quot;,</span><br><span class="line">               &#125;,</span><br><span class="line">               &quot;address&quot;: &#123;</span><br><span class="line">                  &quot;type&quot;: &quot;string&quot;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;,</span><br><span class="line">         &quot;transactions&quot;: &#123;</span><br><span class="line">            &quot;properties&quot;: &#123;</span><br><span class="line">               &quot;timestamp&quot;: &#123;</span><br><span class="line">                  &quot;type&quot;: &quot;date&quot;,</span><br><span class="line">                  &quot;format&quot;: &quot;strict_date_optional_time&quot;</span><br><span class="line">               &#125;,</span><br><span class="line">               &quot;message&quot;: &#123;</span><br><span class="line">                  &quot;type&quot;: &quot;string&quot;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
会被转换为类似下面的映射保存：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &quot;data&quot;: &#123;</span><br><span class="line">      &quot;mappings&quot;: &#123;</span><br><span class="line">        &quot;_type&quot;: &#123;</span><br><span class="line">          &quot;type&quot;: &quot;string&quot;,</span><br><span class="line">          &quot;index&quot;: &quot;not_analyzed&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;name&quot;: &#123;</span><br><span class="line">          &quot;type&quot;: &quot;string&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        &quot;address&quot;: &#123;</span><br><span class="line">          &quot;type&quot;: &quot;string&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        &quot;timestamp&quot;: &#123;</span><br><span class="line">          &quot;type&quot;: &quot;long&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        &quot;message&quot;: &#123;</span><br><span class="line">          &quot;type&quot;: &quot;string&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
所以<strong>虽然创建一个文档后其类型就确定了，但是实际上这个文档所占用的空间是该索引内所有字段的总和</strong>。<br>所以有一条建议：一个索引中的类型应当都是相似的，他们有类似的字段，比如 man 和 woman 共享 name 属性；如果两个类型的字段集互不相同，创建一个 类型的文档后将浪费很多空间，而是应该将他们分到不同的索引中。</li>
</ul>
<h2 id="动态映射机制"><a href="#动态映射机制" class="headerlink" title="动态映射机制"></a>动态映射机制</h2><p>在索引一个新的文档时，es 会自动为每个字段推断类型，这个过程称为<strong>动态映射</strong>。这意味着如果你通过引号( “123” )索引一个数字，它会被映射为 string 类型，而不是 long 。但是，如果这个域已经映射为 long ，那么 Elasticsearch 会尝试将这个字符串转化为 long ，如果无法转化，则抛出一个异常。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PUT movies</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;_doc&quot;: &#123;</span><br><span class="line">      &quot;dynamic&quot;: &quot;false&quot; // true, false, strict</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是新增字段</p>
<ul>
<li>如果Dynamic设置为true，一旦有新增字段的文档写入，Mapping会被同时更新</li>
<li>如果Dynamic设置为false，Mapping不会被更新，新增字段的数据无法被索引，但是信息会出现在_source中</li>
<li>如果Dynamic被设置为strict，则文档写入失败</li>
</ul>
<p>如果是更新字段</p>
<ul>
<li>对已有字段，一旦有数据写入，就不再支持修改字段定义</li>
<li>如果希望改变字段类型，必须reindex重建索引</li>
</ul>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>ES不提供专门的数组类型，但是每个字段都可以包含多个相同类型的数值，所以ES天然是支持数组类型的。</p>
<h2 id="多字段类型"><a href="#多字段类型" class="headerlink" title="多字段类型"></a>多字段类型</h2><p>有时候我们希望一个字段可以被多种方式检索，比如：</p>
<ul>
<li>通过不同语言检索</li>
<li>pinyin字段的搜索</li>
<li>还支持为搜索和索引指定不同的analyzer</li>
</ul>
<h2 id="一些默认的映射"><a href="#一些默认的映射" class="headerlink" title="一些默认的映射"></a>一些默认的映射</h2><p>布尔型: true 或者 false | boolean<br>整数: 123 | long<br>浮点数: 123.45 | double<br>字符串，有效日期: 2014-09-15 | date<br>字符串: foo bar | string<br>整数 : byte, short, integer<br>浮点数: float</p>
<h2 id="自定义映射"><a href="#自定义映射" class="headerlink" title="自定义映射"></a>自定义映射</h2><p>TODO<br>全文字符串域和精确值字符串域的区别<br>使用特定语言分析器<br>优化域以适应部分匹配<br>指定自定义数据格式</p>
<h2 id="查看映射"><a href="#查看映射" class="headerlink" title="查看映射"></a>查看映射</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /megacrp/_mapping</span><br><span class="line">GET /megacrp/employee/_mapping</span><br></pre></td></tr></table></figure>
<p>返回属性包括：</p>
<ul>
<li>index 属性控制怎样索引字符串<ul>
<li>analyzed 分析字符串再索引（全文索引），字符串且只有字符串可以取这个属性</li>
<li>not_analyzed 不分析、直接索引精确值</li>
<li>no 不索引、不能被搜索到</li>
</ul>
</li>
<li>analyzer 对于 analyzed 字符串域，用 analyzer 属性指定在搜索和索引时使用的分析器，默认时 standard</li>
</ul>
<h2 id="更新映射"><a href="#更新映射" class="headerlink" title="更新映射"></a>更新映射</h2><ul>
<li>可以通过更新一个映射来添加一个新域，并为其设置映射（<a target="_blank" rel="noopener" href="https://discuss.elastic.co/t/elasticsearch-5-not-analyzed/68411">后来版本取消了 string 类型，改成了<strong>text</strong>，要注意</a>）</li>
<li>不能将一个存在的域从 analyzed 改为 not_analyzed。因为如果一个域的映射已经存在，那么该域的数据可能已经被索引。如果你意图修改这个域的映射，索引的数据可能会出错，不能被正常的搜索。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">PUT /gb</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;testmapping&quot; : &#123;</span><br><span class="line">      &quot;properties&quot; : &#123;</span><br><span class="line">        &quot;tweetgjghjggh&quot; : &#123;</span><br><span class="line">          &quot;type&quot; : &quot;text&quot;,</span><br><span class="line">          &quot;analyzer&quot;: &quot;english&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;date&quot; : &#123;</span><br><span class="line">          &quot;type&quot; : &quot;date&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;user_id&quot; : &#123;</span><br><span class="line">          &quot;type&quot; : &quot;long&quot;</span><br><span class="line">        &#125;&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/12/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><span class="space">&hellip;</span><a class="page-number" href="/page/19/">19</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/14/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">tallate</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/tallate" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"version":"7.1.2","options":null,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.3.0/mermaid.min.js","integrity":"sha256-9y71g5Lz/KLsHjB8uXwnkuWDtAMDSzD/HdIbqhJfTAI="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>





  





</body>
</html>
