<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"tallate.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.18.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Tallate">
<meta property="og:url" content="https://tallate.github.io/page/17/index.html">
<meta property="og:site_name" content="Tallate">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="tallate">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://tallate.github.io/page/17/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/17/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Tallate</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Tallate</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">该吃吃该喝喝 啥事别往心里搁</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签<span class="badge">83</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="th fa-fw"></i>分类<span class="badge">25</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档<span class="badge">189</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">tallate</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">189</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">83</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/cc86b541.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tallate">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tallate">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/cc86b541.html" class="post-title-link" itemprop="url">TCP协议总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-07-20 14:01:28" itemprop="dateCreated datePublished" datetime="2019-07-20T14:01:28+08:00">2019-07-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-07 01:56:20" itemprop="dateModified" datetime="2025-07-07T01:56:20+08:00">2025-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">网络</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>TCP是<strong>面向连接</strong>的<br><strong>所谓的建立连接，是为了在客户端和服务端维护连接，而建立一定的数据结构来维护双方交互的状态，用这样的数据结构来保证所谓的面向连接的特性</strong>。</li>
<li>TCP 提供<strong>可靠交付</strong><br>通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。</li>
<li>TCP 是<strong>面向字节流</strong><br>发送的时候发的是一个流，没头没尾。</li>
<li>拥塞控制<br>TCP意识到包丢弃了或者网络的环境不好了，就会根据情况调整自己的行为，看看是不是发快了，要不要发慢点。</li>
</ul>
<h3 id="TCP-优点"><a href="#TCP-优点" class="headerlink" title="TCP 优点"></a>TCP 优点</h3><ul>
<li>可靠，稳定<br>TCP 的可靠体现在 TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源。</li>
</ul>
<h3 id="TCP-缺点"><a href="#TCP-缺点" class="headerlink" title="TCP 缺点"></a>TCP 缺点</h3><p>慢，效率低，占用系统资源高，易被攻击<br>TCP 在传递数据之前，要先建连接，这会消耗时间，而且在数据传递时，确认机制、重传机制、拥塞控制机制等都会消耗大量的时间，而且要在每台设备上维护所有的传输连接，事实上，每个连接都会占用系统的 CPU、内存等硬件资源。 而且，因为 TCP 有确认机制、三次握手机制，这些也导致 TCP 容易被人利用，实现 DOS、DDOS、CC 等攻击。</p>
<h3 id="TCP的数据包格式"><a href="#TCP的数据包格式" class="headerlink" title="TCP的数据包格式"></a>TCP的数据包格式</h3><p><img src="/imgs/%E7%BD%91%E7%BB%9C/TCP%E6%95%B0%E6%8D%AE%E5%8C%85%E6%A0%BC%E5%BC%8F.jpg" alt="TCP数据包格式" title="TCP数据包格式"></p>
<ol>
<li>源端口号和目标端口号，用于确定数据应该发给哪个应用；</li>
<li>包序号<br>用于解决乱序问题；</li>
<li>确认序号<br>解决丢包问题，如果没有收到就重新发送，直到送达。</li>
<li>状态位<br>例如SYN是发起一个连接；<br>ACK是回复；<br>RST是重新连接；<br>FIN是结束连接。</li>
<li>窗口大小<br>TCP要做到流量控制，通信双方各声明一个窗口，标识自己当前的处理能力。</li>
</ol>
<h3 id="连接的建立-三次握手"><a href="#连接的建立-三次握手" class="headerlink" title="连接的建立 - 三次握手"></a>连接的建立 - 三次握手</h3><p><img src="/imgs/%E7%BD%91%E7%BB%9C/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.jpg" alt="TCP三次握手" title="TCP三次握手"><br>一开始，客户端和服务端都处于 CLOSED 状态。先是服务端主动监听某个端口，处于 LISTEN 状态。然后客户端主动发起连接 SYN，之后处于 SYN-SENT 状态。服务端收到发起的连接，返回 SYN，并且 ACK 客户端的 SYN，之后处于 SYN-RCVD 状态。客户端收到服务端发送的 SYN 和 ACK 之后，发送 ACK 的 ACK，之后处于 ESTABLISHED 状态，因为它一发一收成功了。服务端收到 ACK 的 ACK 之后，处于 ESTABLISHED 状态，因为它也一发一收了。<br>从连接建立的流程中可见，三次握手除了双方建立连接外，还能确定TCP包的序号问题。</p>
<p>总而言之：</p>
<ol>
<li>首先 Client 端发送连接请求报文，Server 段接受连接后回复 ACK 报文，并为这次连接分配资源。</li>
<li>Client 端接收到 ACK 报文后也向 Server 段发生 ACK 报文，并分配资源，这样 TCP 连接就建立了。<br><img src="/imgs/%E7%BD%91%E7%BB%9C/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.jpg" alt="TCP三次握手" title="TCP三次握手"><br>最初两端的 TCP 进程都处于 CLOSED 关闭状态，A（Client）主动打开连接，而 B（Server）被动打开连接。（A、B 关闭状态 CLOSED——B 创建 TCB，进入 LISTEN 状态，等待 A 请求——A 同步已发送状态 SYN-SENT——B 同步收到状态 SYN-RCVD——A、B 连接已建立状态 ESTABLISHED）</li>
<li>第一次握手：起初两端都处于 CLOSED 关闭状态，A（Client）将标志位 SYN 置为 1，随机产生一个值 seq&#x3D;x，并将该数据包发送给 B（Server），A（Client）进入 SYN-SENT 状态，等待 B（Server）确认；</li>
<li>第二次握手：B（Server）收到连接请求报文段后，如同意建立连接，则向 A（Client）发送确认，在确认报文段中（SYN&#x3D;1，ACK&#x3D;1，确认号 ack&#x3D;x+1，初始序号 seq&#x3D;y），B（Server）TCP 服务器进程进入 SYN-RCVD（同步收到）状态；</li>
<li>第三次握手：TCP 客户进程收到 B（Server）的确认后，要向 B（Server）给出确认报文段（ACK&#x3D;1，确认号 ack&#x3D;y+1，序号 seq&#x3D;x+1）（初始为 seq&#x3D;x，第二个报文段所以要+1），ACK 报文段可以携带数据，不携带数据则不消耗序号。TCP 连接已经建立，A 进入 ESTABLISHED（已建立连接）。<br>当 B 收到 A 的确认后，也进入 ESTABLISHED 状态。<blockquote>
<p><strong>TCB 传输控制块 Transmission Control Block</strong>，存储每一个连接中的重要信息，如 TCP 连接表，到发送和接收缓存的指针，到重传队列的指针，当前的发送和接收序号。</p>
</blockquote>
</li>
</ol>
<p>一些问题：</p>
<ol>
<li>为什么 A 还要发送一次确认呢？可以二次握手吗？<br>主要为了防止已失效的连接请求报文段突然又传送到了 B，因而产生错误。如 A 发出连接请求，但因连接请求报文丢失而未收到确认，于是 A 再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，A 发出了两个连接请求报文段，其中第一个丢失，第二个到达了 B，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达 B，此时 B 误认为 A 又发出一次新的连接请求，于是就向 A 发出确认报文段，同意建立连接，不采用三次握手，只要 B 发出确认，就建立新的连接了，此时 A 不理睬 B 的确认且不发送数据，则 B 一致等待 A 发送数据，浪费资源。</li>
<li>Server 端易受到 SYN 攻击？<br>服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到 SYN 洪泛攻击，SYN 攻击就是 Client 在短时间内伪造大量不存在的 IP 地址，并向 Server 不断地发送 SYN 包，Server 则回复确认包，并等待 Client 确认，由于源地址不存在，因此 Server 需要不断重发直至超时，这些伪造的 SYN 包将长时间占用未连接队列，导致正常的 SYN 请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。<br>防范 SYN 攻击措施：降低主机的等待时间使主机尽快的释放半连接的占用，短时间受到某 IP 的重复 SYN 则丢弃后续请求。</li>
</ol>
<h3 id="连接的断开-四次挥手"><a href="#连接的断开-四次挥手" class="headerlink" title="连接的断开 - 四次挥手"></a>连接的断开 - 四次挥手</h3><p><img src="/imgs/%E7%BD%91%E7%BB%9C/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.jpg" alt="TCP四次挥手" title="TCP四次挥手"><br>假设 Client 端发起中断连接请求，也就是发送 FIN 报文。Server 端接到 FIN 报文后，意思是说”我 Client 端没有数据要发给你了”，但是如果你还有数据没有发送完成，则不必急着关闭 Socket，可以继续发送数据。所以你先发送 ACK，”告诉 Client 端，你的请求我收到了，但是我还没准备好，请继续你等我的消息”。这个时候 Client 端就进入 FIN_WAIT 状态，继续等待 Server 端的 FIN 报文。当 Server 端确定数据已发送完成，则向 Client 端发送 FIN 报文，”告诉 Client 端，好了，我这边数据发完了，准备好关闭连接了”。Client 端收到 FIN 报文后，”就知道可以关闭连接了，但是他还是不相信网络，怕 Server 端不知道要关闭，所以发送 ACK 后进入 TIME_WAIT 状态，如果 Server 端没有收到 ACK 则可以重传。“，Server 端收到 ACK 后，”就知道可以断开连接了”。Client 端等待了 2MSL 后依然没有收到回复，则证明 Server 端已正常关闭，那好，我 Client 端也可以关闭连接了。Ok，TCP 连接就这样关闭了！</p>
<p>数据传输结束后，通信的双方都可释放连接，A 和 B 都处于 ESTABLISHED 状态。（A、B 连接建立状态 ESTABLISHED——A 进入等待 1 状态 FIN-WAIT-1——B 关闭等待状态 CLOSE-WAIT——A 进入等待 2 状态 FIN-WAIT-2——B 最后确认状态 LAST-ACK——A 时间等待状态 TIME-WAIT——B、A 关闭状态 CLOSED）</p>
<ol>
<li>A 的应用进程先向其 TCP 发出连接释放报文段（FIN&#x3D;1，序号 seq&#x3D;u），并停止再发送数据，主动关闭 TCP 连接，进入 FIN-WAIT-1（终止等待 1）状态，等待 B 的确认。</li>
<li>B 收到连接释放报文段后即发出确认报文段，（ACK&#x3D;1，确认号 ack&#x3D;u+1，序号 seq&#x3D;v），B 进入 CLOSE-WAIT（关闭等待）状态，此时的 TCP 处于半关闭状态，A 到 B 的连接释放。</li>
<li>A 收到 B 的确认后，进入 FIN-WAIT-2（终止等待 2）状态，等待 B 发出的连接释放报文段。</li>
<li>B 没有要向 A 发出的数据，B 发出连接释放报文段（FIN&#x3D;1，ACK&#x3D;1，序号 seq&#x3D;w，确认号 ack&#x3D;u+1），B 进入 LAST-ACK（最后确认）状态，等待 A 的确认。</li>
<li>A 收到 B 的连接释放报文段后，对此发出确认报文段（ACK&#x3D;1，seq&#x3D;u+1，ack&#x3D;w+1），A 进入 TIME-WAIT（时间等待）状态。此时 TCP 未释放掉，需要经过时间等待计时器设置的时间 2MSL 后，A 才进入 CLOSED 状态。</li>
</ol>
<p>总而言之：</p>
<ol>
<li>刚开始A发送断开连接请求，进入FIN_WAIT_1状态；</li>
<li>B接收请求进入CLOSED_WAIT状态，并发回响应；</li>
<li>A接收B响应，进入FIN_WAIT_2状态；</li>
<li>B发送断开连接请求，并进入LAST_ACK状态；</li>
<li>A接收请求，进入TIME_WAIT状态，并发回响应；<br>A会在发出响应<code>2MSL</code>后自动进入CLOSED状态。<br>MSL 是 Maximum Segment Lifetime，报文最大生存时间，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为 TCP 报文基于是 IP 协议的，而 IP 头中有一个 TTL 域，是 IP 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。协议规定 MSL 为 2 分钟，实际应用中常用的是 30 秒，1 分钟和 2 分钟等。</li>
<li>B接收响应后进入CLOSED状态。</li>
</ol>
<p>该流程中让人比较困惑的问题是：</p>
<ol>
<li>为什么A断开连接后，第4步还要B在反向发起一次断开连接？<br>不能直接断开，因为A单方面断开连接时，A不知道B是不是还有事情要处理。</li>
<li>如果第4步B没有重新发起断开连接（只有2次挥手），连接怎么断开？<br>如果这期间B宕机了没有重新发起断开连接，A将永远停留在FIN_WAIT_2的状态，TCP 协议里面并没有对这个状态的处理，但是 Linux 有，可以调整 tcp_fin_timeout 这个参数，设置一个超时时间。</li>
<li>第5步如果A响应没有返回给B，B怎么断开？<br>此时B会重新发起一次断开请求，因而TCP要求A最后等待一段时间<code>TIME_WAIT</code>，这个时间要足够长，长到如果B没有收到ACK，B可以重试且时间足够到达。<br>不过，还有一个异常情况就是，B 超过了 2MSL 的时间，依然没有收到它发的 <code>FIN</code> 的 ACK，怎么办呢？按照 TCP 的原理，B 当然还会重发 <code>FIN</code>，这时A再收到这个包后，会直接返回<code>RST</code>，B就知道早已断开连接了。</li>
<li>TIME_WAIT<br>TIME_WAIT 状态容易被人误解，比如当使用三方系统的服务时，看到系统 TIME_WAIT 数量特别高，于是赖对方没有及时把连接释放掉，实际上<strong>TIME_WAIT 产生在主动断开连接的一方</strong>。</li>
<li>为什么 A 在 TIME-WAIT 状态必须等待 2MSL 的时间？（MSL 最长报文段寿命 Maximum Segment Lifetime，MSL&#x3D;2）<br>原因有 2：<br><strong>保证 A 发送的最后一个 ACK 报文段能够到达 B。</strong>这个 ACK 报文段有可能丢失，使得处于 LAST-ACK 状态的 B 收不到对已发送的 FIN+ACK 报文段的确认，B 超时重传 FIN+ACK 报文段，而 A 能在 2MSL 时间内收到这个重传的 FIN+ACK 报文段，接着 A 重传一次确认，重新启动 2MSL 计时器，最后 A 和 B 都进入到 CLOSED 状态，若 A 在 TIME-WAIT 状态不等待一段时间，而是发送完 ACK 报文段后立即释放连接，则无法收到 B 重传的 FIN+ACK 报文段，所以不会再发送一次确认报文段，则 B 无法正常进入到 CLOSED 状态。<br><strong>防止“已失效的连接请求报文段”出现在本连接中。</strong>A 在发送完最后一个 ACK 报文段后，再经过 2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。</li>
<li>为什么连接的时候是三次握手，关闭的时候却是四次握手？<br>因为当 Server 端收到 Client 端的 SYN 连接请求报文后，可以直接发送 SYN+ACK 报文。其中 ACK 报文是用来应答的，SYN 报文是用来同步的。但是关闭连接时，当 Server 端收到 FIN 报文时，很可能并不会立即关闭 SOCKET，所以只能先回复一个 ACK 报文，告诉 Client 端，”你发的 FIN 报文我收到了”。只有等到我 Server 端所有的报文都发送完了，我才能发送 FIN 报文，因此不能一起发送。故需要四步握手。</li>
<li>为什么 TIME_WAIT 状态需要经过 2MSL(最大报文段生存时间)才能返回到 CLOSE 状态？<br>虽然按道理，四个报文都发送完毕，我们可以直接进入 CLOSE 状态了，但是我们必须假象网络是不可靠的，有可能最后一个 ACK 丢失。所以 TIME_WAIT 状态就是用来重发可能丢失的 ACK 报文。</li>
<li>如何优化<br>我们可以通过修改系统参数来优化服务器<br>tcp_tw_reuse: 是否重用处于 TIME_WAIT 状态的 TCP 链接  （设为 true）<br>tcp_max_tw_buckets: 处于 TIME_WAIT 状态的 SOCKET 最大数目 （调大，这个参数千万不要调小了）<br>tcp_fin_timeout: 处于 FIN_WAIT_2 的时间  （调小）</li>
</ol>
<h3 id="TCP状态机"><a href="#TCP状态机" class="headerlink" title="TCP状态机"></a>TCP状态机</h3><p>上面的握手和挥手流程汇总为状态机如下图所示：<br><img src="/imgs/%E7%BD%91%E7%BB%9C/TCP%E7%8A%B6%E6%80%81%E6%9C%BA.jpg" alt="TCP状态机" title="TCP状态机"></p>
<h3 id="累计确认（cumulative-acknowledgment，或称为累计应答）"><a href="#累计确认（cumulative-acknowledgment，或称为累计应答）" class="headerlink" title="累计确认（cumulative acknowledgment，或称为累计应答）"></a>累计确认（cumulative acknowledgment，或称为累计应答）</h3><p>TCP中并不是发1收1，而是使用一个缓冲区保存数据包，这个缓冲区称为<strong>窗口</strong>，发送端的发送窗口如下图所示：<br><img src="/imgs/%E7%BD%91%E7%BB%9C/TCP%E5%8F%91%E9%80%81%E7%AA%97%E5%8F%A3.jpg" alt="TCP发送窗口" title="TCP发送窗口"></p>
<ol>
<li>发送了并且已经确认的。</li>
<li>发送了并且尚未确认的。</li>
<li>没有发送，但是已经等待发送的。</li>
<li>没有发送，并且暂时还不会发送的。</li>
</ol>
<ul>
<li>LastByteAcked：第一部分和第二部分的分界线</li>
<li>LastByteSent：第二部分和第三部分的分界线</li>
<li>LastByteAcked + AdvertisedWindow：第三部分和第四部分的分界线</li>
</ul>
<p>为什么会有第3和第4部分？难道这些不都是等待发送的吗？其实区分第3和第4部分的主要目的是<strong>流量控制</strong>，在 TCP 里，接收端会给发送端报一个窗口的大小，叫 <strong>Advertised window</strong>。这个窗口的大小应该等于上面的第2部分加上第3部分，超过了这个窗口的接收端处理不过来，就不发送了，作为第4部分。</p>
<p>接收端同样也有一个接收窗口：<br><img src="/imgs/%E7%BD%91%E7%BB%9C/TCP%E6%8E%A5%E6%94%B6%E7%AA%97%E5%8F%A3.jpg" alt="TCP接收窗口" title="TCP接收窗口"></p>
<ol>
<li>接受并且确认过的。</li>
<li>还没接收，但是马上就能接收的。</li>
<li>还没接收，也没法接收的。</li>
</ol>
<ul>
<li>MaxRcvBuffer：最大缓存的量；</li>
<li>LastByteRead 之后是已经接收了，但是还没被应用层读取的；</li>
<li>NextByteExpected 是第一部分和第二部分的分界线。</li>
</ul>
<h3 id="顺序问题与丢包问题"><a href="#顺序问题与丢包问题" class="headerlink" title="顺序问题与丢包问题"></a>顺序问题与丢包问题</h3><p>TCP中的重发有两种：</p>
<ol>
<li>超时重试<br>对每一个发送了，但是没有 ACK 的包，都有设一个定时器，超过了一定的时间，就重新尝试。<br>这个时间不宜过短，时间必须大于往返时间 RTT，否则会引起不必要的重传。也不宜过长，这样超时时间变长，访问就变慢了。估计往返时间，需要 TCP 通过采样 RTT 的时间，然后进行加权平均，算出一个值，而且这个值还是要不断变化的，因为网络状况不断地变化。除了采样 RTT，还要采样 RTT 的波动范围，计算出一个估计的超时时间。由于重传时间是不断变化的，我们称为<strong>自适应重传算法（Adaptive Retransmission Algorithm）</strong>。<br><strong>超时间隔加倍</strong>：每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送。</li>
<li>快速重传<br>超时重传存在的问题是超时周期可能会比较长，为了加快重传，TCP采用一种快速重传机制：<br>当接收方收到一个序号大于下一个所期望的报文段时，就会检测到数据流中的一个间隔，于是它就会发送冗余的 ACK，仍然 ACK 的是期望接收的报文段。而当客户端收到三个冗余的 ACK 后，就会在定时器过期之前，重传丢失的报文段。<br>例如，接收方发现 6 收到了，8 也收到了，但是 7 还没来，那肯定是丢了，于是发送 6 的 ACK，要求下一个是 7。接下来，收到后续的包，仍然发送 6 的 ACK，要求下一个是 7。当客户端收到 3 个重复 ACK，就会发现 7 的确丢了，不等超时，马上重发。</li>
<li>Selective Acknowledgment （SACK）<br>接收方可以将缓存的地图发送给发送方，例如发送ACK6、SACK8，SACK8表示已接收但未处理的，有了地图，发送方一下子就能看出来是 7 丢了。</li>
</ol>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>当发送未确认窗口中最早的一个包接收到了确认，则窗口将前移一格：<br><img src="/imgs/%E7%BD%91%E7%BB%9C/TCP%E6%8E%A5%E6%94%B6%E7%AA%97%E5%8F%A3.jpg" alt="TCP接收窗口" title="TCP接收窗口"><br>上图中，5接收到了确认，此时窗口前移一格，第14个包可以发送了。<br><img src="/imgs/%E7%BD%91%E7%BB%9C/TCP%E6%8E%A5%E6%94%B6%E7%AA%97%E5%8F%A3%E7%A7%BB%E5%8A%A8.jpg" alt="TCP接收窗口移动" title="TCP接收窗口移动"><br>如果接收方处理太慢，导致缓存中没有空间了，可以通过确认信息修改窗口的大小，甚至可以设置为 0，则发送方将暂时停止发送。<br>假设一个极端情况，接收端的应用一直不读取缓存中的数据，当数据包 6 确认后，窗口大小就不能再是 9 了，就要缩小一个变为 8。<br>那么缩小后什么时候恢复呢？<strong>发送方会定时发送窗口探测数据包</strong>，看是否有机会调整窗口的大小。</p>
<h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>拥塞控制也是通过控制窗口大小来实现的，前面的滑动窗口 rwnd 是怕发送方把接收方缓存塞满，而拥塞窗口 cwnd，是怕把网络塞满。</p>
<p>TCP的拥塞控制主要是为了避免丢包和超时重传问题：</p>
<ul>
<li><p>如果窗口不经控制——像UDP那样——很有可能发送的数据量超过中间设备的承载能力，多出来的包就会被丢弃，即发生了<strong>丢包</strong>，这是我们不希望看到的。</p>
</li>
<li><p>如果在这些设备上加缓存，处理不过来的先保存在缓存队列里，这样虽然不会丢失，但是会增加时延，如果时延达到一定程度，就会导致<strong>超时重传</strong>。</p>
</li>
<li><p>慢启动（指数增长）<br>刚开始不清楚网络情况，因此发送数据包时一次只能发1个，后来按2、4、8的<strong>指数性增长</strong>速度来增长；</p>
</li>
<li><p>线性增长<br>当超过一个阈值<code>ssthresh=65535</code>时，可能速度达到了网络性能，这时会慢下来，变成线程增长，每收到一个确认后，cwnd才会增加<code>1/cwnd</code>。</p>
</li>
<li><p>指数递减<br>当发生了丢包，需要超时重传时，会设置<code>ssthresh=cwnd/2</code>，并将cwnd设置为1，重新开始慢启动，这种减速方式的问题是太过激进，从原来的高速马上减到1，会造成明显的网络卡顿，因为这个问题，一般会采用<strong>快速重传算法</strong>。</p>
</li>
<li><p>快速重传算法<br>当接收端发现丢了一个中间包的时候，发送三次前一个包的 ACK，于是发送端就会快速地重传，不必等待超时再重传。<br>TCP 认为这种情况不严重，因为大部分没丢，只丢了一小部分，cwnd 减半为 cwnd&#x2F;2，然后 <code>sshthresh = cwnd</code>，当三个包返回的时候，<code>cwnd = sshthresh + 3</code>，也就是说没有立刻减到1。</p>
</li>
</ul>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/e8597381.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tallate">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tallate">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/e8597381.html" class="post-title-link" itemprop="url">网络架构梳理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-07-20 14:01:28" itemprop="dateCreated datePublished" datetime="2019-07-20T14:01:28+08:00">2019-07-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-07 01:56:20" itemprop="dateModified" datetime="2025-07-07T01:56:20+08:00">2025-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">网络</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>不懂很多网络概念，在一些开会、对接场合出了很多洋相，趁机好好补补。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/e8597381.html#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/a4caf2c1.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tallate">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tallate">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/a4caf2c1.html" class="post-title-link" itemprop="url">Nginx 原理总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-07-10 11:32:43" itemprop="dateCreated datePublished" datetime="2019-07-10T11:32:43+08:00">2019-07-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-07 01:56:20" itemprop="dateModified" datetime="2025-07-07T01:56:20+08:00">2025-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Nginx/" itemprop="url" rel="index"><span itemprop="name">Nginx</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>


<h2 id="为什么要使用-Nginx"><a href="#为什么要使用-Nginx" class="headerlink" title="为什么要使用 Nginx"></a>为什么要使用 Nginx</h2><h3 id="Nginx-优点"><a href="#Nginx-优点" class="headerlink" title="Nginx 优点"></a>Nginx 优点</h3><ol>
<li>轻量级，采用 C 进行编写，同样的 web 服务，会占用更少的内存及资源</li>
<li>抗并发，nginx 以 epoll 和 kqueue 作为开发模型，处理请求是异步非阻塞的，负载能力比 apache 高很多，而 apache 则是阻塞型的。在高并发下 nginx 能保持低资源低消耗高性能 ，而 apache 在 PHP 处理慢或者前端压力很大的情况下，很容易出现进程数飙升，从而拒绝服务的现象。</li>
<li>nginx 处理静态文件好，静态处理性能比 apache 高三倍以上</li>
<li>nginx 的设计高度模块化，编写模块相对简单</li>
<li>nginx 配置简洁，正则配置让很多事情变得简单，而且改完配置能使用 -t 测试配置有没有问题，apache 配置复杂 ，重启的时候发现配置出错了，会很崩溃</li>
<li>nginx 作为负载均衡服务器，支持 7 层负载均衡</li>
<li>nginx 本身就是一个反向代理服务器，而且可以作为非常优秀的邮件代理服务器</li>
<li>启动特别容易, 并且几乎可以做到 7*24 不间断运行，即使运行数个月也不需要重新启动，还能够不间断服务的情况下进行软件版本的升级</li>
<li>社区活跃，各种高性能模块出品迅速</li>
</ol>
<h3 id="Nginx-优点（说出原因）"><a href="#Nginx-优点（说出原因）" class="headerlink" title="Nginx 优点（说出原因）"></a>Nginx 优点（说出原因）</h3><ol>
<li>Nginx 在核心代码都使用了与操作系统无关的代码实现，在与操作系统相关的系统调用上则分别针对各个操作系统都有独立实现，这最终造就了 Nginx 的可移植性。</li>
<li>非阻塞、高并发连接：处理 2-3 万并发连接数，官方监测能支持 5 万并发</li>
<li>内存消耗小：开启 10 个 nginx 才占 150M 内存，Nginx 采取了分阶段资源分配技术<br>nginx 处理静态文件好,耗费内存少</li>
<li>内置的健康检查功能：如果有一个服务器宕机，会做一个健康检查，再发送的请求就不会发送到宕机的服务器了。重新将请求提交到其他的节点上。<br>节省宽带：支持 GZIP 压缩，可以添加浏览器本地缓存<br>稳定性高：宕机的概率非常小</li>
<li>master&#x2F;worker 结构：一个 master 进程，生成一个或者多个 worker 进程<br>接收用户请求是异步的：浏览器将请求发送到 nginx 服务器，它先将用户请求全部接收下来，再一次性发送给后端 web 服务器，极大减轻了 web 服务器的压力<br>一边接收 web 服务器的返回数据，一边发送给浏览器客户端<br>网络依赖性比较低，只要 ping 通就可以负载均衡<br>可以有多台 nginx 服务器</li>
<li>事件驱动：通信机制采用 epoll 模型</li>
</ol>
<h3 id="Apache-优点"><a href="#Apache-优点" class="headerlink" title="Apache 优点"></a>Apache 优点</h3><ol>
<li>apache 的 rewrite 比 nginx 强大，在 rewrite 频繁的情况下，用 apache</li>
<li>apache 发展到现在，模块超多，基本想到的都可以找到</li>
<li>apache 更为成熟，少 bug ，nginx 的 bug 相对较多</li>
<li>apache 超稳定</li>
<li>apache 对 PHP 支持比较简单，nginx 需要配合其他后端用</li>
<li>apache 在处理动态请求有优势，nginx 在这方面是鸡肋，一般动态请求要 apache 去做，nginx 适合静态和反向。</li>
<li>apache 仍然是目前的主流，拥有丰富的特性，成熟的技术和开发社区</li>
</ol>
<h3 id="Nginx-和-Apache-区别总结"><a href="#Nginx-和-Apache-区别总结" class="headerlink" title="Nginx 和 Apache 区别总结"></a>Nginx 和 Apache 区别总结</h3><p>两者最核心的区别在于 apache 是同步多进程模型，一个连接对应一个进程，而 nginx 是异步的，多个连接（万级别）可以对应一个进程<br>一般来说，需要性能的 web 服务，用 nginx 。如果不需要性能只求稳定，更考虑 apache ，后者的各种功能模块实现得比前者，例如 ssl 的模块就比前者好，可配置项多。epoll(freebsd 上是 kqueue ) 网络 IO 模型是 nginx 处理性能高的根本理由，但并不是所有的情况下都是 epoll 大获全胜的，如果本身提供静态服务的就只有寥寥几个文件，apache 的 select 模型或许比 epoll 更高性能。当然，这只是根据网络 IO 模型的原理作的一个假设，真正的应用还是需要实测了再说的。<br>更为通用的方案是，前端 nginx 抗并发，后端 apache 集群，配合起来会更好。</p>
<h2 id="接入层演进"><a href="#接入层演进" class="headerlink" title="接入层演进"></a>接入层演进</h2><p>通过研究接入层的发展历程，我们可以一窥 Nginx 在互联网架构中的地位。</p>
<h3 id="接入层结构"><a href="#接入层结构" class="headerlink" title="接入层结构"></a>接入层结构</h3><p><img src="/imgs/Nginx%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/%E6%8E%A5%E5%85%A5%E5%B1%82%E7%BB%93%E6%9E%84.png" alt="接入层结构" title="接入层结构"><br>可以看到，每一个下游都有多个上游调用，只需要做到，<strong>每一个上游都均匀访问每一个下游</strong>，就能实现整体的均匀分摊。</p>
<ol>
<li>客户端层-&gt;反向代理层<br>DNS 轮询<br>DNS-server 对于一个域名配置了多个解析 ip，每次 DNS 解析请求来访问 DNS-server，会轮询返回这些 ip，保证每个 ip 的解析概率是相同的。这些 ip 就是 nginx 的外网 ip，以做到每台 nginx 的请求分配也是均衡的。</li>
<li>反向代理层-&gt;站点层<br>反向代理层到站点层的负载均衡，是通过“nginx”实现的。<br>修改 nginx.conf，可以实现多种均衡策略：<br>2.1 请求轮询：和 DNS 轮询类似，请求依次路由到各个 web-server；<br>2.2 最少连接路由：哪个 web-server 的连接少，路由到哪个 web-server；<br>2.3 ip 哈希：按照访问用户的 ip 哈希值来路由 web-server，只要用户的 ip 分布是均匀的，请求理论上也是均匀的，ip 哈希均衡方法可以做到，同一个用户的请求固定落到同一台 web-server 上，此策略适合有状态服务，例如 session；<blockquote>
<p>session 不推荐放到站点层，后期扩展会有问题，更好的方案是放到数据层。</p>
</blockquote>
</li>
<li>站点层-&gt;服务层<br>站点层到服务层的负载均衡，是通过“服务连接池”实现的。<br>上游连接池会建立与下游服务多个连接，每次请求会“随机”选取连接来访问下游服务。除了负载均衡，服务连接池还能够实现故障转移、超时处理、限流限速、ID 串行化等诸多功能。</li>
<li>服务层-&gt;数据层<br>在数据量很大的情况下，由于数据层（db&#x2F;cache）涉及数据的水平切分，所以数据层的负载均衡更为复杂一些，它分为“数据的均衡”，与“请求的均衡”。<br><strong>数据的均衡</strong>是指：水平切分后的每个服务（db&#x2F;cache），数据量是均匀的。<br><strong>请求的均衡</strong>是指：水平切分后的每个服务（db&#x2F;cache），请求量是均匀的。</li>
</ol>
<h3 id="接入层演进-1"><a href="#接入层演进-1" class="headerlink" title="接入层演进"></a>接入层演进</h3><ol>
<li>单机架构<br>客户端用 DNS 解析出来的 IP 就是 web 服务器的地址。<br>缺点：<ul>
<li>单点；</li>
<li>扩展性差。</li>
</ul>
</li>
<li>DNS 轮询<br>在 DNS 服务器上多配几个 IP，由域名服务器的解析策略实现负载均衡。<br>缺点：<ul>
<li>非高可用，因为一个 web 服务器挂掉后 DNS 服务器仍然会将请求解析到该服务器对应的 IP 上；</li>
<li>扩容非实时，DNS 服务器有一个配置生效的延时时间；</li>
<li>暴露太多外网 IP。</li>
</ul>
</li>
<li>反向代理 Nginx<br>DNS 解析到 Nginx 的 IP，然后由 Nginx 将请求负载均衡到 web 服务器。<br>缺点：基本解决了上一个架构存在的问题，且可以利用 Nginx 的探活机制实现 web 服务器的高可用，但是此时 Nginx 也会成为一个单点。</li>
<li>keepalived<br>两台 Nginx 组成集群，分别部署上 keepalived，设置成相同的虚 IP，保证 Nginx 的高可用。当一台 Nginx 挂了，keepalived 能够探测到并将流量迁移到另一台 Nginx 上，整个过程对调用方透明。<br>缺点：<ul>
<li>资源利用率低；</li>
<li>扩容不方便，如果吞吐量超过 Nginx 性能上线，要加机器配置起来比较麻烦。</li>
</ul>
</li>
<li>lvs&#x2F;f5<br>DNS 解析出来的 IP 是 lvs 的地址。由 lvs 反向代理 Nginx 服务器，lvs 的机器上部署 keepalived+VIP 实现高可用；<br>f5 的性能比 lvs 更高，但是成本也会更高。</li>
<li>DNS 轮询<br>水平扩展才是解决性能问题的根本方案，能够通过加机器扩充性能的方案才具备最好的扩展性。<br><img src="/imgs/Nginx%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/%E5%8F%AF%E6%89%A9%E5%B1%95%E9%AB%98%E5%8F%AF%E7%94%A8%E6%8E%A5%E5%85%A5%E5%B1%82%E6%9E%B6%E6%9E%84.png" alt="可扩展高可用接入层架构" title="可扩展高可用接入层架构"><ul>
<li>通过 DNS 轮询来线性扩展入口 lvs 层的性能；</li>
<li>通过 keepalived 保证高可用；</li>
<li>通过 lvs 来扩展多个 Nginx；</li>
<li>通过 Nginx 实现对业务服务器的七层负载均衡。</li>
</ul>
</li>
</ol>
<h2 id="使用-Nginx"><a href="#使用-Nginx" class="headerlink" title="使用 Nginx"></a>使用 Nginx</h2><h3 id="手动安装-Nginx"><a href="#手动安装-Nginx" class="headerlink" title="手动安装 Nginx"></a>手动安装 Nginx</h3><ol>
<li>配置<br>创建目录<code>/var/temp/nginx</code><br>这个目录保存临时文件，在安装配置中指定：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">./configure \</span><br><span class="line">--prefix=/usr/local/nginx \</span><br><span class="line">--pid-path=/var/run/nginx/nginx.pid \</span><br><span class="line">--lock-path=/var/lock/nginx.lock \</span><br><span class="line">--error-log-path=/var/log/nginx/error.log \</span><br><span class="line">--http-log-path=/var/log/nginx/access.log \</span><br><span class="line">--with-http_gzip_static_module \</span><br><span class="line">--http-client-body-temp-path=/var/temp/nginx/client \</span><br><span class="line">--http-proxy-temp-path=/var/temp/nginx/proxy \</span><br><span class="line">--http-fastcgi-temp-path=/var/temp/nginx/fastcgi \</span><br><span class="line">--http-uwsgi-temp-path=/var/temp/nginx/uwsgi \</span><br><span class="line">--http-scgi-temp-path=/var/temp/nginx/scgi</span><br></pre></td></tr></table></figure></li>
<li>安装<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line">make  install</span><br></pre></td></tr></table></figure></li>
<li>配置环境变量<br>在<code>/etc/profile</code>中编辑，这样就可以直接使用 nginx 命令启动了<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:/usr/local/nginx/sbin</span><br></pre></td></tr></table></figure></li>
<li>启动<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nginx</span><br><span class="line"># 指定配置文件</span><br><span class="line">nginx -c /usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure>
如果不指定-c，nginx 在启动时默认加载 conf&#x2F;nginx.conf 文件，此文件的地址也可以在编译安装 nginx 时指定.&#x2F;configure 的参数（–conf-path&#x3D; 指向配置文件（nginx.conf））</li>
<li>停止<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nginx -s stop # 相当于先查出nginx进程id再kill</span><br><span class="line">nginx -s quit # 建议使用，这种方法是等nginx进程的任务处理完毕后再停止</span><br></pre></td></tr></table></figure></li>
<li>重启<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nginx -s quit</span><br><span class="line">nginx</span><br></pre></td></tr></table></figure>
要想在修改配置文件 nginx.conf 后生效：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="开机自启"><a href="#开机自启" class="headerlink" title="开机自启"></a>开机自启</h3><ol>
<li>创建<code>/etc/init.d/nginx</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># nginx Startup script for the Nginx HTTP Server</span><br><span class="line"># it is v.0.0.2 version.</span><br><span class="line"># chkconfig: - 85 15</span><br><span class="line"># description: Nginx is a high-performance web and proxy server.</span><br><span class="line">#              It has a lot of features, but it&#x27;s not for everyone.</span><br><span class="line"># processname: nginx</span><br><span class="line"># pidfile: /var/run/nginx.pid</span><br><span class="line"># config: /usr/local/nginx/conf/nginx.conf</span><br><span class="line">nginxd=/usr/local/nginx/sbin/nginx</span><br><span class="line">nginx_config=/usr/local/nginx/conf/nginx.conf</span><br><span class="line">nginx_pid=/var/run/nginx.pid</span><br><span class="line">RETVAL=0</span><br><span class="line">prog=&quot;nginx&quot;</span><br><span class="line"># Source function library.</span><br><span class="line">. /etc/rc.d/init.d/functions</span><br><span class="line"># Source networking configuration.</span><br><span class="line">. /etc/sysconfig/network</span><br><span class="line"># Check that networking is up.</span><br><span class="line">[ $&#123;NETWORKING&#125; = &quot;no&quot; ] &amp;&amp; exit 0</span><br><span class="line">[ -x $nginxd ] || exit 0</span><br><span class="line"># Start nginx daemons functions.</span><br><span class="line">start() &#123;</span><br><span class="line">if [ -e $nginx_pid ];then</span><br><span class="line">   echo &quot;nginx already running....&quot;</span><br><span class="line">   exit 1</span><br><span class="line">fi</span><br><span class="line">   echo -n $&quot;Starting $prog: &quot;</span><br><span class="line">   daemon $nginxd -c $&#123;nginx_config&#125;</span><br><span class="line">   RETVAL=$?</span><br><span class="line">   echo</span><br><span class="line">   [ $RETVAL = 0 ] &amp;&amp; touch /var/lock/subsys/nginx</span><br><span class="line">   return $RETVAL</span><br><span class="line">&#125;</span><br><span class="line"># Stop nginx daemons functions.</span><br><span class="line">stop() &#123;</span><br><span class="line">        echo -n $&quot;Stopping $prog: &quot;</span><br><span class="line">        killproc $nginxd</span><br><span class="line">        RETVAL=$?</span><br><span class="line">        echo</span><br><span class="line">        [ $RETVAL = 0 ] &amp;&amp; rm -f /var/lock/subsys/nginx /var/run/nginx.pid</span><br><span class="line">&#125;</span><br><span class="line"># reload nginx service functions.</span><br><span class="line">reload() &#123;</span><br><span class="line">    echo -n $&quot;Reloading $prog: &quot;</span><br><span class="line">    #kill -HUP `cat $&#123;nginx_pid&#125;`</span><br><span class="line">    killproc $nginxd -HUP</span><br><span class="line">    RETVAL=$?</span><br><span class="line">    echo</span><br><span class="line">&#125;</span><br><span class="line"># See how we were called.</span><br><span class="line">case &quot;$1&quot; in</span><br><span class="line">start)</span><br><span class="line">        start</span><br><span class="line">        ;;</span><br><span class="line">stop)</span><br><span class="line">        stop</span><br><span class="line">        ;;</span><br><span class="line">reload)</span><br><span class="line">        reload</span><br><span class="line">        ;;</span><br><span class="line">restart)</span><br><span class="line">        stop</span><br><span class="line">        start</span><br><span class="line">        ;;</span><br><span class="line">status)</span><br><span class="line">        status $prog</span><br><span class="line">        RETVAL=$?</span><br><span class="line">        ;;</span><br><span class="line">*)</span><br><span class="line">        echo $&quot;Usage: $prog &#123;start|stop|restart|reload|status|help&#125;&quot;</span><br><span class="line">        exit 1</span><br><span class="line">esac</span><br><span class="line">exit $RETVAL</span><br></pre></td></tr></table></figure></li>
<li>设置文件访问权限<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod a+x /etc/init.d/nginx</span><br></pre></td></tr></table></figure></li>
<li>设置开机加载<br>在<code>/etc/rc.local</code>中加入一行<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/nginx start</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="通过-Docker-运行-Nginx"><a href="#通过-Docker-运行-Nginx" class="headerlink" title="通过 Docker 运行 Nginx"></a>通过 Docker 运行 Nginx</h3><p>手动进行 Nginx 配置十分繁琐，可以使用 Docker 来简化部署流程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 80:80 nginx</span><br></pre></td></tr></table></figure>


<h2 id="Nginx-原理-进程"><a href="#Nginx-原理-进程" class="headerlink" title="Nginx 原理 - 进程"></a>Nginx 原理 - 进程</h2><h3 id="Nginx-代码的模块化结构"><a href="#Nginx-代码的模块化结构" class="headerlink" title="Nginx 代码的模块化结构"></a>Nginx 代码的模块化结构</h3><p>Nginx 的代码是由一个核心和一系列的模块组成的。<br><strong>核心</strong>主要用于提供 WebServer 的基本功能，以及 Web 和 Mail 反向代理的功能；还用于启用网络协议，创建必要的运行时环境以及确保不同的模块之间平滑地进行交互。<br>不过，大多跟协议相关的功能和应用特有的功能都是由 nginx 的模块实现的。<br>换句话说， <strong>每一个功能或操作都由一个模块来实现</strong>。<br>这些功能模块大致可以分为事件模块、阶段性处理器、输出过滤器、变量处理器、协议、upstream 和负载均衡几个类别，这些共同组成了 nginx 的 http 功能。<br><strong>事件模块</strong>主要用于提供 OS 独立的(不同操作系统的事件机制有所不同)事件通知机制如 kqueue 或 epoll 等。<br><strong>协议模块</strong>则负责实现 nginx 通过 http、tls&#x2F;ssl、smtp、pop3 以及 imap 与对应的客户端建立会话。<br>在 Nginx 内部，进程间的通信是通过模块的 <strong>pipeline</strong> 或 <strong>chain</strong> 实现的。<br>换句话说，每一个功能或操作都由一个模块来实现。例如：压缩、通过 FastCGI 或 uwsgi 协议与 upstream 服务器通信、以及与 memcached 建立会话等。</p>
<h3 id="进程结构"><a href="#进程结构" class="headerlink" title="进程结构"></a>进程结构</h3><p>一个 Nginx 服务器实例由一个 master 进程和多个 worker 进程组成。<br><img src="/imgs/Nginx%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/%E8%BF%9B%E7%A8%8B%E7%BB%93%E6%9E%84.png" alt="进程结构"><br><strong>master</strong>进程主要用来管理 worker 进程，还有一些对整个服务器的初始化和日志记录等工作。<br><strong>管理 worker 的过程</strong>：接收来自外界的信号，向各 worker 进程发送 <strong>信号</strong> ，监控 worker 进程的运行状态，当 worker 进程退出后(异常情况下)，会自动重新启动（fork）新的 worker 进程。  </p>
<p><strong>master 主要功能</strong>：  </p>
<ul>
<li>读取并验证配置信息；</li>
<li>创建、绑定及关闭套接字；</li>
<li>启动、终止 worker 进程及维护 worker 进程的个数；</li>
<li>无须中止服务而重新配置工作；</li>
<li>控制非中断式程序升级，启用新的二进制程序并在需要时回滚至老版本；</li>
<li>重新打开日志文件；</li>
<li>编译嵌入式 perl 脚本</li>
</ul>
<p>对请求的实际处理由 <strong>worker</strong> 负责，且每个请求只能由一个 worker 负责（一对一）。在启动时,创建一组初始的监听套接字，HTTP 请求和响应之时，worker 连续接收、读取和写入套接字。</p>
<p><strong>worker 主要功能</strong>：</p>
<ul>
<li>接收、传入并处理来自客户端的连接；</li>
<li>提供反向代理及过滤功能；</li>
<li>nginx 任何能完成的其它任务</li>
</ul>
<h3 id="Nginx-的启动"><a href="#Nginx-的启动" class="headerlink" title="Nginx 的启动"></a>Nginx 的启动</h3><p>nginx 启动后，在 unix 系统中会以 daemon 的方式在后台运行，后台进程包含一个 master 进程和多个 worker 进程（你可以理解为工人和管理员）。 </p>
<h3 id="Nginx-处理连接过程"><a href="#Nginx-处理连接过程" class="headerlink" title="Nginx 处理连接过程"></a>Nginx 处理连接过程</h3><p>nginx 不会为每个连接派生进程或线程，而是由 worker 进程通过监听共享套接字接受新请求，并且使用高效的 <strong>循环</strong> 来处理数千个连接。<br>Nginx 不使用仲裁器或分发器来分发连接，这个工作由操作系统内核机制完成。 <strong>监听套接字</strong> 在启动时就完成初始化，worker 进程通过这些套接字接受、读取请求和输出响应。  </p>
<p>一次请求过程大概执行过程为：</p>
<ol>
<li>nginx 在启动时，会解析配置文件，得到需要监听的端口与 ip 地址，然后在 nginx 的 master 进程里面先初始化好这个监控的 socket，再进行 listen（listenfd）；</li>
<li>由 master 进程 fork 出多个 worker 进程；</li>
<li>此时客户端可以向 nginx 发起连接了，客户端会与 nginx 进行三次握手（TCP），与 nginx 建立好一个连接；</li>
<li>所有 worker 进程的 listenfd 会在新连接到来时变得可读，为保证只有一个进程处理该连接，所有 worker 进程会在注册 listenfd 读事件前抢 accept_mutex，抢到互斥锁的那个进程注册 listenfd 读事件，然后在读事件里调用 accept 接受该连接</li>
<li>当一个 worker 进程在 accept 这个连接之后，然后创建 nginx 对连接的封装，即 ngx_connection_t 结构体，就开始读取请求、解析请求、处理请求（ <strong>异步非阻塞</strong> ），主要是根据事件调用相应的事件处理模块，如 http 模块与客户端进行数据的交换</li>
<li>产生数据后，再返回给客户端，最后才断开连接，或者由客户端主动关闭连接。</li>
</ol>
<h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p>在 Nginx 内部，进程间的通信是通过模块的 <strong>pipeline</strong> 或 <strong>chain</strong> 实现的，其原理是<strong>信号机制</strong>，master 对 worker 进程采用信号进行控制。</p>
<h3 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h3><p>所谓<strong>事件驱动</strong>架构，简单来说，就是由一些事件发生源来产生事件，由一个或多个事件收集器（epolld 等）来收集、分发事件，然后许多事件处理器会注册自己感兴趣的事件，同时会“消费”这些事件。nginx 不会使用进程或线程作为事件消费者，只能是某个模块，当前进程调用模块。<br>传统 web 服务器（如 Apache）的所谓事件局限在 TCP 连接建立、关闭上，其他读写都不再是事件驱动，这时会退化成按序执行每个操作的批处理模式，这样每个请求在连接建立后都将始终占用系统资源，直到连接关闭才会释放资源。大大浪费了内存、cpu 等资源。并且把一个进程或线程作为事件消费者。 传统 Web 服务器每个事件消费者独占一个进程资源，相对来说，Nginx 只是被事件分发者进程短期调用而已。<br>nginx 采用多 worker 的方式来处理请求，每个 worker 里面只有一个主线程，那能够处理的并发数很有限，多少个 worker 就能处理多少个并发，那么何来的高并发呢？<br>其实，Nginx 是采用了<strong>异步非阻塞</strong>的 IO 模型来处理请求的（epoll），异步的概念是和同步相对的，也就是不同事件之间不是同时发生的。非阻塞的概念是和阻塞对应的，阻塞是事件按顺序执行，每一事件都要等待上一事件的完成，而非阻塞是如果事件没有准备好，这个事件可以直接返回，过一段时间再进行处理询问，这期间可以做其他事情。<br>请求的<strong>多阶段异步处理</strong>只能基于事件驱动框架实现，就是把一个请求的处理过程按照事件的触发方式分为多个阶段，每个阶段都可以有事件收集、分发器（epoll 等）来触发。比如一个 http 请求可以分为七个阶段。<br>每种事件都有一个事件队列，按触发的先后顺序处理。</p>
<h3 id="惊群现象"><a href="#惊群现象" class="headerlink" title="惊群现象"></a>惊群现象</h3><p>惊群是多个子进程在同一时刻监听同一个端口引起的；<br>Nginx 解决方法：同一个时刻只能有唯一一个 worker 子进程监听 web 端口，此时新连接事件只能唤醒唯一正在监听端口的 worker 子进程。这可以通过锁或互斥量实现。</p>
<h3 id="为什么不使用多线程"><a href="#为什么不使用多线程" class="headerlink" title="为什么不使用多线程"></a>为什么不使用多线程</h3><ul>
<li>Apache: 创建多个进程或线程，而每个进程或线程都会为其分配 cpu 和内存（线程要比进程小的多，所以 worker 支持比 perfork 高的并发），并发过大会榨干服务器资源。 </li>
<li>Nginx: 采用单线程来异步非阻塞处理请求（管理员可以配置 Nginx 主进程的工作进程的数量）(epoll)，不会为每个请求分配 cpu 和内存资源，节省了大量资源，同时也减少了大量的 CPU 的上下文切换。所以才使得 Nginx 支持更高的并发。</li>
</ul>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><h3 id="模块命名"><a href="#模块命名" class="headerlink" title="模块命名"></a>模块命名</h3><p><code>ngx_http_[module-name]_[main|srv|loc]_conf_t</code><br>前缀表示模块名，后面表示模块运行在哪一层</p>
<h3 id="模块化结构"><a href="#模块化结构" class="headerlink" title="模块化结构"></a>模块化结构</h3><p>Nginx由内核和一系列模块组成，内核提供web服务的基本功能,如启用网络协议,创建运行环境,接收和分配客户端请求,处理模块之间的交互。Nginx的各种功能和操作都由模块来实现。<br>Nginx的模块从结构上分为核心模块、基础模块和第三方模块。</p>
<ul>
<li>核心模块： HTTP模块、EVENT模块和MAIL模块</li>
<li>基础模块： HTTP Access模块、HTTP FastCGI模块、HTTP Proxy模块和HTTP Rewrite模块</li>
<li>第三方模块： HTTP Upstream Request Hash模块、Notice模块和HTTP Access Key模块及用户自己开发的模块</li>
</ul>
<p>这样的设计使Nginx方便开发和扩展，也正因此才使得Nginx功能如此强大。Nginx的模块默认编译进nginx中，如果需要增加或删除模块，需要重新编译Nginx，这一点不如Apache的动态加载模块方便。如果有需要动态加载模块，可以使用由淘宝网发起的web服务器Tengine，在nginx的基础上增加了很多高级特性，完全兼容Nginx，已被国内很多网站采用。</p>
<p>模块大致结构如下图所示。<br><img src="/imgs/Nginx%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/Nginx%E6%A8%A1%E5%9D%97%E7%BB%93%E6%9E%84.png" alt="Nginx模块结构" title="Nginx模块结构"><br>Nginx模块，简单地讲，就是：在特定地方调用的函数。</p>
<h3 id="模块执行过程"><a href="#模块执行过程" class="headerlink" title="模块执行过程"></a>模块执行过程</h3><p>nginx的配置 <strong>指令作用域</strong> 分为以下几种：main，server，location<br>main作用域的范围为整个配置文件，而server是指某个具体的服务器（通过端口号来区分），而location就是指要访问这个server的哪个location。  </p>
<p>Nginx 本身做的工作实际很少，当它接到一个 HTTP 请求时，它仅仅是通过查找配置文件将此次请求映射到一个 locationblock，而此 location 中所配置的各个指令则会启动不同的模块去完成工作。<br>通常一个 location 中的指令会涉及一个 handler 模块和多个 filter 模块（当然，多个 location 可以复用同一个模块）。handler 模块负责处理请求，完成响应内容的生成，而 filter 模块对响应内容进行处理。<br>模块处理请求的大致过程如下图所示。<br><img src="/imgs/Nginx%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/Nginx%E6%A8%A1%E5%9D%97%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="Nginx模块执行流程" title="Nginx模块执行流程"></p>
<h3 id="http-index模块（ngx-http-index-module）"><a href="#http-index模块（ngx-http-index-module）" class="headerlink" title="http index模块（ngx_http_index_module）"></a>http index模块（ngx_http_index_module）</h3><p>定义将要被作为默认页的文件。 文件的名字可以包含变量。 文件以配置中指定的顺序被 nginx 检查。 列表中的最后一个元素可以是一个带有绝对路径的文件。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    root   /home/ftpuser/www;</span><br><span class="line">    index  index.html index.$haha.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，index 文件会引发内部重定向，请求可能会被其它 location 处理。<br>比如下面的配置，请求”&#x2F;“实际上将会在第二个location中作为”&#x2F;index.html”被处理：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location = / &#123;</span><br><span class="line">    index index.html;</span><br><span class="line">&#125;</span><br><span class="line">location / &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="http-log模块（ngx-http-log-module）"><a href="#http-log模块（ngx-http-log-module）" class="headerlink" title="http log模块（ngx_http_log_module）"></a>http log模块（ngx_http_log_module）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">log_format  gzip &#x27;$remote_addr-$remote_user[$time_local]&#x27;</span><br><span class="line">:&#x27;$request$status $bytes_sent&#x27;</span><br><span class="line">:&#x27;&quot; $ http _ referer&quot; &quot;$http_user_agent&quot; &quot;$gzip_ratio&quot;&#x27;;</span><br><span class="line">access_log  /spool/logs/nginx-access.log  gzip  buffer=32k;</span><br></pre></td></tr></table></figure>
<p>指令 access_log 指派路径、格式和缓存大小：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 格式</span><br><span class="line">access_log path [format [buffer=size | off ]</span><br><span class="line"># 默认</span><br><span class="line">access_log log/access.log combined</span><br></pre></td></tr></table></figure>
<p>其中参数 “off” 将清除当前级别的所有 access_log 指令。如果未指定格式，则使用预置的 “combined” 格式。缓存不能大于能写入磁盘的文件的最大值（在 FreeBSD 3.0-6.0 ，缓存大小无此限制）。<br>指令 log_format 指定日志格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 格式</span><br><span class="line">log_format name format [format ...]</span><br><span class="line"># 默认</span><br><span class="line">log_format combined &quot;...&quot;</span><br></pre></td></tr></table></figure>
<h3 id="Access模块（ngx-http-access-module）"><a href="#Access模块（ngx-http-access-module）" class="headerlink" title="Access模块（ngx_http_access_module）"></a>Access模块（ngx_http_access_module）</h3><p>此模块提供了一个简易的基于主机的访问控制。<br>ngx_http_access_module 模块让我们可以对特定 IP 客户端进行控制。 规则检查按照第一次匹配的顺序，此模块对网络地址有放行和禁止的权利。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 仅允许网段 10.1.1.0/16 和 192.168.1.0/24 中除 192.168.1.1 之外的 ip 访问</span><br><span class="line">location / &#123;</span><br><span class="line">: deny 192.168.1.1;</span><br><span class="line">: allow 192.168.1.0/24;</span><br><span class="line">: allow 10.1.1.0/16;</span><br><span class="line">: deny all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>放行语法 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">allow [ address | CIDR | all ]</span><br></pre></td></tr></table></figure>
作用域: http, server, location, limit_except<br>allow 描述的网络地址有权直接访问</li>
<li>禁止语法 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deny [ address | CIDR | all ]</span><br></pre></td></tr></table></figure>
作用域: http, server, location, limit_except<br>deny 描述的网络地址拒绝访问</li>
</ol>
<h3 id="Rewrite模块（ngx-http-rewrite-module）"><a href="#Rewrite模块（ngx-http-rewrite-module）" class="headerlink" title="Rewrite模块（ngx_http_rewrite_module）"></a>Rewrite模块（ngx_http_rewrite_module）</h3><p>执行 URL 重定向,允许你去掉带有恶意的 URL，包含多个参数（修改）.利用正则的匹配，分组和引用，达到目的 配置范例：该模块允许使用正则表达式改变 URL，并且根据变量来转向以及选择配置</p>
<ol>
<li>if语法 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (condition) &#123; ... &#125;</span><br></pre></td></tr></table></figure>
作用域: server, location <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">if ($http_user_agent ~ MSIE) &#123;</span><br><span class="line">: rewrite ^(.*)$ /msie/$1 break;</span><br><span class="line">&#125;</span><br><span class="line">if ($http_cookie ~* &quot;id=([^;] +)(?:;|$)&quot; ) &#123;</span><br><span class="line">: set $id $1;</span><br><span class="line">&#125;</span><br><span class="line">if ($request_method = POST ) &#123;</span><br><span class="line">: return 405;</span><br><span class="line">&#125;</span><br><span class="line">if (!-f $request_filename) &#123;</span><br><span class="line">: break;</span><br><span class="line">: proxy_pass http://127.0.0.1;</span><br><span class="line">&#125;</span><br><span class="line">if ($slow) &#123;</span><br><span class="line">: limit_rate 10k;</span><br><span class="line">&#125;</span><br><span class="line">if ($invalid_referer) &#123;</span><br><span class="line">: return 403;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>return语法<br>这个指令根据规则的执行情况，返回一个状态值给客户端。可使用值包括：204，400，402-406，408，410，411，413，416 及 500-504。也可以发送非标准的 444 代码-未发送任何头信息下结束连接。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return cod</span><br></pre></td></tr></table></figure>
作用域: server, location, if</li>
<li>rewrite语法<br>这个指令根据正则表达式或者待替换的字符串来更改 URL。指令根据配置文件中的先后顺序执行生效。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rewrite regex replacement flag</span><br></pre></td></tr></table></figure>
flag可以有以下取值：<ul>
<li>last :表示完成 rewrite</li>
<li>break:本规则匹配完成后，终止匹配，不再匹配后面的规则</li>
<li>redirect:返回 302 临时重定向，地址栏会显示跳转后的地址</li>
<li>permanent:返回 301 永久重定向，地址栏会显示跳转后的地址<br>作用域: server, location, if</li>
</ul>
</li>
</ol>
<h3 id="Proxy模块（ngx-http-proxy-module）"><a href="#Proxy模块（ngx-http-proxy-module）" class="headerlink" title="Proxy模块（ngx_http_proxy_module）"></a>Proxy模块（ngx_http_proxy_module）</h3><p>此模块能代理请求到其它服务器.也就是说允许你把客户端的 HTTP 请求转到后端服务器(这部分的指令非常多，但不是全部都会被用到，详细指令列表可以上<a target="_blank" rel="noopener" href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html">官网</a>查看，这里是比较常见的指令简介)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 强制一些被忽略的头传递到客户端</span><br><span class="line">proxy_pass_header Server;</span><br><span class="line"># 允许改写出现在 HTTP 头却被后端服务器触发重定向的 URL,对响应本身不做任何处理</span><br><span class="line">proxy_redirect off;</span><br><span class="line"># 允许你重新定义代理 header 值再转到后端服务器，目标服务器可以看到客户端的原始主机名</span><br><span class="line">proxy_set_header Host $http_host;</span><br><span class="line"># 目标服务器可以看到客户端的真实 ip，而不是转发服务器的 ip</span><br><span class="line">proxy_set_header X-Real-IP $remote_addr;</span><br></pre></td></tr></table></figure>
<h3 id="upstream模块（ngx-http-upstream-module）"><a href="#upstream模块（ngx-http-upstream-module）" class="headerlink" title="upstream模块（ngx_http_upstream_module）"></a>upstream模块（ngx_http_upstream_module）</h3><p>该指令将来自客户端的一个请求分到多个上行服务器上，即我们常说的负载均衡。<br>默认情况下采用<strong>轮询</strong>策略，每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。<br>可以使用<strong>weight</strong>来指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">  server backend1.example.com weight=5;</span><br><span class="line">  server backend2.example.com:8080;</span><br><span class="line">  server unix:/tmp/backend3;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">  location / &#123;</span><br><span class="line">    proxy_pass http://backend;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>upstream指令<br>这个指令描述了一个服务器的集合，该集合可被用于 proxy_pass 和 fastcgi_pass 指令中，作为一个单独的实体。这些服务器可以是监听在不同的端口，另外，并发使用同时监听 TCP 端口和 Unix 套接字的服务器是可能的。 这些服务器能被分配不同的权重。如果没有指定，则都为 1 ，即默认的策略为轮询。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">    server backend1.example.com weight=5;</span><br><span class="line">    server 127.0.0.1:8080 max_fails=3 fail_timeout=30s;</span><br><span class="line">    server unix:/tmp/backend3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
可以通过weight参数指定每个上行服务器的权重，weight和访问比率成正比，用于后端服务器性能不均的情况。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream test&#123;</span><br><span class="line">     server localhost:8080 weight=9;</span><br><span class="line">     server localhost:8081 weight=1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>ip_hash指令<br>请求基于客户端的 IP 地址在服务器间进行分发。 IPv4 地址的前三个字节或者 IPv6 的整个地址，会被用来作为一个散列 key。 这种方法可以确保从同一个客户端过来的请求，会被传给同一台服务器。除了当服务器被认为不可用的时候，这些客户端的请求会被传给其他服务器，而且很有可能也是同一台服务器。<br>如果其中一个服务器想暂时移除，应该加上 down 参数。这样可以保留当前客户端 IP 地址散列分布。<br>作用域：upstream <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">  ip_hash;</span><br><span class="line">  server backend1.example.com;</span><br><span class="line">  server backend2.example.com;</span><br><span class="line">  server backend3.example.com down;</span><br><span class="line">  server backend4.example.com;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>fair（第三方）<br>按后端服务器的响应时间来分配请求，响应时间短的优先分配。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123; </span><br><span class="line">    fair; </span><br><span class="line">    server localhost:8080;</span><br><span class="line">    server localhost:8081;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>url_hash(第三方)<br>按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。 在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">    hash $request_uri;</span><br><span class="line">    hash_method crc32;</span><br><span class="line">    server localhost:8080;</span><br><span class="line">    server localhost:8081;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>server指令<br>定义服务器的地址 address 和其他参数 parameters。 地址可以是域名或者 IP 地址，端口是可选的，或者是指定“unix:”前缀的 UNIX 域套接字的路径。如果没有指定端口，就使用 80 端口。 如果一个域名解析到多个 IP，本质上是定义了多个 server。<br>作用域：upstream <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">  server backend1.example.com weight=5;</span><br><span class="line">  server 127.0.0.1:8080 max_fails=3 fail_timeout=30s;</span><br><span class="line">  server unix:/tmp/backend3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="nginx配置文件优化"><a href="#nginx配置文件优化" class="headerlink" title="nginx配置文件优化"></a>nginx配置文件优化</h2><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>默认配置文件位置在&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf，在configue时决定，也可以在运行nginx时指定配置文件  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx nginx.conf</span><br></pre></td></tr></table></figure>


<h3 id="顶层配置"><a href="#顶层配置" class="headerlink" title="顶层配置"></a>顶层配置</h3><p>顶层配置即nginx.conf中前面、暴露在外面的那几项  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#user  nobody;</span><br><span class="line">worker_processes  1;</span><br><span class="line">#pid        logs/nginx.pid;</span><br></pre></td></tr></table></figure>
<p><strong>worker_processes</strong> 定义了 nginx 在为你的网站提供服务时，worker 进程的数量。<br>这个优化值受到包括 CPU 内核数、存储数据的磁盘数、负载值在内的许多因素的影响。如果不确定的话，将其设置为可用的 CPU 内核的数量是一个不错的选择（设置为“auto”，将会尝试自动检测可用的值）。<br>另外本机的CPU核心信息可以使用下面命令查看  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo | grep processor</span><br></pre></td></tr></table></figure>


<h3 id="events模块"><a href="#events模块" class="headerlink" title="events模块"></a>events模块</h3><p>events模块包括了 nginx 中处理链接的全部设置  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">    # multi_accept on;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>worker_connections</strong> 设置了一个 worker 进程可以同时打开的链接数。<br><strong>multi_accept</strong> 的作用是告诉 nginx 在收到新链接的请求通知时，尽可能接受链接。最好开着  </p>
<h3 id="http模块"><a href="#http模块" class="headerlink" title="http模块"></a>http模块</h3><p>当外部有 http 请求时，nginx 的 http 模块才是处理这个请求的核心。  </p>
<ol>
<li>Basic Settings<br><strong>sendfile</strong> 指向 sendfile()函数。sendfile() 在磁盘和 TCP 端口（或者任意两个文件描述符）之间复制数据。<br>在 sendfile 出现之前，为了传输这样的数据，需要在用户空间上分配一块数据缓存，使用 read() 从源文件读取数据到缓存，然后使用 write() 将缓存写入到网络。<br>sendfile() 直接从磁盘上读取数据到操作系统缓冲。由于这个操作是在内核中完成的，sendfile() 比 read() 和 write() 联合使用要更加有效率。<br><strong>tcp_nopush</strong> 配置 nginx 在一个数据包中发送全部的头文件，而不是一个一个发送。<br><strong>tcp_nodelay</strong> 配置 nginx 不要缓存数据，应该快速的发送小数据——这仅仅应该用于频繁发送小的碎片信息而无需立刻获取响应的、需要实时传递数据的应用中。<br><strong>keepalive_timeout</strong> 指定了与客户端的 keep-alive 链接的超时时间。服务器会在这个时间后关闭链接。我们可以降低这个值，以避免让 worker 过长时间的忙碌。  </li>
<li>Logging Settings<br><strong>access_log</strong> 确定了 nginx 是否保存访问日志。将这个设置为关闭可以降低磁盘 IO 而提升速度。<br><strong>error_log</strong> 设置 nginx 应当记录错误日志。  </li>
<li>Gzip Settings<br><strong>gzip</strong> 设置 nginx gzip 压缩发送的数据。这会减少需要发送的数据的数量。<br><strong>gzip_disable</strong> 为指定的客户端禁用 gzip 功能。<br><strong>gzip_proxied</strong> 允许或禁止基于请求、响应的压缩。设置为 any，就可以 gzip 所有的请求。<br><strong>gzip_comp_level</strong> 设置了数据压缩的等级。等级可以是 1-9 的任意一个值，9 表示最慢但是最高比例的压缩。<br><strong>gzip_types</strong> 设置进行 gzip 的类型。有下面这些，不过还可以添加更多。</li>
</ol>
<h3 id="mail模块"><a href="#mail模块" class="headerlink" title="mail模块"></a>mail模块</h3><p>略…</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">user nginxuser;</span><br><span class="line">worker_processes 4;</span><br><span class="line">pid logs/nginx.pid;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections 1024;</span><br><span class="line">    multi_accept on;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line"></span><br><span class="line">    ##</span><br><span class="line">    # Basic Settings</span><br><span class="line">    ##</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    sendfile on;</span><br><span class="line">    tcp_nopush on;</span><br><span class="line">    tcp_nodelay on;</span><br><span class="line">    keepalive_timeout 15;</span><br><span class="line">    types_hash_max_size 2048;</span><br><span class="line">    # server_tokens off;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # server_names_hash_bucket_size 64;</span><br><span class="line">    # server_name_in_redirect off;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    include /etc/nginx/mime.types;</span><br><span class="line">    default_type application/octet-stream;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ##</span><br><span class="line">    # Logging Settings</span><br><span class="line">    ##</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    access_log off;</span><br><span class="line">    error_log /var/log/nginx/error.log;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ##</span><br><span class="line">    # Gzip Settings</span><br><span class="line">    ##</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    gzip on;</span><br><span class="line">    gzip_disable &quot;msie6&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     gzip_vary on;</span><br><span class="line">     gzip_proxied any;</span><br><span class="line">     gzip_comp_level 9;</span><br><span class="line">     gzip_buffers 16 8k;</span><br><span class="line">     gzip_http_version 1.1;</span><br><span class="line">     gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ##</span><br><span class="line">    # nginx-naxsi config</span><br><span class="line">    ##</span><br><span class="line">    # Uncomment it if you installed nginx-naxsi</span><br><span class="line">    ##</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    #include /etc/nginx/naxsi_core.rules;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ##</span><br><span class="line">    # nginx-passenger config</span><br><span class="line">    ##</span><br><span class="line">    # Uncomment it if you installed nginx-passenger</span><br><span class="line">    ##</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    #passenger_root /usr;</span><br><span class="line">    #passenger_ruby /usr/bin/ruby;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ##</span><br><span class="line">    # Virtual Host Configs</span><br><span class="line">    ##</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    include /etc/nginx/conf.d/*.conf;</span><br><span class="line">    include /etc/nginx/sites-enabled/*;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># mail &#123;</span><br><span class="line">#   # See sample authentication script at:</span><br><span class="line">#   # http://wiki.nginx.org/ImapAuthenticateWithApachePhpScript</span><br><span class="line"># </span><br><span class="line">#   # auth_http localhost/auth.php;</span><br><span class="line">#   # pop3_capabilities &quot;TOP&quot; &quot;USER&quot;;</span><br><span class="line">#   # imap_capabilities &quot;IMAP4rev1&quot; &quot;UIDPLUS&quot;;</span><br><span class="line"># </span><br><span class="line">#   server &#123;</span><br><span class="line">#       listen     localhost:110;</span><br><span class="line">#       protocol   pop3;</span><br><span class="line">#       proxy      on;</span><br><span class="line">#   &#125;</span><br><span class="line"># </span><br><span class="line">#   server &#123;</span><br><span class="line">#       listen     localhost:143;</span><br><span class="line">#       protocol   imap;</span><br><span class="line">#       proxy      on;</span><br><span class="line">#   &#125;</span><br><span class="line">#&#125;</span><br></pre></td></tr></table></figure>


<h2 id="优化-Linux-最大连接数"><a href="#优化-Linux-最大连接数" class="headerlink" title="优化 - Linux 最大连接数"></a>优化 - Linux 最大连接数</h2><h3 id="查看-Linux-连接数"><a href="#查看-Linux-连接数" class="headerlink" title="查看 Linux 连接数"></a>查看 Linux 连接数</h3><p>默认配置下，Linux 只支持有限的连接数。<br>Linux 的线程其实是一个进程，所以 java 的也是，具体来说，叫做“light weight process(LWP)”—轻量级进程。<br>LWP 与其它进程共享所有（或大部分）逻辑地址空间和系统资源，一个进程可以创建多个 LWP，这样它们共享大部分资源；LWP 有它自己的进程标识符，并和其他进程有着父子关系；。LWP 由内核管理并像普通进程一样被调度<br>使用以下命令可以看到某个用户使用了多少进程资源</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -eLf | grep xjjbot(uid)  | wc -l</span><br></pre></td></tr></table></figure>
<p>使用下面命令可以查看具体每个进程开启了多少线程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -o nlwp,pid,lwp,args -u xjjbot(uid)  | sort -n</span><br></pre></td></tr></table></figure>

<p>根据 linux 一切都是文件的规则，首先想到的，是修改 ulimit 的参数，然而也不是，因为它已经足够大了。交叉回想一下 elasticsearch，在安装的时候，需要配置一个叫做 nproc 的东西，问题大概就出在这，是进程资源不够用啦。<br>相关的配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/security/limits.conf</span><br></pre></td></tr></table></figure>
<p>在不同的内核版本上，也有一些小差异。比如：&#x2F;etc&#x2F;security&#x2F;limits.d&#x2F;*<br>下的文件，会在某些时候覆盖 limits.conf 的配置。所以配置不生效的情况下，记得检查一下。<br>鉴于以上原因，可以将 limits.d 中的配置全部注释掉，统一在 limits.conf 中配置。<br>以下是原始配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*          soft    nproc     4096</span><br><span class="line">root       soft    nproc     unlimited</span><br></pre></td></tr></table></figure>
<p>将 4096 改为大点的数字，或者直接改成 unlimited 就可以了。</p>
<p>单机支持 100 万连接是可行的，但带宽问题会成为显著的瓶颈。启用压缩的二进制协议会节省部分带宽，但开发难度增加。</p>
<h3 id="操作系统优化"><a href="#操作系统优化" class="headerlink" title="操作系统优化"></a>操作系统优化</h3><p>更改进程最大文件句柄数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -n 1048576</span><br></pre></td></tr></table></figure>
<p>复制代码修改单个进程可分配的最大文件数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 2097152 &gt; /proc/sys/fs/nr_open</span><br></pre></td></tr></table></figure>
<p>复制代码修改&#x2F;etc&#x2F;security&#x2F;limits.conf 文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*   soft nofile  1048576</span><br><span class="line">*   hard nofile 1048576</span><br><span class="line">*   soft nproc unlimited</span><br><span class="line">root soft nproc unlimited</span><br></pre></td></tr></table></figure>
<p>复制代码记得清理掉&#x2F;etc&#x2F;security&#x2F;limits.d&#x2F;*下的配置</p>
<h3 id="网络优化"><a href="#网络优化" class="headerlink" title="网络优化"></a>网络优化</h3><p>打开&#x2F;etc&#x2F;sysctl.conf，添加配置然后执行，使用 sysctl 生效</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#单个进程可分配的最大文件数</span><br><span class="line">fs.nr_open=2097152</span><br><span class="line"></span><br><span class="line">#系统最大文件句柄数</span><br><span class="line">fs.file-max = 1048576</span><br><span class="line"></span><br><span class="line">#backlog 设置</span><br><span class="line">net.core.somaxconn=32768</span><br><span class="line">net.ipv4.tcp_max_syn_backlog=16384</span><br><span class="line">net.core.netdev_max_backlog=16384</span><br><span class="line"></span><br><span class="line">#可用知名端口范围配置</span><br><span class="line">net.ipv4.ip_local_port_range=&#x27;1000 65535&#x27;</span><br><span class="line"></span><br><span class="line">#TCP Socket 读写 Buffer 设置</span><br><span class="line">net.core.rmem_default=262144</span><br><span class="line">net.core.wmem_default=262144</span><br><span class="line">net.core.rmem_max=16777216</span><br><span class="line">net.core.wmem_max=16777216</span><br><span class="line">net.core.optmem_max=16777216</span><br><span class="line">net.ipv4.tcp_rmem=&#x27;1024 4096 16777216&#x27;</span><br><span class="line">net.ipv4.tcp_wmem=&#x27;1024 4096 16777216&#x27;</span><br><span class="line"></span><br><span class="line">#TCP 连接追踪设置</span><br><span class="line">net.nf_conntrack_max=1000000</span><br><span class="line">net.netfilter.nf_conntrack_max=1000000</span><br><span class="line">net.netfilter.nf_conntrack_tcp_timeout_time_wait=30</span><br><span class="line"></span><br><span class="line">#TIME-WAIT Socket 最大数量、回收与重用设置</span><br><span class="line">net.ipv4.tcp_max_tw_buckets=1048576</span><br><span class="line"></span><br><span class="line"># FIN-WAIT-2 Socket 超时设置</span><br><span class="line">net.ipv4.tcp_fin_timeout = 15</span><br></pre></td></tr></table></figure>



<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a target="_blank" rel="noopener" href="https://www.shiyanlou.com/courses/95">Linux Web 运维（Nginx）实战</a></li>
<li><a target="_blank" rel="noopener" href="http://tengine.taobao.org/book/index.html">Nginx 开发从入门到精通</a></li>
<li><a target="_blank" rel="noopener" href="http://nginx.org/en/docs/">nginx documentation</a></li>
</ol>
<h3 id="config"><a href="#config" class="headerlink" title="config"></a>config</h3><p>nginx.conf配置文件详解 <a target="_blank" rel="noopener" href="http://www.ha97.com/5194.html">http://www.ha97.com/5194.html</a><br>更多配置技巧 <a target="_blank" rel="noopener" href="https://www.nginx.com/resources/wiki/start/">https://www.nginx.com/resources/wiki/start/</a></p>
<h3 id="Nginx-原理"><a href="#Nginx-原理" class="headerlink" title="Nginx 原理"></a>Nginx 原理</h3><ol>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/q/1010000003901360?_ea=416091">Nginx 内部有使用多线程吗？</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/63179839">如果这篇文章说不清 epoll 的本质，那就过来掐死我吧！ （1）</a></li>
</ol>
<h3 id="模块-1"><a href="#模块-1" class="headerlink" title="模块"></a>模块</h3><ol>
<li>log<br><a target="_blank" rel="noopener" href="http://nginx.org/en/docs/http/ngx_http_log_module.html">Module ngx_http_log_module</a><br><a target="_blank" rel="noopener" href="http://nginx.org/en/docs/stream/ngx_stream_log_module.html#log_format">Module ngx_stream_log_module</a><br><a target="_blank" rel="noopener" href="http://blog.chinaunix.net/uid-29179844-id-4433640.html">nginx 日志格式及自定义日志配置</a></li>
<li>proxy<br><a target="_blank" rel="noopener" href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html">Module ngx_http_proxy_module</a></li>
<li>TCP &#x2F; UDP<br><a target="_blank" rel="noopener" href="http://nginx.org/en/docs/stream/stream_processing.html">How nginx processes a TCP&#x2F;UDP session</a></li>
</ol>
<h3 id="Tengine"><a href="#Tengine" class="headerlink" title="Tengine"></a>Tengine</h3><ol>
<li><a target="_blank" rel="noopener" href="http://tengine.taobao.org/documentation.html">Documentation</a></li>
</ol>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/d9054d7.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tallate">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tallate">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/d9054d7.html" class="post-title-link" itemprop="url">Redis事务和Lua</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-07-06 09:42:14" itemprop="dateCreated datePublished" datetime="2019-07-06T09:42:14+08:00">2019-07-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-07 01:56:20" itemprop="dateModified" datetime="2025-07-07T01:56:20+08:00">2025-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%93%E5%AD%98/" itemprop="url" rel="index"><span itemprop="name">缓存</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>这一篇是对在公司内缓存代码应用 Redis-Lua 的一个总结，经过 benchmark 测试，这种方式效率更高，且理论上有更低的可能性。<br>顺便，一开始先描述一下Redis中的事务的原理，因为Redis-Lua本身是事务的一个替代品，这二者一般放在一起讨论。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/d9054d7.html#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/4be4a53c.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tallate">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tallate">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/4be4a53c.html" class="post-title-link" itemprop="url">一些有价值的开源学习资料汇总（updating）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-06-05 21:37:14" itemprop="dateCreated datePublished" datetime="2019-06-05T21:37:14+08:00">2019-06-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-07 01:56:20" itemprop="dateModified" datetime="2025-07-07T01:56:20+08:00">2025-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%85%B6%E4%BB%96/" itemprop="url" rel="index"><span itemprop="name">其他</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>收集从网上找到的学习资料，大部分来自 Github。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/4be4a53c.html#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/1840c3ba.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tallate">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tallate">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/1840c3ba.html" class="post-title-link" itemprop="url">自适应负载均衡(20%)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-05-25 22:32:50" itemprop="dateCreated datePublished" datetime="2019-05-25T22:32:50+08:00">2019-05-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-07 01:56:20" itemprop="dateModified" datetime="2025-07-07T01:56:20+08:00">2025-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">设计</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>云环境下自适应负载均衡算法的设计。<br>题目描述 -&gt; <a target="_blank" rel="noopener" href="https://code.aliyun.com/middlewarerace2019/adaptive-loadbalance">阿里巴巴 2019 中间件性能挑战赛-自适应负载均衡（初赛）赛题</a></p>
<p>抽不出时间，中途放弃了。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/1840c3ba.html#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/7d1f0594.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tallate">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tallate">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/7d1f0594.html" class="post-title-link" itemprop="url">Java 基础总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-05-03 17:23:14" itemprop="dateCreated datePublished" datetime="2019-05-03T17:23:14+08:00">2019-05-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-07 01:56:20" itemprop="dateModified" datetime="2025-07-07T01:56:20+08:00">2025-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>

<h2 id="Java5"><a href="#Java5" class="headerlink" title="Java5"></a>Java5</h2><h3 id="语法、集合框架等"><a href="#语法、集合框架等" class="headerlink" title="语法、集合框架等"></a>语法、集合框架等</h3><ul>
<li>泛型</li>
<li>枚举</li>
<li>装箱拆箱</li>
<li>变长参数</li>
<li>注解</li>
<li>foreach 循环</li>
<li>静态导入</li>
<li>格式化</li>
<li>线程框架&#x2F;数据结构</li>
<li>Arrays 工具类&#x2F;StringBuilder&#x2F;instrument</li>
</ul>
<h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><p>不同于 C++中的泛型，Java 的泛型会在编译后被清除，这种机制被称为泛型擦除。</p>
<blockquote>
<p>java 的类型推断基本都在编译期完成</p>
</blockquote>
<p><strong>优点</strong>：可以免去大量的显式类型转换；<br><strong>缺点</strong>：由于泛型擦除的存在，在很多场合下容易引起误会：</p>
<ul>
<li>比如向 List<Integer>类型的表里添加一个 String 类型对象就不会通过，因为在编译期间还需要进行类型检查。</li>
<li>在继承重写方法时，若父类中被重写的方法中含有泛型，因为泛型擦除理应变成重载，但是 Java 编译器会在编译后的字节码中添加桥方法（已经被类型擦除）、桥方法再调用重写的方法来解决；</li>
<li>泛型类型参数不能使用基本类型，因为基本类型不是 Object 的子类；</li>
<li>其他一些注意事项…</li>
</ul>
<h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><p>枚举可以使用 enum 声明，在 switch 中可以作为 case 后的标签。可以使用 EnumMap 来保存枚举到其他类型的映射或使用 EnumSet 保存枚举值的集合。<br><strong>优点</strong>：</p>
<ul>
<li>相对使用 int 或 String 当作枚举对象来说，Java 编译器本身提供了对 enum 的类型检查，可以更安全地使用；</li>
<li>可以用于声明单例对象。</li>
</ul>
<h4 id="装箱拆箱"><a href="#装箱拆箱" class="headerlink" title="装箱拆箱"></a>装箱拆箱</h4><p>基本类型可以自动转换成对应的包装类型，比如 boolean 会被包装为 Boolean。<br><strong>优点</strong>：</p>
<ul>
<li>方便。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>注意拆箱时不能对 null 拆箱，不然会报空指针。</li>
</ul>
<h4 id="变长参数"><a href="#变长参数" class="headerlink" title="变长参数"></a>变长参数</h4><p>可以传入任意多个相同类型的参数。<br><strong>优点</strong>：</p>
<ul>
<li>提供了更多灵活性，比如编写输出方法时可以格式化多个参数。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>需要注意 null 值的传入。</li>
</ul>
<h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><p>注解需要和反射配合使用，JDK 提供了一些具有特定语义的注解：<br>@Inherited：是否对类的子类继承的方法等起作用；<br>@Target：作用目标；<br>@Rentation：表示 annotation 是否保留在编译过的 class 文件中还是在运行时可读。</p>
<h4 id="for-in-循环"><a href="#for-in-循环" class="headerlink" title="for&#x2F;in 循环"></a>for&#x2F;in 循环</h4><p><strong>优点</strong>：</p>
<ul>
<li>方便</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>获取不到元素所在 index；</li>
<li>无法在遍历的时候删除元素；</li>
</ul>
<h4 id="静态-import"><a href="#静态-import" class="headerlink" title="静态 import"></a>静态 import</h4><p>可以直接使用一个类中的静态方法。<br><strong>缺点</strong>：</p>
<ul>
<li>如果有同名的容易引起混淆；</li>
</ul>
<h4 id="Formatter"><a href="#Formatter" class="headerlink" title="Formatter"></a>Formatter</h4><p>提供对日期、数字等的格式化支持</p>
<h4 id="线程框架-数据结构"><a href="#线程框架-数据结构" class="headerlink" title="线程框架&#x2F;数据结构"></a>线程框架&#x2F;数据结构</h4><ol>
<li>在线程中可以设置 UncaughtExceptionHandler，当抛出异常后可以执行指定的逻辑； <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadingTest extends Thread &#123;</span><br><span class="line">  private int[] numbers;</span><br><span class="line">  public ThreadingTest(int[] numbers) &#123;</span><br><span class="line">    setName(&quot;Simple Thread&quot;);</span><br><span class="line">    setUncaughtExceptionHandler(</span><br><span class="line">        new SimpleThreadExceptionHandler());</span><br><span class="line">    this.numbers = numbers;</span><br><span class="line">  &#125;</span><br><span class="line">  public void run() &#123;</span><br><span class="line">    int index = numbers.length;</span><br><span class="line">    boolean finished = false;</span><br><span class="line">    while (!finished) &#123;</span><br><span class="line">      index--;</span><br><span class="line">      finished = true;</span><br><span class="line">      for (int i = 0; i &lt; index; i++) &#123;</span><br><span class="line">        // Create error condition</span><br><span class="line">        if (numbers[i + 1] &lt; 0) &#123;</span><br><span class="line">          throw new IllegalArgumentException(</span><br><span class="line">              &quot;Cannot pass negative numbers into this thread!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (numbers[i] &gt; numbers[i + 1]) &#123;</span><br><span class="line">          // swap</span><br><span class="line">          int temp = numbers[i];</span><br><span class="line">          numbers[i] = numbers[i + 1];</span><br><span class="line">          numbers[i + 1] = temp;</span><br><span class="line">          finished = false;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    int[] numbers = new int[]&#123;2, -1, 56, 4, 7&#125;;</span><br><span class="line">    ThreadingTest threadingTest = new ThreadingTest(numbers);</span><br><span class="line">    threadingTest.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class SimpleThreadExceptionHandler implements</span><br><span class="line">    Thread.UncaughtExceptionHandler &#123;</span><br><span class="line">  public void uncaughtException(Thread t, Throwable e) &#123;</span><br><span class="line">    System.err.printf(&quot;%s: %s at line %d of %s%n&quot;,</span><br><span class="line">        t.getName(),</span><br><span class="line">        e.toString(),</span><br><span class="line">        e.getStackTrace()[0].getLineNumber(),</span><br><span class="line">        e.getStackTrace()[0].getFileName());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>引入 Queue、BlockingQueue、ConcurrentMap 数据结构；</li>
<li>引入 JUC 线程池；<ul>
<li>每次提交任务时，如果线程数还没达到 coreSize 就创建新线程并绑定该任务。 所以第 coreSize 次提交任务后线程总数必达到 coreSize，不会重用之前的空闲线程。</li>
<li>线程数达到 coreSize 后，新增的任务就放到工作队列里，而线程池里的线程则努力的使用 take()从工作队列里拉活来干。</li>
<li>如果队列是个有界队列，又如果线程池里的线程不能及时将任务取走，工作队列可能会满掉，插入任务就会失败，此时线程池就会紧急的再创建新的临时线程来补救。</li>
<li>临时线程使用 poll(keepAliveTime，timeUnit)来从工作队列拉活，如果时候到了仍然两手空空没拉到活，表明它太闲了，就会被解雇掉。</li>
<li>如果 core 线程数＋临时线程数 &gt;maxSize，则不能再创建新的临时线程了，转头执行 RejectExecutionHanlder。默认的 AbortPolicy 抛 RejectedExecutionException 异常，其他选择包括静默放弃当前任务(Discard)，放弃工作队列里最老的任务(DisacardOldest)，或由主线程来直接执行(CallerRuns)，或你自己发挥想象力写的一个。</li>
</ul>
</li>
<li>Arrays<br>提供数组相关的一些工具类。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(myArray);</span><br><span class="line">Arrays.toString(myArray)</span><br><span class="line">Arrays.binarySearch(myArray, 98)</span><br><span class="line">Arrays.deepToString(ticTacToe)</span><br><span class="line">Arrays.deepEquals(ticTacToe, ticTacToe3)</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="Override-支持协变"><a href="#Override-支持协变" class="headerlink" title="Override 支持协变"></a>Override 支持协变</h4><p>返回类型可以是父类中相应类型或其子类。</p>
<h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><h4 id="CDS（Class-Data-Sharing）"><a href="#CDS（Class-Data-Sharing）" class="headerlink" title="CDS（Class Data Sharing）"></a><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/class-data-sharing.html">CDS（Class Data Sharing）</a></h4><p>JRE installer 能将一些系统 jar 文件加载到一种私有内部表示方式，然后转储到一个文件内，称为“shared archive”，下次启动应用的时候可以直接使用这个包内的类数据，这样可以减少部分启动时间。</p>
<h4 id="自动检测服务器级机器"><a href="#自动检测服务器级机器" class="headerlink" title="自动检测服务器级机器"></a><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/server-class.html">自动检测服务器级机器</a></h4><p>如果机器至少有 2 CPUs 和至少 2GB 物理内存，use the Java HotSpot Server Virtual Machine (server VM) instead of the Java HotSpot Client Virtual Machine (client VM).，The aim is to improve performance even if no one configures the VM to reflect the application it’s running. In general, the server VM starts up more slowly than the client VM, but over time runs more quickly.</p>
<h4 id="垃圾收集器自适应"><a href="#垃圾收集器自适应" class="headerlink" title="垃圾收集器自适应"></a><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gc-ergonomics.html">垃圾收集器自适应</a></h4><p>服务器类机器默认垃圾回收器改为并行垃圾回收器。<br>可以指定性能目标，并行收集器可以自动调整堆的大小，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-XX:GCTimeLimit=time-limit ：花费在GC上的时间上限，默认是98，当超过上限时，会抛出OutOfMemory(HeapSpace)的异常</span><br><span class="line">-XX:GCHeapFreeLimit=space-limit ：Heap空闲空间的最低比例下限，默认是2，当超过下限时，会抛出OutOfMemory(HeapSpace)的异常</span><br><span class="line">-XX:MaxGCPauseMillis=nnn ：最长的GC暂停时间，如果时间过长，会相应调整空间的大小（单位是毫秒）</span><br><span class="line">-XX:GCTimeRatio=nnn ：最大的GC占总可用时间的比例，如果时间过长，会相应调整空间的大小（花费在GC上的时间比例不超过1 / (1 + nnn)）</span><br></pre></td></tr></table></figure>
<h4 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/thread-priorities.html">线程优先级</a></h4><p>Thread 类中给出了三个线程优先级常量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Thread.MIN_PRIORITY = 1</span><br><span class="line">java.lang.Thread.NORM_PRIORITY = 5</span><br><span class="line">java.lang.Thread.MAX_PRIORITY = 10</span><br></pre></td></tr></table></figure>
<p>默认情况下线程优先级为 java.lang.Thread.NORM_PRIORITY，我们可以自定义设置在[1..10]内。<br>JVM（Java HotSpot）将 Java 线程关联到唯一的一个 native thread。</p>
<h2 id="网络编程（Socket）"><a href="#网络编程（Socket）" class="headerlink" title="网络编程（Socket）"></a>网络编程（Socket）</h2><h3 id="InetAddress"><a href="#InetAddress" class="headerlink" title="InetAddress"></a>InetAddress</h3><p>IP 地址是在网络层封装上的，确定 Internet 上的一个唯一的地址，端口号是由传输层封装上的，标志主机上的一个服务。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class InetAddressTest &#123;</span><br><span class="line">    public static void main(String args[])&#123;</span><br><span class="line">        InetAddressTest.printAddress();</span><br><span class="line">    &#125;</span><br><span class="line">    static void printAddress()&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            InetAddress address = InetAddress.getLocalHost();</span><br><span class="line">            System.out.println(address);//输出：机器名/IP地址</span><br><span class="line">            address = InetAddress.getByName(&quot;www.baidu.com&quot;);</span><br><span class="line">            System.out.println(address);//输出：域名/IP地址</span><br><span class="line">            InetAddress[] addresses = InetAddress.getAllByName(&quot;www.baidu.com&quot;);</span><br><span class="line">            for(InetAddress a : addresses)&#123;</span><br><span class="line">                System.out.println(a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        catch(UnknownHostException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="URL-和-UrlConnection"><a href="#URL-和-UrlConnection" class="headerlink" title="URL 和 UrlConnection"></a>URL 和 UrlConnection</h3><p>UrlConnection 可以从一个 URL 中打开流，可以方便地进行 Http 数据的收发。<br>内部是使用 Socket 进行连接的。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 获取链接属性</span><br><span class="line">URL url = new URL(&quot;http://java.sun.com:80/docs/books/tutorial/index.html#DOWN&quot;);//#后面的DOWN是位置标识符，在获得网页后，浏览器将直接跳到网页的DOWN处读取</span><br><span class="line">String protocal = url.getProtocol();</span><br><span class="line">String host = url.getHost();</span><br><span class="line">String file = url.getFile();</span><br><span class="line">int port = url.getPort();</span><br><span class="line">String ref = url.getRef();//获得#后面的</span><br><span class="line">System.out.println(protocal + &quot;, &quot; + host + &quot;, &quot; + file + &quot;, &quot;</span><br><span class="line">        + port + &quot;, &quot; + ref);</span><br></pre></td></tr></table></figure>
<p>访问链接</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 访问链接读取数据</span><br><span class="line">URL url = new URL(&quot;http://www.cnblogs.com/mengdd/archive/2013/03/09/2951877.html&quot;);</span><br><span class="line">BufferedReader reader = new BufferedReader(</span><br><span class="line">        new InputStreamReader(url.openStream()));</span><br><span class="line"></span><br><span class="line">String line;</span><br><span class="line">while((line = reader.readLine()) != null)&#123;</span><br><span class="line">    System.out.println(line);</span><br><span class="line">&#125;</span><br><span class="line">reader.close();</span><br></pre></td></tr></table></figure>
<p>下面是对 URLConnection 的测试：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">public class URLTest &#123;</span><br><span class="line">    public static void main(String args[])&#123;</span><br><span class="line">        URLTest c = new URLTest();</span><br><span class="line">        c.createURL();</span><br><span class="line">        c.printURLParam();</span><br><span class="line">        c.readURL();</span><br><span class="line">        c.printURL();</span><br><span class="line">    &#125;</span><br><span class="line">    void createURL()&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            URL url = new URL(&quot;http://localhost:8080/&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        catch(MalformedURLException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void printURLParam()&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            URL url = new URL(&quot;http://java.sun.com:80/docs/books/tutorial/index.html#DOWN&quot;);//#后面的DOWN是位置标识符，在获得网页后，浏览器将直接跳到网页的DOWN处读取</span><br><span class="line">            String protocal = url.getProtocol();</span><br><span class="line">            String host = url.getHost();</span><br><span class="line">            String file = url.getFile();</span><br><span class="line">            int port = url.getPort();</span><br><span class="line">            String ref = url.getRef();//获得#后面的</span><br><span class="line">            System.out.println(protocal + &quot;, &quot; + host + &quot;, &quot; + file + &quot;, &quot;</span><br><span class="line">                    + port + &quot;, &quot; + ref);</span><br><span class="line">        &#125;</span><br><span class="line">        catch(MalformedURLException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void readURL()&#123;//将网页内容拷贝到本地</span><br><span class="line">        try&#123;</span><br><span class="line">            URL url = new URL(&quot;http://www.baidu.com&quot;);</span><br><span class="line">            URLConnection conn = url.openConnection();</span><br><span class="line">            InputStream is = conn.getInputStream();</span><br><span class="line">            //或者直接is = url.openStream();</span><br><span class="line">            OutputStream os = new FileOutputStream(&quot;e:\\baidu.txt&quot;);</span><br><span class="line">            byte[] buffer = new byte[2048];</span><br><span class="line">            int length = 0;</span><br><span class="line">            while((length = is.read(buffer, 0, buffer.length)) != -1)&#123;</span><br><span class="line">                os.write(buffer, 0, length);</span><br><span class="line">            &#125;</span><br><span class="line">            is.close();</span><br><span class="line">            os.close();</span><br><span class="line">        &#125;</span><br><span class="line">        catch(MalformedURLException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        catch(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void printURL()&#123;//读取网页内容到控制台</span><br><span class="line">        try&#123;</span><br><span class="line">            URL url = new URL(&quot;http://www.baidu.com&quot;);</span><br><span class="line">            BufferedReader reader = new BufferedReader(</span><br><span class="line">                    new InputStreamReader(url.openStream()));</span><br><span class="line">            String line;</span><br><span class="line">            while((line = reader.readLine()) != null)&#123;</span><br><span class="line">                System.out.println(line);</span><br><span class="line">            &#125;</span><br><span class="line">            reader.close();</span><br><span class="line">        &#125;</span><br><span class="line">        catch(MalformedURLException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        catch(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TCP-和-UDP"><a href="#TCP-和-UDP" class="headerlink" title="TCP 和 UDP"></a>TCP 和 UDP</h3><p>它们都是位于传输层的协议，为应用进程提供服务，根据不同的应用场景，会使用不同的协议。<br>TCP 是基于连接的、面向流的协议，提供可靠通信，因此每次通信必须先建立连接，建立连接后可以分多次进行传输任务，并且保证数据的正确性。<br>UDP 是基于无连接的、面向数据报的协议，提供不可靠通信，每次通信只需要发送一次数据报，可以分多次发送，但不保证能否到达、到达的顺序。  </p>
<p>Socket 是 TCP 的应用编程接口，DatagramSocket 是 UDP 的应用编程接口，他们之间没有继承关系（都实现 Closeable 接口）。<br>Socket 使用时需要先指定目标主机地址和端口号，然后打开 io 流进行操作<br>1.服务端</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 监听8080端口</span><br><span class="line">ServerSocket server = new ServerSocket(8080);</span><br><span class="line">// 等待请求</span><br><span class="line">Socket socket = server.accept();</span><br><span class="line">// 进行通信</span><br><span class="line">BufferedReader reader = new BufferedReader(</span><br><span class="line">        new InputStreamReader(socket.getInputStream()));</span><br><span class="line">String line = reader.readLine();</span><br><span class="line">System.out.println(line);</span><br><span class="line">PrintWriter writer = new PrintWriter(socket.getOutputStream());</span><br><span class="line">writer.println(line);</span><br><span class="line">writer.flush(); // 不要忘了这个</span><br><span class="line">// 关闭资源</span><br><span class="line">writer.close();</span><br><span class="line">reader.close();</span><br><span class="line">socket.close();</span><br><span class="line">server.close();</span><br></pre></td></tr></table></figure>
<p>2.客户端</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 监听8080端口</span><br><span class="line">Socket socket = new Socket(&quot;127.0.0.1&quot;, 8080);</span><br><span class="line">// 开始通信</span><br><span class="line">PrintWriter writer = new PrintWriter(socket.getOutputStream());</span><br><span class="line">writer.println(&quot;hello&quot;);</span><br><span class="line">writer.flush();</span><br><span class="line">BufferedReader reader = new BufferedReader(</span><br><span class="line">        new InputStreamReader(socket.getInputStream()));</span><br><span class="line">String line = reader.readLine();</span><br><span class="line">System.out.println(line);</span><br><span class="line">// 关闭资源</span><br><span class="line">writer.close();</span><br><span class="line">reader.close();</span><br><span class="line">socket.close();</span><br></pre></td></tr></table></figure>

<h3 id="SocketChannel-和-ServerSocketChannel"><a href="#SocketChannel-和-ServerSocketChannel" class="headerlink" title="SocketChannel 和 ServerSocketChannel"></a>SocketChannel 和 ServerSocketChannel</h3><p>缓冲（Buffer）：相当于货物<br>管道（Channel）：相当于配货车，支持同时装多件货物。<br>选择器（Selector）：是 SelectableChannel 的多路复用器。用于监控 SelectableChannel 的 IO 状况。相当于中转站的分拣员。</p>
<h3 id="使用-DatagramSocket-进行-UDP-通信"><a href="#使用-DatagramSocket-进行-UDP-通信" class="headerlink" title="使用 DatagramSocket 进行 UDP 通信"></a>使用 DatagramSocket 进行 UDP 通信</h3><h4 id="下面的代码使用-DatagramSocket-实现-UDP-通信"><a href="#下面的代码使用-DatagramSocket-实现-UDP-通信" class="headerlink" title="下面的代码使用 DatagramSocket 实现 UDP 通信"></a>下面的代码使用 DatagramSocket 实现 UDP 通信</h4><p>服务端：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 创建服务器socket，指定端口</span><br><span class="line">DatagramSocket socket = new DatagramSocket(7000);</span><br><span class="line">// 接收信息保存到一个缓冲区，DatagramPacket(bytes, len)</span><br><span class="line">byte[] buffer = new byte[1024];</span><br><span class="line">DatagramPacket packet = new DatagramPacket(buffer, 1024);</span><br><span class="line">socket.receive(packet);</span><br><span class="line">System.out.println(new String(buffer, 0, packet.getLength()));</span><br><span class="line">// 响应信息，接收时需要指定地址和端口</span><br><span class="line">String str = &quot;Welcome!&quot;;</span><br><span class="line">DatagramPacket packet1 = new DatagramPacket(str.getBytes(),</span><br><span class="line">        str.length(), packet.getAddress(), packet.getPort());</span><br><span class="line">socket.send(packet1);</span><br><span class="line">// 关闭资源</span><br><span class="line">socket.close();</span><br></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DatagramSocket socket = new DatagramSocket();</span><br><span class="line">// 发送数据包</span><br><span class="line">String str = &quot;Hello World&quot;;</span><br><span class="line">DatagramPacket packet = new DatagramPacket(str.getBytes(),</span><br><span class="line">        str.length(), InetAddress.getByName(&quot;localhost&quot;), 7000);</span><br><span class="line">socket.send(packet);</span><br><span class="line">// 接收响应</span><br><span class="line">byte[] buffer = new byte[1024];</span><br><span class="line">DatagramPacket packet1 = new DatagramPacket(buffer, 100);</span><br><span class="line">socket.receive(packet1);</span><br><span class="line">System.out.println(new String(buffer, 0, packet1.getLength()));</span><br><span class="line">// 关闭资源</span><br><span class="line">socket.close();</span><br></pre></td></tr></table></figure>
<h4 id="下面的代码使用-NIO-实现数据报协议"><a href="#下面的代码使用-NIO-实现数据报协议" class="headerlink" title="下面的代码使用 NIO 实现数据报协议"></a>下面的代码使用 NIO 实现数据报协议</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// 发送</span><br><span class="line">public void send() throws IOException&#123;</span><br><span class="line">    // 打开数据报通道</span><br><span class="line">    DatagramChannel dc = DatagramChannel.open();</span><br><span class="line">    dc.configureBlocking(false);</span><br><span class="line">    ByteBuffer buf = ByteBuffer.allocate(1024);</span><br><span class="line">    Scanner scan = new Scanner(System.in);</span><br><span class="line">    while(scan.hasNext())&#123;</span><br><span class="line">        String str = scan.next();</span><br><span class="line">        buf.put((new Date().toString() + &quot;:\n&quot; + str).getBytes());</span><br><span class="line">        buf.flip();</span><br><span class="line">        dc.send(buf, new InetSocketAddress(&quot;127.0.0.1&quot;, 9898));</span><br><span class="line">        buf.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    dc.close();</span><br><span class="line">&#125;</span><br><span class="line">// 接收</span><br><span class="line">public void receive() throws IOException&#123;</span><br><span class="line">    // 传送数据报通道</span><br><span class="line">    DatagramChannel dc = DatagramChannel.open();</span><br><span class="line">    dc.configureBlocking(false);</span><br><span class="line">    dc.bind(new InetSocketAddress(9898));</span><br><span class="line">    Selector selector = Selector.open();</span><br><span class="line">    dc.register(selector, SelectionKey.OP_READ);</span><br><span class="line">    while(selector.select() &gt; 0)&#123;</span><br><span class="line">        Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();</span><br><span class="line">        while(it.hasNext())&#123;</span><br><span class="line">            SelectionKey sk = it.next();</span><br><span class="line">            if(sk.isReadable())&#123;</span><br><span class="line">                ByteBuffer buf = ByteBuffer.allocate(1024);</span><br><span class="line">                dc.receive(buf);</span><br><span class="line">                buf.flip();</span><br><span class="line">                System.out.println(new String(buf.array(), 0, buf.limit()));</span><br><span class="line">                buf.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        it.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用-NIO-实现简易-HttpServer"><a href="#使用-NIO-实现简易-HttpServer" class="headerlink" title="使用 NIO 实现简易 HttpServer"></a>使用 NIO 实现简易 HttpServer</h3><p>主要思路很简单：<br>(1) 服务器打开后首先为 Selector 注册一个 OP_ACCEPT 的 key，这样 select 时就能接收客户端请求了；<br>(2) 每接收一个请求后即为该 key 创建一个线程，处理该 key 的操作，操作包括 accept 和 read，对于前者，只需为该 key 的 selector 再注册一个 OP_READ 用于准备接下来的读请求；<br>(3) 读取时先读入一个 Buffer，首先解析请求头部分，直到遇到一个空行结束，因为这里只考虑 GET 请求，所以不必继续解析请求体了；<br>(4) 返回时，首先构建响应头，同样使用一个空行结束，然后构建响应体，写回客户端，结束。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">public class HttpServer &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        // 监听8080端口</span><br><span class="line">        ServerSocketChannel server = ServerSocketChannel.open();</span><br><span class="line">        server.socket().bind(new InetSocketAddress(8080));</span><br><span class="line">        // 设置为非阻塞模式</span><br><span class="line">        server.configureBlocking(false);</span><br><span class="line">        // 为server注册选择器</span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        server.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        // 创建处理器</span><br><span class="line">        while(true) &#123;</span><br><span class="line">            // 等待请求，每次阻塞3s，若超过3s线程继续运行，</span><br><span class="line">            // select(0)或select()表示一直阻塞</span><br><span class="line">            if(selector.select(3000) == 0) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            // 获取所有待处理的选择键</span><br><span class="line">            Iterator&lt;SelectionKey&gt; keyIter = selector.selectedKeys().iterator();</span><br><span class="line">            while(keyIter.hasNext()) &#123;</span><br><span class="line">                SelectionKey key = keyIter.next();</span><br><span class="line">                // 启动新线程以处理SelectionKey</span><br><span class="line">                new Thread(new HttpHandler(key)).run();</span><br><span class="line">                // 处理完毕后，移除当前key</span><br><span class="line">                keyIter.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class HttpHandler implements Runnable &#123;</span><br><span class="line">        private int bufferSize = 1024;</span><br><span class="line">        private String localCharset = &quot;UTF-8&quot;;</span><br><span class="line">        private SelectionKey key;</span><br><span class="line"></span><br><span class="line">        public HttpHandler(SelectionKey key) &#123;</span><br><span class="line">            this.key = key;</span><br><span class="line">        &#125;</span><br><span class="line">        // 定义操作</span><br><span class="line">        private void handleAccept() throws IOException &#123;</span><br><span class="line">            // 接受请求后，注册OP_READ选择键以等待下一次请求</span><br><span class="line">            SocketChannel clientChannel = ((ServerSocketChannel)key.channel()).accept();</span><br><span class="line">            clientChannel.configureBlocking(false);</span><br><span class="line">            // !!!请求报文被限制在1024个字节内</span><br><span class="line">            clientChannel.register(key.selector(),</span><br><span class="line">                    SelectionKey.OP_READ, ByteBuffer.allocate(bufferSize));</span><br><span class="line">        &#125;</span><br><span class="line">        private void handleRead() throws IOException &#123;</span><br><span class="line">            // 获取</span><br><span class="line">            SocketChannel sc = (SocketChannel) key.channel();</span><br><span class="line">            // 获取Buffer并重置</span><br><span class="line">            ByteBuffer buffer = (ByteBuffer) key.attachment();</span><br><span class="line">            buffer.clear();</span><br><span class="line">            // 读取，并判断内容是否为空，若是则关闭并退出</span><br><span class="line">            if(sc.read(buffer) == -1) &#123;</span><br><span class="line">               sc.close();</span><br><span class="line">               return;</span><br><span class="line">            &#125;</span><br><span class="line">            // 接收请求数据</span><br><span class="line">            buffer.flip();</span><br><span class="line">            String receivedString = Charset.forName(localCharset).newDecoder().</span><br><span class="line">                    decode(buffer).toString();</span><br><span class="line"></span><br><span class="line">            // 打印请求报文头</span><br><span class="line">            String[] requestMessage = receivedString.split(&quot;\r\n&quot;);</span><br><span class="line">            for(String s: requestMessage) &#123;</span><br><span class="line">                System.out.println(s);</span><br><span class="line">                // 遇到空行说明报文头已经打印完</span><br><span class="line">                if(s.isEmpty()) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 控制台打印首行信息</span><br><span class="line">            String[] firstLine = requestMessage[0].split(&quot; &quot;);</span><br><span class="line">            System.out.println();</span><br><span class="line">            System.out.println(&quot;Method:\t&quot; + firstLine[0]);</span><br><span class="line">            System.out.println(&quot;url:\t&quot; + firstLine[1]);</span><br><span class="line">            System.out.println(&quot;HTTP Version:\t&quot; + firstLine[2]);</span><br><span class="line">            System.out.println();</span><br><span class="line">            // 返回客户端（!!!考虑对不同的Url和不同的请求方法进行不同的处理和响应）</span><br><span class="line">            StringBuilder sendString = new StringBuilder();</span><br><span class="line">            sendString.append(&quot;HTTP/1.1 200 OK\r\n&quot;); // 响应报文首行</span><br><span class="line">            sendString.append(&quot;Content-Type:text/html;charset=&quot; + // !!!如果要传输流数据必须修改Content-Type</span><br><span class="line">                    localCharset + &quot;\r\n&quot;);</span><br><span class="line">            sendString.append(&quot;\r\n&quot;); // 报文结束后加一空行</span><br><span class="line">            // 响应体</span><br><span class="line">            sendString.append(&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;显示报文&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&quot;);</span><br><span class="line">            sendString.append(&quot;接收到请求报文是: &lt;br/&gt;&quot;);</span><br><span class="line">            for(String s: requestMessage) &#123;</span><br><span class="line">                sendString.append(s + &quot;&lt;br/&gt;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            sendString.append(&quot;&lt;/body&gt;&lt;/html&gt;&quot;);</span><br><span class="line">            // 使用缓冲区写入channel</span><br><span class="line">            buffer = ByteBuffer.wrap(sendString.toString().getBytes(localCharset));</span><br><span class="line">            sc.write(buffer);</span><br><span class="line">            // 关闭资源</span><br><span class="line">            sc.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                // 根据请求类型进行转发</span><br><span class="line">                if(key.isAcceptable()) &#123;</span><br><span class="line">                    handleAccept();</span><br><span class="line">                &#125;</span><br><span class="line">                if(key.isReadable()) &#123;</span><br><span class="line">                    handleRead();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用-NIO-Selector-实现简易聊天室"><a href="#使用-NIO-Selector-实现简易聊天室" class="headerlink" title="使用 NIO-Selector 实现简易聊天室"></a>使用 NIO-Selector 实现简易聊天室</h3><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p>声明数据结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 管道、选择器、字符集</span><br><span class="line">private SocketChannel sc = null;</span><br><span class="line">private Selector selector = null;</span><br><span class="line">private Charset charset = Charset.forName(&quot;UTF-8&quot;);</span><br></pre></td></tr></table></figure>
<p>创建线程类用于从服务端获取数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private class ClientThread extends Thread &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 遍历所有选择键</span><br><span class="line">            while(selector.select() &gt; 0) &#123;</span><br><span class="line">                for(SelectionKey sk : selector.selectedKeys()) &#123;</span><br><span class="line">                    // 删除正在处理的</span><br><span class="line">                    selector.selectedKeys().remove(sk);</span><br><span class="line">                    // 如果该键对应的通道中有可读的数据</span><br><span class="line">                    if(sk.isReadable()) &#123;</span><br><span class="line">                        // 使用缓冲区读取管道内的数据</span><br><span class="line">                        SocketChannel sc = (SocketChannel) sk.channel();</span><br><span class="line">                        ByteBuffer buff = ByteBuffer.allocate(1024);</span><br><span class="line">                        String content = &quot;&quot;;</span><br><span class="line">                        while(sc.read(buff) &gt; 0) &#123;</span><br><span class="line">                            buff.flip();</span><br><span class="line">                            content += charset.decode(buff);</span><br><span class="line">                        &#125;</span><br><span class="line">                        // 打印</span><br><span class="line">                        System.out.println(&quot;聊天信息&quot; + content);</span><br><span class="line">                        sk.interestOps(SelectionKey.OP_READ);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch(IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 初始化SocketChannel</span><br><span class="line">InetSocketAddress isa = new InetSocketAddress(&quot;127.0.0.1&quot;, 9999);</span><br><span class="line">sc = SocketChannel.open(isa);</span><br><span class="line">sc.configureBlocking(false);</span><br><span class="line">// 注册选择器</span><br><span class="line">selector = Selector.open();</span><br><span class="line">sc.register(selector, SelectionKey.OP_READ);</span><br></pre></td></tr></table></figure>
<p>创建线程从服务端拉取数据，及不断从键盘读入发送到服务端</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 启动线程不断从服务端拉取</span><br><span class="line">new ClientThread().start();</span><br><span class="line">// 读取键盘输入到通道</span><br><span class="line">Scanner reader = new Scanner(System.in);</span><br><span class="line">while(reader.hasNextLine()) &#123;</span><br><span class="line">    String line = reader.nextLine();</span><br><span class="line">    sc.write(charset.encode(line));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><p>声明</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 选择器、字符集</span><br><span class="line">private Selector selector = null;</span><br><span class="line">private Charset charset = Charset.forName(&quot;UTF-8&quot;);</span><br></pre></td></tr></table></figure>
<p>初始化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 打开管道</span><br><span class="line">ServerSocketChannel server = ServerSocketChannel.open();</span><br><span class="line">InetSocketAddress isa = new InetSocketAddress(&quot;127.0.0.1&quot;, 9999);</span><br><span class="line">server.socket().bind(isa);</span><br><span class="line">server.configureBlocking(false);</span><br><span class="line">// 打开选择器</span><br><span class="line">selector = Selector.open();</span><br><span class="line">server.register(selector, SelectionKey.OP_ACCEPT);</span><br></pre></td></tr></table></figure>
<p>接受连接，读取及发送数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">// 依次处理选择器上的选择键</span><br><span class="line">while(selector.select() &gt; 0) &#123;</span><br><span class="line">    for(SelectionKey sk : selector.selectedKeys()) &#123;</span><br><span class="line">        selector.selectedKeys().remove(sk);</span><br><span class="line">        // 连接请求</span><br><span class="line">        if(sk.isAcceptable()) &#123;</span><br><span class="line">            SocketChannel sc = server.accept();</span><br><span class="line">            sc.configureBlocking(false);</span><br><span class="line">            sc.register(selector, SelectionKey.OP_READ);</span><br><span class="line">            sk.interestOps(SelectionKey.OP_ACCEPT);</span><br><span class="line">        &#125;</span><br><span class="line">        // 存在可读取数据</span><br><span class="line">        if(sk.isReadable()) &#123;</span><br><span class="line">            // 使用缓冲区读取</span><br><span class="line">            SocketChannel sc = (SocketChannel) sk.channel();</span><br><span class="line">            ByteBuffer buff = ByteBuffer.allocate(1024);</span><br><span class="line">            String content = &quot;&quot;;</span><br><span class="line">            try &#123;</span><br><span class="line">                while(sc.read(buff) &gt; 0) &#123;</span><br><span class="line">                    buff.flip();</span><br><span class="line">                    content += charset.decode(buff);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;=======&quot; + content);</span><br><span class="line">                // 将管道设置为准备下一次读取</span><br><span class="line">                sk.interestOps(SelectionKey.OP_READ);</span><br><span class="line">            &#125; catch(IOException e) &#123;</span><br><span class="line">                // 如果该sk对应的管道出现异常，表明管道的客户端出现异常，</span><br><span class="line">                // 所以从选择器中取消sk</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                sk.cancel();</span><br><span class="line">                if(sk.channel() != null) &#123;</span><br><span class="line">                    sk.channel().close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 说明聊天信息不为空</span><br><span class="line">            if(content.length() &gt; 0) &#123;</span><br><span class="line">                // 将聊天信息输入每个选择键对应的管道中</span><br><span class="line">                for(SelectionKey key : selector.keys()) &#123;</span><br><span class="line">                    Channel targetChannel = key.channel();</span><br><span class="line">                    if(targetChannel instanceof SocketChannel) &#123;</span><br><span class="line">                        SocketChannel dest = (SocketChannel) targetChannel;</span><br><span class="line">                        dest.write(charset.encode(content));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h3><ol>
<li>为什么 Socket 可以通过流来“持续地”读写，而 DatagramSocket 却只能一个一个数据报发哩？<br>这是由 TCP 和 UDP 的协议决定的，TCP 是面向流的协议，而 UDP 是面向数据报的协议。  </li>
<li>可以用 TCP 客户端连接 UDP 服务器吗（或者反过来）？<br>不能，实验过确实不行，但是我还是心存疑惑，我猜测是因为接收方可以判断数据包的协议类型来确定是否接收。  </li>
<li>socket 是怎么实现”全双工”的？</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a target="_blank" rel="noopener" href="https://www.programcreek.com/java-api-examples/index.php">Java Code Examples</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/x5fnncxzq4/article/details/83110446">Java 应用中的日志</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/pin/5cc56f7b6fb9a02f00fc869e">错误处理的推荐实践</a></li>
<li><a target="_blank" rel="noopener" href="http://tech.it168.com/a2013/0829/1527/000001527360.shtml">Java 开发中 10 个最为微妙的最佳编程实践</a></li>
<li>《Effective Java》</li>
<li><a target="_blank" rel="noopener" href="https://edu.aliyun.com/course/417?spm=5176.10731542.0.0.akyXwK">阿里巴巴编码规范（Java）</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/xx326664162/article/details/52175283">Java 泛型中的 PECS 原则</a></li>
</ol>
<h3 id="JNI"><a href="#JNI" class="headerlink" title="JNI"></a>JNI</h3><ol>
<li><a target="_blank" rel="noopener" href="http://tldp.org/HOWTO/Program-Library-HOWTO/index.html">Program Library HOWTO (how to create and use program libraries on Linux)</a></li>
<li><a target="_blank" rel="noopener" href="https://devarea.com/java-and-cc-jni-guide/">Java and C&#x2F;C++: JNI Guide</a></li>
</ol>
<h3 id="Java5-1"><a href="#Java5-1" class="headerlink" title="Java5"></a>Java5</h3><ol>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000004417288">Java5 的新特性</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/1.5.0/docs/relnotes/features.html">New Features and Enhancements J2SE 5.0</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xll1025/p/6489088.html">java 泛型（二）、泛型的内部原理：类型擦除以及类型擦除带来的问题</a></li>
</ol>
<h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><ol>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/wangpeng047/article/details/19624529">HttpClient 使用详解</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/xietansheng/article/details/51673073">基于 JavaMail 的 Java 邮件发送：简单邮件发送</a></li>
<li><a target="_blank" rel="noopener" href="http://kf.qq.com/faq/120322fu63YV130422nqIrqu.html">qq 邮箱服务器地址</a></li>
</ol>
<h3 id="工程"><a href="#工程" class="headerlink" title="工程"></a>工程</h3><ol>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/9c65b7613c30">IntelliJ IDEA 使用教程(2019 图文版) – 从入门到上瘾</a></li>
</ol>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/8ada3a78.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tallate">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tallate">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/8ada3a78.html" class="post-title-link" itemprop="url">JMM 应用总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-05-02 17:22:14" itemprop="dateCreated datePublished" datetime="2019-05-02T17:22:14+08:00">2019-05-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-07 01:56:20" itemprop="dateModified" datetime="2025-07-07T01:56:20+08:00">2025-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>公司内接手的老项目近段时间遇到了内存瓶颈，新发版 GC 日志刷个不停，且集中在 YGC，显然有不自然的内存分配，看来内存优化是绕不过了。<br>在 Java 技术栈内，对内存的分析优化主要集中在堆中，往往需要先使用一些内存分析工具导出堆的一份快照，然后查看是哪些对象在浪费空间，它们可能是非常大的、非常短命的。<br>除了 JMM，对宿主机的内存管理原理也是有必要掌握的，这样能从底层的角度来进行解释 JMM 的原理，在针对 JMM 进行调参的时候也能更有把握（和运维撕的时候也更不容易被忽悠），鉴于现在的生产环境绝大多数都是 Linux，因此我也会对 Linux 的虚拟内存管理机制作一个简单分析。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/8ada3a78.html#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/cac7b0a4.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tallate">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tallate">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/cac7b0a4.html" class="post-title-link" itemprop="url">多级缓存原理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-04-10 23:13:20" itemprop="dateCreated datePublished" datetime="2019-04-10T23:13:20+08:00">2019-04-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-07 01:56:20" itemprop="dateModified" datetime="2025-07-07T01:56:20+08:00">2025-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p> </p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/cac7b0a4.html#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/5ac9459.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tallate">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tallate">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/5ac9459.html" class="post-title-link" itemprop="url">多级缓存原理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-04-10 23:13:20" itemprop="dateCreated datePublished" datetime="2019-04-10T23:13:20+08:00">2019-04-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-07 01:56:20" itemprop="dateModified" datetime="2025-07-07T01:56:20+08:00">2025-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%93%E5%AD%98/" itemprop="url" rel="index"><span itemprop="name">缓存</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>

<h2 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h2><h3 id="由线上缓存-bug-引起的对本地缓存的思考"><a href="#由线上缓存-bug-引起的对本地缓存的思考" class="headerlink" title="由线上缓存 bug 引起的对本地缓存的思考"></a>由线上缓存 bug 引起的对本地缓存的思考</h3><p>LoadingCache 是 Guava 提供的一个本地缓存组件，但是我对它是又爱又恨，一方面因为 LoadingCache 比较完善，免去很多应用层缓存的细节问题（如何写出 GC 友好的缓存？），而另一方面如果对 LoadingCache 了解不够深入又容易出现奇奇怪怪的问题。下面就来描述一下之前碰到过的两个 LoadingCache 的坑，首先给出最简单的缓存配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LoadingCache&lt;String, Object&gt; cache = CacheBuilder.newBuilder()</span><br><span class="line">        .expireAfterAccess(60 * 1000, MILLISECONDS) // 1</span><br><span class="line">        .maximumSize(500)</span><br><span class="line">        .build(new CacheLoader&lt;String, Object&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Object load(String id) throws Exception &#123;</span><br><span class="line">                return query(id); // 2</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<ol>
<li>在构建 LoadingCache 的时候可以配置缓存的过期策略，LoadingCache 其实有三种常用的过期策略：<ul>
<li>expireAfterAccess：在最后一次访问后空闲一段时间才过期；</li>
<li>expireAfterWrite：在最后一次写后空闲一段时间才过期；</li>
<li>refreshAfterWrite：同样是写后空闲一段时间过期，和上一个的区别是不会阻塞过期时到达的请求，因为刷新一般需要请求远程服务来获取数据，会有比较长的延迟，refreshAfterWrite 会先返回旧数据，而 expireAfterWrite 会先阻塞这些请求。<br>如果是为了吞吐量起见，一般使用 refreshAfterWrite 更多，如果是为了保证同步性，则是使用 expireAfterWrite 更多。<br>因为我们使用缓存的场景是“读多写少的场景”，读端是提供给用户的，而写端由甲方客户控制，当它们更新了某个 id 的数据后，希望能够马上展示到用户眼前，换句话说，缓存应当能够被马上刷新，但是前面的配置中使用的是 expireAfterAccess，因为用户的访问非常频繁，所以缓存一直不能过期，上线的数据不能及时地生效，导致甲方爸爸非常生气。</li>
</ul>
</li>
<li>缓存更新的时候一般会从远程服务或数据库查询数据，这里没有考虑返回值为空的情况，为了保险起见，一般都是需要进行空值校验的，而且如果这里返回了空值，LoadingCache 会直接抛出异常。</li>
</ol>
<p>所以更合理的配置方式应该是下面这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LoadingCache&lt;String, Object&gt; cache = CacheBuilder.newBuilder()</span><br><span class="line">        .refreshAfterWrite(60 * 1000, MILLISECONDS) // 1</span><br><span class="line">        .maximumSize(500)</span><br><span class="line">        .build(new CacheLoader&lt;String, Object&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Object load(String id) throws Exception &#123;</span><br><span class="line">                Object res = query(id); // 2</span><br><span class="line">                return res == null ? DEFAULT_OBJ : res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<p>所以，当我们在使用缓存时，一般是事先考虑：</p>
<ul>
<li>dataSource：当没有命中时，从哪里获取数据？一般请求下会调用其他服务的远程接口，也可以直接从数据库、缓存中间件查询，但是要注意数据隔离性，比如权限服务就不适合直接到缓存或数据库中查询订单数据，因为这样不利于后期扩容，而且入口越多越不安全；</li>
<li>expire：定义淘汰策略，比如有一段时间没有访问就淘汰，比如容量限制，当超出容量的时候如何淘汰一般有 LRU（Least Recently Used）、LFU（Least Frequently Used），可以使用 weigher 设置每个 key 的权重；</li>
</ul>
<p>如果是一些要求不高的内部信息管理系统，这些属性不需要太关注，但是如果是对并发量有一定要求的系统，对自己所使用的工具知根知底是最低的要求。</p>
<h3 id="本地缓存是什么"><a href="#本地缓存是什么" class="headerlink" title="本地缓存是什么"></a>本地缓存是什么</h3><p>本地缓存的英文是 Local Cache，Cache、Buffer、Pool 是经常出现但又容易混淆的一组概念，它们都能存取数据，但是有本质上的区别：</p>
<ul>
<li>Cache 的主要功能是“将东西放到更容易拿到的地方”、从而加快速度，具有随机存取的功能，一般为了不导致内存溢出会设置数据的过期回收策略，比如计算机体系结构中的 L1、L2、L3 缓存；</li>
<li>Buffer 是为了缓冲、减少对脆弱系统的冲击，具有顺序访问的特点，比如每个 TCP Socket 都有的接收发送缓存区；</li>
<li>Pool 是为了缓存资源，它和 Cache 的主要区别是 Pool 中缓存的对象往往是同构而没有特殊价值的数据，比如连接池中存储的数据库连接，所以 Pool 不需要随机存取功能、随取随用即可。</li>
</ul>
<h3 id="本地缓存的优点"><a href="#本地缓存的优点" class="headerlink" title="本地缓存的优点"></a>本地缓存的优点</h3><ul>
<li>节省了了内⽹带宽。</li>
<li>响应时延会更低。</li>
</ul>
<h3 id="本地缓存的缺点"><a href="#本地缓存的缺点" class="headerlink" title="本地缓存的缺点"></a>本地缓存的缺点</h3><p>⽆法保证⼀致性，解决办法是：</p>
<ol>
<li>单节点通知其他节点，但是会导致同⼀服务的多个节点相互耦合；</li>
<li>利用 mq 通知其他节点，但系统会变得更复杂；</li>
<li>使用 timer 定时从后端拉取更新内存缓存，但在更新数据后、访问其他节点会得到脏数据，直到其他节点 timer 拉取数据。</li>
</ol>
<h3 id="本地缓存如何保证一致性"><a href="#本地缓存如何保证一致性" class="headerlink" title="本地缓存如何保证一致性"></a>本地缓存如何保证一致性</h3><p>现在基本没有对外应用会是单机部署的，本地缓存是将数据保存到实例本身的内存中，所以一致性问题就是：我们怎么保证同一时间从每台实例上获取到的数据都是相同的？</p>
<ul>
<li>集群广播：当数据源变更时，发消息通知所有实例<br>优点：实现一致性<br>缺点：不适合更新特别频繁的场景，可能产生消息堆积。</li>
<li>定时拉取：每台实例定时从数据源拉取数据更新本地缓存<br>优点：实现简单，使用Guava就可以实现；<br>缺点：无法控制每台实例同时去拉取，可能有的拉到了，有的还没有到定时拉取的时间。</li>
<li>zk同步：将机器注册到zk，所有机器都注册一个watcher，当有数据变更时通知所有实例。<br>优点：类似消息同步的方式实现一致性。<br>缺点：引入zk提升复杂度，zk并不保证高可用（CP）。</li>
</ul>
<h3 id="什么时候需要本地缓存"><a href="#什么时候需要本地缓存" class="headerlink" title="什么时候需要本地缓存"></a>什么时候需要本地缓存</h3><p>分层架构设计，有⼀条准则：站点层、服务层要做到<strong>⽆数据</strong>、<strong>⽆状态</strong>，这样才能任意的加节点⽔平扩展，数据和状态尽量存储到后端的数据存储服务，例如数据库服务或者缓存服务。<br>可以看到，站点与服务的进程内缓存，实际上违背了分层架构设计的⽆状态准则，故<strong>一般情况下并不推荐使用</strong>。<br>在分布式缓存存在的情况下，一般本地缓存都是不必要的，一方面本地缓存会占用大量的堆空间，容易引起频繁的 GC；另一方面，因为是在局域网内，所以访问分布式缓存的网络开销不会太大。</p>
<p>那么，什么时候可以使⽤进程内缓存？以下情况，可以考虑使用进程内缓存，并且应该注意对过期策略、并发安全等的定义。</p>
<ol>
<li>只读数据，可以考虑在进程启动时加载到内存。<blockquote>
<p>当然此时也可以把数据加载到 redis &#x2F; memcache 等缓存中间件，进程外缓存同样能解决这个问题。</p>
</blockquote>
</li>
<li>性能敏感、极其⾼并发的、如果透传对后端压力极大的场景，可以考虑使用进程内缓存。例如，首页列表、秒杀业务，并发量极高，需要站点层挡住流量，可以使⽤内存缓存。</li>
<li>一定程度上允许数据不一致的业务。<br>例如，有一些计数场景，运营场景，⻚面对数据⼀致性要求较低，可以考虑使⽤进程内⻚面缓存。</li>
</ol>
<h3 id="避免过早优化"><a href="#避免过早优化" class="headerlink" title="避免过早优化"></a>避免过早优化</h3><p>后端开发基本都是完美主义者（粗心导致留下 Bug 可是会被产品、测试鄙视的），但是完美主义也有一个缺点——容易过早优化。<br>比如，项目早期使用者不多、订单只有 10W～100W 的量级，但是开发刚上来在对行业知识、产品使用场景都没有深刻理解的情况下，直接决定对 id 散列来进行分表，这个对我们来说当然是无可厚非的，但是随着业务扩大、订单量增加到 100W～1000W，发现线上数据库中近期的订单被使用得更多（即热数据）、而老订单一般不被问津，所以原来那种新老混杂的分表就不合适了，但是现在再重构成按时间分表的方式就费事了。因此，更好的方式是刚开始仅用单表存就足够了，之后时刻关注线上使用的反馈，即时地进行优化。</p>
<h3 id="Java-引用"><a href="#Java-引用" class="headerlink" title="Java 引用"></a>Java 引用</h3><p>Java 中除了基本类型外所有对象都是通过引用来使用的，引用分为强引用、软引用、弱引用和虚引用。<br>对于一般的缓存场景来说，软引用是更好的选择，因为软引用可以避免内存用完而 GC 又回收不了内存进而导致的服务宕机，又不会像弱引用那样每次 GC 都会被回收掉、连带导致缓存被击穿。</p>
<h3 id="应用-失败次数统计"><a href="#应用-失败次数统计" class="headerlink" title="应用 - 失败次数统计"></a>应用 - 失败次数统计</h3><p>一般调用 RPC 接口都会有重试逻辑，最简单的重试可以用一个局部变量记录失败次数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int failedCount = 0;</span><br><span class="line">while(failedCount &lt; 3) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        rpcService.hello();</span><br><span class="line">        break;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        logger.warn(&quot;调用失败 &quot; + failedCount + &quot; 次&quot;, e);</span><br><span class="line">        failedCount++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不是需要实时响应的功能，可以用一个队列缓存请求，然后用一个线程轮询，因为失败后需要重新丢进队列中等待，这时就不能单纯使用局部变量来保存失败次数了，可以使用一个 Cache&lt;string, AtomicInteger&gt;<strong>软引用</strong>缓存失败调用记录，成功后再使其失效。这种方式能控制失败重试次数，而且当内存不足时，缓存数据可以被 GC 回收以腾出一些空间。<br>以 Guava 中的 LoadingCache 为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private LoadingCache&lt;String, AtomicInteger&gt; failedCache = </span><br><span class="line">    CacheBuilder.newBuilder()</span><br><span class="line">        .softValues()</span><br><span class="line">        .maximumSize(10000)</span><br><span class="line">        .build(new CacheLoader&lt;String, AtomicInteger&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public AtomicInteger load(String id) throws Exception &#123;</span><br><span class="line">                return new AtomicInteger(0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>当失败时，调用 failedCache.getUnchecked(id).incrementAndGet()增加失败次数。</li>
<li>当成功时，调用 failedCache.invalidate(id)使缓存失效。</li>
</ul>
<h3 id="GC-友好的缓存"><a href="#GC-友好的缓存" class="headerlink" title="GC 友好的缓存"></a>GC 友好的缓存</h3><p>diff（在不等的情况下才 put 或直接修改已有对象，提高内存利用率，不然每次刷新缓存都要放到年轻代。不能用分离链接法实现，因为老的会引用年轻的(每次 put 到头部不就可以了？)，导致年轻代不能转移到老年代）</p>
<p>如何避免 OOM（弱引用）</p>
<p>缓存淘汰机制<br>过期策略</p>
<h3 id="如何实现一个本地缓存-ConcurrentHashMap"><a href="#如何实现一个本地缓存-ConcurrentHashMap" class="headerlink" title="如何实现一个本地缓存 - ConcurrentHashMap"></a>如何实现一个本地缓存 - ConcurrentHashMap</h3><ol>
<li>线程安全的 Map</li>
<li>回收机制<br>如 LRU</li>
<li>软引用</li>
</ol>
<h2 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h2><h3 id="本地缓存和分布式缓存"><a href="#本地缓存和分布式缓存" class="headerlink" title="本地缓存和分布式缓存"></a>本地缓存和分布式缓存</h3><p>缓存一般分为本地缓存和分布式缓存两种。本地缓存指的是将数据存储在本机内存中，操作缓存数据的速度很快，但是缺点也很明显：第一，缓存数据的数量与大小受限于本地内存；第二，如果有多台应用服务器，可能所有应用服务器都要维护一份缓存，这样就占用了很多的内存。<br>分布式缓存正好解决了这两个问题。首先，数据存储在了另外的机器上，理论上由于可以不断添加缓存机器，所以缓存的数据的数量是无限的；其次，缓存集中设置在远程的缓存服务器上，应用服务器不需要耗费空间来维护缓存。但是，分布式缓存也是有缺点的，比如由于是远程操作，所以操作缓存数据的速度相较于本地缓存慢很多。<br>当前用得最多的本地缓存是 GoogleGuavache，用得最多的分布式缓存是 Memcached 和 Redis</p>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>概念及场景：缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。在流量大时，可能 DB 就挂掉了，要是有人利用不存在的 key 频繁攻击我们的应用，这就是漏洞。<br>解决方案：有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用<strong>布隆过滤器</strong>，将所有可能存在的数据哈希到一个足够大的<strong>bitmap</strong>中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力。另外也有一个更为简单粗暴的方法，如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。<br>总而言之，当通过一个 key 去数据库查询出来的数据结果为 null,缓存系统就不会缓存该数据,每次该 key 查询都会经过数据库层,造成没有必要的 DB 开销。这种情况下，我们可以将该 key 缓存至缓存系统中,value 为一个特殊值(^^,&amp;&amp;…)。</p>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><h4 id="概念及场景"><a href="#概念及场景" class="headerlink" title="概念及场景"></a>概念及场景</h4><p>缓存雪崩是指在我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到 DB，DB 瞬时压力过重雪崩。<br>key 缓存过期失效而新缓存未到期间,该 key 的查询所有请求都会去查询数据，造成 DB 压力上升，产生不必要的 DB 开销 </p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>缓存失效时的雪崩效应对底层系统的冲击非常可怕。大多数系统设计者考虑用加锁或者队列的方式保证缓存的单线程（进程）写，从而避免失效时大量的并发请求落到底层存储系统上。这里分享一个简单方案就是将缓存失效时间分散开，比如我们可以在原有的失效时间基础上增加一个随机值，比如 1-5 分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。<br>解决方案总结：</p>
<ol>
<li>加锁排队重建,使请求可以串行化,而不用全部的请求都去查询数据库</li>
<li>假设 key 的过期时间是 A,创建一个 key_sign,它的过期时间比 A 小,查询 key 的时候检查 key_sign 是否已经过期,如果过期则加锁后台起一个线程异步去更新 key 的值,而实际的缓存没有过期(如果实际缓存已经过期,需要加锁排队重建),但是会浪费双份缓存</li>
<li>在原有的 value 中存一个过期值 B,B 比 A 小,取值的时候根据 B 判断 value 是否过期,如果过期,解决方案同上</li>
<li>牺牲用户体验,当发现缓存中没有对应的数据直接返回失败,并且把需要的数据放入一个分布式队列,后台通过异步线程更新队列中需要更新的缓存</li>
</ol>
<h3 id="缓存污染"><a href="#缓存污染" class="headerlink" title="缓存污染"></a>缓存污染</h3><h4 id="概念和场景"><a href="#概念和场景" class="headerlink" title="概念和场景"></a>概念和场景</h4><p>一些非正常操作（比如导出 excel 文件、运营偶发性访问）而导致内存中出现很多冷数据 </p>
<h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><p>选取合适的缓存算法(LUR-N 算法)。</p>
<h3 id="缓存首次上线"><a href="#缓存首次上线" class="headerlink" title="缓存首次上线"></a>缓存首次上线</h3><h4 id="概念及场景-1"><a href="#概念及场景-1" class="headerlink" title="概念及场景"></a>概念及场景</h4><p>缓存首次上线,如果网站的访问量很大,所有的请求都经过数据库(如果访问量比较少,可以由用户访问自行缓存) </p>
<h4 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h4><p>缓存预热,在系统上线之前,所有的缓存都预先加载完毕(增加一个刷新缓存程序,上线后手动刷新或发布时自动调用刷用)</p>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>概念及场景：对于一些设置了过期时间的 key，如果这些 key 可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题，这个和缓存雪崩的区别在于这里针对某一 key 缓存，前者则是很多 key。缓存在某个时间点过期的时候，恰好在这个时间点对这个 Key 有大量的并发请求过来，这些请求发现缓存过期一般都会从后端 DB 加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端 DB 压垮。</p>
<h4 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h4><p>1.使用互斥锁(mutex key)<br>业界比较常用的做法，是使用 mutex。简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去 load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如 Redis 的 SETNX 或者 Memcache 的 ADD）去 set 一个 mutex key，当操作返回成功时，再进行 load db 的操作并回设缓存；否则，就重试整个 get 缓存的方法。<br>SETNX，是「SET if Not eXists」的缩写，也就是只有不存在的时候才设置，可以利用它来实现锁的效果。在 redis2.6.1 之前版本未实现 setnx 的过期时间，所以这里给出两种版本代码参考：<br>&#x2F;&#x2F;2.6.1 前单机版本锁<br>String get(String key) {<br>   String value &#x3D; redis.get(key);<br>   if (value &#x3D;&#x3D; null) {<br>    if (redis.setnx(key_mutex, “1”)) {<br>        &#x2F;&#x2F; 3 min timeout to avoid mutex holder crash<br>        redis.expire(key_mutex, 3 * 60)<br>        value &#x3D; db.get(key);<br>        redis.set(key, value);<br>        redis.delete(key_mutex);<br>    } else {<br>        &#x2F;&#x2F;其他线程休息 50 毫秒后重试<br>        Thread.sleep(50);<br>        get(key);<br>    }<br>  }<br>}<br>最新版本代码：<br>public String get(key) {<br>      String value &#x3D; redis.get(key);<br>      if (value &#x3D;&#x3D; null) { &#x2F;&#x2F;代表缓存值过期<br>          &#x2F;&#x2F;设置 3min 的超时，防止 del 操作失败的时候，下次缓存过期一直不能 load db<br>          if (redis.setnx(key_mutex, 1, 3 * 60) &#x3D;&#x3D; 1) { &#x2F;&#x2F;代表设置成功<br>               value &#x3D; db.get(key);<br>                      redis.set(key, value, expire_secs);<br>                      redis.del(key_mutex);<br>              } else { &#x2F;&#x2F;这个时候代表同时候的其他线程已经 load db 并回设到缓存了，这时候重试获取缓存值即可<br>                      sleep(50);<br>                      get(key); &#x2F;&#x2F;重试<br>              }<br>          } else {<br>              return value;<br>          }<br> }<br>memcache 代码：<br>if (memcache.get(key) &#x3D;&#x3D; null) {<br>    &#x2F;&#x2F; 3 min timeout to avoid mutex holder crash<br>    if (memcache.add(key_mutex, 3 * 60 * 1000) &#x3D;&#x3D; true) {<br>        value &#x3D; db.get(key);<br>        memcache.set(key, value);<br>        memcache.delete(key_mutex);<br>    } else {<br>        sleep(50);<br>        retry();<br>    }<br>}</p>
<p>除了使用Redis加锁，zk也是常见的分布式锁实现方案：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    value = redis.get(key);</span><br><span class="line">    if (Objects.isNull(value)) &#123;</span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        InterProcessLock lock = ZKSpringFactory.get().opsForLock(key.toString());</span><br><span class="line">        try &#123;</span><br><span class="line">            // 获取zk分布式锁</span><br><span class="line">            acquire(lock, key);</span><br><span class="line">            if (Objects.isNull(value = redis.get(key))) &#123;</span><br><span class="line">                // 利用客户端传入的callback回源，一般是查数据库</span><br><span class="line">                value = callback.call();</span><br><span class="line">                redis.setnx(key,value.toString(),expireTime,timeUnit);</span><br><span class="line">                return value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Throwable throwable) &#123;</span><br><span class="line">            logger.error(&quot;加载redisson key异常,key=&#123;&#125;&quot;, key, throwable);</span><br><span class="line">            // TODO 报警</span><br><span class="line">            throw UnsafeUtil.throwException(throwable);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                lock.release();</span><br><span class="line">                M.zk_lock_time.timer().get().update(System.currentTimeMillis() - start, TimeUnit.MILLISECONDS);</span><br><span class="line">            &#125; catch (Throwable throwable) &#123;</span><br><span class="line">                logger.error(&quot;释放lock异常&quot;, throwable);</span><br><span class="line">                // TODO 报警</span><br><span class="line">                try &#123;</span><br><span class="line">                    lock.release();</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    logger.error(&quot;释放lock异常&quot;, throwable);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; catch (Exception ex) &#123;</span><br><span class="line">    logger.error(&quot;redisson 获取值异常,key:&quot;+key,ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void acquire(InterProcessLock lock, String key) throws Exception &#123;</span><br><span class="line">    if (!lock.acquire(LOCK_EXPIRE_SECOND, TimeUnit.SECONDS)) &#123;</span><br><span class="line">        logger.error(&quot;获取lock超时,key=&#123;&#125;&quot;, key);</span><br><span class="line">        // 报警</span><br><span class="line">        throw new BizException(&quot;网络繁忙,请您稍后再试&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.”提前”使用互斥锁(mutex key)：<br>在 value 内部设置 1 个超时值(timeout1), timeout1 比实际的 memcache timeout(timeout2)小。当从 cache 读取到 timeout1 发现它已经过期时候，马上延长 timeout1 并重新设置到 cache。然后再从数据库加载数据并设置到 cache 中。伪代码如下：<br>v &#x3D; memcache.get(key);<br>if (v &#x3D;&#x3D; null) {<br>    if (memcache.add(key_mutex, 3 * 60 * 1000) &#x3D;&#x3D; true) {<br>        value &#x3D; db.get(key);<br>        memcache.set(key, value);<br>        memcache.delete(key_mutex);<br>    } else {<br>        sleep(50);<br>        retry();<br>    }<br>} else {<br>    if (v.timeout &lt;&#x3D; now()) {<br>        if (memcache.add(key_mutex, 3 * 60 * 1000) &#x3D;&#x3D; true) {<br>            &#x2F;&#x2F; extend the timeout for other threads<br>            v.timeout +&#x3D; 3 * 60 * 1000;<br>            memcache.set(key, v, KEY_TIMEOUT * 2);    </p>
<pre><code>        // load the latest value from dbplainplainplainplainplainplainplainplainplainplainplainplainplainplainplainplainplain
        v = db.get(key);    
        v.timeout = KEY_TIMEOUT;    
        memcache.set(key, value, KEY_TIMEOUT * 2);    
        memcache.delete(key_mutex);    
    &#125; else &#123;    
        sleep(50);    
        retry();    
    &#125;    
&#125;    
</code></pre>
<p>}</p>
<p>3.”永远不过期”：<br>这里的“永远不过期”包含两层意思：<br>(1) 从 redis 上看，确实没有设置过期时间，这就保证了，不会出现热点 key 过期问题，也就是“物理”不过期。<br>(2) 从功能上看，如果不过期，那不就成静态的了吗？所以我们把过期时间存在 key 对应的 value 里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建，也就是“逻辑”过期<br>        从实战看，这种方法对于性能非常友好，唯一不足的就是构建缓存时候，其余线程(非构建缓存的线程)可能访问的是老数据，但是对于一般的互联网功能来说这个还是可以忍受。<br>String get(final String key) {<br>        V v &#x3D; redis.get(key);<br>        String value &#x3D; v.getValue();<br>        long timeout &#x3D; v.getTimeout();<br>        if (v.timeout &lt;&#x3D; System.currentTimeMillis()) {<br>            &#x2F;&#x2F; 异步更新后台异常执行<br>            threadPool.execute(new Runnable() {<br>                public void run() {<br>                    String keyMutex &#x3D; “mutex:” + key;<br>                    if (redis.setnx(keyMutex, “1”)) {<br>                        &#x2F;&#x2F; 3 min timeout to avoid mutex holder crash<br>                        redis.expire(keyMutex, 3 * 60);<br>                        String dbValue &#x3D; db.get(key);<br>                        redis.set(key, dbValue);<br>                        redis.delete(keyMutex);<br>                    }<br>                }<br>            });<br>        }<br>        return value;<br>}</p>
<ol start="4">
<li>资源保护：<br>采用 netflix 的 hystrix，可以做资源的隔离保护主线程池，如果把这个应用到缓存的构建也未尝不可。</li>
</ol>
<table>
<thead>
<tr>
<th>解决方案</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>简单分布式互斥锁（mutex key）</td>
<td>1. 思路简单；2. 保证一致性</td>
<td>1. 代码复杂度增大；2. 存在死锁的风险；3. 存在线程池阻塞的风险</td>
</tr>
<tr>
<td>“提前”使用互斥锁</td>
<td>1. 保证一致性</td>
<td>同上</td>
</tr>
<tr>
<td>不过期(本文)</td>
<td>1. 异步构建缓存，不会阻塞线程池</td>
<td>1. 不保证一致性；2. 代码复杂度增大(每个 value 都要维护一个 timekey)；3. 占用一定的内存空间(每个 value 都要维护一个 timekey)。</td>
</tr>
<tr>
<td>资源隔离组件 hystrix(本文)</td>
<td>1. hystrix 技术成熟，有效保证后端；2. hystrix 监控强大。</td>
<td>1. 部分访问存在降级策略。</td>
</tr>
</tbody></table>
<h3 id="设计总结"><a href="#设计总结" class="headerlink" title="设计总结"></a>设计总结</h3><p>针对业务系统，永远都是具体情况具体分析，没有最好，只有最合适。<br>最后，对于缓存系统常见的缓存满了和数据丢失问题，需要根据具体业务分析，通常我们采用 LRU 策略处理溢出，Redis 的 RDB 和 AOF 持久化策略来保证一定情况下的数据安全。</p>
<ol>
<li>缓存失效策略<br>添加 key 的时候要设置一个过期时间,采用惰性删除和定时删除相结合的策略删除过期键</li>
<li>多级缓存<br>线程级-&gt;内存级-&gt;进程级-&gt;文件(静态资源)-&gt;分布式(redis)-&gt;Db 结果.</li>
<li>二级缓存<br>二级缓存更多的解决是,缓存穿透与程序的健壮性,当集中式缓存出现问题的时候,我们的应用能够继续运行;一些热点数据做成内存缓存,这些数据是在上线之前是已知的(比如说秒杀,大促商品),通过配置定时任务定时刷新内存缓存,完成和分布式缓存的数据置换;更加自动化的方案,可以根据上游自动发现热点数据,广播消息替换现在集群中内存缓存的数据(但在整个集群中广播,成本比较高,并且二级缓存的管理的成本也很大);</li>
</ol>
<h2 id="实现一个简单的多级缓存"><a href="#实现一个简单的多级缓存" class="headerlink" title="实现一个简单的多级缓存"></a>实现一个简单的多级缓存</h2><p><img src="/imgs/%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98/%E5%A4%9A%E7%BA%A7%E6%95%B0%E6%8D%AE%E6%9D%A5%E6%BA%90.png" alt="多级数据来源" title="多级数据来源示意图"></p>
<ul>
<li>本地缓存<br>在并发量不大的系统内，本地缓存的意义不大，反而增加维护的困难。但在高并发系统中，本地缓存可以大大节约带宽。但是要注意本地缓存不是银弹，它会引起多个副本间数据的不一致，还会占据大量的内存，所以不适合保存特别大的数据，而且需要严格考虑刷新机制。</li>
<li>缓存 &#x2F; 搜索服务器<br>TODO: </li>
<li>数据库服务器<br>TODO：</li>
<li>同机房的其他业务服务器<br>TODO：</li>
<li>不同机房的其他业务服务器<br>TODO：</li>
</ul>
<p><img src="/imgs/%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98/cache-drawer-core.png" alt="多级缓存组件的主要执行流程" title="cache-drawer-core 的主要执行流程"><br>详细描述 TODO：</p>
<h3 id="缓存时机"><a href="#缓存时机" class="headerlink" title="缓存时机"></a>缓存时机</h3><ul>
<li>5 分钟法则<br>5 分钟法则即：如果一个数据的访问周期在 5 分钟以内则存放在内存中，否则应该存放在硬盘中。<br>引申到缓存中，可以表述为：如果一个数据访问吞吐率大于 1 次 &#x2F; 5 分钟，就可以考虑放到缓存中。</li>
<li>局部性原理<br>局部性原理原指 CPU 访问存储器时，无论是存取指令还是存取数据，所访问的存储单元都趋于聚集在一个较小的连续区域中。<br>反过来说，如果访问存在热点，就完全可以把这些热点数据放到缓存里。</li>
</ul>
<h3 id="算法-FIFO"><a href="#算法-FIFO" class="headerlink" title="算法 - FIFO"></a>算法 - FIFO</h3><h3 id="算法-LRU"><a href="#算法-LRU" class="headerlink" title="算法 - LRU"></a>算法 - LRU</h3><h3 id="算法-LFU"><a href="#算法-LFU" class="headerlink" title="算法 - LFU"></a>算法 - LFU</h3><h3 id="回收策略"><a href="#回收策略" class="headerlink" title="回收策略"></a>回收策略</h3><ul>
<li>空间</li>
<li>容量<br>条⽬数</li>
<li>时间<br>存活期活太久淘汰<br>空闲期太久没访问淘汰</li>
</ul>
<h3 id="缓存监控"><a href="#缓存监控" class="headerlink" title="缓存监控"></a>缓存监控</h3><p>命中率 &#x3D; 缓存读取次数 &#x2F; (缓存读取次数 + 慢速设备读取次数)</p>
<h3 id="过期时间"><a href="#过期时间" class="headerlink" title="过期时间"></a>过期时间</h3><p>本地缓存过期时间比分布式缓存小至少一半，以防止本地缓存太久造成多实例数据不一致。</p>
<ul>
<li>不过期缓存<br>场景：长尾访问的数据、访问频率⾼、缓存空间⾜够<br>使⽤Cache-Aside 模式<br>不要放事务⾥，因为⽹络抖动可能导致写缓存响应时间慢，阻塞数据库事务。但是同样存在事务成功但缓存失败⽆法回滚的情况。解决办法是使用 canal 实现缓存同步。<br>若对⼀致性要求不高且数据量不⼤可改成定期全量同步</li>
<li>过期缓存<br>场景：热点数据、来⾃自其他系统的数据、空间有限、访问频率低</li>
</ul>
<h3 id="SoR（Source-of-Resource）"><a href="#SoR（Source-of-Resource）" class="headerlink" title="SoR（Source-of-Resource）"></a>SoR（Source-of-Resource）</h3><p>数据的来源，一般称为记录系统或<strong>数据源</strong>。<br><strong>回源</strong>即回到源头获取数据，Cache 没有命中时，需要从 SoR 获取数据，即回源。</p>
<h3 id="大-Value"><a href="#大-Value" class="headerlink" title="大 Value"></a>大 Value</h3><p>如果有⼤Value 最好切换到多线程实现的缓存如 MC，或者拆成多个小 Value 由客户端聚合。</p>
<h3 id="热点缓存"><a href="#热点缓存" class="headerlink" title="热点缓存"></a>热点缓存</h3><p>频繁访问的热点数据，如果每次都要从缓存服务器获取，可能导致缓存服务器负载过高、或者带宽过⾼。<br>解决办法是加缓存服务器，或者加本地缓存。</p>
<h3 id="缓存更新"><a href="#缓存更新" class="headerlink" title="缓存更新"></a>缓存更新</h3><p>原⼦更新：</p>
<ul>
<li>版本号</li>
<li>如果是 redis，因为单线程机制本身就是⽀持原⼦更新的</li>
<li>使用 canal 订阅数据库 binlog 将更新请求按规则路由到多个队列，每个队列进⾏单线程的更新</li>
<li>加分布式锁</li>
</ul>
<h3 id="异步写"><a href="#异步写" class="headerlink" title="异步写"></a>异步写</h3><p>写本地缓存后异步更新分布式缓存，尽快返回用户请求，最好不要同步写分布式缓存。</p>
<h3 id="维度化与增量缓存"><a href="#维度化与增量缓存" class="headerlink" title="维度化与增量缓存"></a>维度化与增量缓存</h3><p>场景：一个商品包含多个属性，其中部分属性如上下架这种可能频繁更新的，最好做维度化并增量更新。</p>
<h3 id="缓存策略-分区读"><a href="#缓存策略-分区读" class="headerlink" title="缓存策略 - 分区读"></a>缓存策略 - 分区读</h3><p>读缓存时划分分区异步批量读：</p>
<ul>
<li>分区可以防⽌出现慢查询；</li>
<li>异步可以把各批 key 并⾏化。</li>
</ul>
<h3 id="缓存策略-nullobj-防缓存击穿"><a href="#缓存策略-nullobj-防缓存击穿" class="headerlink" title="缓存策略 - nullobj 防缓存击穿"></a>缓存策略 - nullobj 防缓存击穿</h3><p>当 db 中本身就没有该数据时，会产生每次请求都击穿的现象，解决办法是引入一个 <strong>nullobj</strong>。<br>db 不不存在时写一个 <strong>nullobj</strong> 到缓存，下次读到 null 对象 就不去 db 读了。</p>
<h3 id="缓存策略-Cache-aside-模式"><a href="#缓存策略-Cache-aside-模式" class="headerlink" title="缓存策略 - Cache-aside 模式"></a>缓存策略 - Cache-aside 模式</h3><p>Cache-Aside 即业务代码围绕着 Cache 写，是由业务代码直接维护缓存。</p>
<h4 id="什么时候使用"><a href="#什么时候使用" class="headerlink" title="什么时候使用"></a>什么时候使用</h4><ul>
<li>当 Cache不提供原⽣的 Read-Through 和 Write-Through 操作的时候</li>
<li>资源的需求是不可预测的时候。Cache-Aside 模式令应用可以根据需求来加载数据，对于应⽤需求什么数据，不需要提前做出假设。</li>
</ul>
<h3 id="Read-模式"><a href="#Read-模式" class="headerlink" title="Read 模式"></a>Read 模式</h3><p>先从缓存获取数据，如果没有命中，则回源到 SoR 并将源数据放入缓存供下次读取使用。</p>
<h3 id="Write-模式"><a href="#Write-模式" class="headerlink" title="Write 模式"></a>Write 模式</h3><p>类似 Write-Through 策略。</p>
<ol>
<li>先将数据写入 SoR，写入成功后立即将数据同步写入缓存；</li>
<li>或先将数据写入 SoR，写入成功后将缓存数据过期，下次读取时再加载缓存。</li>
</ol>
<h4 id="读优化-一致性哈希"><a href="#读优化-一致性哈希" class="headerlink" title="读优化 - 一致性哈希"></a>读优化 - 一致性哈希</h4><p>读可以⽤⼀致性哈希减少并发。</p>
<h4 id="写优化-使用-Canal-订阅更新"><a href="#写优化-使用-Canal-订阅更新" class="headerlink" title="写优化 - 使用 Canal 订阅更新"></a>写优化 - 使用 Canal 订阅更新</h4><p>更新可以⽤Canal 订阅 binlog。</p>
<h4 id="缓存数据的⽣存时间"><a href="#缓存数据的⽣存时间" class="headerlink" title="缓存数据的⽣存时间"></a>缓存数据的⽣存时间</h4><p>很多 Cache 实现了过期的策略的，这些过期的策略可以实现数据的更新，将旧数据失效化，同时也令⼀定时间没有访问的数据失效。<br>为了让 Cache-Aside 模式能够⽣效，开发者必须确保过期策略能够正确匹配应用所访问的数据。同时，注意不能让过期时间太短，因为太短的过期时间会令应⽤频繁地从数据仓库中获取数据来添加到 Cache 之中。当然，也不要配置超时的时间太⻓，过⻓的超时时间会让缓存的数据冗余。Cache 的性能是跟其相关的数据的读取周期等信息⾼度相关的。</p>
<h4 id="去除数据"><a href="#去除数据" class="headerlink" title="去除数据"></a>去除数据</h4><p>绝⼤多数的缓存跟数据仓库⽐起来，容量是很有限的，所以，如果可以的话，Cache 会移除数据。<br>多数的 Cache 会采用 LRU 的策略来移除缓存中的数据，当然，移除的策略也是可以⾃定义的。配置全局的过期属性和缓存的其他属性，可以确保 Cache 消耗的内存资源是高效的。当然，通常不会只配置⼀个全局的过期策略。比如，某些特别昂贵、访问特别频繁而又不常更新的数据，完全可以延长其过期时间。</p>
<h4 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h4><p>实现 Cache-Aside 模式并不能保证 Cache 和数据仓库之间的数据⼀致性。因为数据仓库中的数据可能在任何时候被其他程序所修改，⽽这个修改不会及时的反映到 Cache 上，直到下一次 Cache 被刷新为止。如果数据仓库中数据频繁由⾮Cahce 程序更新的话，这种一致性问题会变得更加明显。</p>
<h4 id="本地（内存）缓存"><a href="#本地（内存）缓存" class="headerlink" title="本地（内存）缓存"></a>本地（内存）缓存</h4><p>Cache 也是可以做到应⽤本身里⾯的。Cache-Aside 模式在⼀些应⽤频繁访问相同的数据的时候尤其有效。然⽽，本地 Cache 都是应⽤私有 的，是属于每个应用中独有的额外的拷⻉。所以这个数据可能很快在不同的应⽤中就不一致了，所以刷新的频率最好更快些以保证⼀致性。在 有些情况下可以使⽤共享的缓存，有的时候也可以使⽤本地 Cache，具体使⽤哪⼀种就需要根据实际的场景来判断了。</p>
<h3 id="缓存策略-Cache-as-SoR-模式"><a href="#缓存策略-Cache-as-SoR-模式" class="headerlink" title="缓存策略 - Cache-as-SoR 模式"></a>缓存策略 - Cache-as-SoR 模式</h3><p>由 Cache 委托给 SoR 进⾏真实的读写</p>
<h3 id="缓存策略-Read-Through"><a href="#缓存策略-Read-Through" class="headerlink" title="缓存策略 - Read-Through"></a>缓存策略 - Read-Through</h3><p>读 miss 则由 cache 回源到 SoR(需要防⽌dog-pile effect 即 miss 时只允许⼀个请求回源而不是所有请求都回源)。</p>
<h3 id="缓存策略-Write-Through"><a href="#缓存策略-Write-Through" class="headerlink" title="缓存策略 - Write-Through"></a>缓存策略 - Write-Through</h3><p>由 cache 组件负责写缓存和 SoR(一般是先 SoR 再缓存)</p>
<h3 id="缓存策略-Write-Behind"><a href="#缓存策略-Write-Behind" class="headerlink" title="缓存策略 - Write-Behind"></a>缓存策略 - Write-Behind</h3><p>异步(队列+线程池)写 SoR</p>
<h3 id="缓存策略-Copy-Pattern"><a href="#缓存策略-Copy-Pattern" class="headerlink" title="缓存策略 - Copy-Pattern"></a>缓存策略 - Copy-Pattern</h3><p>Copy-On-Read<br>Copy-On-Write<br>本地缓存的是引⽤，被擅⾃修改可能引起不可预测的问题</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>所有参考文献的归档，集中管理，方便随时查阅。</p>
<h3 id="多级缓存架构"><a href="#多级缓存架构" class="headerlink" title="多级缓存架构"></a>多级缓存架构</h3><ol>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5d86cf7f6fb9a06b211724e7">一篇文章让你明白你多级缓存的分层架构</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zlc3323/article/details/89984961">一个牛逼的多级缓存实现方案</a></li>
<li><a target="_blank" rel="noopener" href="https://www.sohu.com/a/250055167_673711">日访问量百亿级的微博如何做缓存架构设计</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/eeaa62dfaf72">分布式内存缓存系统设计</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/mushroom/p/4199701.html#wechat_redirect">那些年我们一起追过的缓存写法(一)</a></li>
</ol>
<h3 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a>内存池</h3><ol>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45583158/article/details/102618077">设计模式之争：新分配内存还是内存池？（含评测）</a></li>
</ol>
<h3 id="本地缓存-1"><a href="#本地缓存-1" class="headerlink" title="本地缓存"></a>本地缓存</h3><p>不得不承认本地缓存不比分布式缓存更简单，当我们讨论分布式缓存时，更多的是在讨论如何节省带宽、如何平滑扩容，但在本地缓存的范畴内，我们更多的需要关注所使用语言的内存管理机制、甚至需要向下探索到硬件层面（其实分布式缓存的基础一般也是本地缓存）。</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/lru-cache/">146. LRU Cache</a><br><a target="_blank" rel="noopener" href="https://leetcode.com/problems/lfu-cache/">460. LFU Cache</a><br>LeetCode 上有几道缓存相关的问题，可以拿来作热身。</li>
<li>Java 内存模型<br>Java 中的垃圾回收技术已经比较完善了，开发人员能做的除了给出合理的配置外，就是要做到对自己使用的垃圾回收技术知根知底、能写出 GC 友好的代码。<br><a target="_blank" rel="noopener" href="http://www.cs.umd.edu/~pugh/java/memoryModel/">The Java Memory Model - William Pugh</a><br><a target="_blank" rel="noopener" href="http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html">JSR 133 (Java Memory Model) FAQ</a><br><a target="_blank" rel="noopener" href="http://ifeve.com/jmm-faq/">Java 内存模型 FAQ</a><br>上面这篇的中文翻译，适合我这种英语渣对照阅读。<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/youyou1543724847/article/details/52728301">GC(GC 友好编程)</a><br><a target="_blank" rel="noopener" href="http://gee.cs.oswego.edu/">Doug Lea’s Home Page</a><br><a target="_blank" rel="noopener" href="http://ifeve.com/doug-lea/">Doug Lea 并发编程文章全部译文</a></li>
<li>NonBlocking HashTable<br>HashTable 是实现缓存的常用数据结构，而在操作时进行普通的加锁又非常影响性能，所以一般会做一些 NonBlocking 的优化。除了 JUC 的 ConcurrentHashMap，还有其他的一些相似实现。<br><a target="_blank" rel="noopener" href="https://github.com/stephenc/high-scale-lib">stephenc&#x2F;high-scale-lib</a><br><a target="_blank" rel="noopener" href="https://github.com/JCTools/JCTools">JCTools&#x2F;JCTools</a></li>
<li>guava - cache<br><a target="_blank" rel="noopener" href="https://github.com/google/guava/wiki/CachesExplained">github - google&#x2F;guava - Caches</a></li>
<li>ehcache<br><a target="_blank" rel="noopener" href="https://github.com/ehcache">github - ehcache3</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/5a0669d6305e">玩转 EhCache 之最简单的缓存框架</a></li>
<li>J2Cache<br>J2Cache 是一个国产的本地缓存框架，同时也提供了二级缓存、多机同步等特性。<br><a target="_blank" rel="noopener" href="https://gitee.com/ld/J2Cache">红薯 &#x2F; J2Cache</a></li>
<li>Netty 中的对象池<br><a target="_blank" rel="noopener" href="https://github.com/netty/netty/wiki/Reference-counted-objects">netty&#x2F;netty - Reference counted objects</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/levena/article/details/78144924">Netty 源码 Recycler 对象池全面解析</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/854b855bd198">netty 源码分析 4 - Recycler 对象池的设计</a><br>Netty 为了提高性能，IO 时直接使用非堆内存来缓存收发的内容（Buf 对象），在非堆内存中 GC 效率会比 JVM 的堆内存效率低（只能通过 FullGC 回收或 CMS GC），所以 Netty 内部维护了一个对象池（Recycler），使用引用计数法来回收不用的对象到对象池中，而不是直接回收，减少了 GC 的频率。</li>
<li>C &#x2F; C++ 内存模型<br>C &#x2F; C++ 只保证最基本的内存管理（malloc &#x2F; free），因为其贴近操作系统的特性，很多框架都会封装一套自己的内存管理库（包括 memcached、MySQL、Cocos2d-x 等），甚至是 GC。<br>《C 语言接口与实现》 - 第 2、4、5、6 章<br><a href="ftp://g.oswego.edu/pub/misc/malloc.c">dlmalloc - Doug Lea</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/xushiweizh/article/category/265099">内存管理（Memory） - 许式伟</a><br><a target="_blank" rel="noopener" href="http://xushiwei.com/gc-allocator">C++ Memory Management Innovation: GC Allocator</a><br>《STL 源码剖析》 - 第 2 章<br>《深入探索 C++对象模型》</li>
<li><a target="_blank" rel="noopener" href="https://github.com/bangerlee/mempool">bangerlee&#x2F;mempool</a></li>
<li>应用层内存管理<br><a target="_blank" rel="noopener" href="https://www.memorymanagement.org/index.html">Memory Management Reference</a><br>一个神奇的网站，内存管理相关的概念、综述、深入参考文献基本都能在这里找到，而且偏应用层，讲解方式友好、适合扫盲。</li>
<li>操作系统层内存管理<br><a target="_blank" rel="noopener" href="http://en.tldp.org/HOWTO/Unix-and-Internet-Fundamentals-HOWTO/">The Unix and Internet Fundamentals HOWTO</a><br>非常精炼地解释了 Unix 系统和网络的基本原理。</li>
<li>硬件层内存管理</li>
</ol>
<h3 id="分布式缓存-1"><a href="#分布式缓存-1" class="headerlink" title="分布式缓存"></a>分布式缓存</h3><ol>
<li>分布式缓存设计及解决方案（后端）<br><a target="_blank" rel="noopener" href="http://www.cnblogs.com/itfly8/category/756114.html">大型分布式网站架构</a><br><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000006007338">浅谈缓存(一)</a><br><a target="_blank" rel="noopener" href="http://www.cnblogs.com/mushroom/p/4199701.html">那些年我们一起追过的缓存写法(一)</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzIwMzg1ODcwMw==&mid=2247486493&amp;idx=1&amp;sn=2d159e329b3e579d6b844754df0dd265&source=41#wechat_redirect">缓存穿透、并发和失效，来自一线架构师的解决方案</a></li>
<li>《分布式缓存——原理、架构及 Go 语言实现》</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/F8qG7f9YD02Pe/article/details/78937081">荐书：《深入分布式缓存》</a></li>
<li>Redis 教程及手册<br>《Redis 设计与实现》<br>《Redis 深度历险：核心原理与应用实践》<br><a target="_blank" rel="noopener" href="http://redisdoc.com/index.html">Redis 命令参考</a><br><a target="_blank" rel="noopener" href="https://redis.io/commands">Redis Command Reference</a><br><a target="_blank" rel="noopener" href="https://redis.io/documentation">Redis Documentation</a></li>
<li>Redis 及客户端源码<br><a target="_blank" rel="noopener" href="https://github.com/antirez/redis">github - antirez&#x2F;redis</a><br><a target="_blank" rel="noopener" href="https://github.com/redisson/redisson/wiki/Redisson%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D">github - redisson&#x2F;redisson</a><br><a target="_blank" rel="noopener" href="https://github.com/xetorthio/jedis/wiki">github - xetorthio&#x2F;jedis</a><br><a target="_blank" rel="noopener" href="https://github.com/lettuce-io/lettuce-core/wiki/Redis-Command-Interfaces">github - lettuce-io&#x2F;lettuce-core</a></li>
<li>Redis - 数据结构<br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzI0MDQ4MTM5NQ==&mid=2247488450&idx=1&sn=88239e7fa2b80a9922db5fbc9629c770&chksm=e91b76dede6cffc8b8820e7730349fe83cef1cdf0ac73b7a5e13569e596c77264b92edacf4f2&token=649184257&lang=zh_CN#rd">Redis 为何这么快</a><br><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/16375188/redis-strings-vs-redis-hashes-to-represent-json-efficiency">Redis strings vs Redis hashes to represent JSON: efficiency?</a><br>如果业务里需要使用到对象的单个域则使用 hash 类型保存 JSON，否则使用 string。</li>
<li>Redis - Sentinel<br>Sentinel 是 Redis 提供的一种高可用集群方案，它能实现自动的故障转移。<br><a target="_blank" rel="noopener" href="https://redis.io/topics/sentinel">Redis Sentinel Documentation</a><br><a target="_blank" rel="noopener" href="https://redis.io/topics/sentinel-clients">Sentinel Clients</a><br><a target="_blank" rel="noopener" href="https://aphyr.com/posts/283-call-me-maybe-redis">Jepsen: Redis</a><br><a target="_blank" rel="noopener" href="http://antirez.com/news/55"><antirez> Reply to Aphyr attack to Sentinel</a><br><a target="_blank" rel="noopener" href="https://aphyr.com/posts/287-asynchronous-replication-with-failover">Asynchronous replication with failover</a></li>
<li>Redis - Cluster<br>Redis Cluster 不是使用<strong>一致性 hash</strong>、而是利用<strong>哈希槽</strong>的模式来分配数据，相对来说更简单，但是数据迁移的时候成本也会更大。<br><a target="_blank" rel="noopener" href="https://redis.io/topics/cluster-tutorial">Redis cluster tutorial</a><br><a target="_blank" rel="noopener" href="https://redis.io/topics/cluster-spec">Redis Cluster Specification</a></li>
<li>在 Spring 架构后台中使用 Redis<br><a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.0.3.RELEASE/spring-framework-reference/integration.html#cache">spring-framework-reference - 8. Cache Abstraction</a><br><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/redis/docs/2.0.3.RELEASE/reference/html/">Spring Data Redis</a><br><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/">Spring Boot Reference Guide</a></li>
<li>Redis 最佳实践<br><a target="_blank" rel="noopener" href="https://yq.aliyun.com/articles/531067">阿里云 Redis 开发规范</a><br><a target="_blank" rel="noopener" href="https://juejin.im/post/5cee39a26fb9a07ed36e8c4c">你所不知道的 Redis 热点问题以及如何发现热点</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/javaMerea/article/details/89317071">史上最全 50 道 Redis 面试题（含答案），以后面试再也不怕问 Redis 了</a></li>
<li>Redis 应用<br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/y2HPj2ji2KLS_eTR5nBnDA">一文看透 Redis 分布式锁进化史（解读 + 缺陷分析）</a><br><a target="_blank" rel="noopener" href="http://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html">How to do distributed locking</a><br>刷新 Redis 缓存时需要加分布式锁，保证只有一个线程能够写入缓存。<br><a target="_blank" rel="noopener" href="https://redis.io/commands/incr#pattern-rate-limiter">INCR key (分布式限流器的例子)</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/q-y10hMPjApWgnQacu-nsA">布隆过滤器实战【防止缓存击穿】</a><br><a target="_blank" rel="noopener" href="https://coolshell.cn/articles/7270.html">NOSQL 数据建模技术</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/memcached/memcached">github - memcached</a><br>memcached 是经常和 Redis 一并提起的一个分布式缓存中间件，了解其原理能对分布式缓存的实现模式有更好的认识。</li>
</ol>
<h3 id="Web-缓存"><a href="#Web-缓存" class="headerlink" title="Web 缓存"></a>Web 缓存</h3><p>Web 缓存指的是在服务器和客户端之间的缓存，不同于我们上边提到的都是服务器（本地缓存）及服务器之后的缓存（分布式缓存）。<br>Web 缓存其实不仅仅指浏览器内的缓存，在剖析从客户端发送请求到服务器接收为止的一系列链路之后，可以发现 Web 缓存主要包括浏览器缓存、代理服务器缓存、网关缓存。</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/rubylouvre/p/3139620.html">Web 开发人员需知的 Web 缓存知识</a></li>
</ol>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>测试是发现问题的手段，最好的解决问题方式是避免问题。</p>
<ol>
<li>《Java 并发编程实战》 - 第三部分（并发安全及性能）</li>
<li><a target="_blank" rel="noopener" href="http://www.redis.cn/topics/benchmarks.html">Redis 有多快?</a></li>
<li>《构建高性能 Web 站点》 - 第 3 章</li>
<li>《Java 程序性能优化》</li>
<li>《Web 性能权威指南》</li>
<li>《OptimizingLinux(R)PerformanceAHands-OnGuidetoLinux(R)PerformanceTools》</li>
<li>《性能之巅》</li>
</ol>
<h3 id="运维"><a href="#运维" class="headerlink" title="运维"></a>运维</h3><ol>
<li>《The Art of Capacity Planning》</li>
<li><a target="_blank" rel="noopener" href="http://stor.51cto.com/art/201808/580165.htm">探寻 Redis 内存诡异增长的元凶</a></li>
</ol>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol>
<li><a target="_blank" rel="noopener" href="http://www.catb.org/~esr/faqs/smart-questions.html">How To Ask Questions The Smart Way</a></li>
<li><a target="_blank" rel="noopener" href="http://en.tldp.org/HOWTO/Software-Release-Practice-HOWTO/index.html">Software Release Practice HOWTO</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/hyperoslo/Cache">github - hyperoslo&#x2F;Cache</a><br>这个项目同样在缓存上做文章，不过是用 swift 写的。</li>
<li><a target="_blank" rel="noopener" href="https://learnxinyminutes.com/docs/lua/">Learn X in Y minutes - Where X&#x3D;Lua</a></li>
<li>《设计模式》 - Factory, Builder, Proxy, Chain of Responsibility, Command, Iterator, template method</li>
<li>《Spring 源码深度解析》 - 第 5、6、7 章</li>
<li><a target="_blank" rel="noopener" href="https://app.brandmark.io/v2/">使用 AI 生成图标</a></li>
</ol>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/16/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><span class="page-number current">17</span><a class="page-number" href="/page/18/">18</a><a class="page-number" href="/page/19/">19</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/18/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">tallate</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/tallate" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"version":"7.1.2","options":null,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.3.0/mermaid.min.js","integrity":"sha256-9y71g5Lz/KLsHjB8uXwnkuWDtAMDSzD/HdIbqhJfTAI="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>





  





</body>
</html>
