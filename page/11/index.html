<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"tallate.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.18.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Tallate">
<meta property="og:url" content="https://tallate.github.io/page/11/index.html">
<meta property="og:site_name" content="Tallate">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="tallate">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://tallate.github.io/page/11/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/11/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Tallate</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Tallate</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">该吃吃该喝喝 啥事别往心里搁</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签<span class="badge">83</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="th fa-fw"></i>分类<span class="badge">25</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档<span class="badge">189</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">tallate</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">189</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">83</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/d368c702.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tallate">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tallate">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/d368c702.html" class="post-title-link" itemprop="url">Redis高可用方案Sentinel</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-09-22 12:21:48" itemprop="dateCreated datePublished" datetime="2019-09-22T12:21:48+08:00">2019-09-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-07 01:56:20" itemprop="dateModified" datetime="2025-07-07T01:56:20+08:00">2025-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%93%E5%AD%98/" itemprop="url" rel="index"><span itemprop="name">缓存</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>



<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><ol>
<li><p>Master<br>TODO</p>
</li>
<li><p>Slave</p>
</li>
<li><p>Sentinel</p>
</li>
<li><p>获取集群信息</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 26379 info Sentinel</span><br></pre></td></tr></table></figure></li>
<li><p>获取 master 节点地址</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 26379 SENTINEL get-master-addr-by-name mymaster</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="客户端如何连接Sentinel集群"><a href="#客户端如何连接Sentinel集群" class="headerlink" title="客户端如何连接Sentinel集群"></a>客户端如何连接Sentinel集群</h2><p><img src="/imgs/Redis/Sentinel.png" alt="Sentinel" title="Sentinel"><br>在 Sentinel 模式下，客户端不是直接连接服务器的，而是先访问 Sentinel 拿到集群信息再尝试连接 Master。当 Master 发生故障时，客户端会重新向 Sentinel 要地址，并自动完成节点切换。</p>
<ul>
<li>Master 和 Slave 的配置和之前并无区别；</li>
<li>Sentinel 相当于对 Master 的代理，Sentinel 可以通过发布订阅功能获取到 Slave 和其他 Sentinel 的信息。<blockquote>
<p>其实 Sentinel 的内核与其他形式的 Redis 服务器基本一致，只是支持的命令不同、负责的任务也不同。</p>
</blockquote>
</li>
</ul>
<p>同理，客户端也可以通过pubsub功能来订阅集群中的其他信息，关键事件如下：<br><img src="/imgs/Redis/RedisSentinel%E4%BA%8B%E4%BB%B6.jpg" alt="RedisSentinel事件" title="RedisSentinel事件"></p>
<h2 id="Sentinel-执行原理"><a href="#Sentinel-执行原理" class="headerlink" title="Sentinel 执行原理"></a>Sentinel 执行原理</h2><p><img src="/imgs/Redis/Sentinel%E7%9A%84%E4%B8%BB%E8%A6%81%E4%BB%BB%E5%8A%A1.jpg" alt="Sentinel的主要任务" title="Sentinel的主要任务"><br>在Sentinel的主事件循环中可以看到它每100毫秒执行的定时任务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int serverCron(struct aeEventLoop *eventLoop, long long id, void *clientData) &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    /* Run the Sentinel timer if we are in sentinel mode. */</span><br><span class="line">    // 如果服务器运行在 sentinel 模式下，那么执行 SENTINEL 的主函数</span><br><span class="line">    run_with_period(100) &#123;</span><br><span class="line">        if (server.sentinel_mode) sentinelTimer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实例状态探测"><a href="#实例状态探测" class="headerlink" title="实例状态探测"></a>实例状态探测</h3><ul>
<li>每个 Sentinel 以每秒钟一次的频率向它所知的主服务器、从服务器以及其他 Sentinel 实例发送一个 <code>PING 命令</code>。<br>如果一个实例（instance）距离最后一次有效回复 <code>PING</code> 命令的时间超过 <code>down-after-milliseconds</code> 选项所指定的值， 那么这个实例会被 Sentinel 标记为<strong>主观下线</strong>。 一个有效回复可以是： +PONG 、 -LOADING 或者 -MASTERDOWN。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">void sentinelHandleDictOfRedisInstances(dict *instances) &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    // 遍历多个实例，这些实例可以是多个主服务器、多个从服务器或者多个 sentinel</span><br><span class="line">    di = dictGetIterator(instances);</span><br><span class="line">    while((de = dictNext(di)) != NULL) &#123;</span><br><span class="line"></span><br><span class="line">        // 取出实例对应的实例结构</span><br><span class="line">        sentinelRedisInstance *ri = dictGetVal(de);</span><br><span class="line"></span><br><span class="line">        // 执行调度操作</span><br><span class="line">        sentinelHandleRedisInstance(ri);</span><br><span class="line"></span><br><span class="line">        // 如果被遍历的是主服务器，那么递归地遍历该主服务器的所有从服务器</span><br><span class="line">        // 以及所有 sentinel</span><br><span class="line">        if (ri-&gt;flags &amp; SRI_MASTER) &#123;</span><br><span class="line"></span><br><span class="line">            // 所有从服务器</span><br><span class="line">            sentinelHandleDictOfRedisInstances(ri-&gt;slaves);</span><br><span class="line"></span><br><span class="line">            // 所有 sentinel</span><br><span class="line">            sentinelHandleDictOfRedisInstances(ri-&gt;sentinels);</span><br><span class="line"></span><br><span class="line">            // 对已下线主服务器（ri）的故障迁移已经完成</span><br><span class="line">            // ri 的所有从服务器都已经同步到新主服务器</span><br><span class="line">            if (ri-&gt;failover_state == SENTINEL_FAILOVER_STATE_UPDATE_CONFIG) &#123;</span><br><span class="line">                // 已选出新的主服务器</span><br><span class="line">                switch_to_promoted = ri;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* Perform scheduled operations for the specified Redis instance. */</span><br><span class="line">// 对给定的实例执行定期操作</span><br><span class="line">void sentinelHandleRedisInstance(sentinelRedisInstance *ri) &#123;</span><br><span class="line"></span><br><span class="line">    /* ========== MONITORING HALF ============ */</span><br><span class="line">    /* ==========     监控操作    =========*/</span><br><span class="line"></span><br><span class="line">    /* Every kind of instance */</span><br><span class="line">    /* 对所有类型实例进行处理 */</span><br><span class="line"></span><br><span class="line">    // 如果有需要的话，创建连向实例的网络连接</span><br><span class="line">    sentinelReconnectInstance(ri);</span><br><span class="line"></span><br><span class="line">    // 根据情况，向实例发送 PING、 INFO 或者 PUBLISH 命令</span><br><span class="line">    sentinelSendPeriodicCommands(ri);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 根据时间和实例类型等情况，向实例发送命令，比如 INFO 、PING 和 PUBLISH</span><br><span class="line">// 虽然函数的名字包含 Ping ，但命令并不只发送 PING 命令</span><br><span class="line">/* Send periodic PING, INFO, and PUBLISH to the Hello channel to</span><br><span class="line"> * the specified master or slave instance. */</span><br><span class="line">void sentinelSendPeriodicCommands(sentinelRedisInstance *ri) &#123;</span><br><span class="line">    mstime_t now = mstime();</span><br><span class="line">    mstime_t info_period, ping_period;</span><br><span class="line">    int retval;</span><br><span class="line"></span><br><span class="line">    /* Return ASAP if we have already a PING or INFO already pending, or</span><br><span class="line">     * in the case the instance is not properly connected. */</span><br><span class="line">    // 函数不能在网络连接未创建时执行</span><br><span class="line">    if (ri-&gt;flags &amp; SRI_DISCONNECTED) return;</span><br><span class="line"></span><br><span class="line">    /* For INFO, PING, PUBLISH that are not critical commands to send we</span><br><span class="line">     * also have a limit of SENTINEL_MAX_PENDING_COMMANDS. We don&#x27;t</span><br><span class="line">     * want to use a lot of memory just because a link is not working</span><br><span class="line">     * properly (note that anyway there is a redundant protection about this,</span><br><span class="line">     * that is, the link will be disconnected and reconnected if a long</span><br><span class="line">     * timeout condition is detected. */</span><br><span class="line">    // 为了避免 sentinel 在实例处于不正常状态时，发送过多命令</span><br><span class="line">    // sentinel 只在待发送命令的数量未超过 SENTINEL_MAX_PENDING_COMMANDS 常量时</span><br><span class="line">    // 才进行命令发送</span><br><span class="line">    if (ri-&gt;pending_commands &gt;= SENTINEL_MAX_PENDING_COMMANDS) return;</span><br><span class="line"></span><br><span class="line">    /* If this is a slave of a master in O_DOWN condition we start sending</span><br><span class="line">     * it INFO every second, instead of the usual SENTINEL_INFO_PERIOD</span><br><span class="line">     * period. In this state we want to closely monitor slaves in case they</span><br><span class="line">     * are turned into masters by another Sentinel, or by the sysadmin. */</span><br><span class="line">    // 对于从服务器来说， sentinel 默认每 SENTINEL_INFO_PERIOD 秒向它发送一次 INFO 命令</span><br><span class="line">    // 但是，当从服务器的主服务器处于 SDOWN 状态，或者正在执行故障转移时</span><br><span class="line">    // 为了更快速地捕捉从服务器的变动， sentinel 会将发送 INFO 命令的频率该为每秒一次</span><br><span class="line">    if ((ri-&gt;flags &amp; SRI_SLAVE) &amp;&amp;</span><br><span class="line">        (ri-&gt;master-&gt;flags &amp; (SRI_O_DOWN|SRI_FAILOVER_IN_PROGRESS))) &#123;</span><br><span class="line">        info_period = 1000;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        info_period = SENTINEL_INFO_PERIOD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* We ping instances every time the last received pong is older than</span><br><span class="line">     * the configured &#x27;down-after-milliseconds&#x27; time, but every second</span><br><span class="line">     * anyway if &#x27;down-after-milliseconds&#x27; is greater than 1 second. */</span><br><span class="line">    ping_period = ri-&gt;down_after_period;</span><br><span class="line">    if (ping_period &gt; SENTINEL_PING_PERIOD) ping_period = SENTINEL_PING_PERIOD;</span><br><span class="line"></span><br><span class="line">    // 实例不是 Sentinel （主服务器或者从服务器）</span><br><span class="line">    // 并且以下条件的其中一个成立：</span><br><span class="line">    // 1）SENTINEL 未收到过这个服务器的 INFO 命令回复</span><br><span class="line">    // 2）距离上一次该实例回复 INFO 命令已经超过 info_period 间隔</span><br><span class="line">    // 那么向实例发送 INFO 命令</span><br><span class="line">    if ((ri-&gt;flags &amp; SRI_SENTINEL) == 0 &amp;&amp;</span><br><span class="line">        (ri-&gt;info_refresh == 0 ||</span><br><span class="line">        (now - ri-&gt;info_refresh) &gt; info_period))</span><br><span class="line">    &#123;</span><br><span class="line">        /* Send INFO to masters and slaves, not sentinels. */</span><br><span class="line">        retval = redisAsyncCommand(ri-&gt;cc,</span><br><span class="line">            sentinelInfoReplyCallback, NULL, &quot;INFO&quot;);</span><br><span class="line">        if (retval == REDIS_OK) ri-&gt;pending_commands++;</span><br><span class="line">    &#125; else if ((now - ri-&gt;last_pong_time) &gt; ping_period) &#123;</span><br><span class="line">        /* Send PING to all the three kinds of instances. */</span><br><span class="line">        sentinelSendPing(ri);</span><br><span class="line">    &#125; else if ((now - ri-&gt;last_pub_time) &gt; SENTINEL_PUBLISH_PERIOD) &#123;</span><br><span class="line">        /* PUBLISH hello messages to all the three kinds of instances. */</span><br><span class="line">        sentinelSendHello(ri);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="从主观下线到客观下线"><a href="#从主观下线到客观下线" class="headerlink" title="从主观下线到客观下线"></a>从主观下线到客观下线</h3><ul>
<li>如果一个主服务器被标记为<strong>主观下线</strong>， 那么正在监视这个主服务器的所有 Sentinel 要以每秒一次的频率确认主服务器的确进入了主观下线状态。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">/* Perform scheduled operations for the specified Redis instance. */</span><br><span class="line">// 对给定的实例执行定期操作</span><br><span class="line">void sentinelHandleRedisInstance(sentinelRedisInstance *ri) &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    /* ============== ACTING HALF ============= */</span><br><span class="line">    /* ==============  故障检测   ============= */</span><br><span class="line"></span><br><span class="line">    /* We don&#x27;t proceed with the acting half if we are in TILT mode.</span><br><span class="line">     * TILT happens when we find something odd with the time, like a</span><br><span class="line">     * sudden change in the clock. */</span><br><span class="line">    // 如果 Sentinel 处于 TILT 模式，那么不执行故障检测。</span><br><span class="line">    if (sentinel.tilt) &#123;</span><br><span class="line"></span><br><span class="line">        // 如果 TILI 模式未解除，那么不执行动作</span><br><span class="line">        if (mstime()-sentinel.tilt_start_time &lt; SENTINEL_TILT_PERIOD) return;</span><br><span class="line"></span><br><span class="line">        // 时间已过，退出 TILT 模式</span><br><span class="line">        sentinel.tilt = 0;</span><br><span class="line">        sentinelEvent(REDIS_WARNING,&quot;-tilt&quot;,NULL,&quot;#tilt mode exited&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Every kind of instance */</span><br><span class="line">    // 检查给定实例是否进入 SDOWN 状态</span><br><span class="line">    sentinelCheckSubjectivelyDown(ri);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* Is this instance down from our point of view? */</span><br><span class="line">// 检查实例是否已下线（从本 Sentinel 的角度来看）</span><br><span class="line">void sentinelCheckSubjectivelyDown(sentinelRedisInstance *ri) &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    /* Update the SDOWN flag. We believe the instance is SDOWN if:</span><br><span class="line">     *</span><br><span class="line">     * 更新 SDOWN 标识。如果以下条件被满足，那么 Sentinel 认为实例已下线：</span><br><span class="line">     *</span><br><span class="line">     * 1) It is not replying.</span><br><span class="line">     *    它没有回应命令</span><br><span class="line">     * 2) We believe it is a master, it reports to be a slave for enough time</span><br><span class="line">     *    to meet the down_after_period, plus enough time to get two times</span><br><span class="line">     *    INFO report from the instance. </span><br><span class="line">     *    Sentinel 认为实例是主服务器，这个服务器向 Sentinel 报告它将成为从服务器，</span><br><span class="line">     *    但在超过给定时限之后，服务器仍然没有完成这一角色转换。</span><br><span class="line">     */</span><br><span class="line">    if (elapsed &gt; ri-&gt;down_after_period ||</span><br><span class="line">        (ri-&gt;flags &amp; SRI_MASTER &amp;&amp;</span><br><span class="line">         ri-&gt;role_reported == SRI_SLAVE &amp;&amp;</span><br><span class="line">         mstime() - ri-&gt;role_reported_time &gt;</span><br><span class="line">          (ri-&gt;down_after_period+SENTINEL_INFO_PERIOD*2)))</span><br><span class="line">    &#123;</span><br><span class="line">        /* Is subjectively down */</span><br><span class="line">        if ((ri-&gt;flags &amp; SRI_S_DOWN) == 0) &#123;</span><br><span class="line">            // 发送事件</span><br><span class="line">            sentinelEvent(REDIS_WARNING,&quot;+sdown&quot;,ri,&quot;%@&quot;);</span><br><span class="line">            // 记录进入 SDOWN 状态的时间</span><br><span class="line">            ri-&gt;s_down_since_time = mstime();</span><br><span class="line">            // 打开 SDOWN 标志</span><br><span class="line">            ri-&gt;flags |= SRI_S_DOWN;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 移除（可能有的） SDOWN 状态</span><br><span class="line">        /* Is subjectively up */</span><br><span class="line">        if (ri-&gt;flags &amp; SRI_S_DOWN) &#123;</span><br><span class="line">            // 发送事件</span><br><span class="line">            sentinelEvent(REDIS_WARNING,&quot;-sdown&quot;,ri,&quot;%@&quot;);</span><br><span class="line">            // 移除相关标志</span><br><span class="line">            ri-&gt;flags &amp;= ~(SRI_S_DOWN|SRI_SCRIPT_KILL_SENT);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
如果有足够数量的 Sentinel （至少要达到配置文件指定的数量）在指定的时间范围内同意这一判断， 那么这个主服务器被标记为<strong>客观下线</strong>。<br>这个数量是可以配置的，即<strong>quorum</strong>的数量。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/* Perform scheduled operations for the specified Redis instance. */</span><br><span class="line">// 对给定的实例执行定期操作</span><br><span class="line">void sentinelHandleRedisInstance(sentinelRedisInstance *ri) &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    /* ============== ACTING HALF ============= */</span><br><span class="line">    /* ==============  故障检测   ============= */</span><br><span class="line">    </span><br><span class="line">    ...这里省略SDOWN检测代码</span><br><span class="line"></span><br><span class="line">    /* Only masters */</span><br><span class="line">    /* 对主服务器进行处理 */</span><br><span class="line">    if (ri-&gt;flags &amp; SRI_MASTER) &#123;</span><br><span class="line"></span><br><span class="line">        // 判断 master 是否进入 ODOWN 状态</span><br><span class="line">        sentinelCheckObjectivelyDown(ri);</span><br><span class="line"></span><br><span class="line">        // 如果主服务器进入了 ODOWN 状态，那么开始一次故障转移操作</span><br><span class="line">        if (sentinelStartFailoverIfNeeded(ri))</span><br><span class="line">            // 强制向其他 Sentinel 发送 SENTINEL is-master-down-by-addr 命令</span><br><span class="line">            // 刷新其他 Sentinel 关于主服务器的状态</span><br><span class="line">            sentinelAskMasterStateToOtherSentinels(ri,SENTINEL_ASK_FORCED);</span><br><span class="line"></span><br><span class="line">        // 执行故障转移</span><br><span class="line">        sentinelFailoverStateMachine(ri);</span><br><span class="line"></span><br><span class="line">        // 如果有需要的话，向其他 Sentinel 发送 SENTINEL is-master-down-by-addr 命令</span><br><span class="line">        // 刷新其他 Sentinel 关于主服务器的状态</span><br><span class="line">        // 这一句是对那些没有进入 if(sentinelStartFailoverIfNeeded(ri)) &#123; /* ... */ &#125;</span><br><span class="line">        // 语句的主服务器使用的</span><br><span class="line">        sentinelAskMasterStateToOtherSentinels(ri,SENTINEL_NO_FLAGS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在一般情况下， 每个 Sentinel 会以每 10 秒一次的频率向它已知的所有主服务器和从服务器发送 <code>INFO 命令</code>。 当一个主服务器被 Sentinel 标记为客观下线时， Sentinel 向下线主服务器的所有从服务器发送 INFO 命令的频率会从 10 秒一次改为每秒一次。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">void sentinelSendPeriodicCommands(sentinelRedisInstance *ri) &#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    /* If this is a slave of a master in O_DOWN condition we start sending</span><br><span class="line">     * it INFO every second, instead of the usual SENTINEL_INFO_PERIOD</span><br><span class="line">     * period. In this state we want to closely monitor slaves in case they</span><br><span class="line">     * are turned into masters by another Sentinel, or by the sysadmin. */</span><br><span class="line">    // 对于从服务器来说， sentinel 默认每 SENTINEL_INFO_PERIOD 秒向它发送一次 INFO 命令</span><br><span class="line">    // 但是，当从服务器的主服务器处于 SDOWN 状态，或者正在执行故障转移时</span><br><span class="line">    // 为了更快速地捕捉从服务器的变动， sentinel 会将发送 INFO 命令的频率该为每秒一次</span><br><span class="line">    if ((ri-&gt;flags &amp; SRI_SLAVE) &amp;&amp;</span><br><span class="line">        (ri-&gt;master-&gt;flags &amp; (SRI_O_DOWN|SRI_FAILOVER_IN_PROGRESS))) &#123;</span><br><span class="line">        info_period = 1000;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        info_period = SENTINEL_INFO_PERIOD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    // 实例不是 Sentinel （主服务器或者从服务器）</span><br><span class="line">    // 并且以下条件的其中一个成立：</span><br><span class="line">    // 1）SENTINEL 未收到过这个服务器的 INFO 命令回复</span><br><span class="line">    // 2）距离上一次该实例回复 INFO 命令已经超过 info_period 间隔</span><br><span class="line">    // 那么向实例发送 INFO 命令</span><br><span class="line">    if ((ri-&gt;flags &amp; SRI_SENTINEL) == 0 &amp;&amp;</span><br><span class="line">        (ri-&gt;info_refresh == 0 ||</span><br><span class="line">        (now - ri-&gt;info_refresh) &gt; info_period))</span><br><span class="line">    &#123;</span><br><span class="line">        /* Send INFO to masters and slaves, not sentinels. */</span><br><span class="line">        retval = redisAsyncCommand(ri-&gt;cc,</span><br><span class="line">            sentinelInfoReplyCallback, NULL, &quot;INFO&quot;);</span><br><span class="line">        if (retval == REDIS_OK) ri-&gt;pending_commands++;</span><br><span class="line">    &#125; else if</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
注意上边发请求时使用的回调函数<code>sentinelInfoReplyCallback</code>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 处理 INFO 命令的回复</span><br><span class="line">void sentinelInfoReplyCallback(redisAsyncContext *c, void *reply, void *privdata) &#123;</span><br><span class="line">    sentinelRedisInstance *ri = c-&gt;data;</span><br><span class="line">    redisReply *r;</span><br><span class="line"></span><br><span class="line">    if (ri) ri-&gt;pending_commands--;</span><br><span class="line">    if (!reply || !ri) return;</span><br><span class="line">    r = reply;</span><br><span class="line"></span><br><span class="line">    if (r-&gt;type == REDIS_REPLY_STRING) &#123;</span><br><span class="line">        // 解析info命令的响应数据</span><br><span class="line">        sentinelRefreshInstanceInfo(ri,r-&gt;str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>当没有足够数量的 Sentinel 同意主服务器已经下线，主服务器的客观下线状态就会被移除。<br>当主服务器重新向 Sentinel 的 PING 命令返回有效回复时，主服务器的主观下线状态就会被移除。</li>
</ul>
<h3 id="故障转移-选举-Sentinel-Leader"><a href="#故障转移-选举-Sentinel-Leader" class="headerlink" title="故障转移 - 选举 Sentinel Leader"></a>故障转移 - 选举 Sentinel Leader</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">void sentinelHandleRedisInstance(sentinelRedisInstance *ri) &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    /* ============== ACTING HALF ============= */</span><br><span class="line">    /* ==============  故障检测   ============= */</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    /* Only masters */</span><br><span class="line">    /* 对主服务器进行处理 */</span><br><span class="line">    if (ri-&gt;flags &amp; SRI_MASTER) &#123;</span><br><span class="line"></span><br><span class="line">        // 判断 master 是否进入 ODOWN 状态</span><br><span class="line">        sentinelCheckObjectivelyDown(ri);</span><br><span class="line"></span><br><span class="line">        // 如果主服务器进入了 ODOWN 状态，那么开始一次故障转移操作</span><br><span class="line">        if (sentinelStartFailoverIfNeeded(ri))</span><br><span class="line">            // 强制向其他 Sentinel 发送 SENTINEL is-master-down-by-addr 命令</span><br><span class="line">            // 刷新其他 Sentinel 关于主服务器的状态</span><br><span class="line">            sentinelAskMasterStateToOtherSentinels(ri,SENTINEL_ASK_FORCED);</span><br><span class="line"></span><br><span class="line">        // 执行故障转移</span><br><span class="line">        sentinelFailoverStateMachine(ri);</span><br><span class="line"></span><br><span class="line">        // 如果有需要的话，向其他 Sentinel 发送 SENTINEL is-master-down-by-addr 命令</span><br><span class="line">        // 刷新其他 Sentinel 关于主服务器的状态</span><br><span class="line">        // 这一句是对那些没有进入 if(sentinelStartFailoverIfNeeded(ri)) &#123; /* ... */ &#125;</span><br><span class="line">        // 语句的主服务器使用的</span><br><span class="line">        sentinelAskMasterStateToOtherSentinels(ri,SENTINEL_NO_FLAGS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="状态感知（info）"><a href="#状态感知（info）" class="headerlink" title="状态感知（info）"></a>状态感知（info）</h2><p>Sentinel服务器只需配置Master的地址，其他Slave的信息是通过定时（10秒）向Master发送info命令来获取的，info命令返回的信息中，包含了主从拓扑关系，其中包括每个slave的地址和端口号。有了这些信息后，哨兵就会记住这些节点的拓扑信息，在后续发生故障时，选择合适的slave节点进行故障恢复。<br>哨兵除了向master发送info之外，还会向每个master节点特殊的<code>pubsub</code>中发送master当前的状态信息和哨兵自身的信息，其他哨兵节点通过订阅这个pubsub，就可以拿到每个哨兵发来的信息。这么做的目的主要有2个：</p>
<ul>
<li>哨兵节点可以发现其他哨兵的加入，进而方便多个哨兵节点通信，为后续共同协商提供基础</li>
<li>与其他哨兵节点交换master的状态信息，为后续判断master是否故障提供依据</li>
</ul>
<h2 id="心跳检测（ping）"><a href="#心跳检测（ping）" class="headerlink" title="心跳检测（ping）"></a>心跳检测（ping）</h2><p>故障发生时，需要立即启动故障恢复机制，那么Sentinel怎么及时地知道哪些节点发生故障了呢？这主要是通过向所有其他节点发送<code>PING命令</code>来实现的。<br>每个哨兵节点每隔1秒向master、slave、其他哨兵节点发送ping命令，如果对方能在指定时间内响应，说明节点健康存活。如果未在规定时间内（可配置）响应，那么该哨兵节点认为此节点<strong>主观下线</strong>。</p>
<blockquote>
<p>至于Sentinel怎么知道其他节点的地址，其实就是通过前面提到的info命令来感知的。</p>
</blockquote>
<h2 id="主观下线和客观下线"><a href="#主观下线和客观下线" class="headerlink" title="主观下线和客观下线"></a>主观下线和客观下线</h2><ul>
<li>主观下线（Subjectively Down， 简称 SDOWN）<br>主观下线指的是单个 Sentinel 实例对服务器做出的下线判断。<br>如果一个服务器没有在 <code>master-down-after-milliseconds</code> 选项所指定的时间内， 对向它发送 <code>PING 命令</code>的 Sentinel 返回一个有效回复（有效回复只有+PONG、-LOADING 错误或 -MASTERDOWN 错误）， 那么 Sentinel 就会将这个服务器标记为主观下线。<blockquote>
<p>注意是在<code>master-down-after-milliseconds</code>时间内一直返回无效回复。</p>
</blockquote>
</li>
<li>客观下线（Objectively Down， 简称 ODOWN）<br>客观下线指的是多个 Sentinel 实例在对同一个 Master 做出 SDOWN 判断， 并且通过 SENTINEL <code>is-master-down-by-addr</code> 命令互相交流之后，得出的服务器下线判断。 （一个 Sentinel 可以通过向另一个 Sentinel 发送 SENTINEL is-master-down-by-addr 命令来询问对方是否认为给定的服务器已下线。）<br>从主观下线切换到客观下线并不是通过较严格的投票算法，而是采用了<strong>流言协议（gossip protocol）</strong>：只要 Sentinel 在给定时间内从其他 Sentinel 接收到足够数量的 Master 下线通知，那么 Sentinel 就会执行状态的切换；如果之后其他 Sentinel 不再报告 Master 已下线，则客观下线状态就会被移除。<br>只要一个 Sentinel 发现某个 Master 进入客观下线状态，之后就会进入<strong>故障迁移</strong>阶段，选举出一个 Sentinel 对失效的 Master 执行自动故障迁移操作。<blockquote>
<p>客观下线只适用于 Master，对 Slave 或 Sentinel 则不会达到客观下线状态。</p>
</blockquote>
</li>
</ul>
<h2 id="故障迁移（Master-挂掉，Sentinel选举新Master）"><a href="#故障迁移（Master-挂掉，Sentinel选举新Master）" class="headerlink" title="故障迁移（Master 挂掉，Sentinel选举新Master）"></a>故障迁移（Master 挂掉，Sentinel选举新Master）</h2><p>单纯的主从架构并不能挽救 Master 挂掉的情况，因此引入了 Sentinel 集群。Sentinel 会不断地检查集群主服务器和从服务器是否运作正常，并在超过 n 个 Sentinel 同意后判断主节点失效（配置<code>sentinel monitor mymaster 127.0.0.1 6379 2</code>表示这个n&#x3D;2），不过要注意，无论设置多少个 Sentinel 同意才能判断一个服务器失效， 一个 Sentinel 都需要获得系统中多数 Sentinel 的支持， 才能发起一次自动故障迁移。</p>
<ul>
<li>当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作，它会将失效主服务器的其中一个从服务器升级为新的主服务器，并让失效主服务器的其他从服务器改为复制新的主服务器；</li>
<li>当客户端试图连接失效的主服务器时，集群也会向客户端返回新主服务器的地址，使得集群可以使用新主服务器代替失效服务器。</li>
</ul>
<p>故障转移主要分为Sentinel选举和故障转移（Master替换）两个步骤，Sentinel选主流程如下：</p>
<ul>
<li>Sentinel发现主服务器已经进入客观下线状态。</li>
<li>利用<code>Raft leader election</code>算法选举 Sentinel 中的 Leader，对我们的当前 epoch 进行自增， 并尝试在这个epoch中当选，之后，所有 Sentinel 都以更高的 epoch 为准，并主动用更新的 epoch 代替自己的配置。</li>
<li>如果当选失败， 那么在设定的故障迁移超时时间的两倍之后，重新尝试当选。 如果当选成功， 那么执行Slave的选主。</li>
</ul>
<h3 id="Slave选举"><a href="#Slave选举" class="headerlink" title="Slave选举"></a>Slave选举</h3><p>Slave选举的规则如下：</p>
<ul>
<li>在失效主服务器属下的从服务器当中， 那些被标记为主观下线、已断线、或者最后一次回复 PING 命令的时间大于五秒钟的从服务器都会被淘汰。</li>
<li>在失效主服务器属下的从服务器当中， 那些与失效主服务器连接断开的时长超过 down-after 选项指定的时长十倍的从服务器都会被淘汰。</li>
<li>在经历了以上两轮淘汰之后剩下来的从服务器中， 我们选出复制偏移量（replication offset）最大的那个从服务器作为新的主服务器； 如果复制偏移量不可用， 或者从服务器的复制偏移量相同， 那么带有最小运行 ID 的那个从服务器成为新的主服务器。</li>
</ul>
<p>也就是说，多个Slave的优先级按照：slave-priority配置 &gt; 数据完整性 &gt; runid较小者进行选择。</p>
<p>之后所有Sentinel要进行投票选出一个Leader：<br><img src="/imgs/Redis/RedisSentinel%E6%8A%95%E7%A5%A8.jpg" alt="RedisSentinel投票" title="RedisSentinel投票"></p>
<p>选出Leader后，Leader需要从现有的Slave中选出</p>
<h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h3><p>提升新的Master的流程如下：</p>
<ul>
<li>向被选中的从服务器发送 SLAVEOF NO ONE 命令，让它转变为主服务器。</li>
<li>通过发布与订阅功能， 将更新后的配置传播给所有其他 Sentinel ， 其他 Sentinel 对它们自己的配置进行更新。</li>
<li>向已下线主服务器的从服务器发送 SLAVEOF 命令， 让它们去复制新的主服务器。</li>
<li>当所有从服务器都已经开始复制新的主服务器时， 领头 Sentinel 终止这次故障迁移操作。</li>
</ul>
<p>客户端感知新master流程如下：<br>哨兵在故障切换完成之后，会向自身节点的指定pubsub中写入一条信息，客户端可以订阅这个pubsub来感知master的变化通知。我们的客户端也可以通过在哨兵节点主动查询当前最新的master，来拿到最新的master地址。<br>另外，哨兵还提供了“钩子”机制，我们也可以在哨兵配置文件中配置一些脚本逻辑，在故障切换完成时，触发“钩子”逻辑，通知客户端发生了切换，让客户端重新在哨兵上获取最新的master地址。<br>一般来说，推荐采用第一种方式进行处理，很多客户端SDK中已经集成好了从哨兵节点获取最新master的方法，我们直接使用即可。</p>
<h2 id="Sentinel-选举的安全性"><a href="#Sentinel-选举的安全性" class="headerlink" title="Sentinel 选举的安全性"></a>Sentinel 选举的安全性</h2><p>配置安全性：</p>
<ul>
<li>每当一个 Redis 实例被重新配置（reconfigured） —— 无论是被设置成主服务器、从服务器、又或者被设置成其他主服务器的从服务器 —— Sentinel 都会向被重新配置的实例发送一个 CONFIG REWRITE 命令， 从而确保这些配置会持久化在硬盘里。完成重新配置之后，从服务器会去复制正确的主服务器。</li>
<li>Sentinel 的状态会被持久化到 Sentinel 配置文件里，当 Sentinel 接收到新配置或 Leader Sentinel 为 Master 创建一个新配置时，这些配置都会与<code>epoch</code>一起被保存到磁盘；</li>
</ul>
<p>故障自动迁移的一致性：</p>
<ul>
<li>Raft 算法保证在一个 epoch 里只有一个 Leader Sentinel 产生，减少了脑裂的风险；</li>
<li>Sentinel 集群总是以更高的 epoch 为准，因为发生<code>网络分区（network partition）</code>时可能会有 Sentinel 包含老的配置，而当这个 Sentinel 服务器接收到其他 Sentinel 的版本更新配置时就会进行更新。</li>
<li>发生网络分区并且某些 Sentinel 仍在采用老的配置时，如果有客户端连接到这些 Sentinel 上，最终可能就会将请求转发到非 Master 服务器上，造成数据不一致。因此，应该使用 <code>min-slaves-to-write</code> 选项， 让主服务器在连接的从实例少于给定数量时停止执行写操作， 与此同时， 应该在每个运行 Redis 主服务器或从服务器的机器上运行 Redis Sentinel 进程。</li>
</ul>
<h2 id="Sentinel-故障迁移的实时性"><a href="#Sentinel-故障迁移的实时性" class="headerlink" title="Sentinel 故障迁移的实时性"></a>Sentinel 故障迁移的实时性</h2><p>故障迁移虽然能提供主从切换来保证挂掉的Master能被其他Slave顶替上来，但是这个顶替过程大概需要多长时间呢？具体又是哪些步骤会比较耗时？</p>
<ol>
<li><p>判断Master下线<br>Sentinel会PING Master，如果距离上次PING成功的时间超过了<code>master-down-after-milliseconds</code>时间，则表示主观下线了。<br>将Master标记为SDOWN后，这个Sentinel会通过发事件消息来通知其他Sentinel。</p>
<blockquote>
<p>Cluster中是通过gossip协议来通知其他节点的。</p>
</blockquote>
</li>
<li><p>重新选主</p>
</li>
<li><p>Slave提升</p>
</li>
</ol>
<p>这个实时性的讨论并不是纯粹的极客行为，因为切换要多长时间是评估我们服务可用性的重要指标，并且提供后续优化的指导方向。</p>
<h2 id="TILT-模式"><a href="#TILT-模式" class="headerlink" title="TILT 模式"></a>TILT 模式</h2><p>TILT 模式是一种特殊的保护模式，Sentinel 每隔 100ms 会向实例发一次<code>PING</code>命令，并将上一次 PING 成功的时间和当前时间比对，从而知道与该实例有多长时间没有进行任何成功通讯：</p>
<ul>
<li>如果两次调用时间之间的差距为负值， 或者非常大（超过 2 秒钟）， 那么 Sentinel 进入 TILT 模式。</li>
<li>如果 Sentinel 已经进入 TILT 模式， 那么 Sentinel 延迟退出 TILT 模式的时间。<blockquote>
<p>Sentinel严重依赖计算机的时间功能，一旦计算机的时间功能出现故障， 或者计算机非常忙碌， 又或者进程因为某些原因而被阻塞时， Sentinel 可能也会跟着出现故障。</p>
</blockquote>
</li>
</ul>
<p>进入 TILT 模式后，Sentinel 仍然会继续监视所有目标，但是：</p>
<ul>
<li>它不再执行任何操作，比如故障转移。</li>
<li>当有实例向这个 Sentinel 发送 SENTINEL <code>is-master-down-by-addr</code> 命令时， Sentinel 返回负值： 因为这个 Sentinel 所进行的下线判断已经不再准确。</li>
</ul>
<p>TILT 相当于降级，如果 Sentinel 可以在 TILT 模式下正常维持 30s，那么 Sentinel 会退出 TILT 模式。</p>
<h2 id="BUSY-状态"><a href="#BUSY-状态" class="headerlink" title="BUSY 状态"></a>BUSY 状态</h2><p>当 Lus 脚本执行时间超过阈值，Redis 会返回<code>BUSY</code>错误，当出现这种情况时， Sentinel 在尝试执行故障转移操作之前， 会先向服务器发送一个 <code>SCRIPT KILL</code> 命令， 如果服务器正在执行的是一个只读脚本的话， 那么这个脚本就会被杀死， 服务器就会回到正常状态。</p>
<h2 id="脑裂"><a href="#脑裂" class="headerlink" title="脑裂"></a>脑裂</h2><p>虽然Sentinel利用Raft选举不会发生脑裂，但是在一些极端的情况下还是有可能会发生脑裂的，比如：</p>
<ol>
<li>原Master不能提供服务了，但是它本身并没有挂掉；</li>
<li>Sentinel发现连不上Master，于是判定客观下线，并发起主从切换；</li>
<li>原Master和新Master同时给Client提供服务，发生脑裂。</li>
</ol>
<p>这种脑裂并不会影响可用性，但是却破坏了数据的一致性，甚至会导致数据丢失：在Sentinel重连上原Master后，会将其归入到新Master的Slave，这时脑裂期间的数据就会被从新Master上复制过来的数据覆盖掉了，导致数据的丢失。</p>
<p>脑裂的解决办法主要是以下两个配置参数：</p>
<ul>
<li>min-slaves-to-write：这个配置项设置了主库能进行数据同步的最少从库数量；</li>
<li>min-slaves-max-lag：这个配置项设置了主从库间进行数据复制时，从库给主库发送 ACK 消息的最大延迟（以秒为单位）。</li>
</ul>
<h2 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h2><h3 id="5个哨兵的集群，quorum设置为2，在运行过程中，有3个实例都发生了故障，这时主库也发生了故障，还能正确判断主库的客观下线吗？还能执行主从的自动切换吗？"><a href="#5个哨兵的集群，quorum设置为2，在运行过程中，有3个实例都发生了故障，这时主库也发生了故障，还能正确判断主库的客观下线吗？还能执行主从的自动切换吗？" class="headerlink" title="5个哨兵的集群，quorum设置为2，在运行过程中，有3个实例都发生了故障，这时主库也发生了故障，还能正确判断主库的客观下线吗？还能执行主从的自动切换吗？"></a>5个哨兵的集群，quorum设置为2，在运行过程中，有3个实例都发生了故障，这时主库也发生了故障，还能正确判断主库的客观下线吗？还能执行主从的自动切换吗？</h3><p>判断客户端下线是可以的，因为判断ODOWN的条件是有不少于quorum数量的Sentinel同意即可。<br>不可执行主从切换，因为一个哨兵要执行主从切换，得获得半数以上哨兵的投票同意，也就是3个哨兵。</p>
<h3 id="哨兵实例是不是越多越好？"><a href="#哨兵实例是不是越多越好？" class="headerlink" title="哨兵实例是不是越多越好？"></a>哨兵实例是不是越多越好？</h3><p>哨兵实例越多，误判率越低，但是判断主库下线和选举Leader时实例要拿到的赞成票也越多，主从切换花费的时间也相对会更多。<br>如果客户端对Redis的响应时间有要求，则很有可能会报警。</p>
<h3 id="调大down-after-milliseconds对减少误判是不是有好处？"><a href="#调大down-after-milliseconds对减少误判是不是有好处？" class="headerlink" title="调大down-after-milliseconds对减少误判是不是有好处？"></a>调大down-after-milliseconds对减少误判是不是有好处？</h3><p>这个值的作用是：判断距离上次PING成功的时间超过了这个值，就标记实例主观下线。<br>调大的话Sentinel需要更长的时间才能判断集群出问题了，也即影响到Redis的可用性。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a target="_blank" rel="noopener" href="http://redisdoc.com/topic/sentinel.html">Sentinel</a></li>
</ol>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/fb6b62e.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tallate">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tallate">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/fb6b62e.html" class="post-title-link" itemprop="url">Redis高可用方案Cluster</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-09-22 12:21:48" itemprop="dateCreated datePublished" datetime="2019-09-22T12:21:48+08:00">2019-09-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-07 01:56:20" itemprop="dateModified" datetime="2025-07-07T01:56:20+08:00">2025-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%93%E5%AD%98/" itemprop="url" rel="index"><span itemprop="name">缓存</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>

<h2 id="Redis-Cluster介绍"><a href="#Redis-Cluster介绍" class="headerlink" title="Redis Cluster介绍"></a>Redis Cluster介绍</h2><h3 id="Cluster-优势"><a href="#Cluster-优势" class="headerlink" title="Cluster 优势"></a>Cluster 优势</h3><ol>
<li>线性的可扩展性：扩容即迁移槽，已有很多迁移案例；<br>如果要保存更多的数据，可以直接增加Master来支持，比如每台Master存32G，要完美存下1T数据的话，可以设置32台的Master，当然实际情况下这样非常浪费，一般会少设置一些，只用几台Master来存储最热的数据。</li>
<li>没有合并操作：因为 Redis 中的 List 和 Set 中保存的 Value 通常是比较大的，可能会达数以百万计的元素，而它们可能被存储到了不同的 Redis 实例上，传输和合并这样的值将很容易称为一个主要的性能瓶颈；</li>
<li>写入安全（Write Safety）：只有在非常少见的 Master 宕机的情况下，写入才会失败，并且这个失败的时间窗口不大（由一个 Slave 顶替上来）；</li>
<li>可用性（Availability）：就算有部分 Master 不可用了，它们的 Slave 仍然可以通过选举提升为 Master。</li>
</ol>
<h3 id="Cluster-缺点"><a href="#Cluster-缺点" class="headerlink" title="Cluster 缺点"></a>Cluster 缺点</h3><ol>
<li>Redis 集群并不支持处理多个 keys 的命令，因为这需要在不同的节点间移动数据，从而达不到像 Redis 那样的性能，在高负载的情况下可能会导致不可预料的错误。</li>
<li>Redis 集群不像单机版本的 Redis 那样支持多个数据库，集群只有数据库 0，而且也不支持 SELECT 命令。</li>
</ol>
<h3 id="Cluster的去中心化架构"><a href="#Cluster的去中心化架构" class="headerlink" title="Cluster的去中心化架构"></a>Cluster的去中心化架构</h3><p><img src="/imgs/Redis/Cluster.png" alt="Cluster" title="Cluster"><br>redis cluster在设计的时候，就考虑到了<strong>去中心化</strong>，去中间件，也就是说，集群中的每个节点都是平等的关系，都是对等的，每个节点都保存各自的数据和整个集群的状态。<strong>所有的 redis 节点彼此互联(PING-PONG 机制)<strong>，内部使用</strong>二进制协议</strong>优化传输速度和带宽，而且这些连接保持活跃，这样就保证了我们只需要连接集群中的任意一个节点，就可以获取到其他节点的数据。客户端与 redis 节点直连，不需要中间 proxy 层，客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可。</p>
<h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>Redis 不能保证强一致性，因为：</p>
<ol>
<li>异步复制：写操作会被异步复制到 slave 节点，但可能由于出现网络分区、脑裂而导致数据丢失。<br><img src="/imgs/Redis/%E7%BD%91%E7%BB%9C%E5%88%86%E5%8C%BA.png" alt="网络分区" title="网络分区"><br>如上图所示，客户端 Z1 向 Master-B 写入数据后，集群出现了网络分区，且分区持续的时间足够长导致此时 B1 被选举为新的 Master，则在此期间 Z1 向 B 写入的数据就都丢失了。<blockquote>
<p>网络分区出现期间，客户端 Z1 可以向主节点 B 发送写命令的最大时间是有限制的， 这一时间限制称为节点超时时间（node timeout）， 是 Redis 集群的一个重要的配置选项。</p>
</blockquote>
</li>
</ol>
<h3 id="Cluster-VS-Codis"><a href="#Cluster-VS-Codis" class="headerlink" title="Cluster VS Codis"></a>Cluster VS Codis</h3><p>Codis 集群中包含了 4 类关键组件。</p>
<ul>
<li>codis server：这是进行了二次开发的 Redis 实例，其中增加了额外的数据结构，支持数据迁移操作，主要负责处理具体的数据读写请求。</li>
<li>codis proxy：接收客户端请求，并把请求转发给 codis server。</li>
<li>Zookeeper 集群：保存集群元数据，例如数据位置信息和 codis proxy 信息。</li>
<li>codis dashboard 和 codis fe：共同组成了集群管理工具。其中，codis dashboard 负责执行集群管理工作，包括增删 codis server、codis proxy 和进行数据迁移。而 codis fe 负责提供 dashboard 的 Web 操作界面，便于我们直接在 Web 界面上进行集群管理。</li>
</ul>
<p>Codis如何处理一次请求：</p>
<ol>
<li>客户端连接Codis Proxy，将请求发给Proxy；</li>
<li>codis proxy 接收到请求，就会查询请求数据和 codis server 的映射关系，并把请求转发给相应的 codis server 进行处理</li>
<li>当 codis server 处理完请求后，会把结果返回给 codis proxy，proxy 再把数据返回给客户端。</li>
</ol>
<p>以4个方面来讨论</p>
<ul>
<li>数据分布<br>和Cluster类似，Codis将数据保存到slot，集群一共有1024个slot，需要手动分配给Codis Server，或者由dashboard自动分配。<br>当客户端要读写数据时，会使用CRC32算法计算key的哈希值，并对1024取模，就可以知道对应的是哪个slot了。<br>这个路由规则需要先配置到dashboard，dashboard会把路由表发送给codis proxy，并同时保存到ZooKeeper。<br>而Cluster的数据路由表是由每个实例管理的，如果发生变化，这些实例会通过Gossip协议来互相传播，如果实例比较多，就会占用比较多的网络资源。</li>
<li>集群扩容和数据迁移<br>如果要增加Codis Server来负载slot，需要配置要迁移的slot，Codis Server会将该slot中的数据<strong>一个一个</strong>地发送给目标Server。<br>增加Codis Proxy也是类似的流程。</li>
<li>客户端兼容性<br>Codis客户端直接和Codis Proxy连接，codis proxy 是和单实例客户端兼容的，而集群相关的管理工作又都是由Codis Proxy和Codis dashboard这些组件来完成的，不需要客户端参与。</li>
<li>可靠性保证<br>Codis Server保证可靠性：Codis Server本身是Redis实例，只是增加了集群相关的操作命令，可靠性是可以通过主从机制+哨兵来实现的。<br>Codis Proxy的可靠性：Proxy上的信息都来自ZooKeeper，例如路由表，只要ZooKeeper集群中实例半数以上可以正常工作，那么ZooKeeper集群就是正常的。</li>
</ul>
<p>比较：<br><img src="/imgs/Redis/RedisCluster%E6%AF%94%E5%AF%B9Codis.jpg" alt="RedisCluster比对Codis" title="RedisCluster比对Codis"></p>
<ul>
<li>从稳定性和成熟度来看，Codis 应用得比较早，在业界已经有了成熟的生产部署。虽然 Codis 引入了 proxy 和 Zookeeper，增加了集群复杂度，但是，proxy 的无状态设计和 Zookeeper 自身的稳定性，也给 Codis 的稳定使用提供了保证。而 Redis Cluster 的推出时间晚于 Codis，相对来说，成熟度要弱于 Codis，如果你想选择一个成熟稳定的方案，Codis 更加合适些。</li>
<li>从业务应用客户端兼容性来看，连接单实例的客户端可以直接连接 codis proxy，而原本连接单实例的客户端要想连接 Redis Cluster 的话，就需要开发新功能。所以，如果你的业务应用中大量使用了单实例的客户端，而现在想应用切片集群的话，建议你选择 Codis，这样可以避免修改业务应用中的客户端。</li>
<li>从使用 Redis 新命令和新特性来看，Codis server 是基于开源的 Redis 3.2.8 开发的，所以，Codis 并不支持 Redis 后续的开源版本中的新增命令和数据类型。另外，Codis 并没有实现开源 Redis 版本的所有命令，比如 BITOP、BLPOP、BRPOP，以及和与事务相关的 MUTLI、EXEC 等命令。Codis 官网上列出了不被支持的命令列表，你在使用时记得去核查一下。所以，如果你想使用开源 Redis 版本的新特性，Redis Cluster 是一个合适的选择。</li>
<li>从数据迁移性能维度来看，Codis 能支持异步迁移，异步迁移对集群处理正常请求的性能影响要比使用同步迁移的小。所以，如果你在应用集群时，数据迁移比较频繁的话，Codis 是个更合适的选择。</li>
</ul>
<h2 id="数据分布（分区）和查询路由"><a href="#数据分布（分区）和查询路由" class="headerlink" title="数据分布（分区）和查询路由"></a>数据分布（分区）和查询路由</h2><h3 id="分区策略"><a href="#分区策略" class="headerlink" title="分区策略"></a>分区策略</h3><p>分区将原来比较大的数据集分离存储到多个存储媒介上，分区后Redis可以管理更大的内存空间和计算能力，但同时多主机又会面临很多分布式集群的可用性、一致性等问题。<br>分区策略：</p>
<ol>
<li>范围分区<br>将不同范围的对象映射到不同的Redis实例，比如用户ID为0到10000的存储到R0,10001到20000的存储到R1，以此类推。<br>缺点是需要建立一张映射表，谨小甚微地维护ID和Redis实例之间的映射关系，而且由于需要维护表，导致效率不如其他方案。</li>
<li>散列分区<br>使用散列函数（如CRC32）将key转换为一个数字，取模得到一个0到3的数字（假设Redis服务器有4台），这个数字即对应服务器的序号。</li>
<li>一致性哈希<br>一致性哈希的一种示例实现可以参考Dubbo中的实现：<code>com.alibaba.dubbo.rpc.cluster.loadbalance.ConsistentHashLoadBalance</code><br>关键代码如下：<br><img src="/imgs/Redis/ConsistentHashLoadBalance.png" alt="ConsistentHashLoadBalance" title="ConsistentHashLoadBalance"></li>
<li>哈希槽<br>Redis Cluster采用的是哈希槽的方式。<br>Redis 集群没有并使用传统的<strong>一致性哈希</strong>来分配数据，而是采用另外一种叫做<strong>哈希槽 (hash slot)<strong>的方式来分配的。redis cluster 默认分配了 16384 个 slot，当我们 set 一个 key 时，会用</strong>CRC16</strong>算法来取模得到所属的 slot，然后将这个 key 分到哈希槽区间的节点上，具体算法就是：<code>CRC16(key) % 16384</code>。所以我们在测试的时候看到 set 和 get 的时候，直接跳转到了 7000 端口的节点。<br>客户端在接收到重定向错误（redirections errors） -MOVED 和 -ASK 的时候， 将命令重定向到其他节点。客户端不需要存储集群信息（槽所在位置），但是如何客户端可以缓存键值和节点之间的映射关系，就可以明显提高命令执行的效率了（Redisson 中就是这么做的）。<br>在 Cluster 架构中，slave 节点不分配槽，只拥有读权限，但是在代码中 cluster 执行读写操作的都是 master 节点，并不是读就是从节点、写就是主节点。</li>
</ol>
<p>源码中，Redis采用一个大小固定为<code>CLUSTER_SLOTS</code>的clusterNode数组<code>slots</code>来保存每个桶的负责节点，这是个字节数组，每个位表示当前节点是否负责这个槽：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line">// 节点状态</span><br><span class="line">struct clusterNode &#123;</span><br><span class="line"></span><br><span class="line">    // 创建节点的时间</span><br><span class="line">    mstime_t ctime; /* Node object creation time. */</span><br><span class="line"></span><br><span class="line">    // 节点的名字，由 40 个十六进制字符组成</span><br><span class="line">    // 例如 68eef66df23420a5862208ef5b1a7005b806f2ff</span><br><span class="line">    char name[REDIS_CLUSTER_NAMELEN]; /* Node name, hex string, sha1-size */</span><br><span class="line"></span><br><span class="line">    // 节点标识</span><br><span class="line">    // 使用各种不同的标识值记录节点的角色（比如主节点或者从节点），</span><br><span class="line">    // 以及节点目前所处的状态（比如在线或者下线）。</span><br><span class="line">    int flags;      /* REDIS_NODE_... */</span><br><span class="line"></span><br><span class="line">    // 节点当前的配置纪元，用于实现故障转移</span><br><span class="line">    uint64_t configEpoch; /* Last configEpoch observed for this node */</span><br><span class="line"></span><br><span class="line">    // 由这个节点负责处理的槽</span><br><span class="line">    // 一共有 REDIS_CLUSTER_SLOTS / 8 个字节长</span><br><span class="line">    // 每个字节的每个位记录了一个槽的保存状态</span><br><span class="line">    // 位的值为 1 表示槽正由本节点处理，值为 0 则表示槽并非本节点处理</span><br><span class="line">    // 比如 slots[0] 的第一个位保存了槽 0 的保存情况</span><br><span class="line">    // slots[0] 的第二个位保存了槽 1 的保存情况，以此类推</span><br><span class="line">    unsigned char slots[REDIS_CLUSTER_SLOTS/8]; /* slots handled by this node */</span><br><span class="line"></span><br><span class="line">    // 该节点负责处理的槽数量</span><br><span class="line">    int numslots;   /* Number of slots handled by this node */</span><br><span class="line"></span><br><span class="line">    // 如果本节点是主节点，那么用这个属性记录从节点的数量</span><br><span class="line">    int numslaves;  /* Number of slave nodes, if this is a master */</span><br><span class="line"></span><br><span class="line">    // 指针数组，指向各个从节点</span><br><span class="line">    struct clusterNode **slaves; /* pointers to slave nodes */</span><br><span class="line"></span><br><span class="line">    // 如果这是一个从节点，那么指向主节点</span><br><span class="line">    struct clusterNode *slaveof; /* pointer to the master node */</span><br><span class="line"></span><br><span class="line">    // 最后一次发送 PING 命令的时间</span><br><span class="line">    mstime_t ping_sent;      /* Unix time we sent latest ping */</span><br><span class="line"></span><br><span class="line">    // 最后一次接收 PONG 回复的时间戳</span><br><span class="line">    mstime_t pong_received;  /* Unix time we received the pong */</span><br><span class="line"></span><br><span class="line">    // 最后一次被设置为 FAIL 状态的时间</span><br><span class="line">    mstime_t fail_time;      /* Unix time when FAIL flag was set */</span><br><span class="line"></span><br><span class="line">    // 最后一次给某个从节点投票的时间</span><br><span class="line">    mstime_t voted_time;     /* Last time we voted for a slave of this master */</span><br><span class="line"></span><br><span class="line">    // 最后一次从这个节点接收到复制偏移量的时间</span><br><span class="line">    mstime_t repl_offset_time;  /* Unix time we received offset for this node */</span><br><span class="line"></span><br><span class="line">    // 这个节点的复制偏移量</span><br><span class="line">    long long repl_offset;      /* Last known repl offset for this node. */</span><br><span class="line"></span><br><span class="line">    // 节点的 IP 地址</span><br><span class="line">    char ip[REDIS_IP_STR_LEN];  /* Latest known IP address of this node */</span><br><span class="line"></span><br><span class="line">    // 节点的端口号</span><br><span class="line">    int port;                   /* Latest known port of this node */</span><br><span class="line"></span><br><span class="line">    // 保存连接节点所需的有关信息</span><br><span class="line">    clusterLink *link;          /* TCP/IP link with this node */</span><br><span class="line"></span><br><span class="line">    // 一个链表，记录了所有其他节点对该节点的下线报告</span><br><span class="line">    list *fail_reports;         /* List of nodes signaling this as failing */</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">typedef struct clusterNode clusterNode;</span><br><span class="line"></span><br><span class="line">// 集群状态，每个节点都保存着一个这样的状态，记录了它们眼中的集群的样子。</span><br><span class="line">// 另外，虽然这个结构主要用于记录集群的属性，但是为了节约资源，</span><br><span class="line">// 有些与节点有关的属性，比如 slots_to_keys 、 failover_auth_count </span><br><span class="line">// 也被放到了这个结构里面。</span><br><span class="line">typedef struct clusterState &#123;</span><br><span class="line"></span><br><span class="line">    // 指向当前节点的指针</span><br><span class="line">    clusterNode *myself;  /* This node */</span><br><span class="line"></span><br><span class="line">    // 集群当前的配置纪元，用于实现故障转移</span><br><span class="line">    uint64_t currentEpoch;</span><br><span class="line"></span><br><span class="line">    // 集群当前的状态：是在线还是下线</span><br><span class="line">    int state;            /* REDIS_CLUSTER_OK, REDIS_CLUSTER_FAIL, ... */</span><br><span class="line"></span><br><span class="line">    // 集群中至少处理着一个槽的节点的数量。</span><br><span class="line">    int size;             /* Num of master nodes with at least one slot */</span><br><span class="line"></span><br><span class="line">    // 集群节点名单（包括 myself 节点）</span><br><span class="line">    // 字典的键为节点的名字，字典的值为 clusterNode 结构</span><br><span class="line">    dict *nodes;          /* Hash table of name -&gt; clusterNode structures */</span><br><span class="line"></span><br><span class="line">    // 节点黑名单，用于 CLUSTER FORGET 命令</span><br><span class="line">    // 防止被 FORGET 的命令重新被添加到集群里面</span><br><span class="line">    // （不过现在似乎没有在使用的样子，已废弃？还是尚未实现？）</span><br><span class="line">    dict *nodes_black_list; /* Nodes we don&#x27;t re-add for a few seconds. */</span><br><span class="line"></span><br><span class="line">    // 记录要从当前节点迁移到目标节点的槽，以及迁移的目标节点</span><br><span class="line">    // migrating_slots_to[i] = NULL 表示槽 i 未被迁移</span><br><span class="line">    // migrating_slots_to[i] = clusterNode_A 表示槽 i 要从本节点迁移至节点 A</span><br><span class="line">    clusterNode *migrating_slots_to[REDIS_CLUSTER_SLOTS];</span><br><span class="line"></span><br><span class="line">    // 记录要从源节点迁移到本节点的槽，以及进行迁移的源节点</span><br><span class="line">    // importing_slots_from[i] = NULL 表示槽 i 未进行导入</span><br><span class="line">    // importing_slots_from[i] = clusterNode_A 表示正从节点 A 中导入槽 i</span><br><span class="line">    clusterNode *importing_slots_from[REDIS_CLUSTER_SLOTS];</span><br><span class="line"></span><br><span class="line">    // 负责处理各个槽的节点</span><br><span class="line">    // 例如 slots[i] = clusterNode_A 表示槽 i 由节点 A 处理</span><br><span class="line">    clusterNode *slots[REDIS_CLUSTER_SLOTS];</span><br><span class="line"></span><br><span class="line">    // 跳跃表，表中以槽作为分值，键作为成员，对槽进行有序排序</span><br><span class="line">    // 当需要对某些槽进行区间（range）操作时，这个跳跃表可以提供方便</span><br><span class="line">    // 具体操作定义在 db.c 里面</span><br><span class="line">    zskiplist *slots_to_keys;</span><br><span class="line"></span><br><span class="line">    /* The following fields are used to take the slave state on elections. */</span><br><span class="line">    // 以下这些域被用于进行故障转移选举</span><br><span class="line"></span><br><span class="line">    // 上次执行选举或者下次执行选举的时间</span><br><span class="line">    mstime_t failover_auth_time; /* Time of previous or next election. */</span><br><span class="line"></span><br><span class="line">    // 节点获得的投票数量</span><br><span class="line">    int failover_auth_count;    /* Number of votes received so far. */</span><br><span class="line"></span><br><span class="line">    // 如果值为 1 ，表示本节点已经向其他节点发送了投票请求</span><br><span class="line">    int failover_auth_sent;     /* True if we already asked for votes. */</span><br><span class="line"></span><br><span class="line">    int failover_auth_rank;     /* This slave rank for current auth request. */</span><br><span class="line"></span><br><span class="line">    uint64_t failover_auth_epoch; /* Epoch of the current election. */</span><br><span class="line"></span><br><span class="line">    /* Manual failover state in common. */</span><br><span class="line">    /* 共用的手动故障转移状态 */</span><br><span class="line"></span><br><span class="line">    // 手动故障转移执行的时间限制</span><br><span class="line">    mstime_t mf_end;            /* Manual failover time limit (ms unixtime).</span><br><span class="line">                                   It is zero if there is no MF in progress. */</span><br><span class="line">    /* Manual failover state of master. */</span><br><span class="line">    /* 主服务器的手动故障转移状态 */</span><br><span class="line">    clusterNode *mf_slave;      /* Slave performing the manual failover. */</span><br><span class="line">    /* Manual failover state of slave. */</span><br><span class="line">    /* 从服务器的手动故障转移状态 */</span><br><span class="line">    long long mf_master_offset; /* Master offset the slave needs to start MF</span><br><span class="line">                                   or zero if stil not received. */</span><br><span class="line">    // 指示手动故障转移是否可以开始的标志值</span><br><span class="line">    // 值为非 0 时表示各个主服务器可以开始投票</span><br><span class="line">    int mf_can_start;           /* If non-zero signal that the manual failover</span><br><span class="line">                                   can start requesting masters vote. */</span><br><span class="line"></span><br><span class="line">    /* The followign fields are uesd by masters to take state on elections. */</span><br><span class="line">    /* 以下这些域由主服务器使用，用于记录选举时的状态 */</span><br><span class="line"></span><br><span class="line">    // 集群最后一次进行投票的纪元</span><br><span class="line">    uint64_t lastVoteEpoch;     /* Epoch of the last vote granted. */</span><br><span class="line"></span><br><span class="line">    // 在进入下个事件循环之前要做的事情，以各个 flag 来记录</span><br><span class="line">    int todo_before_sleep; /* Things to do in clusterBeforeSleep(). */</span><br><span class="line"></span><br><span class="line">    // 通过 cluster 连接发送的消息数量</span><br><span class="line">    long long stats_bus_messages_sent;  /* Num of msg sent via cluster bus. */</span><br><span class="line"></span><br><span class="line">    // 通过 cluster 接收到的消息数量</span><br><span class="line">    long long stats_bus_messages_received; /* Num of msg rcvd via cluster bus.*/</span><br><span class="line"></span><br><span class="line">&#125; clusterState;</span><br></pre></td></tr></table></figure>

<h3 id="分区的实现层次"><a href="#分区的实现层次" class="headerlink" title="分区的实现层次"></a>分区的实现层次</h3><p>分区可以在程序的不同层次实现。</p>
<ul>
<li><strong>客户端分区</strong><br>就是在客户端就已经决定数据会被存储到哪个redis节点或者从哪个redis节点读取。大多数客户端已经实现了客户端分区。</li>
<li><strong>代理分区</strong><br>意味着客户端将请求发送给代理，然后代理决定去哪个节点写数据或者读数据。代理根据分区规则决定请求哪些Redis实例，然后根据Redis的响应结果返回给客户端。redis和memcached的一种代理实现就是Twemproxy</li>
<li><strong>查询路由(Query routing)</strong><br>意思是客户端随机地请求任意一个redis实例，然后由Redis将请求转发给正确的Redis节点。Redis Cluster实现了一种混合形式的查询路由，但并不是直接将请求从一个redis节点转发到另一个redis节点，而是在客户端的帮助下直接redirected到正确的redis节点。</li>
</ul>
<p>Redis Cluster采用的是<strong>查询路由</strong>的方式。<br>在Cluster模式下，Redis接收任何命令都会首先计算键对应的桶编号，再根据桶找出所对应的节点，如果节点是自身，则处理键命令；否则回复<code>MOVED</code>重定向错误，通知客户端请求正确的节点，这个过程称为MOVED重定向。<br>在客户端初次连接Redis集群时，如果客户端是<strong>Smart Client</strong>，它会获取集群的节点信息及slot的分布信息，并在本地缓存一份 hash slot 与node关系的路由表，这样不必每次访问服务器时都因为重定向而经过多次网络调用。<br>redis-cli不是smart client，它没有缓存路由表的功能；Java客户端Redisson是smart client，它在初始化时会调用redis实例的<code>CLUSTER NODES</code>命令来获取集群中每个Master负责的slot范围，并启动一个定时任务来每秒刷新本地缓存的集群状态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 启动时查询集群状态</span><br><span class="line"> */</span><br><span class="line">public ClusterConnectionManager(ClusterServersConfig cfg, Config config) &#123;</span><br><span class="line">    super(config);</span><br><span class="line"></span><br><span class="line">    this.config = create(cfg);</span><br><span class="line">    initTimer(this.config);</span><br><span class="line"></span><br><span class="line">    Throwable lastException = null;</span><br><span class="line">    List&lt;String&gt; failedMasters = new ArrayList&lt;String&gt;();</span><br><span class="line">    for (URI addr : cfg.getNodeAddresses()) &#123;</span><br><span class="line">        RFuture&lt;RedisConnection&gt; connectionFuture = connect(cfg, addr);</span><br><span class="line">        try &#123;</span><br><span class="line">            RedisConnection connection = connectionFuture.syncUninterruptibly().getNow();</span><br><span class="line">            </span><br><span class="line">            // 发送cluster nodes命令</span><br><span class="line">            </span><br><span class="line">            clusterNodesCommand = RedisCommands.CLUSTER_NODES;</span><br><span class="line">            if (&quot;rediss&quot;.equals(addr.getScheme())) &#123;</span><br><span class="line">                clusterNodesCommand = RedisCommands.CLUSTER_NODES_SSL;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            List&lt;ClusterNodeInfo&gt; nodes = connection.sync(clusterNodesCommand);</span><br><span class="line">            </span><br><span class="line">            StringBuilder nodesValue = new StringBuilder();</span><br><span class="line">            for (ClusterNodeInfo clusterNodeInfo : nodes) &#123;</span><br><span class="line">                nodesValue.append(clusterNodeInfo.getNodeInfo()).append(&quot;\n&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            log.info(&quot;Redis cluster nodes configuration got from &#123;&#125;:\n&#123;&#125;&quot;, connection.getRedisClient().getAddr(), nodesValue);</span><br><span class="line"></span><br><span class="line">            lastClusterNode = addr;</span><br><span class="line">            </span><br><span class="line">            // 读取每个节点的分区配置</span><br><span class="line">            </span><br><span class="line">            Collection&lt;ClusterPartition&gt; partitions = parsePartitions(nodes);</span><br><span class="line">            </span><br><span class="line">            ...</span><br><span class="line">            </span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            lastException = e;</span><br><span class="line">            log.warn(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    // 每秒定时刷新本地缓存的cluster状态，包括每个Master节点负责的slot范围</span><br><span class="line">    scheduleClusterChangeCheck(cfg, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取key所处的节点</span><br><span class="line"> */</span><br><span class="line">private NodeSource getNodeSource(String key) &#123;</span><br><span class="line">    int slot = connectionManager.calcSlot(key);</span><br><span class="line">    MasterSlaveEntry entry = connectionManager.getEntry(slot);</span><br><span class="line">    return new NodeSource(entry);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取key所处的节点</span><br><span class="line"> */</span><br><span class="line">protected &lt;V, R&gt; void async(final boolean readOnlyMode, final NodeSource source, final Codec codec,</span><br><span class="line">    // 建立连接、发送命令</span><br><span class="line">    final RFuture&lt;RedisConnection&gt; connectionFuture;</span><br><span class="line">    if (readOnlyMode) &#123;</span><br><span class="line">        connectionFuture = connectionManager.connectionReadOp(source, command);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        connectionFuture = connectionManager.connectionWriteOp(source, command);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    connectionFuture.addListener(new FutureListener&lt;RedisConnection&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void operationComplete(Future&lt;RedisConnection&gt; connFuture) throws Exception &#123;</span><br><span class="line">            if (connFuture.isCancelled()) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            // 如果执行不成功，则设置异常信息</span><br><span class="line">            if (!connFuture.isSuccess()) &#123;</span><br><span class="line">                connectionManager.getShutdownLatch().release();</span><br><span class="line">                details.setException(convertException(connectionFuture));</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            // 如果执行OK，释放连接</span><br><span class="line">            if (details.getAttemptPromise().isDone() || details.getMainPromise().isDone()) &#123;</span><br><span class="line">                releaseConnection(source, connectionFuture, details.isReadOnlyMode(), details.getAttemptPromise(), details);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            final RedisConnection connection = connFuture.getNow();</span><br><span class="line">            // 响应ASK的情况</span><br><span class="line">            if (details.getSource().getRedirect() == Redirect.ASK) &#123;</span><br><span class="line">                List&lt;CommandData&lt;?, ?&gt;&gt; list = new ArrayList&lt;CommandData&lt;?, ?&gt;&gt;(2);</span><br><span class="line">                RPromise&lt;Void&gt; promise = connectionManager.newPromise();</span><br><span class="line">                list.add(new CommandData&lt;Void, Void&gt;(promise, details.getCodec(), RedisCommands.ASKING, new Object[]&#123;&#125;));</span><br><span class="line">                list.add(new CommandData&lt;V, R&gt;(details.getAttemptPromise(), details.getCodec(), details.getCommand(), details.getParams()));</span><br><span class="line">                RPromise&lt;Void&gt; main = connectionManager.newPromise();</span><br><span class="line">                ChannelFuture future = connection.send(new CommandsData(main, list));</span><br><span class="line">                details.setWriteFuture(future);</span><br><span class="line">            &#125;</span><br><span class="line">            // 响应MOVED的情况</span><br><span class="line">            else &#123;</span><br><span class="line">                if (log.isDebugEnabled()) &#123;</span><br><span class="line">                    log.debug(&quot;acquired connection for command &#123;&#125; and params &#123;&#125; from slot &#123;&#125; using node &#123;&#125;... &#123;&#125;&quot;,</span><br><span class="line">                            details.getCommand(), Arrays.toString(details.getParams()), details.getSource(), connection.getRedisClient().getAddr(), connection);</span><br><span class="line">                &#125;</span><br><span class="line">                ChannelFuture future = connection.send(new CommandData&lt;V, R&gt;(details.getAttemptPromise(), details.getCodec(), details.getCommand(), details.getParams()));</span><br><span class="line">                details.setWriteFuture(future);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            details.getWriteFuture().addListener(new ChannelFutureListener() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void operationComplete(ChannelFuture future) throws Exception &#123;</span><br><span class="line">                    checkWriteFuture(details, connection);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            releaseConnection(source, connectionFuture, details.isReadOnlyMode(), details.getAttemptPromise(), details);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是手动调用<code>cluster nodes</code>可以得到的响应，从中可以看到每个master所负责的slot范围：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">hgc@hgc-X555LD:~$ redis-cli -h 10.32.64.12 -p 16371 -c</span><br><span class="line">10.32.64.12:16371&gt; auth 123456</span><br><span class="line">OK</span><br><span class="line">10.32.64.12:16371&gt; cluster nodes</span><br><span class="line">d0af93527054ae3713c6ae82f4f58e016c4968d7 10.32.64.161:16371@26371 slave dbf60db7dc4c2d8ea944481d162bf6be7ef48f5a 0 1604569999114 28 connected</span><br><span class="line">20def2dff31ba78c04f72431a51054def2120638 10.32.64.161:16372@26372 master - 0 1604569998112 31 connected 0-5460</span><br><span class="line">b0c86436cd4cf6d2240faf01b45735616b82cae8 10.32.64.12:16371@26371 myself,slave 20def2dff31ba78c04f72431a51054def2120638 0 1604569995000 30 connected</span><br><span class="line">dbf60db7dc4c2d8ea944481d162bf6be7ef48f5a 10.32.64.162:16372@26372 master - 0 1604569996000 28 connected 5461-10922</span><br><span class="line">005c670071b5dab4ef085613f0ca6666fc5bcbce 10.32.64.12:16373@26373 slave df7f690feee2ad536f2573b55190e0f8d576779e 0 1604569998000 25 connected</span><br><span class="line">df7f690feee2ad536f2573b55190e0f8d576779e 10.32.64.162:16373@26373 master - 0 1604569997000 25 connected 10923-16383</span><br></pre></td></tr></table></figure>
<p>如果Cluster发生了扩容缩容或failover导致客户端缓存的信息过期，客户端只需要MOVED时重新更新本地缓存即可。<br>但是这里有一个问题，如果扩容缩容时正在发生槽迁移，这时正在迁移中的槽在哪个节点是不确定的，可能会导致客户端本地缓存的频繁更新。因此，Redis迁移过程中，会对正在迁移的槽打标记（<code>server.cluster-&gt;migrating_slots_to</code>），如果客户端访问的key命中了正在迁移中的槽，则服务器会返回<code>ASK</code>而不是<code>MOVED</code>，客户端接收到<code>ASK</code>后不会重新更新本地的槽缓存。<br>代码：<code>redis.c/processCommand</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">/* If cluster is enabled perform the cluster redirection here.</span><br><span class="line"> *</span><br><span class="line"> * 如果开启了集群模式，那么在这里进行转向操作。</span><br><span class="line"> *</span><br><span class="line"> * However we don&#x27;t perform the redirection if:</span><br><span class="line"> *</span><br><span class="line"> * 不过，如果有以下情况出现，那么节点不进行转向：</span><br><span class="line"> *</span><br><span class="line"> * 1) The sender of this command is our master.</span><br><span class="line"> *    命令的发送者是本节点的主节点</span><br><span class="line"> *</span><br><span class="line"> * 2) The command has no key arguments. </span><br><span class="line"> *    命令没有 key 参数</span><br><span class="line"> */</span><br><span class="line">if (server.cluster_enabled &amp;&amp;</span><br><span class="line">    !(c-&gt;flags &amp; REDIS_MASTER) &amp;&amp;</span><br><span class="line">    !(c-&gt;cmd-&gt;getkeys_proc == NULL &amp;&amp; c-&gt;cmd-&gt;firstkey == 0))</span><br><span class="line">&#123;</span><br><span class="line">    int hashslot;</span><br><span class="line"></span><br><span class="line">    // 集群已下线</span><br><span class="line">    if (server.cluster-&gt;state != REDIS_CLUSTER_OK) &#123;</span><br><span class="line">        flagTransaction(c);</span><br><span class="line">        addReplySds(c,sdsnew(&quot;-CLUSTERDOWN The cluster is down. Use CLUSTER INFO for more information\r\n&quot;));</span><br><span class="line">        return REDIS_OK;</span><br><span class="line"></span><br><span class="line">    // 集群运作正常</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        int error_code;</span><br><span class="line">        clusterNode *n = getNodeByQuery(c,c-&gt;cmd,c-&gt;argv,c-&gt;argc,&amp;hashslot,&amp;error_code);</span><br><span class="line">        // 不能执行多键处理命令</span><br><span class="line">        if (n == NULL) &#123;</span><br><span class="line">            flagTransaction(c);</span><br><span class="line">            if (error_code == REDIS_CLUSTER_REDIR_CROSS_SLOT) &#123;</span><br><span class="line">                addReplySds(c,sdsnew(&quot;-CROSSSLOT Keys in request don&#x27;t hash to the same slot\r\n&quot;));</span><br><span class="line">            &#125; else if (error_code == REDIS_CLUSTER_REDIR_UNSTABLE) &#123;</span><br><span class="line">                /* The request spawns mutliple keys in the same slot,</span><br><span class="line">                 * but the slot is not &quot;stable&quot; currently as there is</span><br><span class="line">                 * a migration or import in progress. */</span><br><span class="line">                addReplySds(c,sdsnew(&quot;-TRYAGAIN Multiple keys request during rehashing of slot\r\n&quot;));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                redisPanic(&quot;getNodeByQuery() unknown error.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            return REDIS_OK;</span><br><span class="line"></span><br><span class="line">        // 命令针对的槽和键不是本节点处理的，进行转向</span><br><span class="line">        &#125; else if (n != server.cluster-&gt;myself) &#123;</span><br><span class="line">            flagTransaction(c);</span><br><span class="line">            // -&lt;ASK or MOVED&gt; &lt;slot&gt; &lt;ip&gt;:&lt;port&gt;</span><br><span class="line">            // 例如 -ASK 10086 127.0.0.1:12345</span><br><span class="line">            addReplySds(c,sdscatprintf(sdsempty(),</span><br><span class="line">                &quot;-%s %d %s:%d\r\n&quot;,</span><br><span class="line">                (error_code == REDIS_CLUSTER_REDIR_ASK) ? &quot;ASK&quot; : &quot;MOVED&quot;,</span><br><span class="line">                hashslot,n-&gt;ip,n-&gt;port));</span><br><span class="line"></span><br><span class="line">            return REDIS_OK;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 如果执行到这里，说明键 key 所在的槽由本节点处理</span><br><span class="line">        // 或者客户端执行的是无参数命令</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分区的缺点"><a href="#分区的缺点" class="headerlink" title="分区的缺点"></a>分区的缺点</h3><p>有些特性在分区的情况下会受到限制：</p>
<ul>
<li>涉及多个key的操作通常不会被支持。例如你不能对两个集合求交集，因为他们可能被存储到不同的Redis实例（实际上这种情况也有办法，但是不能直接使用交集指令）。<br>同时操作多个key,则不能使用Redis事务.</li>
<li>分区使用的粒度是key，不能使用一个非常长的排序key存储一个数据集（The partitioning granularity is the key, so it is not possible to shard a dataset with a single huge key like a very big sorted set）.</li>
<li>当使用分区的时候，数据处理会非常复杂，例如为了备份你必须从不同的Redis实例和主机同时收集RDB &#x2F; AOF文件。</li>
<li>分区时动态扩容或缩容可能非常复杂。Redis集群在运行时增加或者删除Redis节点，能做到最大程度对用户透明地数据再平衡，但其他一些客户端分区或者代理分区方法则不支持这种特性。然而，有一种预分片的技术也可以较好的解决这个问题。</li>
</ul>
<p>当要把Redis当作持久化存储时，需要注意分区的性质</p>
<ul>
<li>如果Redis被当做缓存使用，使用一致性哈希实现动态扩容缩容。</li>
<li>如果Redis被当做一个持久化存储使用，必须使用固定的keys-to-nodes映射关系，节点的数量一旦确定不能变化。否则的话(即Redis节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，现在Redis Cluster已经支持这种再平衡。</li>
</ul>
<h2 id="节点通信"><a href="#节点通信" class="headerlink" title="节点通信"></a>节点通信</h2><p>Redis Cluster采用Gossip协议完成集群状态数据及路由数据等元数据的管理。<br>一种简单的集群内状态同步思路是：每次节点都将自己本地的集群状态数据广播到集群内所有N个节点，其他节点判断接收到的数据比本地的新则更新本地数据。但是这种方式的缺点是通信量剧增，网络带宽变得紧张。<br>因此Redis采用Gossip协议来进行集群内元数据的同步，而且：<br>1、每次只随机选择K（K &lt;&lt; N）个其他节点来同步状态；<br>集群内每个节点维护定时任务默认每秒执行10次，每秒会随机选取5个节点找出最久没有通信的节点发送ping消息，用于保证Gossip信息交换的随机性。每100毫秒都会扫描本地节点列表，如果发现节点最近一次接受pong消息的时间大于cluster_node_timeout&#x2F;2，则立刻发送ping消息，防止该节点信息太长时间未更新。根据以上规则得出每个节点每秒需要发送ping消息的数量&#x3D;1+10*num（node.pong_received&gt;cluster_node_timeout&#x2F;2），因此cluster_node_timeout参数对消息发送的节点数量影响非常大。当我们的带宽资源紧张时，可以适当调大这个参数，如从默认15秒改为30秒来降低带宽占用率。过度调大cluster_node_timeout会影响消息交换的频率从而影响故障转移、槽信息更新、新节点发现的速度。因此需要根据业务容忍度和资源消耗进行平衡。同时整个集群消息总交换量也跟节点数成正比。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br></pre></td><td class="code"><pre><span class="line">/* This is executed 10 times every second */</span><br><span class="line">// 集群常规操作函数，默认每秒执行 10 次（每间隔 100 毫秒执行一次）</span><br><span class="line">void clusterCron(void) &#123;</span><br><span class="line">    dictIterator *di;</span><br><span class="line">    dictEntry *de;</span><br><span class="line">    int update_state = 0;</span><br><span class="line">    int orphaned_masters; /* How many masters there are without ok slaves. */</span><br><span class="line">    int max_slaves; /* Max number of ok slaves for a single master. */</span><br><span class="line">    int this_slaves; /* Number of ok slaves for our master (if we are slave). */</span><br><span class="line">    mstime_t min_pong = 0, now = mstime();</span><br><span class="line">    clusterNode *min_pong_node = NULL;</span><br><span class="line">    // 迭代计数器，一个静态变量</span><br><span class="line">    static unsigned long long iteration = 0;</span><br><span class="line">    mstime_t handshake_timeout;</span><br><span class="line"></span><br><span class="line">    // 记录一次迭代</span><br><span class="line">    iteration++; /* Number of times this function was called so far. */</span><br><span class="line"></span><br><span class="line">    /* The handshake timeout is the time after which a handshake node that was</span><br><span class="line">     * not turned into a normal node is removed from the nodes. Usually it is</span><br><span class="line">     * just the NODE_TIMEOUT value, but when NODE_TIMEOUT is too small we use</span><br><span class="line">     * the value of 1 second. */</span><br><span class="line">    // 如果一个 handshake 节点没有在 handshake timeout 内</span><br><span class="line">    // 转换成普通节点（normal node），</span><br><span class="line">    // 那么节点会从 nodes 表中移除这个 handshake 节点</span><br><span class="line">    // 一般来说 handshake timeout 的值总是等于 NODE_TIMEOUT</span><br><span class="line">    // 不过如果 NODE_TIMEOUT 太少的话，程序会将值设为 1 秒钟</span><br><span class="line">    handshake_timeout = server.cluster_node_timeout;</span><br><span class="line">    if (handshake_timeout &lt; 1000) handshake_timeout = 1000;</span><br><span class="line"></span><br><span class="line">    /* Check if we have disconnected nodes and re-establish the connection. */</span><br><span class="line">    // 向集群中的所有断线或者未连接节点发送消息</span><br><span class="line">    di = dictGetSafeIterator(server.cluster-&gt;nodes);</span><br><span class="line">    while((de = dictNext(di)) != NULL) &#123;</span><br><span class="line">        clusterNode *node = dictGetVal(de);</span><br><span class="line"></span><br><span class="line">        // 跳过当前节点以及没有地址的节点</span><br><span class="line">        if (node-&gt;flags &amp; (REDIS_NODE_MYSELF|REDIS_NODE_NOADDR)) continue;</span><br><span class="line"></span><br><span class="line">        /* A Node in HANDSHAKE state has a limited lifespan equal to the</span><br><span class="line">         * configured node timeout. */</span><br><span class="line">        // 如果 handshake 节点已超时，释放它</span><br><span class="line">        if (nodeInHandshake(node) &amp;&amp; now - node-&gt;ctime &gt; handshake_timeout) &#123;</span><br><span class="line">            freeClusterNode(node);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 为未创建连接的节点创建连接</span><br><span class="line">        if (node-&gt;link == NULL) &#123;</span><br><span class="line">            int fd;</span><br><span class="line">            mstime_t old_ping_sent;</span><br><span class="line">            clusterLink *link;</span><br><span class="line"></span><br><span class="line">            fd = anetTcpNonBlockBindConnect(server.neterr, node-&gt;ip,</span><br><span class="line">                node-&gt;port+REDIS_CLUSTER_PORT_INCR,</span><br><span class="line">                    server.bindaddr_count ? server.bindaddr[0] : NULL);</span><br><span class="line">            if (fd == -1) &#123;</span><br><span class="line">                redisLog(REDIS_DEBUG, &quot;Unable to connect to &quot;</span><br><span class="line">                    &quot;Cluster Node [%s]:%d -&gt; %s&quot;, node-&gt;ip,</span><br><span class="line">                    node-&gt;port+REDIS_CLUSTER_PORT_INCR,</span><br><span class="line">                    server.neterr);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            link = createClusterLink(node);</span><br><span class="line">            link-&gt;fd = fd;</span><br><span class="line">            node-&gt;link = link;</span><br><span class="line">            aeCreateFileEvent(server.el,link-&gt;fd,AE_READABLE,</span><br><span class="line">                    clusterReadHandler,link);</span><br><span class="line">            /* Queue a PING in the new connection ASAP: this is crucial</span><br><span class="line">             * to avoid false positives in failure detection.</span><br><span class="line">             *</span><br><span class="line">             * If the node is flagged as MEET, we send a MEET message instead</span><br><span class="line">             * of a PING one, to force the receiver to add us in its node</span><br><span class="line">             * table. */</span><br><span class="line">            // 向新连接的节点发送 PING 命令，防止节点被识进入下线</span><br><span class="line">            // 如果节点被标记为 MEET ，那么发送 MEET 命令，否则发送 PING 命令</span><br><span class="line">            old_ping_sent = node-&gt;ping_sent;</span><br><span class="line">            clusterSendPing(link, node-&gt;flags &amp; REDIS_NODE_MEET ?</span><br><span class="line">                    CLUSTERMSG_TYPE_MEET : CLUSTERMSG_TYPE_PING);</span><br><span class="line"></span><br><span class="line">            // 这不是第一次发送 PING 信息，所以可以还原这个时间</span><br><span class="line">            // 等 clusterSendPing() 函数来更新它</span><br><span class="line">            if (old_ping_sent) &#123;</span><br><span class="line">                /* If there was an active ping before the link was</span><br><span class="line">                 * disconnected, we want to restore the ping time, otherwise</span><br><span class="line">                 * replaced by the clusterSendPing() call. */</span><br><span class="line">                node-&gt;ping_sent = old_ping_sent;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            /* We can clear the flag after the first packet is sent.</span><br><span class="line">             *</span><br><span class="line">             * 在发送 MEET 信息之后，清除节点的 MEET 标识。</span><br><span class="line">             *</span><br><span class="line">             * If we&#x27;ll never receive a PONG, we&#x27;ll never send new packets</span><br><span class="line">             * to this node. Instead after the PONG is received and we</span><br><span class="line">             * are no longer in meet/handshake status, we want to send</span><br><span class="line">             * normal PING packets. </span><br><span class="line">             *</span><br><span class="line">             * 如果当前节点（发送者）没能收到 MEET 信息的回复，</span><br><span class="line">             * 那么它将不再向目标节点发送命令。</span><br><span class="line">             *</span><br><span class="line">             * 如果接收到回复的话，那么节点将不再处于 HANDSHAKE 状态，</span><br><span class="line">             * 并继续向目标节点发送普通 PING 命令。</span><br><span class="line">             */</span><br><span class="line">            node-&gt;flags &amp;= ~REDIS_NODE_MEET;</span><br><span class="line"></span><br><span class="line">            redisLog(REDIS_DEBUG,&quot;Connecting with Node %.40s at %s:%d&quot;,</span><br><span class="line">                    node-&gt;name, node-&gt;ip, node-&gt;port+REDIS_CLUSTER_PORT_INCR);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dictReleaseIterator(di);</span><br><span class="line"></span><br><span class="line">    /* Ping some random node 1 time every 10 iterations, so that we usually ping</span><br><span class="line">     * one random node every second. */</span><br><span class="line">    // clusterCron() 每执行 10 次（至少间隔一秒钟），就向一个随机节点发送 gossip 信息</span><br><span class="line">    if (!(iteration % 10)) &#123;</span><br><span class="line">        int j;</span><br><span class="line"></span><br><span class="line">        /* Check a few random nodes and ping the one with the oldest</span><br><span class="line">         * pong_received time. */</span><br><span class="line">        // 随机 5 个节点，选出其中一个</span><br><span class="line">        for (j = 0; j &lt; 5; j++) &#123;</span><br><span class="line"></span><br><span class="line">            // 随机在集群中挑选节点</span><br><span class="line">            de = dictGetRandomKey(server.cluster-&gt;nodes);</span><br><span class="line">            clusterNode *this = dictGetVal(de);</span><br><span class="line"></span><br><span class="line">            /* Don&#x27;t ping nodes disconnected or with a ping currently active. */</span><br><span class="line">            // 不要 PING 连接断开的节点，也不要 PING 最近已经 PING 过的节点</span><br><span class="line">            if (this-&gt;link == NULL || this-&gt;ping_sent != 0) continue;</span><br><span class="line"></span><br><span class="line">            if (this-&gt;flags &amp; (REDIS_NODE_MYSELF|REDIS_NODE_HANDSHAKE))</span><br><span class="line">                continue;</span><br><span class="line"></span><br><span class="line">            // 选出 5 个随机节点中最近一次接收 PONG 回复距离现在最旧的节点</span><br><span class="line">            if (min_pong_node == NULL || min_pong &gt; this-&gt;pong_received) &#123;</span><br><span class="line">                min_pong_node = this;</span><br><span class="line">                min_pong = this-&gt;pong_received;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 向最久没有收到 PONG 回复的节点发送 PING 命令</span><br><span class="line">        if (min_pong_node) &#123;</span><br><span class="line">            redisLog(REDIS_DEBUG,&quot;Pinging node %.40s&quot;, min_pong_node-&gt;name);</span><br><span class="line">            clusterSendPing(min_pong_node-&gt;link, CLUSTERMSG_TYPE_PING);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 遍历所有节点，检查是否需要将某个节点标记为下线</span><br><span class="line">    /* Iterate nodes to check if we need to flag something as failing.</span><br><span class="line">     * This loop is also responsible to:</span><br><span class="line">     * 1) Check if there are orphaned masters (masters without non failing</span><br><span class="line">     *    slaves).</span><br><span class="line">     * 2) Count the max number of non failing slaves for a single master.</span><br><span class="line">     * 3) Count the number of slaves for our master, if we are a slave. */</span><br><span class="line">    orphaned_masters = 0;</span><br><span class="line">    max_slaves = 0;</span><br><span class="line">    this_slaves = 0;</span><br><span class="line">    di = dictGetSafeIterator(server.cluster-&gt;nodes);</span><br><span class="line">    while((de = dictNext(di)) != NULL) &#123;</span><br><span class="line">        clusterNode *node = dictGetVal(de);</span><br><span class="line">        now = mstime(); /* Use an updated time at every iteration. */</span><br><span class="line">        mstime_t delay;</span><br><span class="line"></span><br><span class="line">        // 跳过节点本身、无地址节点、HANDSHAKE 状态的节点</span><br><span class="line">        if (node-&gt;flags &amp;</span><br><span class="line">            (REDIS_NODE_MYSELF|REDIS_NODE_NOADDR|REDIS_NODE_HANDSHAKE))</span><br><span class="line">                continue;</span><br><span class="line"></span><br><span class="line">        /* Orphaned master check, useful only if the current instance</span><br><span class="line">         * is a slave that may migrate to another master. */</span><br><span class="line">        if (nodeIsSlave(myself) &amp;&amp; nodeIsMaster(node) &amp;&amp; !nodeFailed(node)) &#123;</span><br><span class="line">            int okslaves = clusterCountNonFailingSlaves(node);</span><br><span class="line"></span><br><span class="line">            if (okslaves == 0 &amp;&amp; node-&gt;numslots &gt; 0) orphaned_masters++;</span><br><span class="line">            if (okslaves &gt; max_slaves) max_slaves = okslaves;</span><br><span class="line">            if (nodeIsSlave(myself) &amp;&amp; myself-&gt;slaveof == node)</span><br><span class="line">                this_slaves = okslaves;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* If we are waiting for the PONG more than half the cluster</span><br><span class="line">         * timeout, reconnect the link: maybe there is a connection</span><br><span class="line">         * issue even if the node is alive. */</span><br><span class="line">        // 如果等到 PONG 到达的时间超过了 node timeout 一半的连接</span><br><span class="line">        // 因为尽管节点依然正常，但连接可能已经出问题了</span><br><span class="line">        if (node-&gt;link &amp;&amp; /* is connected */</span><br><span class="line">            now - node-&gt;link-&gt;ctime &gt;</span><br><span class="line">            server.cluster_node_timeout &amp;&amp; /* was not already reconnected */</span><br><span class="line">            node-&gt;ping_sent &amp;&amp; /* we already sent a ping */</span><br><span class="line">            node-&gt;pong_received &lt; node-&gt;ping_sent &amp;&amp; /* still waiting pong */</span><br><span class="line">            /* and we are waiting for the pong more than timeout/2 */</span><br><span class="line">            now - node-&gt;ping_sent &gt; server.cluster_node_timeout/2)</span><br><span class="line">        &#123;</span><br><span class="line">            /* Disconnect the link, it will be reconnected automatically. */</span><br><span class="line">            // 释放连接，下次 clusterCron() 会自动重连</span><br><span class="line">            freeClusterLink(node-&gt;link);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* If we have currently no active ping in this instance, and the</span><br><span class="line">         * received PONG is older than half the cluster timeout, send</span><br><span class="line">         * a new ping now, to ensure all the nodes are pinged without</span><br><span class="line">         * a too big delay. */</span><br><span class="line">        // 如果目前没有在 PING 节点</span><br><span class="line">        // 并且已经有 node timeout 一半的时间没有从节点那里收到 PONG 回复</span><br><span class="line">        // 那么向节点发送一个 PING ，确保节点的信息不会太旧</span><br><span class="line">        // （因为一部分节点可能一直没有被随机中）</span><br><span class="line">        if (node-&gt;link &amp;&amp;</span><br><span class="line">            node-&gt;ping_sent == 0 &amp;&amp;</span><br><span class="line">            (now - node-&gt;pong_received) &gt; server.cluster_node_timeout/2)</span><br><span class="line">        &#123;</span><br><span class="line">            clusterSendPing(node-&gt;link, CLUSTERMSG_TYPE_PING);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* If we are a master and one of the slaves requested a manual</span><br><span class="line">         * failover, ping it continuously. */</span><br><span class="line">        // 如果这是一个主节点，并且有一个从服务器请求进行手动故障转移</span><br><span class="line">        // 那么向从服务器发送 PING 。</span><br><span class="line">        if (server.cluster-&gt;mf_end &amp;&amp;</span><br><span class="line">            nodeIsMaster(myself) &amp;&amp;</span><br><span class="line">            server.cluster-&gt;mf_slave == node &amp;&amp;</span><br><span class="line">            node-&gt;link)</span><br><span class="line">        &#123;</span><br><span class="line">            clusterSendPing(node-&gt;link, CLUSTERMSG_TYPE_PING);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* Check only if we have an active ping for this instance. */</span><br><span class="line">        // 以下代码只在节点发送了 PING 命令的情况下执行</span><br><span class="line">        if (node-&gt;ping_sent == 0) continue;</span><br><span class="line"></span><br><span class="line">        /* Compute the delay of the PONG. Note that if we already received</span><br><span class="line">         * the PONG, then node-&gt;ping_sent is zero, so can&#x27;t reach this</span><br><span class="line">         * code at all. */</span><br><span class="line">        // 计算等待 PONG 回复的时长</span><br><span class="line">        delay = now - node-&gt;ping_sent;</span><br><span class="line"></span><br><span class="line">        // 等待 PONG 回复的时长超过了限制值，将目标节点标记为 PFAIL （疑似下线）</span><br><span class="line">        if (delay &gt; server.cluster_node_timeout) &#123;</span><br><span class="line">            /* Timeout reached. Set the node as possibly failing if it is</span><br><span class="line">             * not already in this state. */</span><br><span class="line">            if (!(node-&gt;flags &amp; (REDIS_NODE_PFAIL|REDIS_NODE_FAIL))) &#123;</span><br><span class="line">                redisLog(REDIS_DEBUG,&quot;*** NODE %.40s possibly failing&quot;,</span><br><span class="line">                    node-&gt;name);</span><br><span class="line">                // 打开疑似下线标记</span><br><span class="line">                node-&gt;flags |= REDIS_NODE_PFAIL;</span><br><span class="line">                update_state = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dictReleaseIterator(di);</span><br><span class="line"></span><br><span class="line">    /* If we are a slave node but the replication is still turned off,</span><br><span class="line">     * enable it if we know the address of our master and it appears to</span><br><span class="line">     * be up. */</span><br><span class="line">    // 如果从节点没有在复制主节点，那么对从节点进行设置</span><br><span class="line">    if (nodeIsSlave(myself) &amp;&amp;</span><br><span class="line">        server.masterhost == NULL &amp;&amp;</span><br><span class="line">        myself-&gt;slaveof &amp;&amp;</span><br><span class="line">        nodeHasAddr(myself-&gt;slaveof))</span><br><span class="line">    &#123;</span><br><span class="line">        replicationSetMaster(myself-&gt;slaveof-&gt;ip, myself-&gt;slaveof-&gt;port);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Abourt a manual failover if the timeout is reached. */</span><br><span class="line">    manualFailoverCheckTimeout();</span><br><span class="line"></span><br><span class="line">    if (nodeIsSlave(myself)) &#123;</span><br><span class="line">        clusterHandleManualFailover();</span><br><span class="line">        clusterHandleSlaveFailover();</span><br><span class="line">        /* If there are orphaned slaves, and we are a slave among the masters</span><br><span class="line">         * with the max number of non-failing slaves, consider migrating to</span><br><span class="line">         * the orphaned masters. Note that it does not make sense to try</span><br><span class="line">         * a migration if there is no master with at least *two* working</span><br><span class="line">         * slaves. */</span><br><span class="line">        if (orphaned_masters &amp;&amp; max_slaves &gt;= 2 &amp;&amp; this_slaves == max_slaves)</span><br><span class="line">            clusterHandleSlaveMigration(max_slaves);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 更新集群状态</span><br><span class="line">    if (update_state || server.cluster-&gt;state == REDIS_CLUSTER_FAIL)</span><br><span class="line">        clusterUpdateState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、状态信息并不是全量同步，而是随机选M（M &lt;&lt; N）个节点的状态同步到其他节点。<br>M值最小为3，最大为<code>N - 2</code>，一般情况下<code>M = N / 10</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">/* Send a PING or PONG packet to the specified node, making sure to add enough</span><br><span class="line"> * gossip informations. */</span><br><span class="line">// 向指定节点发送一条 MEET 、 PING 或者 PONG 消息</span><br><span class="line">void clusterSendPing(clusterLink *link, int type) &#123;</span><br><span class="line">    unsigned char buf[sizeof(clusterMsg)];</span><br><span class="line">    clusterMsg *hdr = (clusterMsg*) buf;</span><br><span class="line">    int gossipcount = 0, totlen;</span><br><span class="line">    /* freshnodes is the number of nodes we can still use to populate the</span><br><span class="line">     * gossip section of the ping packet. Basically we start with the nodes</span><br><span class="line">     * we have in memory minus two (ourself and the node we are sending the</span><br><span class="line">     * message to). Every time we add a node we decrement the counter, so when</span><br><span class="line">     * it will drop to &lt;= zero we know there is no more gossip info we can</span><br><span class="line">     * send. */</span><br><span class="line">    // freshnodes 是用于发送 gossip 信息的计数器</span><br><span class="line">    // 每次发送一条信息时，程序将 freshnodes 的值减一</span><br><span class="line">    // 当 freshnodes 的数值小于等于 0 时，程序停止发送 gossip 信息</span><br><span class="line">    // freshnodes 的数量是节点目前的 nodes 表中的节点数量减去 2 </span><br><span class="line">    // 这里的 2 指两个节点，一个是 myself 节点（也即是发送信息的这个节点）</span><br><span class="line">    // 另一个是接受 gossip 信息的节点</span><br><span class="line">    int freshnodes = dictSize(server.cluster-&gt;nodes)-2;</span><br><span class="line"></span><br><span class="line">    // 如果发送的信息是 PING ，那么更新最后一次发送 PING 命令的时间戳</span><br><span class="line">    if (link-&gt;node &amp;&amp; type == CLUSTERMSG_TYPE_PING)</span><br><span class="line">        link-&gt;node-&gt;ping_sent = mstime();</span><br><span class="line"></span><br><span class="line">    // 将当前节点的信息（比如名字、地址、端口号、负责处理的槽）记录到消息里面</span><br><span class="line">    clusterBuildMessageHdr(hdr,type);</span><br><span class="line"></span><br><span class="line">    /* Populate the gossip fields */</span><br><span class="line">    // 从当前节点已知的节点中随机选出两个节点</span><br><span class="line">    // 并通过这条消息捎带给目标节点，从而实现 gossip 协议</span><br><span class="line"></span><br><span class="line">    // 每个节点有 freshnodes 次发送 gossip 信息的机会</span><br><span class="line">    // 每次向目标节点发送 2 个被选中节点的 gossip 信息（gossipcount 计数）</span><br><span class="line">    while(freshnodes &gt; 0 &amp;&amp; gossipcount &lt; 3) &#123;</span><br><span class="line">        // 从 nodes 字典中随机选出一个节点（被选中节点）</span><br><span class="line">        dictEntry *de = dictGetRandomKey(server.cluster-&gt;nodes);</span><br><span class="line">        clusterNode *this = dictGetVal(de);</span><br><span class="line"></span><br><span class="line">        clusterMsgDataGossip *gossip;</span><br><span class="line">        int j;</span><br><span class="line"></span><br><span class="line">        /* In the gossip section don&#x27;t include:</span><br><span class="line">         * 以下节点不能作为被选中节点：</span><br><span class="line">         * 1) Myself.</span><br><span class="line">         *    节点本身。</span><br><span class="line">         * 2) Nodes in HANDSHAKE state.</span><br><span class="line">         *    处于 HANDSHAKE 状态的节点。</span><br><span class="line">         * 3) Nodes with the NOADDR flag set.</span><br><span class="line">         *    带有 NOADDR 标识的节点</span><br><span class="line">         * 4) Disconnected nodes if they don&#x27;t have configured slots.</span><br><span class="line">         *    因为不处理任何槽而被断开连接的节点 </span><br><span class="line">         */</span><br><span class="line">        if (this == myself ||</span><br><span class="line">            this-&gt;flags &amp; (REDIS_NODE_HANDSHAKE|REDIS_NODE_NOADDR) ||</span><br><span class="line">            (this-&gt;link == NULL &amp;&amp; this-&gt;numslots == 0))</span><br><span class="line">        &#123;</span><br><span class="line">                freshnodes--; /* otherwise we may loop forever. */</span><br><span class="line">                continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* Check if we already added this node */</span><br><span class="line">        // 检查被选中节点是否已经在 hdr-&gt;data.ping.gossip 数组里面</span><br><span class="line">        // 如果是的话说明这个节点之前已经被选中了</span><br><span class="line">        // 不要再选中它（否则就会出现重复）</span><br><span class="line">        for (j = 0; j &lt; gossipcount; j++) &#123;</span><br><span class="line">            if (memcmp(hdr-&gt;data.ping.gossip[j].nodename,this-&gt;name,</span><br><span class="line">                    REDIS_CLUSTER_NAMELEN) == 0) break;</span><br><span class="line">        &#125;</span><br><span class="line">        if (j != gossipcount) continue;</span><br><span class="line"></span><br><span class="line">        /* Add it */</span><br><span class="line"></span><br><span class="line">        // 这个被选中节点有效，计数器减一</span><br><span class="line">        freshnodes--;</span><br><span class="line"></span><br><span class="line">        // 指向 gossip 信息结构</span><br><span class="line">        gossip = &amp;(hdr-&gt;data.ping.gossip[gossipcount]);</span><br><span class="line"></span><br><span class="line">        // 将被选中节点的名字记录到 gossip 信息</span><br><span class="line">        memcpy(gossip-&gt;nodename,this-&gt;name,REDIS_CLUSTER_NAMELEN);</span><br><span class="line">        // 将被选中节点的 PING 命令发送时间戳记录到 gossip 信息</span><br><span class="line">        gossip-&gt;ping_sent = htonl(this-&gt;ping_sent);</span><br><span class="line">        // 将被选中节点的 PING 命令回复的时间戳记录到 gossip 信息</span><br><span class="line">        gossip-&gt;pong_received = htonl(this-&gt;pong_received);</span><br><span class="line">        // 将被选中节点的 IP 记录到 gossip 信息</span><br><span class="line">        memcpy(gossip-&gt;ip,this-&gt;ip,sizeof(this-&gt;ip));</span><br><span class="line">        // 将被选中节点的端口号记录到 gossip 信息</span><br><span class="line">        gossip-&gt;port = htons(this-&gt;port);</span><br><span class="line">        // 将被选中节点的标识值记录到 gossip 信息</span><br><span class="line">        gossip-&gt;flags = htons(this-&gt;flags);</span><br><span class="line"></span><br><span class="line">        // 这个被选中节点有效，计数器增一</span><br><span class="line">        gossipcount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 计算信息长度</span><br><span class="line">    totlen = sizeof(clusterMsg)-sizeof(union clusterMsgData);</span><br><span class="line">    totlen += (sizeof(clusterMsgDataGossip)*gossipcount);</span><br><span class="line">    // 将被选中节点的数量（gossip 信息中包含了多少个节点的信息）</span><br><span class="line">    // 记录在 count 属性里面</span><br><span class="line">    hdr-&gt;count = htons(gossipcount);</span><br><span class="line">    // 将信息的长度记录到信息里面</span><br><span class="line">    hdr-&gt;totlen = htonl(totlen);</span><br><span class="line"></span><br><span class="line">    // 发送信息</span><br><span class="line">    clusterSendMessage(link,buf,totlen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="扩容-缩容"><a href="#扩容-缩容" class="headerlink" title="扩容 &#x2F; 缩容"></a>扩容 &#x2F; 缩容</h2><p>当新的节点加入时，我们该如何重新分配数据，让新的节点也对外提供服务。当有节点退出时，我们该如何把存在该节点上的数据分配到其他机器上，让其他机器来提供这部分数据的服务。即集群的扩缩容问题。</p>
<h3 id="新节点加入流程"><a href="#新节点加入流程" class="headerlink" title="新节点加入流程"></a>新节点加入流程</h3><p>新节点加入时，需要把一部分数据迁移到新节点来达到集群的负载均衡。<br>在Redis集群中，数据的存储是以slot为单位的，因此：</p>
<ol>
<li>集群的伸缩本质上就是slot在不同机器节点之间的迁移；</li>
<li>迁移过程中，有的slot在老节点上，有的slot在新节点上，这时，客户端请求应该被重定向到正确的节点上。<br>比如slot1从A迁移到B上时，请求A或B会怎么样？请求别的节点又会怎么样？</li>
</ol>
<p>节点的迁移过程主要分为3个步骤：</p>
<ol>
<li>准备新节点</li>
<li>加入集群</li>
<li>迁移slot到新节点</li>
</ol>
<p>以下迁移过程的伪代码来自：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/105569485">Redis集群详解（中）</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">def move_slot(source,target,slot):</span><br><span class="line">    # 目标节点准备导入槽</span><br><span class="line">    target.cluster(&quot;setslot&quot;,slot,&quot;importing&quot;,source.nodeId);</span><br><span class="line">    # 目标节点准备全出槽</span><br><span class="line">    source.cluster(&quot;setslot&quot;,slot,&quot;migrating&quot;,target.nodeId);</span><br><span class="line">    while true :</span><br><span class="line">        # 批量从源节点获取键</span><br><span class="line">        keys = source.cluster(&quot;getkeysinslot&quot;,slot,pipeline_size);</span><br><span class="line">        if keys.length == 0:</span><br><span class="line">            # 键列表为空时，退出循环</span><br><span class="line">            break;</span><br><span class="line">        # 批量迁移键到目标节点</span><br><span class="line">        source.call(&quot;migrate&quot;,target.host,target.port,&quot;&quot;,0,timeout,&quot;keys&quot;,keys);</span><br><span class="line">    # 向集群所有主节点通知槽被分配给目标节点</span><br><span class="line">    for node in nodes:</span><br><span class="line">        if node.flag == &quot;slave&quot;:</span><br><span class="line">            continue;</span><br><span class="line">        node.cluster(&quot;setslot&quot;,slot,&quot;node&quot;,target.nodeId);</span><br></pre></td></tr></table></figure>

<h4 id="节点迁移过程"><a href="#节点迁移过程" class="headerlink" title="节点迁移过程"></a>节点迁移过程</h4><p>以下命令告知目标节点准备导入slot：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster setslot &lt;slot&gt; IMPORTING &lt;nodeId&gt;</span><br></pre></td></tr></table></figure>
<p>以下命令告知目标节点准备导出slot：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster setslot &lt;slot&gt; MIGRATING &lt;nodeId&gt;</span><br></pre></td></tr></table></figure>
<p>每个节点保存的集群状态中记录了迁移中的slot，其中，迁出的slot放到<code>migrating_slots_to</code>中，迁入的slot放到<code>importing_slots_from</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">typedef struct clusterState &#123;</span><br><span class="line">    clusterNode *myself;  /* This node */</span><br><span class="line">    // 当前纪元</span><br><span class="line">    uint64_t currentEpoch;</span><br><span class="line">    // 集群的状态</span><br><span class="line">    int state;            /* CLUSTER_OK, CLUSTER_FAIL, ... */</span><br><span class="line">    // 集群中至少负责一个槽的主节点个数</span><br><span class="line">    int size;             /* Num of master nodes with at least one slot */</span><br><span class="line">    // 保存集群节点的字典，键是节点名字，值是clusterNode结构的指针</span><br><span class="line">    dict *nodes;          /* Hash table of name -&gt; clusterNode structures */</span><br><span class="line">    // 防止重复添加节点的黑名单</span><br><span class="line">    dict *nodes_black_list; /* Nodes we don&#x27;t re-add for a few seconds. */</span><br><span class="line">    // 导入槽数据到目标节点，该数组记录这些节点</span><br><span class="line">    clusterNode *migrating_slots_to[CLUSTER_SLOTS];</span><br><span class="line">    // 导出槽数据到目标节点，该数组记录这些节点</span><br><span class="line">    clusterNode *importing_slots_from[CLUSTER_SLOTS];</span><br><span class="line">    // 槽和负责槽节点的映射</span><br><span class="line">    clusterNode *slots[CLUSTER_SLOTS];</span><br><span class="line">    // 槽映射到键的有序集合</span><br><span class="line">    zskiplist *slots_to_keys;</span><br><span class="line">    </span><br><span class="line">&#125; clusterState;</span><br></pre></td></tr></table></figure>

<p>接下来，将待迁移slot中的key批量转移到目标节点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 返回count个slot中的键</span><br><span class="line">cluster getkeysinslot &lt;slot&gt; &lt;count&gt;</span><br><span class="line"># 需要对上面命令返回的每个键都发送以下命令，该命令会将所指定的键原子地从源节点移动到目标节点</span><br><span class="line">migrate &lt;host&gt; &lt;port&gt; key destination-db timeout</span><br></pre></td></tr></table></figure>
<p>migrate命令就是向节点发送了N个RESTORE-ASKING命令，实现代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/* Create RESTORE payload and generate the protocol to call the command. */</span><br><span class="line">for (j = 0; j &lt; num_keys; j++) &#123;</span><br><span class="line">    long long ttl = 0;</span><br><span class="line">    long long expireat = getExpire(c-&gt;db,kv[j]);</span><br><span class="line">    //检查键是不是已经过期</span><br><span class="line">    if (expireat != -1) &#123;</span><br><span class="line">        ttl = expireat-mstime();</span><br><span class="line">        if (ttl &lt; 0) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        if (ttl &lt; 1) ttl = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    kv[non_expired++] = kv[j];</span><br><span class="line"></span><br><span class="line">    // 集群模式下写入RESTORE-ASKING命令，普通模式下写入RESTORE命令</span><br><span class="line">    if (server.cluster_enabled)</span><br><span class="line">        serverAssertWithInfo(c,NULL,</span><br><span class="line">            rioWriteBulkString(&amp;cmd,&quot;RESTORE-ASKING&quot;,14));</span><br><span class="line">    else</span><br><span class="line">        serverAssertWithInfo(c,NULL,rioWriteBulkString(&amp;cmd,&quot;RESTORE&quot;,7));</span><br><span class="line">    // 写入KEY，写入TTL</span><br><span class="line">    serverAssertWithInfo(c,NULL,sdsEncodedObject(kv[j]));</span><br><span class="line">    serverAssertWithInfo(c,NULL,rioWriteBulkString(&amp;cmd,kv[j]-&gt;ptr,</span><br><span class="line">            sdslen(kv[j]-&gt;ptr)));</span><br><span class="line">    serverAssertWithInfo(c,NULL,rioWriteBulkLongLong(&amp;cmd,ttl));</span><br><span class="line">    // 写入VALUE以及Redis版本校验码等信息</span><br><span class="line">    createDumpPayload(&amp;payload,ov[j],kv[j]);</span><br><span class="line">    serverAssertWithInfo(c,NULL,</span><br><span class="line">        rioWriteBulkString(&amp;cmd,payload.io.buffer.ptr,</span><br><span class="line">                           sdslen(payload.io.buffer.ptr)));</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迁入节点接收到restore-asking命令后，执行节点的恢复操作，即获取key，解析出value，然后写入数据库：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/* RESTORE key ttl serialized-value [REPLACE] */</span><br><span class="line">// 根据给定的 DUMP 数据，还原出一个键值对数据，并将它保存到数据库里面</span><br><span class="line">void restoreCommand(redisClient *c) &#123;</span><br><span class="line">    long long ttl;</span><br><span class="line">    rio payload;</span><br><span class="line">    int j, type, replace = 0;</span><br><span class="line">    robj *obj;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    // 读取 DUMP 数据，并反序列化出键值对的类型和值</span><br><span class="line">    rioInitWithBuffer(&amp;payload,c-&gt;argv[3]-&gt;ptr);</span><br><span class="line">    if (((type = rdbLoadObjectType(&amp;payload)) == -1) ||</span><br><span class="line">        ((obj = rdbLoadObject(type,&amp;payload)) == NULL))</span><br><span class="line">    &#123;</span><br><span class="line">        addReplyError(c,&quot;Bad data format&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Remove the old key if needed. */</span><br><span class="line">    // 如果给定了 REPLACE 选项，那么先删除数据库中已存在的同名键</span><br><span class="line">    if (replace) dbDelete(c-&gt;db,c-&gt;argv[1]);</span><br><span class="line"></span><br><span class="line">    /* Create the key and set the TTL if any */</span><br><span class="line">    // 将键值对添加到数据库</span><br><span class="line">    dbAdd(c-&gt;db,c-&gt;argv[1],obj);</span><br><span class="line"></span><br><span class="line">    // 如果键带有 TTL 的话，设置键的 TTL</span><br><span class="line">    if (ttl) setExpire(c-&gt;db,c-&gt;argv[1],mstime()+ttl);</span><br><span class="line"></span><br><span class="line">    signalModifiedKey(c-&gt;db,c-&gt;argv[1]);</span><br><span class="line"></span><br><span class="line">    addReply(c,shared.ok);</span><br><span class="line">    server.dirty++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迁移过程中，在外部客户端的视角看来，在任意时间点上，key只会存在于某个节点上，而不会同时存在于两个节点上。</p>
<p>现在，待迁移槽中的key都已经被迁移了，但是对其他节点来说，该slot仍是由迁出节点负责的，它们接收到相关请求后仍然会路由到迁出节点，所以迁移的最后一步需要向集群中的所有主节点通知槽已经被分配给目标节点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster setslot &lt;slot&gt; node &lt;nodeId&gt;</span><br></pre></td></tr></table></figure>

<h4 id="迁移过程中对新请求的响应"><a href="#迁移过程中对新请求的响应" class="headerlink" title="迁移过程中对新请求的响应"></a>迁移过程中对新请求的响应</h4><p>迁移过程中：</p>
<ul>
<li>如果迁出节点接收请求，迁出节点判断slot或key是否已迁出，若是则<strong>ASK重定向</strong>到迁入节点上，否则迁出节点自己负责处理请求；</li>
<li>如果迁入节点接收请求，会把请求重定向到迁出节点上，除非请求中包含<strong>ASKING</strong>命令；</li>
<li>其他节点接收到的相关请求会被重定向到迁出节点上；<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">int processCommand(redisClient *c) &#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    /* If cluster is enabled perform the cluster redirection here.</span><br><span class="line">     *</span><br><span class="line">     * 如果开启了集群模式，那么在这里进行转向操作。</span><br><span class="line">     *</span><br><span class="line">     * However we don&#x27;t perform the redirection if:</span><br><span class="line">     *</span><br><span class="line">     * 不过，如果有以下情况出现，那么节点不进行转向：</span><br><span class="line">     *</span><br><span class="line">     * 1) The sender of this command is our master.</span><br><span class="line">     *    命令的发送者是本节点的主节点</span><br><span class="line">     *</span><br><span class="line">     * 2) The command has no key arguments. </span><br><span class="line">     *    命令没有 key 参数</span><br><span class="line">     */</span><br><span class="line">    if (server.cluster_enabled &amp;&amp;</span><br><span class="line">        !(c-&gt;flags &amp; REDIS_MASTER) &amp;&amp;</span><br><span class="line">        !(c-&gt;cmd-&gt;getkeys_proc == NULL &amp;&amp; c-&gt;cmd-&gt;firstkey == 0))</span><br><span class="line">    &#123;</span><br><span class="line">        int hashslot;</span><br><span class="line"></span><br><span class="line">        // 集群已下线</span><br><span class="line">        if (server.cluster-&gt;state != REDIS_CLUSTER_OK) &#123;</span><br><span class="line">            flagTransaction(c);</span><br><span class="line">            addReplySds(c,sdsnew(&quot;-CLUSTERDOWN The cluster is down. Use CLUSTER INFO for more information\r\n&quot;));</span><br><span class="line">            return REDIS_OK;</span><br><span class="line"></span><br><span class="line">        // 集群运作正常</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            int error_code;</span><br><span class="line">            clusterNode *n = getNodeByQuery(c,c-&gt;cmd,c-&gt;argv,c-&gt;argc,&amp;hashslot,&amp;error_code);</span><br><span class="line">            // 不能执行多键处理命令</span><br><span class="line">            if (n == NULL) &#123;</span><br><span class="line">                flagTransaction(c);</span><br><span class="line">                if (error_code == REDIS_CLUSTER_REDIR_CROSS_SLOT) &#123;</span><br><span class="line">                    addReplySds(c,sdsnew(&quot;-CROSSSLOT Keys in request don&#x27;t hash to the same slot\r\n&quot;));</span><br><span class="line">                &#125; else if (error_code == REDIS_CLUSTER_REDIR_UNSTABLE) &#123;</span><br><span class="line">                    /* The request spawns mutliple keys in the same slot,</span><br><span class="line">                     * but the slot is not &quot;stable&quot; currently as there is</span><br><span class="line">                     * a migration or import in progress. */</span><br><span class="line">                    addReplySds(c,sdsnew(&quot;-TRYAGAIN Multiple keys request during rehashing of slot\r\n&quot;));</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    redisPanic(&quot;getNodeByQuery() unknown error.&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                return REDIS_OK;</span><br><span class="line"></span><br><span class="line">            // 命令针对的槽和键不是本节点处理的，进行转向</span><br><span class="line">            &#125; else if (n != server.cluster-&gt;myself) &#123;</span><br><span class="line">                flagTransaction(c);</span><br><span class="line">                // -&lt;ASK or MOVED&gt; &lt;slot&gt; &lt;ip&gt;:&lt;port&gt;</span><br><span class="line">                // 例如 -ASK 10086 127.0.0.1:12345</span><br><span class="line">                addReplySds(c,sdscatprintf(sdsempty(),</span><br><span class="line">                    &quot;-%s %d %s:%d\r\n&quot;,</span><br><span class="line">                    (error_code == REDIS_CLUSTER_REDIR_ASK) ? &quot;ASK&quot; : &quot;MOVED&quot;,</span><br><span class="line">                    hashslot,n-&gt;ip,n-&gt;port));</span><br><span class="line"></span><br><span class="line">                return REDIS_OK;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 如果执行到这里，说明键 key 所在的槽由本节点处理</span><br><span class="line">            // 或者客户端执行的是无参数命令</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
注意上边的<code>getNodeByQuery</code>根据key的散列结果查询命令应该被打到的节点，可以看到这个函数里有对ASKING标识的特殊处理：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">clusterNode *getNodeByQuery(redisClient *c, struct redisCommand *cmd, robj **argv, int argc, int *hashslot, int *error_code) &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    /* If we are receiving the slot, and the client correctly flagged the</span><br><span class="line">     * request as &quot;ASKING&quot;, we can serve the request. However if the request</span><br><span class="line">     * involves multiple keys and we don&#x27;t have them all, the only option is</span><br><span class="line">     * to send a TRYAGAIN error. */</span><br><span class="line">    if (importing_slot &amp;&amp;</span><br><span class="line">        (c-&gt;flags &amp; REDIS_ASKING || cmd-&gt;flags &amp; REDIS_CMD_ASKING))</span><br><span class="line">    &#123;</span><br><span class="line">        if (multiple_keys &amp;&amp; missing_keys) &#123;</span><br><span class="line">            if (error_code) *error_code = REDIS_CLUSTER_REDIR_UNSTABLE;</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return myself;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="旧节点退出流程"><a href="#旧节点退出流程" class="headerlink" title="旧节点退出流程"></a>旧节点退出流程</h3><p>与新节点的加入相反的是，旧节点退出时需要把其上的数据迁移到其他节点上，确保该节点上的数据能够被正常访问。<br>槽的迁移过程和上边扩容中描述的没有区别，主要区别是在迁移完毕后需要轮询每个节点发送<code>cluster forget</code>命令，让它们能忘记下线的节点。<br>节点在接收<code>cluster forget</code>命令后，会将目标节点的状态从自己保存的集群状态中移除，并将其加入黑名单中60s，这期间其他节点不会再去更新自己维护的该节点的信息，也就是说这60秒内该节点无法重新加入集群内。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">def delnode_cluster_cmd(downNode):</span><br><span class="line">    # 下线节点不允许包含slots</span><br><span class="line">    if downNode.slots.length != 0</span><br><span class="line">        exit 1</span><br><span class="line">    end</span><br><span class="line">    # 向集群内节点发送cluster forget</span><br><span class="line">    for n in nodes:</span><br><span class="line">        if n.id == downNode.id:</span><br><span class="line">            # 不能对自己做forget操作</span><br><span class="line">            continue;</span><br><span class="line">        # 如果下线节点有从节点则把从节点指向其他主节点</span><br><span class="line">        if n.replicate &amp;&amp; n.replicate.nodeId == downNode.id :</span><br><span class="line">            # 指向拥有最少从节点的主节点</span><br><span class="line">            master = get_master_with_least_replicas();</span><br><span class="line">            n.cluster(&quot;replicate&quot;,master.nodeId);</span><br><span class="line">        #发送忘记节点命令</span><br><span class="line">        n.cluster(&#x27;forget&#x27;,downNode.id)</span><br><span class="line">    # 节点关闭</span><br><span class="line">    downNode.shutdown();</span><br></pre></td></tr></table></figure>

<h3 id="集群规模估算"><a href="#集群规模估算" class="headerlink" title="集群规模估算"></a>集群规模估算</h3><p>集群规模并不是没有限制的，理论上每个节点一个slot集群可以扩容到16384个节点，但是Redis官方给出的规模上限是一个集群1000个节点，因为<strong>实例间的通信开销会随着实例规模增加而增大</strong>。<br>下面来讨论下集群内部有哪些交互，并分析它们会对性能有什么样的影响。</p>
<h4 id="实例间数据的同步"><a href="#实例间数据的同步" class="headerlink" title="实例间数据的同步"></a>实例间数据的同步</h4><p>集群每个节点都会记录slot和实例间的映射关系，用于请求的重定向。<br>每个实例都需要通过Gossip协议将数据同步到其他节点，大致流程为：</p>
<ol>
<li>每个实例之间会按照<strong>一定的频率</strong>，从集群中<strong>随机挑选一些实例</strong>，把 PING 消息发送给挑选出来的实例，用来检测这些实例是否在线，并交换彼此的状态信息。PING 消息中封装了发送消息的实例自身的状态信息、部分其它实例的状态信息，以及 Slot 映射表。<br>发送的<strong>节点状态信息</strong>在源码中由<code>clusterMsgDataGossip</code>这个结构来表示，大小为104字节。每个实例在发送Gossip消息时，除了传递自身的状态信息，默认还会传递集群十分之一实例的状态信息，比如，对于一个包含了 1000 个实例的集群来说，每个实例发送一个 PING 消息时，会包含 100 个实例的状态信息，总的数据量是 10400 字节，再加上发送实例自身的信息，一个 Gossip 消息大约是 10KB。<br>另外，Slot映射表是一个16384位的bitmap，算上上面的10KB就是12KB的内容。</li>
<li>一个实例在接收到 PING 消息后，会给发送 PING 消息的实例，发送一个 PONG 消息。PONG 消息包含的内容和 PING 消息一样，也是12KB。</li>
<li>另外，上面是随机选节点发PING请求的，如果部分节点一直没有被选到，就会导致这些节点和其他节点不同步。<br>为了避免这种情况，Redis Cluster 的实例会按照每 100ms 一次的频率，扫描本地的实例列表，如果发现有实例最近一次接收 PONG 消息的时间，已经大于配置项 cluster-node-timeout 的一半了（cluster-node-timeout&#x2F;2），就会立刻给该实例发送 PING 消息，更新这个实例上的集群状态信息。<br>当集群规模扩大之后，因为网络拥塞或是不同服务器间的流量竞争，会导致实例间的网络通信延迟增加。如果有部分实例无法收到其它实例发送的 PONG 消息，就会引起实例之间频繁地发送 PING 消息，这又会对集群网络通信带来额外的开销了。</li>
</ol>
<p>从上可知，实例间的数据同步受到<strong>通信消息大小</strong>和<strong>通信频率</strong>这两方面的影响。<br>当集群规模扩大后，PING&#x2F;PONG会占用大量的集群内网络带宽，降低集群服务正常请求的吞吐量。<br>单实例<strong>每秒</strong>会发送的PING消息数量大致可以算出是（注意cron是100ms执行一次）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PING 消息发送数量 = 1 + 10 * 实例数（最近一次接收 PONG 消息的时间超出 cluster-node-timeout/2）</span><br></pre></td></tr></table></figure>
<p>其中，1 是指单实例常规按照每 1 秒发送一个 PING 消息，10 是指每 1 秒内实例会执行 10 次检查，每次检查后会给 PONG 消息超时的实例发送消息。<br>假设单个实例检测发现，每 100 毫秒有 10 个实例的 PONG 消息接收超时，那么，这个实例每秒就会发送 101 个 PING 消息，约占 1.2MB&#x2F;s 带宽。如果集群中有 30 个实例按照这种频率发送消息，就会占用 36MB&#x2F;s 带宽，这就会挤占集群中用于服务正常请求的带宽。</p>
<p>因此实例间的通信开销优化主要是：</p>
<ol>
<li>减少实例传输的消息大小（PING&#x2F;PONG 消息、Slot 分配信息）<br>但是，因为集群实例依赖 PING、PONG 消息和 Slot 分配信息，来维持集群状态的统一，一旦减小了传递的消息大小，就会导致实例间的通信信息减少，不利于集群维护，所以，我们不能采用这种方式。</li>
<li>降低实例间发送消息的频率<br>从上面<code>PING消息发送数量</code>公式可以看出，每秒发送一条PING消息的频率不算高，如果要降低可能导致集群内数据同步延迟；每100ms做一次检测并给延迟超过<code>cluster-node-timeout/2</code>的节点发送PING消息，这个配置是可以适当调大的。<ul>
<li>如果配置得比较小，则在大规模集群中会频繁出现PONG超时的情况；</li>
<li>如果配置得过大，则如果真得发生了故障，我们反而需要等比较长的时间才能检测出来。<br>可以在调整前后使用tcpdump抓取实例发送心跳网络包的情况。<br><code>tcpdump host 192.168.10.3 port 16379 -i 网卡名 -w /tmp/r1.cap</code></li>
</ul>
</li>
</ol>
<h2 id="故障恢复（容错）"><a href="#故障恢复（容错）" class="headerlink" title="故障恢复（容错）"></a>故障恢复（容错）</h2><p>Redis故障恢复主要分为以下3个步骤：</p>
<ol>
<li>故障发现<br>采用多数派协议完成故障检测判断（即至少有半数以上节点认为某主节点故障后才真正判断节点故障）。</li>
<li>子节点选举<br>Redis Cluster中每个Master都会有1至多个Slave，通过复制实现高可用（故障转移），当Master有多个Slave，会采用Raft实现选举出一个主节点以实现故障恢复。</li>
<li>配置更新<br>故障转移后，那么之前的Master和其他Slave怎么处理？Redis会将这些节点成为新Master节点的子节点。</li>
</ol>
<h3 id="故障发现"><a href="#故障发现" class="headerlink" title="故障发现"></a>故障发现</h3><p>一些 CP 特性且中心化的集群来说，当出现节点宕机时经常需要选举新的 Leader 节点，但是 Redis-Cluster 是<strong>去中心化</strong>的，某个 Master 的宕机并不会影响其他节点的工作。但是，当节点失联时，需要考虑网络的抖动情况，毕竟不能因为某几个请求意外超时就推断集群失败了，部分节点判断一个节点失联只会标记这个节点状态为<strong>PFAIL（主观下线）</strong>，之后如果多数节点<strong>投票</strong>通过才会真正标记这个节点<strong>FAIL（下线）</strong>。<br>投票过程是集群中所有 master 参与的，每个节点都存有整个集群所有主节点及从节点的信息，它们之间通过互相 ping-pong 来判断节点是否可以连上，如果半数以上 master 节点与当前 master 节点通信超时（cluster-node-timeout），则认为当前 master 节点挂掉，标记这个节点状态为<strong>FAIL</strong>。</p>
<p>当 master 挂掉时，并不意味着集群已无法再提供服务了，集群要进入<code>fail（不可用）</code>状态需要满足以下条件之一：</p>
<ol>
<li>集群的任意 master 挂掉，且该 master 没有 slave 或 slave 全挂掉了，则集群进入 fail 状态。<br>这是因为，Cluster中所有slot是平均分配到每个Master的，如果有一个Master的slot不能用了、而且这个Master还没有Slave，那么集群就不能提供服务了，如果Master还有Slave，Slave可以代替Master继续向外提供服务，这个步骤称为<strong>slave promotion</strong>。<br>单独的一对Master-Slave挂掉，Redis还提供一个叫 <strong>Replica Migration</strong> 的解决方案：当集群中的某个Master节点没有Slave节点时（称之为 Orphaned Master），其他有富余Slave节点的主节点会向该节点迁移一个Slave节点以防该节点下线之后没有子节点来替换从而导致整个集群下线。</li>
<li>集群超过半数以上 master 挂掉，无论有无 slave 都进入 fail 状态。</li>
</ol>
<p>当集群不可用时，任何操作都将返回<code>((error) CLUSTERDOWN The cluster is down)</code>错误。需要注意的是，必须要 3 个或以上的主节点，否则在创建集群时会失败。</p>
<h4 id="PFAIL"><a href="#PFAIL" class="headerlink" title="PFAIL"></a>PFAIL</h4><p>1、Redis每个节点会不断向其他节点发送<code>PING</code>消息来检测其他节点是否可达，如果超时会先断开连接：<br>代码：<code>cluster.c/clusterCron</code><br><img src="/imgs/Redis/RedisCluster%E6%95%85%E9%9A%9C%E5%8F%91%E7%8E%B01.png" alt="RedisCluster故障发现1" title="RedisCluster故障发现1"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/* This is executed 10 times every second */</span><br><span class="line">// 集群常规操作函数，默认每秒执行 10 次（每间隔 100 毫秒执行一次）</span><br><span class="line">void clusterCron(void) &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    while((de = dictNext(di)) != NULL) &#123;</span><br><span class="line">        clusterNode *node = dictGetVal(de);</span><br><span class="line">        now = mstime(); /* Use an updated time at every iteration. */</span><br><span class="line">        mstime_t delay;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        /* If we are waiting for the PONG more than half the cluster</span><br><span class="line">         * timeout, reconnect the link: maybe there is a connection</span><br><span class="line">         * issue even if the node is alive. */</span><br><span class="line">        // 判断连接的节点是否出事</span><br><span class="line">        if (node-&gt;link &amp;&amp; /* is connected */</span><br><span class="line">            now - node-&gt;link-&gt;ctime &gt;</span><br><span class="line">            server.cluster_node_timeout &amp;&amp; /* was not already reconnected */</span><br><span class="line">            // ping_sent记录发送命令的时间</span><br><span class="line">            node-&gt;ping_sent &amp;&amp; /* we already sent a ping */</span><br><span class="line">            node-&gt;pong_received &lt; node-&gt;ping_sent &amp;&amp; /* still waiting pong */</span><br><span class="line">            /* and we are waiting for the pong more than timeout/2 */</span><br><span class="line">            // PONG 到达的时间超过了 node_timeout 的一半</span><br><span class="line">            now - node-&gt;ping_sent &gt; server.cluster_node_timeout/2)</span><br><span class="line">        &#123;</span><br><span class="line">            /* Disconnect the link, it will be reconnected automatically. */</span><br><span class="line">            // 释放连接，此时node-&gt;link=NULL，下次 clusterCron() 会自动重连</span><br><span class="line">            freeClusterLink(node-&gt;link);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、此时节点A PING目标节点B失败，A会尝试重连，并将重连时间记录到ping_sent变量中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">/* This is executed 10 times every second */</span><br><span class="line">// 集群常规操作函数，默认每秒执行 10 次（每间隔 100 毫秒执行一次）</span><br><span class="line">void clusterCron(void) &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    /* Check if we have disconnected nodes and re-establish the connection. */</span><br><span class="line">    // 向集群中的所有断线或者未连接节点发送消息</span><br><span class="line">    di = dictGetSafeIterator(server.cluster-&gt;nodes);</span><br><span class="line">    while((de = dictNext(di)) != NULL) &#123;</span><br><span class="line">        clusterNode *node = dictGetVal(de);</span><br><span class="line"></span><br><span class="line">        // 跳过当前节点以及没有地址的节点</span><br><span class="line">        if (node-&gt;flags &amp; (REDIS_NODE_MYSELF|REDIS_NODE_NOADDR)) continue;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        // 为未创建连接的节点创建连接</span><br><span class="line">        if (node-&gt;link == NULL) &#123;</span><br><span class="line">            int fd;</span><br><span class="line">            mstime_t old_ping_sent;</span><br><span class="line">            clusterLink *link;</span><br><span class="line"></span><br><span class="line">            fd = anetTcpNonBlockBindConnect(server.neterr, node-&gt;ip,</span><br><span class="line">                node-&gt;port+REDIS_CLUSTER_PORT_INCR,</span><br><span class="line">                    server.bindaddr_count ? server.bindaddr[0] : NULL);</span><br><span class="line">            if (fd == -1) &#123;</span><br><span class="line">                redisLog(REDIS_DEBUG, &quot;Unable to connect to &quot;</span><br><span class="line">                    &quot;Cluster Node [%s]:%d -&gt; %s&quot;, node-&gt;ip,</span><br><span class="line">                    node-&gt;port+REDIS_CLUSTER_PORT_INCR,</span><br><span class="line">                    server.neterr);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            link = createClusterLink(node);</span><br><span class="line">            link-&gt;fd = fd;</span><br><span class="line">            node-&gt;link = link;</span><br><span class="line">            aeCreateFileEvent(server.el,link-&gt;fd,AE_READABLE,</span><br><span class="line">                    clusterReadHandler,link);</span><br><span class="line">            /* Queue a PING in the new connection ASAP: this is crucial</span><br><span class="line">             * to avoid false positives in failure detection.</span><br><span class="line">             *</span><br><span class="line">             * If the node is flagged as MEET, we send a MEET message instead</span><br><span class="line">             * of a PING one, to force the receiver to add us in its node</span><br><span class="line">             * table. */</span><br><span class="line">            // 向新连接的节点发送 PING 命令，防止节点被识进入下线</span><br><span class="line">            // 如果节点被标记为 MEET ，那么发送 MEET 命令，否则发送 PING 命令</span><br><span class="line">            old_ping_sent = node-&gt;ping_sent;</span><br><span class="line">            clusterSendPing(link, node-&gt;flags &amp; REDIS_NODE_MEET ?</span><br><span class="line">                    CLUSTERMSG_TYPE_MEET : CLUSTERMSG_TYPE_PING);</span><br><span class="line"></span><br><span class="line">            // 这不是第一次发送 PING 信息，所以可以还原这个时间</span><br><span class="line">            // 等 clusterSendPing() 函数来更新它</span><br><span class="line">            if (old_ping_sent) &#123;</span><br><span class="line">                /* If there was an active ping before the link was</span><br><span class="line">                 * disconnected, we want to restore the ping time, otherwise</span><br><span class="line">                 * replaced by the clusterSendPing() call. */</span><br><span class="line">                node-&gt;ping_sent = old_ping_sent;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            /* We can clear the flag after the first packet is sent.</span><br><span class="line">             *</span><br><span class="line">             * 在发送 MEET 信息之后，清除节点的 MEET 标识。</span><br><span class="line">             *</span><br><span class="line">             * If we&#x27;ll never receive a PONG, we&#x27;ll never send new packets</span><br><span class="line">             * to this node. Instead after the PONG is received and we</span><br><span class="line">             * are no longer in meet/handshake status, we want to send</span><br><span class="line">             * normal PING packets. </span><br><span class="line">             *</span><br><span class="line">             * 如果当前节点（发送者）没能收到 MEET 信息的回复，</span><br><span class="line">             * 那么它将不再向目标节点发送命令。</span><br><span class="line">             *</span><br><span class="line">             * 如果接收到回复的话，那么节点将不再处于 HANDSHAKE 状态，</span><br><span class="line">             * 并继续向目标节点发送普通 PING 命令。</span><br><span class="line">             */</span><br><span class="line">            node-&gt;flags &amp;= ~REDIS_NODE_MEET;</span><br><span class="line"></span><br><span class="line">            redisLog(REDIS_DEBUG,&quot;Connecting with Node %.40s at %s:%d&quot;,</span><br><span class="line">                    node-&gt;name, node-&gt;ip, node-&gt;port+REDIS_CLUSTER_PORT_INCR);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、节点A发现PING B的延时时间超过了node_timeout之后，就会标记该节点为PFAIL（Possible FAILure），即主观下线：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">void clusterCron(void) &#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    // 遍历所有节点，检查是否需要将某个节点标记为下线</span><br><span class="line">    /* Iterate nodes to check if we need to flag something as failing.</span><br><span class="line">     * This loop is also responsible to:</span><br><span class="line">     * 1) Check if there are orphaned masters (masters without non failing</span><br><span class="line">     *    slaves).</span><br><span class="line">     * 2) Count the max number of non failing slaves for a single master.</span><br><span class="line">     * 3) Count the number of slaves for our master, if we are a slave. */</span><br><span class="line">    orphaned_masters = 0;</span><br><span class="line">    max_slaves = 0;</span><br><span class="line">    this_slaves = 0;</span><br><span class="line">    di = dictGetSafeIterator(server.cluster-&gt;nodes);</span><br><span class="line">    while((de = dictNext(di)) != NULL) &#123;</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        /* Check only if we have an active ping for this instance. */</span><br><span class="line">        // 以下代码只在节点发送了 PING 命令的情况下执行</span><br><span class="line">        if (node-&gt;ping_sent == 0) continue;</span><br><span class="line"></span><br><span class="line">        /* Compute the delay of the PONG. Note that if we already received</span><br><span class="line">         * the PONG, then node-&gt;ping_sent is zero, so can&#x27;t reach this</span><br><span class="line">         * code at all. */</span><br><span class="line">        // 计算等待 PONG 回复的时长</span><br><span class="line">        delay = now - node-&gt;ping_sent;</span><br><span class="line"></span><br><span class="line">        // 等待 PONG 回复的时长超过了限制值，将目标节点标记为 PFAIL （疑似下线）</span><br><span class="line">        if (delay &gt; server.cluster_node_timeout) &#123;</span><br><span class="line">            /* Timeout reached. Set the node as possibly failing if it is</span><br><span class="line">             * not already in this state. */</span><br><span class="line">            if (!(node-&gt;flags &amp; (REDIS_NODE_PFAIL|REDIS_NODE_FAIL))) &#123;</span><br><span class="line">                redisLog(REDIS_DEBUG,&quot;*** NODE %.40s possibly failing&quot;,</span><br><span class="line">                    node-&gt;name);</span><br><span class="line">                // 打开疑似下线标记</span><br><span class="line">                node-&gt;flags |= REDIS_NODE_PFAIL;</span><br><span class="line">                update_state = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="FAIL"><a href="#FAIL" class="headerlink" title="FAIL"></a>FAIL</h4><p><img src="/imgs/Redis/RedisCluster%E6%95%85%E9%9A%9C%E5%8F%91%E7%8E%B02.png" alt="RedisCluster故障发现2" title="RedisCluster故障发现2"><br>1、A将B标记为PFAIL后，A会通过<strong>Gossip</strong>通知到其他节点。</p>
<p>2、所有节点会维护一个下线报告列表（Fail Report），主要维护一个节点被哪些节点报告处于下线状态，此时，C会记录“B被A报告下线了”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line">int clusterProcessPacket(clusterLink *link) &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    /* Process packets by type. */</span><br><span class="line">    // 根据消息的类型，处理节点</span><br><span class="line"></span><br><span class="line">    // 这是一条 PING 消息或者 MEET 消息</span><br><span class="line">    if (type == CLUSTERMSG_TYPE_PING || type == CLUSTERMSG_TYPE_MEET) &#123;</span><br><span class="line">        redisLog(REDIS_DEBUG,&quot;Ping packet received: %p&quot;, (void*)link-&gt;node);</span><br><span class="line"></span><br><span class="line">        /* Add this node if it is new for us and the msg type is MEET.</span><br><span class="line">         *</span><br><span class="line">         * 如果当前节点是第一次遇见这个节点，并且对方发来的是 MEET 信息，</span><br><span class="line">         * 那么将这个节点添加到集群的节点列表里面。</span><br><span class="line">         *</span><br><span class="line">         * In this stage we don&#x27;t try to add the node with the right</span><br><span class="line">         * flags, slaveof pointer, and so forth, as this details will be</span><br><span class="line">         * resolved when we&#x27;ll receive PONGs from the node. </span><br><span class="line">         *</span><br><span class="line">         * 节点目前的 flag 、 slaveof 等属性的值都是未设置的，</span><br><span class="line">         * 等当前节点向对方发送 PING 命令之后，</span><br><span class="line">         * 这些信息可以从对方回复的 PONG 信息中取得。</span><br><span class="line">         */</span><br><span class="line">        if (!sender &amp;&amp; type == CLUSTERMSG_TYPE_MEET) &#123;</span><br><span class="line">            clusterNode *node;</span><br><span class="line"></span><br><span class="line">            // 创建 HANDSHAKE 状态的新节点</span><br><span class="line">            node = createClusterNode(NULL,REDIS_NODE_HANDSHAKE);</span><br><span class="line"></span><br><span class="line">            // 设置 IP 和端口</span><br><span class="line">            nodeIp2String(node-&gt;ip,link);</span><br><span class="line">            node-&gt;port = ntohs(hdr-&gt;port);</span><br><span class="line"></span><br><span class="line">            // 将新节点添加到集群</span><br><span class="line">            clusterAddNode(node);</span><br><span class="line"></span><br><span class="line">            clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* Get info from the gossip section */</span><br><span class="line">        // 分析并取出消息中的 gossip 节点信息</span><br><span class="line">        clusterProcessGossipSection(hdr,link);</span><br><span class="line"></span><br><span class="line">        /* Anyway reply with a PONG */</span><br><span class="line">        // 向目标节点返回一个 PONG</span><br><span class="line">        clusterSendPing(link,CLUSTERMSG_TYPE_PONG);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void clusterProcessGossipSection(clusterMsg *hdr, clusterLink *link) &#123;</span><br><span class="line"></span><br><span class="line">    // 记录这条消息中包含了多少个节点的信息</span><br><span class="line">    uint16_t count = ntohs(hdr-&gt;count);</span><br><span class="line"></span><br><span class="line">    // 指向第一个节点的信息</span><br><span class="line">    clusterMsgDataGossip *g = (clusterMsgDataGossip*) hdr-&gt;data.ping.gossip;</span><br><span class="line"></span><br><span class="line">    // 取出发送者</span><br><span class="line">    clusterNode *sender = link-&gt;node ? link-&gt;node : clusterLookupNode(hdr-&gt;sender);</span><br><span class="line"></span><br><span class="line">    // 遍历所有节点的信息</span><br><span class="line">    while(count--) &#123;</span><br><span class="line">        sds ci = sdsempty();</span><br><span class="line"></span><br><span class="line">        // 分析节点的 flag</span><br><span class="line">        uint16_t flags = ntohs(g-&gt;flags);</span><br><span class="line"></span><br><span class="line">        // 信息节点</span><br><span class="line">        clusterNode *node;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        /* Update our state accordingly to the gossip sections */</span><br><span class="line">        // 使用消息中的信息对节点进行更新</span><br><span class="line">        node = clusterLookupNode(g-&gt;nodename);</span><br><span class="line">        // 节点已经存在于当前节点</span><br><span class="line">        if (node) &#123;</span><br><span class="line">            /* We already know this node.</span><br><span class="line">               Handle failure reports, only when the sender is a master. */</span><br><span class="line">            // 如果 sender 是一个主节点，那么我们需要处理下线报告</span><br><span class="line">            if (sender &amp;&amp; nodeIsMaster(sender) &amp;&amp; node != myself) &#123;</span><br><span class="line">                // 节点处于 FAIL 或者 PFAIL 状态</span><br><span class="line">                if (flags &amp; (REDIS_NODE_FAIL|REDIS_NODE_PFAIL)) &#123;</span><br><span class="line"></span><br><span class="line">                    // 添加 sender 对 node 的下线报告</span><br><span class="line">                    if (clusterNodeAddFailureReport(node,sender)) &#123;</span><br><span class="line">                        redisLog(REDIS_VERBOSE,</span><br><span class="line">                            &quot;Node %.40s reported node %.40s as not reachable.&quot;,</span><br><span class="line">                            sender-&gt;name, node-&gt;name);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    // 尝试将 node 标记为 FAIL</span><br><span class="line">                    markNodeAsFailingIfNeeded(node);</span><br><span class="line"></span><br><span class="line">                // 节点处于正常状态</span><br><span class="line">                &#125; else &#123;</span><br><span class="line"></span><br><span class="line">                    // 如果 sender 曾经发送过对 node 的下线报告</span><br><span class="line">                    // 那么清除该报告</span><br><span class="line">                    if (clusterNodeDelFailureReport(node,sender)) &#123;</span><br><span class="line">                        redisLog(REDIS_VERBOSE,</span><br><span class="line">                            &quot;Node %.40s reported node %.40s is back online.&quot;,</span><br><span class="line">                            sender-&gt;name, node-&gt;name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            /* If we already know this node, but it is not reachable, and</span><br><span class="line">             * we see a different address in the gossip section, start an</span><br><span class="line">             * handshake with the (possibly) new address: this will result</span><br><span class="line">             * into a node address update if the handshake will be</span><br><span class="line">             * successful. */</span><br><span class="line">            // 如果节点之前处于 PFAIL 或者 FAIL 状态</span><br><span class="line">            // 并且该节点的 IP 或者端口号已经发生变化</span><br><span class="line">            // 那么可能是节点换了新地址，尝试对它进行握手</span><br><span class="line">            if (node-&gt;flags &amp; (REDIS_NODE_FAIL|REDIS_NODE_PFAIL) &amp;&amp;</span><br><span class="line">                (strcasecmp(node-&gt;ip,g-&gt;ip) || node-&gt;port != ntohs(g-&gt;port)))</span><br><span class="line">            &#123;</span><br><span class="line">                clusterStartHandshake(g-&gt;ip,ntohs(g-&gt;port));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        // 当前节点不认识 node</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            /* If it&#x27;s not in NOADDR state and we don&#x27;t have it, we</span><br><span class="line">             * start a handshake process against this IP/PORT pairs.</span><br><span class="line">             *</span><br><span class="line">             * 如果 node 不在 NOADDR 状态，并且当前节点不认识 node </span><br><span class="line">             * 那么向 node 发送 HANDSHAKE 消息。</span><br><span class="line">             *</span><br><span class="line">             * Note that we require that the sender of this gossip message</span><br><span class="line">             * is a well known node in our cluster, otherwise we risk</span><br><span class="line">             * joining another cluster.</span><br><span class="line">             *</span><br><span class="line">             * 注意，当前节点必须保证 sender 是本集群的节点，</span><br><span class="line">             * 否则我们将有加入了另一个集群的风险。</span><br><span class="line">             */</span><br><span class="line">            if (sender &amp;&amp;</span><br><span class="line">                !(flags &amp; REDIS_NODE_NOADDR) &amp;&amp;</span><br><span class="line">                !clusterBlacklistExists(g-&gt;nodename))</span><br><span class="line">            &#123;</span><br><span class="line">                clusterStartHandshake(g-&gt;ip,ntohs(g-&gt;port));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* Next node */</span><br><span class="line">        // 处理下个节点的信息</span><br><span class="line">        g++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、C添加下线报告之后，会进行B节点的客观下线状态（FAIL）判定。<br>当集群中有超过半数的节点都认为节点B处于PFAIL后才会判断B为FAIL，且需要注意的是，A将PFAIL通知给C后，C自己本身也得认为B处于PFAIL状态才会开始客观下线判定。<br>当C认为B正式FAIL后，它就会立刻向集群所有节点广播这个消息。<br><img src="/imgs/Redis/RedisCluster%E6%95%85%E9%9A%9C%E5%8F%91%E7%8E%B03.png" alt="RedisCluster故障发现3" title="RedisCluster故障发现3"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">/* This function checks if a given node should be marked as FAIL.</span><br><span class="line"> * It happens if the following conditions are met:</span><br><span class="line"> *</span><br><span class="line"> * 此函数用于判断是否需要将 node 标记为 FAIL 。</span><br><span class="line"> *</span><br><span class="line"> * 将 node 标记为 FAIL 需要满足以下两个条件：</span><br><span class="line"> *</span><br><span class="line"> * 1) We received enough failure reports from other master nodes via gossip.</span><br><span class="line"> *    Enough means that the majority of the masters signaled the node is</span><br><span class="line"> *    down recently.</span><br><span class="line"> *    有半数以上的主节点将 node 标记为 PFAIL 状态。</span><br><span class="line"> * 2) We believe this node is in PFAIL state.</span><br><span class="line"> *    当前节点也将 node 标记为 PFAIL 状态。</span><br><span class="line"> *</span><br><span class="line"> * If a failure is detected we also inform the whole cluster about this</span><br><span class="line"> * event trying to force every other node to set the FAIL flag for the node.</span><br><span class="line"> *</span><br><span class="line"> * 如果确认 node 已经进入了 FAIL 状态，</span><br><span class="line"> * 那么节点还会向其他节点发送 FAIL 消息，让其他节点也将 node 标记为 FAIL 。</span><br><span class="line"> *</span><br><span class="line"> * Note that the form of agreement used here is weak, as we collect the majority</span><br><span class="line"> * of masters state during some time, and even if we force agreement by</span><br><span class="line"> * propagating the FAIL message, because of partitions we may not reach every</span><br><span class="line"> * node. However:</span><br><span class="line"> *</span><br><span class="line"> * 注意，集群判断一个 node 进入 FAIL 所需的条件是弱（weak）的，</span><br><span class="line"> * 因为节点们对 node 的状态报告并不是实时的，而是有一段时间间隔</span><br><span class="line"> * （这段时间内 node 的状态可能已经发生了改变），</span><br><span class="line"> * 并且尽管当前节点会向其他节点发送 FAIL 消息，</span><br><span class="line"> * 但因为网络分裂（network partition）的问题，</span><br><span class="line"> * 有一部分节点可能还是会不知道将 node 标记为 FAIL 。</span><br><span class="line"> *</span><br><span class="line"> * 不过：</span><br><span class="line"> *</span><br><span class="line"> * 1) Either we reach the majority and eventually the FAIL state will propagate</span><br><span class="line"> *    to all the cluster.</span><br><span class="line"> *    只要我们成功将 node 标记为 FAIL ，</span><br><span class="line"> *    那么这个 FAIL 状态最终（eventually）总会传播至整个集群的所有节点。</span><br><span class="line"> * 2) Or there is no majority so no slave promotion will be authorized and the</span><br><span class="line"> *    FAIL flag will be cleared after some time.</span><br><span class="line"> *    又或者，因为没有半数的节点支持，当前节点不能将 node 标记为 FAIL ，</span><br><span class="line"> *    所以对 FAIL 节点的故障转移将无法进行， FAIL 标识可能会在之后被移除。</span><br><span class="line"> *    </span><br><span class="line"> */</span><br><span class="line">void markNodeAsFailingIfNeeded(clusterNode *node) &#123;</span><br><span class="line">    int failures;</span><br><span class="line"></span><br><span class="line">    // 标记为 FAIL 所需的节点数量，需要超过集群节点数量的一半</span><br><span class="line">    int needed_quorum = (server.cluster-&gt;size / 2) + 1;</span><br><span class="line"></span><br><span class="line">    if (!nodeTimedOut(node)) return; /* We can reach it. */</span><br><span class="line">    if (nodeFailed(node)) return; /* Already FAILing. */</span><br><span class="line"></span><br><span class="line">    // 统计将 node 标记为 PFAIL 或者 FAIL 的节点数量（不包括当前节点）</span><br><span class="line">    failures = clusterNodeFailureReportsCount(node);</span><br><span class="line"></span><br><span class="line">    /* Also count myself as a voter if I&#x27;m a master. */</span><br><span class="line">    // 如果当前节点是主节点，那么将当前节点也算在 failures 之内</span><br><span class="line">    if (nodeIsMaster(myself)) failures++;</span><br><span class="line">    // 报告下线节点的数量不足节点总数的一半，不能将节点判断为 FAIL ，返回</span><br><span class="line">    if (failures &lt; needed_quorum) return; /* No weak agreement from masters. */</span><br><span class="line"></span><br><span class="line">    redisLog(REDIS_NOTICE,</span><br><span class="line">        &quot;Marking node %.40s as failing (quorum reached).&quot;, node-&gt;name);</span><br><span class="line"></span><br><span class="line">    /* Mark the node as failing. */</span><br><span class="line">    // 将 node 标记为 FAIL</span><br><span class="line">    node-&gt;flags &amp;= ~REDIS_NODE_PFAIL;</span><br><span class="line">    node-&gt;flags |= REDIS_NODE_FAIL;</span><br><span class="line">    node-&gt;fail_time = mstime();</span><br><span class="line"></span><br><span class="line">    /* Broadcast the failing node name to everybody, forcing all the other</span><br><span class="line">     * reachable nodes to flag the node as FAIL. */</span><br><span class="line">    // 如果当前节点是主节点的话，那么向其他节点发送报告 node 的 FAIL 信息</span><br><span class="line">    // 让其他节点也将 node 标记为 FAIL</span><br><span class="line">    if (nodeIsMaster(myself)) clusterSendFail(node-&gt;name);</span><br><span class="line">    clusterDoBeforeSleep(CLUSTER_TODO_UPDATE_STATE|CLUSTER_TODO_SAVE_CONFIG);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、当C标记了B为FAIL状态，则它会广播到整个集群中的所有节点（包括子节点），其他节点都会更新自己维护的节点B的状态信息为FAIL</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/* Send a FAIL message to all the nodes we are able to contact.</span><br><span class="line"> *</span><br><span class="line"> * 向当前节点已知的所有节点发送 FAIL 信息。</span><br><span class="line"> */</span><br><span class="line">void clusterSendFail(char *nodename) &#123;</span><br><span class="line">    unsigned char buf[sizeof(clusterMsg)];</span><br><span class="line">    clusterMsg *hdr = (clusterMsg *) buf;</span><br><span class="line"></span><br><span class="line">    // 创建下线消息</span><br><span class="line">    clusterBuildMessageHdr(hdr, CLUSTERMSG_TYPE_FAIL);</span><br><span class="line"></span><br><span class="line">    // 记录命令</span><br><span class="line">    memcpy(hdr-&gt;data.fail.about.nodename, nodename, REDIS_CLUSTER_NAMELEN);</span><br><span class="line"></span><br><span class="line">    // 广播消息</span><br><span class="line">    clusterBroadcastMessage(buf, ntohl(hdr-&gt;totlen));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* Send a message to all the nodes that are part of the cluster having</span><br><span class="line"> * a connected link.</span><br><span class="line"> *</span><br><span class="line"> * 向节点连接的所有其他节点发送信息。</span><br><span class="line"> */</span><br><span class="line">void clusterBroadcastMessage(void *buf, size_t len) &#123;</span><br><span class="line">    dictIterator *di;</span><br><span class="line">    dictEntry *de;</span><br><span class="line"></span><br><span class="line">    // 遍历所有已知节点</span><br><span class="line">    di = dictGetSafeIterator(server.cluster-&gt;nodes);</span><br><span class="line">    while ((de = dictNext(di)) != NULL) &#123;</span><br><span class="line">        clusterNode *node = dictGetVal(de);</span><br><span class="line"></span><br><span class="line">        // 不向未连接节点发送信息</span><br><span class="line">        if (!node-&gt;link) continue;</span><br><span class="line"></span><br><span class="line">        // 不向节点自身或者 HANDSHAKE 状态的节点发送信息</span><br><span class="line">        if (node-&gt;flags &amp; (REDIS_NODE_MYSELF | REDIS_NODE_HANDSHAKE))</span><br><span class="line">            continue;</span><br><span class="line"></span><br><span class="line">        // 发送信息</span><br><span class="line">        clusterSendMessage(node-&gt;link, buf, len);</span><br><span class="line">    &#125;</span><br><span class="line">    dictReleaseIterator(di);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="子节点选举（故障迁移）"><a href="#子节点选举（故障迁移）" class="headerlink" title="子节点选举（故障迁移）"></a>子节点选举（故障迁移）</h3><p>1、当B的两个子节点接收到B的FAIL状态消息时，它们会更新自己本地内存中的集群状态</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">int clusterProcessPacket(clusterLink *link) &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    // 这是一条 FAIL 消息： sender 告知当前节点，某个节点已经进入 FAIL 状态。</span><br><span class="line">    else if (type == CLUSTERMSG_TYPE_FAIL) &#123;</span><br><span class="line">        clusterNode *failing;</span><br><span class="line"></span><br><span class="line">        if (sender) &#123;</span><br><span class="line"></span><br><span class="line">            // 获取下线节点的消息</span><br><span class="line">            failing = clusterLookupNode(hdr-&gt;data.fail.about.nodename);</span><br><span class="line">            // 下线的节点既不是当前节点，也没有处于 FAIL 状态</span><br><span class="line">            if (failing &amp;&amp;</span><br><span class="line">                !(failing-&gt;flags &amp; (REDIS_NODE_FAIL | REDIS_NODE_MYSELF))) &#123;</span><br><span class="line">                redisLog(REDIS_NOTICE,</span><br><span class="line">                         &quot;FAIL message received from %.40s about %.40s&quot;,</span><br><span class="line">                         hdr-&gt;sender, hdr-&gt;data.fail.about.nodename);</span><br><span class="line"></span><br><span class="line">                // 打开 FAIL 状态</span><br><span class="line">                failing-&gt;flags |= REDIS_NODE_FAIL;</span><br><span class="line">                failing-&gt;fail_time = mstime();</span><br><span class="line">                // 关闭 PFAIL 状态</span><br><span class="line">                failing-&gt;flags &amp;= ~REDIS_NODE_PFAIL;</span><br><span class="line">                clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG |</span><br><span class="line">                                     CLUSTER_TODO_UPDATE_STATE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            redisLog(REDIS_NOTICE,</span><br><span class="line">                     &quot;Ignoring FAIL message from unknonw node %.40s about %.40s&quot;,</span><br><span class="line">                     hdr-&gt;sender, hdr-&gt;data.fail.about.nodename);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、随后，在clusterCron定时任务中就会开始发起故障迁移，竞选成为新的Master</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">void clusterCron(void) &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    /* Abourt a manual failover if the timeout is reached. */</span><br><span class="line">    manualFailoverCheckTimeout();</span><br><span class="line"></span><br><span class="line">    // 如果当前节点是子节点</span><br><span class="line">    if (nodeIsSlave(myself)) &#123;</span><br><span class="line">        clusterHandleManualFailover();</span><br><span class="line">        // 处理集群子节点的故障迁移</span><br><span class="line">        clusterHandleSlaveFailover();</span><br><span class="line">        </span><br><span class="line">        /* If there are orphaned slaves, and we are a slave among the masters</span><br><span class="line">         * with the max number of non-failing slaves, consider migrating to</span><br><span class="line">         * the orphaned masters. Note that it does not make sense to try</span><br><span class="line">         * a migration if there is no master with at least *two* working</span><br><span class="line">         * slaves. */</span><br><span class="line">        if (orphaned_masters &amp;&amp; max_slaves &gt;= 2 &amp;&amp; this_slaves == max_slaves)</span><br><span class="line">            clusterHandleSlaveMigration(max_slaves);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 更新集群状态</span><br><span class="line">    if (update_state || server.cluster-&gt;state == REDIS_CLUSTER_FAIL)</span><br><span class="line">        clusterUpdateState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* This function is called if we are a slave node and our master serving</span><br><span class="line"> * a non-zero amount of hash slots is in FAIL state.</span><br><span class="line"> *</span><br><span class="line"> * 如果当前节点是一个从节点，并且它正在复制的一个负责非零个槽的主节点处于 FAIL 状态，</span><br><span class="line"> * 那么执行这个函数。</span><br><span class="line"> *</span><br><span class="line"> * The gaol of this function is:</span><br><span class="line"> *</span><br><span class="line"> * 这个函数有三个目标：</span><br><span class="line"> *</span><br><span class="line"> * 1) To check if we are able to perform a failover, is our data updated?</span><br><span class="line"> *    检查是否可以对主节点执行一次故障转移，节点的关于主节点的信息是否准确和最新（updated）？</span><br><span class="line"> * 2) Try to get elected by masters.</span><br><span class="line"> *    选举一个新的主节点</span><br><span class="line"> * 3) Perform the failover informing all the other nodes.</span><br><span class="line"> *    执行故障转移，并通知其他节点</span><br><span class="line"> */</span><br><span class="line">void clusterHandleSlaveFailover(void) &#123;</span><br><span class="line">    mstime_t data_age;</span><br><span class="line">    mstime_t auth_age = mstime() - server.cluster-&gt;failover_auth_time;</span><br><span class="line">    int needed_quorum = (server.cluster-&gt;size / 2) + 1;</span><br><span class="line">    int manual_failover = server.cluster-&gt;mf_end != 0 &amp;&amp;</span><br><span class="line">                          server.cluster-&gt;mf_can_start;</span><br><span class="line">    int j;</span><br><span class="line">    mstime_t auth_timeout, auth_retry_time;</span><br><span class="line"></span><br><span class="line">    server.cluster-&gt;todo_before_sleep &amp;= ~CLUSTER_TODO_HANDLE_FAILOVER;</span><br><span class="line"></span><br><span class="line">    /* Compute the failover timeout (the max time we have to send votes</span><br><span class="line">     * and wait for replies), and the failover retry time (the time to wait</span><br><span class="line">     * before waiting again.</span><br><span class="line">     *</span><br><span class="line">     * Timeout is MIN(NODE_TIMEOUT*2,2000) milliseconds.</span><br><span class="line">     * Retry is two times the Timeout.</span><br><span class="line">     */</span><br><span class="line">    auth_timeout = server.cluster_node_timeout * 2;</span><br><span class="line">    if (auth_timeout &lt; 2000) auth_timeout = 2000;</span><br><span class="line">    auth_retry_time = auth_timeout * 2;</span><br><span class="line"></span><br><span class="line">    /* Pre conditions to run the function, that must be met both in case</span><br><span class="line">     * of an automatic or manual failover:</span><br><span class="line">     * 1) We are a slave.</span><br><span class="line">     * 2) Our master is flagged as FAIL, or this is a manual failover.</span><br><span class="line">     * 3) It is serving slots. */</span><br><span class="line">    if (nodeIsMaster(myself) ||</span><br><span class="line">        myself-&gt;slaveof == NULL ||</span><br><span class="line">        (!nodeFailed(myself-&gt;slaveof) &amp;&amp; !manual_failover) ||</span><br><span class="line">        myself-&gt;slaveof-&gt;numslots == 0)</span><br><span class="line">        return;</span><br><span class="line">        </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、资格检查<br>Slave节点会不停的与Master节点通信来复制Master节点的数据，如果一个Slave节点长时间不与Master节点通信，那么很可能意味着该Slave节点上的数据已经落后Master节点过多（因为Master节点再不停的更新数据但是Slave节点并没有随之更新）。Redis认为，当一个Slave节点过长时间不与Master节点通信，那么该节点就不具备参与竞选的资格。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">void clusterHandleSlaveFailover(void) &#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    /* Set data_age to the number of seconds we are disconnected from</span><br><span class="line">     * the master. */</span><br><span class="line">    // 将 data_age 设置为从节点与主节点的断开秒数</span><br><span class="line">    if (server.repl_state == REDIS_REPL_CONNECTED) &#123;</span><br><span class="line">        data_age = (mstime_t) (server.unixtime - server.master-&gt;lastinteraction)</span><br><span class="line">                   * 1000;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        data_age = (mstime_t) (server.unixtime - server.repl_down_since) * 1000;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Remove the node timeout from the data age as it is fine that we are</span><br><span class="line">     * disconnected from our master at least for the time it was down to be</span><br><span class="line">     * flagged as FAIL, that&#x27;s the baseline. */</span><br><span class="line">    // node timeout 的时间不计入断线时间之内</span><br><span class="line">    if (data_age &gt; server.cluster_node_timeout)</span><br><span class="line">        data_age -= server.cluster_node_timeout;</span><br><span class="line"></span><br><span class="line">    /* Check if our data is recent enough. For now we just use a fixed</span><br><span class="line">     * constant of ten times the node timeout since the cluster should</span><br><span class="line">     * react much faster to a master down.</span><br><span class="line">     *</span><br><span class="line">     * Check bypassed for manual failovers. */</span><br><span class="line">    // 检查这个从节点的数据是否较新：</span><br><span class="line">    // 目前的检测办法是断线时间不能超过 node timeout 的十倍</span><br><span class="line">    if (data_age &gt;</span><br><span class="line">        ((mstime_t)server.repl_ping_slave_period * 1000) +</span><br><span class="line">        (server.cluster_node_timeout * REDIS_CLUSTER_SLAVE_VALIDITY_MULT))</span><br><span class="line">    &#123;</span><br><span class="line">        if (!manual_failover) return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、休眠时间计算<br>B的所有子节点（B1、B2）在判断自己具备选举资格时，就开始执行竞选，竞选协议是Raft，选举过程中，所有参与选举的节点首先随机休眠一段时间。<br>整个休眠时间由两个部分组成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELAY = 500 milliseconds + random delay between 0 and 500 milliseconds + SLAVE_RANK * 1000 milliseconds.</span><br></pre></td></tr></table></figure>
<ul>
<li>一部分为固定的500ms时间，这500ms主要是为了等待集群状态同步。上面提到节点C会向集群所有节点广播消息，那么这500ms就是等待确保集群的所有节点都收到了消息并更新了状态。</li>
<li>另一部分主要是一个随机的时间加上由该Slave节点的排名决定的附加时间。每个slave都会记录自己从主节点同步数据的复制偏移量。复制偏移量越大，说明该节点与主节点数据保持的越一致。那么显然我们选举的时候肯定是想选状态更新最近的子节点，所以我们按照更新状态的排序来确定休眠时间的附加部分。状态更新最近的节点SLAVE_RANK排名为1，那么其休眠的时间相应的也最短，也就意味着该节点最有可能获得大部分选票。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">void clusterHandleSlaveFailover(void) &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    /* If the previous failover attempt timedout and the retry time has</span><br><span class="line">     * elapsed, we can setup a new one. */</span><br><span class="line">    if (auth_age &gt; auth_retry_time) &#123;</span><br><span class="line">        server.cluster-&gt;failover_auth_time = mstime() +</span><br><span class="line">                                             500 + /* Fixed delay of 500 milliseconds, let FAIL msg propagate. */</span><br><span class="line">                                             random() % 500; /* Random delay between 0 and 500 milliseconds. */</span><br><span class="line">        server.cluster-&gt;failover_auth_count = 0;</span><br><span class="line">        server.cluster-&gt;failover_auth_sent = 0;</span><br><span class="line">        server.cluster-&gt;failover_auth_rank = clusterGetSlaveRank();</span><br><span class="line">        /* We add another delay that is proportional to the slave rank.</span><br><span class="line">         * Specifically 1 second * rank. This way slaves that have a probably</span><br><span class="line">         * less updated replication offset, are penalized. */</span><br><span class="line">        server.cluster-&gt;failover_auth_time +=</span><br><span class="line">                server.cluster-&gt;failover_auth_rank * 1000;</span><br><span class="line">        /* However if this is a manual failover, no delay is needed. */</span><br><span class="line">        if (server.cluster-&gt;mf_end) &#123;</span><br><span class="line">            server.cluster-&gt;failover_auth_time = mstime();</span><br><span class="line">            server.cluster-&gt;failover_auth_rank = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        redisLog(REDIS_WARNING,</span><br><span class="line">                 &quot;Start of election delayed for %lld milliseconds &quot;</span><br><span class="line">                 &quot;(rank #%d, offset %lld).&quot;,</span><br><span class="line">                 server.cluster-&gt;failover_auth_time - mstime(),</span><br><span class="line">                 server.cluster-&gt;failover_auth_rank,</span><br><span class="line">                 replicationGetSlaveOffset());</span><br><span class="line">        /* Now that we have a scheduled election, broadcast our offset</span><br><span class="line">         * to all the other slaves so that they&#x27;ll updated their offsets</span><br><span class="line">         * if our offset is better. */</span><br><span class="line">        clusterBroadcastPong(CLUSTER_BROADCAST_LOCAL_SLAVES);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    /* Return ASAP if we can&#x27;t still start the election. */</span><br><span class="line">    // 如果执行故障转移的时间未到，先返回</span><br><span class="line">    if (mstime() &lt; server.cluster-&gt;failover_auth_time) return;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
5、发起拉票 &amp; 选举投票<br>B1唤醒后，会向其他所有节点发送拉票请求，即<code>CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST</code>类型的消息。<br>其他主节点接收到拉票请求，且此时它还没有投出自己的票，则会将自己票投给发请求的B1，即回复<code>FAILOVER_AUTH_ACK</code>消息。<br>其他子节点没有投票的资格，因此即使接收到<code>CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST</code>类型消息也会直接忽略。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">void clusterHandleSlaveFailover(void) &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    /* Ask for votes if needed. */</span><br><span class="line">    // 向其他节点发送故障转移请求</span><br><span class="line">    if (server.cluster-&gt;failover_auth_sent == 0) &#123;</span><br><span class="line"></span><br><span class="line">        // 增加配置纪元</span><br><span class="line">        server.cluster-&gt;currentEpoch++;</span><br><span class="line"></span><br><span class="line">        // 记录发起故障转移的配置纪元</span><br><span class="line">        server.cluster-&gt;failover_auth_epoch = server.cluster-&gt;currentEpoch;</span><br><span class="line"></span><br><span class="line">        redisLog(REDIS_WARNING, &quot;Starting a failover election for epoch %llu.&quot;,</span><br><span class="line">                 (unsigned long long) server.cluster-&gt;currentEpoch);</span><br><span class="line"></span><br><span class="line">        // 向其他所有节点发送信息，看它们是否支持由本节点来对下线主节点进行故障转移</span><br><span class="line">        clusterRequestFailoverAuth();</span><br><span class="line"></span><br><span class="line">        // 打开标识，表示已发送信息</span><br><span class="line">        server.cluster-&gt;failover_auth_sent = 1;</span><br><span class="line"></span><br><span class="line">        // TODO:</span><br><span class="line">        // 在进入下个事件循环之前，执行：</span><br><span class="line">        // 1）保存配置文件</span><br><span class="line">        // 2）更新节点状态</span><br><span class="line">        // 3）同步配置</span><br><span class="line">        clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG |</span><br><span class="line">                             CLUSTER_TODO_UPDATE_STATE |</span><br><span class="line">                             CLUSTER_TODO_FSYNC_CONFIG);</span><br><span class="line">        return; /* Wait for replies. */</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
6、替换节点（failover）<br>当子节点接收到来自其他节点的ACK消息时会统计自己获得的票数，当达到集群Master总数的一半以上时，就会开始执行failover，即替换自己的主节点。<br>首先标记自己为主节点，然后将原来由节点B负责的slots标记为由自己负责，最后向整个集群广播现在自己是Master同时负责旧Master所有slots的信息。其他节点接收到该信息后会更新自己维护的B1的状态并标记B1为主节点，将节点B负责的slots的负责节点设置为B1节点。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">void clusterHandleSlaveFailover(void) &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    /* Check if we reached the quorum. */</span><br><span class="line">    // 如果当前节点获得了足够多的投票，那么对下线主节点进行故障转移</span><br><span class="line">    if (server.cluster-&gt;failover_auth_count &gt;= needed_quorum) &#123;</span><br><span class="line">        // 旧主节点</span><br><span class="line">        clusterNode *oldmaster = myself-&gt;slaveof;</span><br><span class="line"></span><br><span class="line">        redisLog(REDIS_WARNING,</span><br><span class="line">                 &quot;Failover election won: I&#x27;m the new master.&quot;);</span><br><span class="line"></span><br><span class="line">        /* We have the quorum, perform all the steps to correctly promote</span><br><span class="line">         * this slave to a master.</span><br><span class="line">         *</span><br><span class="line">         * 1) Turn this node into a master. </span><br><span class="line">         *    将当前节点的身份由从节点改为主节点</span><br><span class="line">         */</span><br><span class="line">        clusterSetNodeAsMaster(myself);</span><br><span class="line">        // 让从节点取消复制，成为新的主节点</span><br><span class="line">        replicationUnsetMaster();</span><br><span class="line"></span><br><span class="line">        /* 2) Claim all the slots assigned to our master. */</span><br><span class="line">        // 接收所有主节点负责处理的槽</span><br><span class="line">        for (j = 0; j &lt; REDIS_CLUSTER_SLOTS; j++) &#123;</span><br><span class="line">            if (clusterNodeGetSlotBit(oldmaster, j)) &#123;</span><br><span class="line">                // 将槽设置为未分配的</span><br><span class="line">                clusterDelSlot(j);</span><br><span class="line">                // 将槽的负责人设置为当前节点</span><br><span class="line">                clusterAddSlot(myself, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* 3) Update my configEpoch to the epoch of the election. */</span><br><span class="line">        // 更新集群配置纪元</span><br><span class="line">        myself-&gt;configEpoch = server.cluster-&gt;failover_auth_epoch;</span><br><span class="line"></span><br><span class="line">        /* 4) Update state and save config. */</span><br><span class="line">        // 更新节点状态</span><br><span class="line">        clusterUpdateState();</span><br><span class="line">        // 并保存配置文件</span><br><span class="line">        clusterSaveConfigOrDie(1);</span><br><span class="line"></span><br><span class="line">        /* 5) Pong all the other nodes so that they can update the state</span><br><span class="line">         *    accordingly and detect that we switched to master role. */</span><br><span class="line">        // 向所有节点发送 PONG 信息</span><br><span class="line">        // 让它们可以知道当前节点已经升级为主节点了</span><br><span class="line">        clusterBroadcastPong(CLUSTER_BROADCAST_ALL);</span><br><span class="line"></span><br><span class="line">        /* 6) If there was a manual failover in progress, clear the state. */</span><br><span class="line">        // 如果有手动故障转移正在执行，那么清理和它有关的状态</span><br><span class="line">        resetManualFailover();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="配置更新"><a href="#配置更新" class="headerlink" title="配置更新"></a>配置更新</h3><p>上边我们已经通过故障发现和子节点选举机制用B1这个子节点替换掉了它的Master节点B，那么留下来的节点B和B2应该怎么处理呢？实际上Redis会让它们变成B1的Slave节点。<br>1、对B2来说，B1升级成Master后会给B2发送消息，让它知道自己已经升级成Master了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void clusterHandleSlaveFailover(void) &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">        /* 5) Pong all the other nodes so that they can update the state</span><br><span class="line">         *    accordingly and detect that we switched to master role. */</span><br><span class="line">        // 向所有节点发送 PONG 信息</span><br><span class="line">        // 让它们可以知道当前节点已经升级为主节点了</span><br><span class="line">        clusterBroadcastPong(CLUSTER_BROADCAST_ALL);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、对B来说，B1已经成为了Master，B从故障恢复后再次加入集群时，会成为B1的Slave。</p>
<h2 id="Cluster数据丢失隐患及处理方案"><a href="#Cluster数据丢失隐患及处理方案" class="headerlink" title="Cluster数据丢失隐患及处理方案"></a>Cluster数据丢失隐患及处理方案</h2><p>一种数据丢失的场景是主从复制时Master挂掉了，这点我在《<a href="https://tallate.github.io/edd4cfac.html#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%B8%BB%E4%BB%8E%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7-%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1%E7%AA%97%E5%8F%A3%E7%9A%84%E5%AD%98%E5%9C%A8">Redis 复制</a>》讨论过。<br>另一种数据丢失的场景存在于Cluster集群中，并且并不是特别容易出现，也就是Cluster发生了脑裂，分区恢复时脑裂期间的数据被覆盖：</p>
<ol>
<li>主节点挂掉了，从节点选举出了一个新的主节点，但是此时客户端还在与老主节点通信，将数据写入到老的主节点上；<blockquote>
<p>这种情况是可能发生的，因为客户端会记忆槽所在的节点，而不是每次请求都通过重定向定位到槽实际所在的节点上。</p>
</blockquote>
</li>
<li>之后主从切换成功后，老的主节点会成功新主节点的Slave，并从新的主节点上获取数据，这时该节点上的数据会被清空，从而导致数据丢失。</li>
</ol>
<h3 id="为什么会发生脑裂？"><a href="#为什么会发生脑裂？" class="headerlink" title="为什么会发生脑裂？"></a>为什么会发生脑裂？</h3><p>在《<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/303568">Redis核心技术与实战</a>》中提到了一种会导致脑裂的情况：</p>
<ol>
<li>Slave会定时地PING Master，发生的错误达到一定时间会被标记为主观下线，当标记主观下线的次数达到规定数量后，标记为客观下线；</li>
<li>但是Master实际上是“假故障”，即虽然响应Slave的心跳失败了，但是客户端还是可以和Master正常通信的。<br>比如宿主机上有一些其他进程将CPU打满了，在打满期间，Slave就会有可能将Master判断为下线，开始选举及主从切换。</li>
</ol>
<h3 id="为什么脑裂会导致数据丢失？"><a href="#为什么脑裂会导致数据丢失？" class="headerlink" title="为什么脑裂会导致数据丢失？"></a>为什么脑裂会导致数据丢失？</h3><p>主从切换后，从库会升级为新主库，这时如果老主库重新上线了，会成为新主库的Slave，执行全量同步，而全量同步执行的最后阶段，需要清空本地的数据，加载新主库发送过来的RDB文件，这期间写入的数据就会丢失了。</p>
<h3 id="如何解决这种脑裂问题？"><a href="#如何解决这种脑裂问题？" class="headerlink" title="如何解决这种脑裂问题？"></a>如何解决这种脑裂问题？</h3><p>可以通过两个配置来解决这个脑裂问题：</p>
<ul>
<li><code>min-slaves-to-write</code><br>这个配置项设置了主库能进行数据同步的最少从库数量</li>
<li><code>min-slaves-to-write</code><br>min-slaves-max-lag：这个配置项设置了主从库间进行数据复制时，从库给主库发送 ACK 消息的最大延迟（以秒为单位）</li>
</ul>
<p>我们可以把 min-slaves-to-write 和 min-slaves-max-lag 这两个配置项搭配起来使用，分别给它们设置一定的阈值，假设为 N 和 T。这两个配置项组合后的要求是，主库连接的从库中至少有 N 个从库，和主库进行数据复制时的 ACK 消息延迟不能超过 T 秒，否则，主库就不会再接收客户端的请求了。即使原主库是假故障，它在假故障期间也无法响应哨兵心跳，也不能和从库进行同步，自然也就无法和从库进行 ACK 确认了。这样一来，min-slaves-to-write 和 min-slaves-max-lag 的组合要求就无法得到满足，原主库就会被限制接收客户端请求，客户端也就不能在原主库中写入新数据了。等到新主库上线时，就只有新主库能接收和处理客户端请求，此时，新写的数据会被直接写到新主库中。而原主库会被哨兵降为从库，即使它的数据被清空了，也不会有新数据丢失。<br>举个例子：假设我们将min-slaves-to-write 设置为 1，把 min-slaves-max-lag 设置为 12s，把哨兵的 down-after-milliseconds 设置为 10s，主库因为某些原因卡住了 15s，导致哨兵判断主库客观下线，开始进行主从切换。同时，因为原主库卡住了 15s，没有一个从库能和原主库在 12s 内进行数据复制，原主库也无法接收客户端请求了。这样一来，主从切换完成后，也只有新主库能接收请求，不会发生脑裂，也就不会发生数据丢失的问题了。</p>
<h2 id="数据倾斜"><a href="#数据倾斜" class="headerlink" title="数据倾斜"></a>数据倾斜</h2><p>Cluster集群通过CRC16算法将key hash到节点槽上，这个过程还是存在很多不确定性，可能很多数据会被hash到固定的某几个槽上，造成数据分布的不均匀，或者某些key是热点数据，被访问得尤其频繁。</p>
<h3 id="数据倾斜的危害"><a href="#数据倾斜的危害" class="headerlink" title="数据倾斜的危害"></a>数据倾斜的危害</h3><p>数据倾斜的危害主要是保存热点数据的节点处理压力会增大，速度变慢，甚至内存资源耗尽而崩溃。</p>
<h3 id="数据倾斜的成因"><a href="#数据倾斜的成因" class="headerlink" title="数据倾斜的成因"></a>数据倾斜的成因</h3><p>数据倾斜的成因主要有3个：</p>
<ol>
<li>bigkey<br>bigkey一般是value值很大的string或保存了大量对象的集合类型。<br>bigkey可能会造成实例IO线程阻塞，影响其他请求的执行效率。<br>为了处理bigkey，设计的时候最好避免把过多的数据保存在同一个键值对中，如果是集合类型，还可以把bigkey拆分成多个小的集合类型数据，分散保存在不同的实例上。</li>
<li>slot分配不均衡<br>如果没有均衡地分配slot，就会有大量的数据被分配到同一个slot中，而同一个slot只会在一个实例上分布，并导致大量数据被集中到同一个实例上。</li>
<li>Hash Tag<br>hash tag指针对key的某个部分进行hash，比如user:123，可以加上hash tag后变成user:{123}，只针对123进行hash。<br>hash tag的意义主要在于可以将同类的数据hash到同一个槽上，便于范围查询。<br>hash tag的缺点也在于分布到同一槽内后，对该槽所在节点的压力会变大。</li>
</ol>
<h3 id="数据倾斜的解决办法"><a href="#数据倾斜的解决办法" class="headerlink" title="数据倾斜的解决办法"></a>数据倾斜的解决办法</h3><p>数据倾斜可以通过重分配slot来解决。<br>但是热点数据往往是少部分数据被频繁访问，这种情况下重分配slot是无法解决的，为此可以通过热点数据多副本的方法来解决，比如同一key添加一个前缀然后hash到其他slot上。<br>但是多副本只能用于只读热点key，对于有读有写的热点数据，就只能给实例本身增加资源了，比如改成配置更高的机器。</p>
<h2 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h2><ol>
<li>Redis Cluster哈希槽通过CRC16算法将key哈希到实例上的槽，这样做有什么好处？为什么不直接用一张表来存储key和哈希槽之间的对应关系？<br>如果用一张关系表来做映射，问题太多了，比如：key太多了怎么存关系？集群扩容、缩容、故障转移时怎么修改key和实例间的对应关系？<br>而引入哈希槽，实际上是将数据和节点解耦，客户端只需关注key被hash到哪个哈希槽，就算打到错误的节点上，也可以通过</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a target="_blank" rel="noopener" href="http://redisdoc.com/topic/cluster-spec.html">Redis 集群规范</a></li>
<li><a target="_blank" rel="noopener" href="https://redissrc.readthedocs.io/en/latest/">redis源码解析</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/104641341">Redis集群详解（上）</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/105569485">Redis集群详解（中）</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/106110578">Redis集群（终篇）</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhaohongfei_358/article/details/102665730">Redis在线数据迁移工具redis-migrate-tool详解，轻松实现redis集群之间的数据同步</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/hellozhxy/article/details/103527186">CRDT——解决最终一致问题的利器</a></li>
</ol>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/7731e967.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tallate">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tallate">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/7731e967.html" class="post-title-link" itemprop="url">发号器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-09-21 23:51:08" itemprop="dateCreated datePublished" datetime="2019-09-21T23:51:08+08:00">2019-09-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-07 01:56:20" itemprop="dateModified" datetime="2025-07-07T01:56:20+08:00">2025-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">分布式系统</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>发号器几乎是最简单的一个中间件了，它旨在生成一个全局唯一ID，用于在业务领域内标识一个对象。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/7731e967.html#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/bcd62ed6.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tallate">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tallate">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/bcd62ed6.html" class="post-title-link" itemprop="url">并发和常见并发问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-09-21 21:07:49" itemprop="dateCreated datePublished" datetime="2019-09-21T21:07:49+08:00">2019-09-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-07 01:56:20" itemprop="dateModified" datetime="2025-07-07T01:56:20+08:00">2025-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>

<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>序列化（Serialization）：事件A必须在事件B之前发生。<br>互斥（Mutual exclusion）：事件A和B不能同时发生。</p>
<h2 id="同步方式"><a href="#同步方式" class="headerlink" title="同步方式"></a>同步方式</h2><h3 id="使用消息同步"><a href="#使用消息同步" class="headerlink" title="使用消息同步"></a>使用消息同步</h3><p>线程A：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">do sth...</span><br><span class="line">call B</span><br></pre></td></tr></table></figure>
<p>线程B：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wait for A</span><br><span class="line">do sth...</span><br></pre></td></tr></table></figure>
<p>B会等待A发来消息后再执行后续的指令。</p>
<h3 id="共享变量"><a href="#共享变量" class="headerlink" title="共享变量"></a>共享变量</h3><p>1、并发写<br>线程A</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = 5</span><br><span class="line">print x</span><br></pre></td></tr></table></figure>
<p>线程B</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = 7</span><br></pre></td></tr></table></figure>
<p>这两个线程并发执行，最后打印出来的结果不确定是5还是7。<br>2、并发更新<br>线程A：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count = count + 1</span><br></pre></td></tr></table></figure>
<p>线程B：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count = count + 1</span><br></pre></td></tr></table></figure>
<p>两个线程的操作都是读后写，可能就会发生同时读出旧值然后都+1，最终结果并没有+2的情况。<br>3、通过发消息互斥执行<br>通过发消息保证共享变量的安全更新。</p>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>支持PV操作，P原子地减少信号量值，当值为0时阻塞，V原子地增加信号量值。</p>
<p>信号量的优点：</p>
<ol>
<li>信号量的约定使得代码更不容易出错；</li>
<li>信号量在很多系统都有实现，使用信号量是可移植的。</li>
</ol>
<h1 id="基础同步模式"><a href="#基础同步模式" class="headerlink" title="基础同步模式"></a>基础同步模式</h1><h2 id="发信号（Signaling）"><a href="#发信号（Signaling）" class="headerlink" title="发信号（Signaling）"></a>发信号（Signaling）</h2><p>一个线程发消息给另一个线程告知某件事情的发生。<br>线程A：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">statement a1</span><br><span class="line">sem.signal()</span><br></pre></td></tr></table></figure>
<p>线程B：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sem.wait()</span><br><span class="line">statement b1</span><br></pre></td></tr></table></figure>
<p>只有A signal发出消息后，B才能从wait离开继续执行。</p>
<p>在Java中，发信号的功能可以通过Object的wait&#x2F;notify、Lock的Condition、LockSupport、Semaphore实现。</p>
<h2 id="Rendezvous"><a href="#Rendezvous" class="headerlink" title="Rendezvous"></a>Rendezvous</h2><p>不知道怎么翻译，叫做汇聚？作者给出的是类似下面这样的例子：<br>线程A：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">statement a1</span><br><span class="line">aArrived.signal()</span><br><span class="line">bArrived.wait()</span><br><span class="line">statement a2</span><br></pre></td></tr></table></figure>
<p>线程B：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">statement b1</span><br><span class="line">bArrived.signal()</span><br><span class="line">aArrived.wait()</span><br><span class="line">statement b2</span><br></pre></td></tr></table></figure>
<p>注意signal和wait不要写反了，写反了会死锁。<br>在Java中，可以通过<code>CyclicBarrier</code>实现。</p>
<h2 id="互斥量（Mutex）"><a href="#互斥量（Mutex）" class="headerlink" title="互斥量（Mutex）"></a>互斥量（Mutex）</h2><p>使用信号量可以实现互斥量，实际上互斥量可以看作<code>Semaphore(1)</code>，使用以下代码就可以实现两个线程的互斥执行：<br>线程A：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mutex.wait()</span><br><span class="line">count = count + 1</span><br><span class="line">mutex.signal()</span><br></pre></td></tr></table></figure>
<p>线程B：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mutex.wait()</span><br><span class="line">count = count + 1</span><br><span class="line">mutex.signal()</span><br></pre></td></tr></table></figure>
<p>上边mutex包围的代码就称为临界区代码（critical section）。</p>
<h2 id="多路复用（Multiplex）"><a href="#多路复用（Multiplex）" class="headerlink" title="多路复用（Multiplex）"></a>多路复用（Multiplex）</h2><p>将上边的互斥量泛化，我们让多个线程可以同时执行一块临界区代码。<br>其实就是用<code>Semaphore(n)</code>就可以实现n个线程同时执行了。</p>
<h2 id="栅栏（Barrier）"><a href="#栅栏（Barrier）" class="headerlink" title="栅栏（Barrier）"></a>栅栏（Barrier）</h2><p>只有所有线程都到达某个位置才能一块继续执行下去，栅栏可以通过以下代码实现（有bug，会出现死锁）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">count = 0</span><br><span class="line">mutex = Semaphore(1)</span><br><span class="line">barrier = Semaphore(0)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">rendezvous // 汇聚</span><br><span class="line"></span><br><span class="line">mutex.wait()</span><br><span class="line">count = count + 1</span><br><span class="line">mutex.signal()</span><br><span class="line"></span><br><span class="line">if count == n</span><br><span class="line">    barrier.signal()</span><br><span class="line"></span><br><span class="line">barrier.wait()</span><br><span class="line">其他代码</span><br></pre></td></tr></table></figure>
<p>如果直接拿来执行，容易发现只有1个线程能执行下去，因为：</p>
<ol>
<li>假设有n&#x3D;5，即5个线程并发执行；</li>
<li>前4个线程到了<code>barrier.wait</code>后barrier的值变为-4；</li>
<li>第5个线程<code>barrier.signal</code>释放了1个，barrier的值变为-3，此时只有一个线程被放过去了，另外还有3个线程仍阻塞，且第5个线程随后也会进入阻塞状态。</li>
</ol>
<p>修改后的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">rendezvous // 汇聚</span><br><span class="line"></span><br><span class="line">mutex.wait()</span><br><span class="line">count = count + 1</span><br><span class="line">mutex.signal()</span><br><span class="line"></span><br><span class="line">if count == n</span><br><span class="line">    barrier.signal()</span><br><span class="line"></span><br><span class="line">barrier.wait()</span><br><span class="line">barrier.sign</span><br><span class="line">其他代码</span><br></pre></td></tr></table></figure>


<h1 id="并发问题解题模型"><a href="#并发问题解题模型" class="headerlink" title="并发问题解题模型"></a>并发问题解题模型</h1><p>分析问题时：</p>
<ol>
<li>寻找角色，每个角色对应一个独立线程；</li>
<li>寻找共享资源，每个共享资源对应一个信号量（或其他并发控制类）；</li>
<li>按场景描述进行模拟；</li>
</ol>
<h1 id="交错打印"><a href="#交错打印" class="headerlink" title="交错打印"></a>交错打印</h1><p>两个线程交替打印数组的功能，虽然比较简单，但是面试时问的还蛮多的，如果用Semaphore实现会比较简单，用Java的wait&#x2F;notify或Condition实现则会稍微麻烦一点。</p>
<h2 id="Semaphore实现交错打印"><a href="#Semaphore实现交错打印" class="headerlink" title="Semaphore实现交错打印"></a>Semaphore实现交错打印</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class OneByOneTest &#123;</span><br><span class="line"></span><br><span class="line">    static int count = 0;</span><br><span class="line">    static Semaphore first = new Semaphore(1);</span><br><span class="line">    static Semaphore second = new Semaphore(0);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Thread t1 = new Thread(() -&gt; &#123;</span><br><span class="line">            while(true) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    first.acquire();</span><br><span class="line">                    Thread.sleep(10);</span><br><span class="line">                    System.out.println(&quot;线程1: &quot; + count++);</span><br><span class="line">                    second.release();</span><br><span class="line">                &#125;catch (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread t2 = new Thread(() -&gt; &#123;</span><br><span class="line">            while(true) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    second.acquire();</span><br><span class="line">                    Thread.sleep(10);</span><br><span class="line">                    System.out.println(&quot;线程2: &quot; + count++);</span><br><span class="line">                    first.release();</span><br><span class="line">                &#125;catch (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public class OneByOneConditionTest &#123;</span><br><span class="line"></span><br><span class="line">    private static int counter = 0;</span><br><span class="line">    private static Lock lock = new ReentrantLock();</span><br><span class="line">    private static Condition first = lock.newCondition();</span><br><span class="line">    private static Condition second = lock.newCondition();</span><br><span class="line">    private static int currentPrinter = 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Thread t1 = new Thread(() -&gt; &#123;</span><br><span class="line">            while(true) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    lock.lock();</span><br><span class="line">                    while(currentPrinter == 1) &#123;</span><br><span class="line">                        first.await();</span><br><span class="line">                    &#125;</span><br><span class="line">                    Thread.sleep(100);</span><br><span class="line">                    System.out.println(&quot;线程1： &quot; + counter++);</span><br><span class="line">                    second.signal();</span><br><span class="line">                    currentPrinter = 1;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread t2 = new Thread(() -&gt; &#123;</span><br><span class="line">            while(true) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    lock.lock();</span><br><span class="line">                    while(currentPrinter == 0) &#123;</span><br><span class="line">                        second.await();</span><br><span class="line">                    &#125;</span><br><span class="line">                    Thread.sleep(100);</span><br><span class="line">                    System.out.println(&quot;线程2： &quot; + counter++);</span><br><span class="line">                    first.signal();</span><br><span class="line">                    currentPrinter = 0;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="wait-notify"><a href="#wait-notify" class="headerlink" title="wait&#x2F;notify"></a>wait&#x2F;notify</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">public class WaitNotiftTest &#123;</span><br><span class="line"></span><br><span class="line">    private static int count = 1;</span><br><span class="line">    private static Object lock = new Object();</span><br><span class="line">    private static int cur = 1;</span><br><span class="line"></span><br><span class="line">    static class A implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    synchronized (lock) &#123;</span><br><span class="line">                        if (count &gt; 100) &#123;</span><br><span class="line">                            return;</span><br><span class="line">                        &#125;</span><br><span class="line">                        while (cur != 1) &#123;</span><br><span class="line">                            lock.wait();</span><br><span class="line">                        &#125;</span><br><span class="line">                        System.out.println(&quot;第一个线程输出: &quot; + count++);</span><br><span class="line">                        Thread.sleep(100);</span><br><span class="line">                        cur = 2;</span><br><span class="line">                        lock.notifyAll();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class B implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    synchronized (lock) &#123;</span><br><span class="line">                        if (count &gt; 100) &#123;</span><br><span class="line">                            return;</span><br><span class="line">                        &#125;</span><br><span class="line">                        while (cur != 2) &#123;</span><br><span class="line">                            lock.wait();</span><br><span class="line">                        &#125;</span><br><span class="line">                        System.out.println(&quot;第二个线程输出: &quot; + count++);</span><br><span class="line">                        Thread.sleep(100);</span><br><span class="line">                        cur = 1;</span><br><span class="line">                        lock.notifyAll();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Thread a = new Thread(new A());</span><br><span class="line">        Thread b = new Thread(new B());</span><br><span class="line">        a.start();</span><br><span class="line">        b.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="Producer-Consumer"><a href="#Producer-Consumer" class="headerlink" title="Producer-Consumer"></a>Producer-Consumer</h1><p>解决生产者&#x2F;消费者问题需要维护一个队列，生产者向队列添加，消费者从队列获取，同步问题出现在队列为空或满的情况，因此我们需要对队列进行同步化。<br>为了简化问题，可以使用 juc 引入的 BlockingQueue（阻塞队列），这种数据结构能在下面两种情况下阻塞当前线程</p>
<ul>
<li>当队列为空时，调用 take 或 poll</li>
<li>当队列满时，调用 put 或 offer</li>
</ul>
<h2 id="使用-Semaphore-实现Producer-Consumer代码"><a href="#使用-Semaphore-实现Producer-Consumer代码" class="headerlink" title="使用 Semaphore 实现Producer&#x2F;Consumer代码"></a>使用 Semaphore 实现Producer&#x2F;Consumer代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public class ProducerConsumerTest &#123;</span><br><span class="line"></span><br><span class="line">    static Semaphore mutex = new Semaphore(1);</span><br><span class="line">    static Semaphore items = new Semaphore(0);</span><br><span class="line">    static Semaphore spaces = new Semaphore(10);</span><br><span class="line"></span><br><span class="line">    static int resource = 0;</span><br><span class="line"></span><br><span class="line">    static class Producer implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            int count = 5;</span><br><span class="line">            while (count-- &gt; 0) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    spaces.acquire();</span><br><span class="line">                    mutex.acquire();</span><br><span class="line">                    resource++;</span><br><span class="line">                    System.out.println(&quot;Producer添加一个，现在resource=&quot; + resource);</span><br><span class="line">                    mutex.release();</span><br><span class="line">                    items.release();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Consumer implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            int count = 5;</span><br><span class="line">            while (count-- &gt; 0) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    items.acquire();</span><br><span class="line">                    mutex.acquire();</span><br><span class="line">                    resource--;</span><br><span class="line">                    System.out.println(&quot;Consumer消费一个，现在resource=&quot; + resource);</span><br><span class="line">                    mutex.release();</span><br><span class="line">                    spaces.release();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Thread a = new Thread(new Producer());</span><br><span class="line">        Thread b = new Thread(new Consumer());</span><br><span class="line">        a.start();</span><br><span class="line">        b.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用-BlockingQueue-实现生产者-消费者代码"><a href="#使用-BlockingQueue-实现生产者-消费者代码" class="headerlink" title="使用 BlockingQueue 实现生产者&#x2F;消费者代码"></a>使用 BlockingQueue 实现生产者&#x2F;消费者代码</h2><p>下面是使用 BlockingQueue 实现的生产者&#x2F;消费者代码<br>注意要使用put&#x2F;take这组方法，而不是offer&#x2F;poll，因为后者会在满&#x2F;空时直接返回（而非阻塞等待）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">public class Producer implements Runnable &#123;</span><br><span class="line">    private final BlockingQueue&lt;String&gt; queue;</span><br><span class="line"></span><br><span class="line">    public Producer(BlockingQueue&lt;String&gt; queue) &#123;</span><br><span class="line">        this.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for(int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                queue.put(&quot;Course&quot; + (i + 1));</span><br><span class="line">                System.out.println(&quot;Complete production:Course&quot; + (i + 1));</span><br><span class="line">                Thread.sleep(100);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Consumer implements Runnable &#123;</span><br><span class="line">    private final BlockingQueue&lt;String&gt; queue;</span><br><span class="line"></span><br><span class="line">    public Consumer(BlockingQueue&lt;String&gt; queue) &#123;</span><br><span class="line">        this.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for(int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                String course = queue.take();</span><br><span class="line">                System.out.println(&quot;Complete consumption:&quot; + course);</span><br><span class="line">                Thread.sleep(100);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        BlockingQueue&lt;String&gt; queue = new ArrayBlockingQueue&lt;String&gt;(2);</span><br><span class="line">        Thread t1 = new Thread(new Producer(queue));</span><br><span class="line">        Thread t2 = new Thread(new Consumer(queue));</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        try &#123;</span><br><span class="line">            t1.join();</span><br><span class="line">            t2.join();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Readers-writers"><a href="#Readers-writers" class="headerlink" title="Readers-writers"></a>Readers-writers</h1><p>读写问题中有两类线程：</p>
<ul>
<li>读线程：多个读线程可以同时在临界区；</li>
<li>写线程：多个写线程之间互斥，与读线程也互斥。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">public class ReaderWriterTest &#123;</span><br><span class="line"></span><br><span class="line">    // 当前有多少读线程正在读</span><br><span class="line">    static int readers = 0;</span><br><span class="line">    // 保护readers计数器</span><br><span class="line">    static Semaphore mutex = new Semaphore(1);</span><br><span class="line">    // 0表示有线程正在临界区，1表示没有</span><br><span class="line">    static Semaphore rootEmpty = new Semaphore(1);</span><br><span class="line"></span><br><span class="line">    static Runnable reader = () -&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            mutex.acquire();</span><br><span class="line">            readers++;</span><br><span class="line">            // 第一个来的需要等锁释放，其他reader会在mutex那里等着</span><br><span class="line">            if(readers == 1) &#123;</span><br><span class="line">                rootEmpty.acquire();</span><br><span class="line">            &#125;</span><br><span class="line">            mutex.release();</span><br><span class="line">            System.out.println(&quot;读取开始, readers:&quot; + readers);</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">            System.out.println(&quot;读取结束, readers:&quot; + readers);</span><br><span class="line">            mutex.acquire();</span><br><span class="line">            readers--;</span><br><span class="line">            if(readers == 0) &#123;</span><br><span class="line">                rootEmpty.release();</span><br><span class="line">            &#125;</span><br><span class="line">            mutex.release();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    static Runnable writer = () -&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            rootEmpty.acquire();</span><br><span class="line">            System.out.println(&quot;写入开始&quot;);</span><br><span class="line">            Thread.sleep(3000);</span><br><span class="line">            System.out.println(&quot;写入结束&quot;);</span><br><span class="line">            rootEmpty.release();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Thread reader1 = new Thread(reader);</span><br><span class="line">        Thread reader2 = new Thread(reader);</span><br><span class="line">        Thread reader3 = new Thread(reader);</span><br><span class="line">        Thread reader4 = new Thread(reader);</span><br><span class="line">        Thread reader5 = new Thread(reader);</span><br><span class="line">        Thread reader6 = new Thread(reader);</span><br><span class="line">        Thread writer1 = new Thread(writer);</span><br><span class="line">        reader1.start();</span><br><span class="line">        reader2.start();</span><br><span class="line">        reader3.start();</span><br><span class="line">        reader4.start();</span><br><span class="line">        reader5.start();</span><br><span class="line">        reader6.start();</span><br><span class="line">        writer1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码有个问题，就是写线程可能被饿死，因为第一个读线程通过<code>rootEmpty.acquire</code>进来后，后续的读线程都不必再等待，可以直接进入临界区，而同时执行的写线程就永远都等在<code>rootEmpty.acquire</code>上了。<br>改成如下的方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">public class ReaderWriterTest &#123;</span><br><span class="line"></span><br><span class="line">    // 当前有多少读线程正在读</span><br><span class="line">    static int readers = 0;</span><br><span class="line">    // 保护readers计数器</span><br><span class="line">    static Semaphore mutex = new Semaphore(1);</span><br><span class="line">    // 0表示有线程正在临界区，1表示没有</span><br><span class="line">    static Semaphore rootEmpty = new Semaphore(1);</span><br><span class="line">    // 控制reader和writer获取锁</span><br><span class="line">    static Semaphore turnstile = new Semaphore(1);</span><br><span class="line"></span><br><span class="line">    static Runnable reader = () -&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            turnstile.acquire();</span><br><span class="line">            turnstile.release();</span><br><span class="line">            mutex.acquire();</span><br><span class="line">            readers++;</span><br><span class="line">            // 第一个来的需要等锁释放，其他reader会在mutex那里等着</span><br><span class="line">            if(readers == 1) &#123;</span><br><span class="line">                rootEmpty.acquire();</span><br><span class="line">            &#125;</span><br><span class="line">            mutex.release();</span><br><span class="line">            System.out.println(&quot;读取开始, readers:&quot; + readers);</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">            System.out.println(&quot;读取结束, readers:&quot; + readers);</span><br><span class="line">            mutex.acquire();</span><br><span class="line">            readers--;</span><br><span class="line">            if(readers == 0) &#123;</span><br><span class="line">                rootEmpty.release();</span><br><span class="line">            &#125;</span><br><span class="line">            mutex.release();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    static Runnable writer = () -&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            turnstile.acquire();</span><br><span class="line">            rootEmpty.acquire();</span><br><span class="line">            System.out.println(&quot;写入开始&quot;);</span><br><span class="line">            Thread.sleep(3000);</span><br><span class="line">            System.out.println(&quot;写入结束&quot;);</span><br><span class="line">            turnstile.release();</span><br><span class="line">            rootEmpty.release();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Thread reader1 = new Thread(reader);</span><br><span class="line">        Thread reader2 = new Thread(reader);</span><br><span class="line">        Thread reader3 = new Thread(reader);</span><br><span class="line">        Thread reader4 = new Thread(reader);</span><br><span class="line">        Thread reader5 = new Thread(reader);</span><br><span class="line">        Thread reader6 = new Thread(reader);</span><br><span class="line">        Thread writer1 = new Thread(writer);</span><br><span class="line">        reader1.start();</span><br><span class="line">        reader2.start();</span><br><span class="line">        reader3.start();</span><br><span class="line">        reader4.start();</span><br><span class="line">        reader5.start();</span><br><span class="line">        reader6.start();</span><br><span class="line">        writer1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="Dining-philosophers（哲学家就餐）"><a href="#Dining-philosophers（哲学家就餐）" class="headerlink" title="Dining philosophers（哲学家就餐）"></a>Dining philosophers（哲学家就餐）</h1><p>我们先来看下最开始最直观的一种错误解法，这种解法会导致死锁：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public class DiningPhilosophersTest &#123;</span><br><span class="line"></span><br><span class="line">    private static final int count = 2;</span><br><span class="line"></span><br><span class="line">    private Semaphore[] forks = new Semaphore[count];</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        for (int i = 0; i &lt; forks.length; i++) &#123;</span><br><span class="line">            forks[i] = new Semaphore(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int left(int i) &#123;</span><br><span class="line">        return i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int right(int i) &#123;</span><br><span class="line">        return (i + 1) % forks.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void getForks(int i) throws InterruptedException &#123;</span><br><span class="line">        forks[left(i)].acquire();</span><br><span class="line">        forks[right(i)].acquire();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void putForks(int i) &#123;</span><br><span class="line">        forks[left(i)].release();</span><br><span class="line">        forks[right(i)].release();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void doDining() &#123;</span><br><span class="line">        Thread[] threads = new Thread[count];</span><br><span class="line">        for (int i = 0; i &lt; threads.length; i++) &#123;</span><br><span class="line">            int finalI = i;</span><br><span class="line">            threads[i] = new Thread(() -&gt; &#123;</span><br><span class="line">                while (true) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        getForks(finalI);</span><br><span class="line">                        System.out.println(finalI + &quot; 开始就餐&quot;);</span><br><span class="line">                        Thread.sleep(10);</span><br><span class="line">                        System.out.println(finalI + &quot; 结束就餐&quot;);</span><br><span class="line">                        putForks(finalI);</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        DiningPhilosophersTest test = new DiningPhilosophersTest();</span><br><span class="line">        test.doDining();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然，n位哲学家刚开始都没有处于就餐状态，如果他们同时拿起左边的叉子，然后尝试取右边的叉子，就会直接导致死锁。</p>
<h2 id="减少同时获取叉子的哲学家数量"><a href="#减少同时获取叉子的哲学家数量" class="headerlink" title="减少同时获取叉子的哲学家数量"></a>减少同时获取叉子的哲学家数量</h2><p>注意，上面发生死锁的必要条件是“n位哲学家同时就餐”，如果n位无法同时就餐，那这个问题也就迎刃而解了，所以我们额外引入一个<code>footman</code>信号量，它的数量控制在<code>n - 1</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private Semaphore footman = new Semaphore(count - 1);</span><br><span class="line"></span><br><span class="line">private void getForks(int i) throws InterruptedException &#123;</span><br><span class="line">    footman.acquire();</span><br><span class="line">    forks[left(i)].acquire();</span><br><span class="line">    forks[right(i)].acquire();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void putForks(int i) &#123;</span><br><span class="line">    forks[left(i)].release();</span><br><span class="line">    forks[right(i)].release();</span><br><span class="line">    footman.release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="同时存在左撇子（先拿左手边叉子的）和右撇子（先拿右手边叉子的）"><a href="#同时存在左撇子（先拿左手边叉子的）和右撇子（先拿右手边叉子的）" class="headerlink" title="同时存在左撇子（先拿左手边叉子的）和右撇子（先拿右手边叉子的）"></a>同时存在左撇子（先拿左手边叉子的）和右撇子（先拿右手边叉子的）</h2><p>另外一种解决办法是让一个哲学家先获取右边的叉子再获取左边的叉子，这样其实解除了环路等待条件：假设有5个哲学家，其中4个哲学家拿到左手的叉子后，第五个哲学家会尝试取第一个叉子，也就是第一个哲学家左手的叉子，他们两个不满足死锁的条件。<br>这种思路的代码比较简单，就先忽略了。</p>
<h2 id="Tanenbaum的解"><a href="#Tanenbaum的解" class="headerlink" title="Tanenbaum的解"></a>Tanenbaum的解</h2><p>这是一种相对比较极端的解，每个哲学家都需要等两边的人不在就餐的情况下才能就餐，否则他什么都不做：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">private static final int count = 2;</span><br><span class="line"></span><br><span class="line">private Semaphore mutex = new Semaphore(1);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * state为0表示正在思考（thinking），1表示准备就餐（hungry），2表示正在就餐（eating）</span><br><span class="line"> */</span><br><span class="line">private int[] states = new int[count];</span><br><span class="line"></span><br><span class="line">private Semaphore[] forks = new Semaphore[count];</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 0; i &lt; forks.length; i++) &#123;</span><br><span class="line">        forks[i] = new Semaphore(0);</span><br><span class="line">        states[i] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private int left(int i) &#123;</span><br><span class="line">    return i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private int right(int i) &#123;</span><br><span class="line">    return (i + 1) % forks.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void test(int i) &#123;</span><br><span class="line">    // 如果自己准备就餐且两边的人都不在就餐，则自己可以就餐</span><br><span class="line">    if(states[i] == 1</span><br><span class="line">            &amp;&amp; states[left(i)] != 2</span><br><span class="line">            &amp;&amp; states[right(i)] != 2) &#123;</span><br><span class="line">        states[i] = 2;</span><br><span class="line">        forks[i].release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void getForks(int i) throws InterruptedException &#123;</span><br><span class="line">    mutex.acquire();</span><br><span class="line">    states[i] = 1;</span><br><span class="line">    test(i);</span><br><span class="line">    mutex.release();</span><br><span class="line">    forks[i].acquire();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void putForks(int i) throws InterruptedException &#123;</span><br><span class="line">    mutex.acquire();</span><br><span class="line">    states[i] = 0;</span><br><span class="line">    test(right(i));</span><br><span class="line">    test(left(i));</span><br><span class="line">    mutex.release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种解存在的主要问题是会发生饥饿，比如2个哲学家的情况下，可能1号会一直处于就餐状态，2号一直处于循环检测的状态，于是就发生了饥饿。</p>
<h1 id="Cigarette-smokers"><a href="#Cigarette-smokers" class="headerlink" title="Cigarette smokers"></a>Cigarette smokers</h1><h1 id="The-dining-savages（野人就餐）"><a href="#The-dining-savages（野人就餐）" class="headerlink" title="The dining savages（野人就餐）"></a>The dining savages（野人就餐）</h1><h1 id="The-barbershop（理发师问题）"><a href="#The-barbershop（理发师问题）" class="headerlink" title="The barbershop（理发师问题）"></a>The barbershop（理发师问题）</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">#define N 10 //最多10个顾客</span><br><span class="line">typedef struct queue&#123;</span><br><span class="line">    int nums[N];</span><br><span class="line">    int front;</span><br><span class="line">    int rear;</span><br><span class="line">&#125;queue;</span><br><span class="line">int isFull(queue *q)&#123;</span><br><span class="line">    return q-&gt;front + 1 == q-&gt;rear;</span><br><span class="line">&#125;</span><br><span class="line">int isEmpty(queue *q)&#123;</span><br><span class="line">    return q-&gt;front == q-&gt;rear;</span><br><span class="line">&#125;</span><br><span class="line">//返回顾客标志</span><br><span class="line">int dequeue(queue *q)&#123;</span><br><span class="line">    if(isEmpty(q))&#123;</span><br><span class="line">        puts(&quot;error: empty!&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        int num = q-&gt;nums[q-&gt;rear];</span><br><span class="line">        q-&gt;rear = (q-&gt;rear + 1) % N;</span><br><span class="line"></span><br><span class="line">        return num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void enqueue(queue *q, int num)&#123;</span><br><span class="line">    if(isFull(q))&#123;</span><br><span class="line">        puts(&quot;error: full queue!&quot;);</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        q-&gt;nums[q-&gt;front] = num;</span><br><span class="line">        q-&gt;front = (q-&gt;front + 1) % N;</span><br><span class="line">        q-&gt;front++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//顾客每次等待，若队列已满将会被忽略</span><br><span class="line">void customerWait(semaphore *barber, int num)&#123;</span><br><span class="line">    if(barber-&gt;busy == no)&#123;</span><br><span class="line">        barber-&gt;busy = yes;</span><br><span class="line">        enqueue(&amp;barber-&gt;customers, num);</span><br><span class="line">        printf(&quot;这个顾客开始接受服务&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        //将当前顾客加入等待队列，似乎不是原子操作？</span><br><span class="line">        enqueue(&amp;barber-&gt;customers, num);</span><br><span class="line">        printf(&quot;加入顾客%d&quot;, num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//理发师每次等待新用户，</span><br><span class="line">void barberSignal(semaphore *barber)&#123;</span><br><span class="line">    if(isEmpty(&amp;barber-&gt;customers))&#123;</span><br><span class="line">        barber-&gt;busy = no;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        int num = dequeue(&amp;barber-&gt;customers);</span><br><span class="line">        printf(&quot;顾客%d开始交易&quot;, num);</span><br><span class="line">        sleep(3000);//每个顾客睡三秒</span><br><span class="line">        printf(&quot;结束交易&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">    用一个主函数开启一个理发师进程，理发师进程等待新顾客，对每一个顾客sleep(3000)作为服务时间，然后signal，</span><br><span class="line">    主函数等待用户输入用户id，对每一个用户id开启一个进程，</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">semaphore barber;</span><br><span class="line">void simulate()&#123;</span><br><span class="line">    barber.busy = no;</span><br><span class="line">    barber.customers.front = barber.customers.rear = 0;</span><br><span class="line">    </span><br><span class="line">    int pid = fork();</span><br><span class="line">    if(pid == 0)&#123;</span><br><span class="line">        //说明是理发师</span><br><span class="line">        while(1)&#123;</span><br><span class="line">            barberSignal(&amp;barber);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        int num;</span><br><span class="line">        while(1)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;num);</span><br><span class="line">            printf(&quot;%d&quot;, num);</span><br><span class="line">            //int pid1 = fork();</span><br><span class="line">            //if(pid1 != 0)&#123;</span><br><span class="line">                //顾客进程</span><br><span class="line">                customerWait(&amp;barber, num);</span><br><span class="line">            //  printf(&quot;哈哈哈&quot;);</span><br><span class="line">            //  return ;</span><br><span class="line">            //&#125;</span><br><span class="line">            //父进程继续运行</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;semaphore.h&gt;</span><br><span class="line"></span><br><span class="line">#define N 10 //最多10个顾客</span><br><span class="line">/***********************信号量**************************/</span><br><span class="line">sem_t barbers;</span><br><span class="line">sem_t customers;</span><br><span class="line">sem_t mutex;</span><br><span class="line">int customerCount = 0;</span><br><span class="line"></span><br><span class="line">void haircut()&#123;</span><br><span class="line">	printf(&quot;理发师剪头中\n&quot;);</span><br><span class="line">	sleep(3);//服务时间</span><br><span class="line">&#125;</span><br><span class="line">void get_haircut()&#123;</span><br><span class="line">	sleep(3);</span><br><span class="line">&#125;</span><br><span class="line">void *barber(void *arg)&#123;</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		if(customerCount == 0)&#123;</span><br><span class="line">			printf(&quot;理发师打瞌睡\n&quot;);</span><br><span class="line">			sem_wait(&amp;customers);//等顾客</span><br><span class="line">			printf(&quot;理发师被叫醒了\n&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			sem_wait(&amp;customers);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		sem_post(&amp;barbers);//唤醒理发师</span><br><span class="line">		haircut();//开始服务</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void *customer(void *arg)&#123;</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		if(customerCount &gt; 0)&#123;</span><br><span class="line">			printf(&quot;顾客等理发师\n&quot;);</span><br><span class="line">			sem_wait(&amp;barbers);//等理发师	</span><br><span class="line">			</span><br><span class="line">			sem_wait(&amp;mutex);</span><br><span class="line">			customerCount--;	</span><br><span class="line">			sem_post(&amp;mutex);</span><br><span class="line">			</span><br><span class="line">			get_haircut();//接受服务			</span><br><span class="line">			printf(&quot;理完头这个顾客离开了\n&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void *customer_arrive(void *arg)&#123;</span><br><span class="line">	int num;</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;num);</span><br><span class="line">		printf(&quot;来了一个顾客\n&quot;);</span><br><span class="line">		sem_wait(&amp;mutex);</span><br><span class="line">		if(customerCount &lt; N)&#123;//如果还有空位</span><br><span class="line">		sem_post(&amp;mutex);</span><br><span class="line">			sem_post(&amp;customers);//添加一个顾客资源</span><br><span class="line">			customerCount++;//顾客增加</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">		sem_post(&amp;mutex);</span><br><span class="line">			printf(&quot;没椅子了，顾客离开了\n&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void simulate()&#123;</span><br><span class="line">	pthread_t barber_t, customer_t, customer_arrive_t;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	if(sem_init(&amp;barbers, 0, 1) != 0)&#123;</span><br><span class="line">		printf(&quot;sem init failed&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	if(sem_init(&amp;customers, 0, 0) != 0)&#123;</span><br><span class="line">		printf(&quot;sem init failed&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	if(sem_init(&amp;mutex, 0, 1) != 0)&#123;</span><br><span class="line">		printf(&quot;sem init failed&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	printf(&quot;begin barber_t\n&quot;);</span><br><span class="line">	pthread_create(&amp;barber_t, NULL, barber, NULL);</span><br><span class="line">	printf(&quot;begin customer_t\n&quot;);</span><br><span class="line">	pthread_create(&amp;customer_t, NULL, customer, NULL);</span><br><span class="line">	printf(&quot;begin customer_arrive_t\n&quot;);</span><br><span class="line">	pthread_create(&amp;customer_arrive_t, NULL, customer_arrive, NULL);</span><br><span class="line">	</span><br><span class="line">	while(1)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(void )&#123;</span><br><span class="line">	simulate();</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="卖票问题"><a href="#卖票问题" class="headerlink" title="卖票问题"></a>卖票问题</h1><p>一个火车站有多个窗口，它们同时卖票，而票数使用一个 ticket 变量进行计算，对票数有查询和修改两个操作，这两个操作不能同时进行，并且写操作可能不是原子的，两个写操作也不能同时进行</p>
<ul>
<li>使用 Atom 类型来保存票数，这样写之间就不需要进行同步了</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a target="_blank" rel="noopener" href="https://greenteapress.com/wp/semaphores/">The Little Book of Semaphores</a></li>
</ol>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/e913f4bd.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tallate">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tallate">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/e913f4bd.html" class="post-title-link" itemprop="url">JVM 与动态内存管理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-09-21 15:26:49" itemprop="dateCreated datePublished" datetime="2019-09-21T15:26:49+08:00">2019-09-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-07 01:56:20" itemprop="dateModified" datetime="2025-07-07T01:56:20+08:00">2025-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在 Java 体系中，提到并发就不得不提到 JMM，因为所有并发安全都是围绕内存来展开的，可以说不懂内存结构就不懂并发。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/e913f4bd.html#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/b27f4a82.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tallate">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tallate">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/b27f4a82.html" class="post-title-link" itemprop="url">JVM与垃圾收集器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-09-21 15:26:49" itemprop="dateCreated datePublished" datetime="2019-09-21T15:26:49+08:00">2019-09-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-07 01:56:20" itemprop="dateModified" datetime="2025-07-07T01:56:20+08:00">2025-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>


<h2 id="垃圾收集（GC）"><a href="#垃圾收集（GC）" class="headerlink" title="垃圾收集（GC）"></a>垃圾收集（GC）</h2><h3 id="垃圾检测"><a href="#垃圾检测" class="headerlink" title="垃圾检测"></a>垃圾检测</h3><p>在实际回收垃圾对象前，我们必须标识出哪些对象该被回收，即垃圾检测。</p>
<h4 id="对象引用类型"><a href="#对象引用类型" class="headerlink" title="对象引用类型"></a>对象引用类型</h4><ol>
<li>强引用(StrongReference)<br><code>Object obj = new Object()</code>的 obj 就是一个强引用。<br>当内存不足，JVM 宁愿抛出 <code>OutOfMemoryError</code> 错误，使程序异常终止，也不会回收强引用对象来释放内存，除非已经没有引用关联这些对象了。<br>除了强引用之外，其他三种引用都在<code>java.lang.ref</code>包中。</li>
<li>软引用(SoftReference)<br>GC 发现了只具有软引用的对象并不会立即进行回收，而是让它活的尽可能久一些，在内存不足前再进行回收。<br>在使用<strong>缓存的场景</strong>的时候会经常采用此种引用方式，来增加系统可用性的弹性空间。Spring 和 cache 里面大量采用了此种引用方式。</li>
<li>弱引用(WeakReference)<br>GC 一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。如果有场景，发现创建完对象很少可能会用到，就采用这种方式，不过实际工作确实很少见到有人用到3，4两个引用。</li>
<li>虚引用(PhantomReference)<br>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期；如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。<br>虚引用主要用来跟踪对象被 GC 回收的活动，虚引用必须和引用队列（ReferenceQueue）配合使用。</li>
</ol>
<h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>Reference 抽象类是除强引用外的所有引用类型的父类，有以下几种子类</p>
<ol>
<li>SoftReference 类：软引用 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyObject obj = new MyObject();  </span><br><span class="line">SoftReference&lt;MyObject&gt; ref = new SoftReference&lt;MyObject&gt;(obj);</span><br></pre></td></tr></table></figure></li>
<li>WeakReference 类：弱引用</li>
<li>PhantomReference 类：虚引用</li>
<li>ReferenceQueue 类：引用队列</li>
</ol>
<h4 id="垃圾检测算法-引用计数"><a href="#垃圾检测算法-引用计数" class="headerlink" title="垃圾检测算法 - 引用计数"></a>垃圾检测算法 - 引用计数</h4><p>堆中的每一个对象的对象域包含一个引用计数器。该计数器的维护规则如下：</p>
<ul>
<li>当一个对象被创建，并把指向该对象的引用赋值给一个变量时，引用计数置为1</li>
<li>当再把这个引用赋值给其他变量时，引用计数加1</li>
<li>当一个对象的引用超过了生命周期或者被设置为新值时，对象的引用计数减 1，任何引用计数为 0 的对象都可以被当成垃圾回收。</li>
<li>当一个对象被回收时，它所引用的任何对象计数减1，这样，可能会导致其他对象也被当垃圾回收。</li>
</ul>
<p>但是一般垃圾回收器并不会采用这种算法，主要是因为引用计数算法存在循环引用的问题（注意不是栈帧里的引用，而是堆中实例的互相引用）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class ReferenceCountingGC &#123;</span><br><span class="line">    public Object instance = null;</span><br><span class="line">    private static final int _1MB = 1024 * 1024;</span><br><span class="line">    /**</span><br><span class="line">     * 这个成员属性的唯一意义就是占点内存,以便能在GC日志中看清楚是否被回收过</span><br><span class="line">     */</span><br><span class="line">    private byte[] bigSize = new byte[2 * _1MB];</span><br><span class="line"></span><br><span class="line">    public static void testGC() &#123;</span><br><span class="line">        // 定义两个对象</span><br><span class="line">        ReferenceCountingGC objA = new ReferenceCountingGC();</span><br><span class="line">        ReferenceCountingGC objB = new ReferenceCountingGC();</span><br><span class="line"></span><br><span class="line">        // 给对象的成员赋值，即存在相互引用情况</span><br><span class="line">        objA.instance = objB;</span><br><span class="line">        objB.instance = objA;</span><br><span class="line"></span><br><span class="line">        // 将引用设为空，即没有到堆对象的引用了</span><br><span class="line">        objA = null;</span><br><span class="line">        objB = null;</span><br><span class="line"></span><br><span class="line">        // 进行垃圾回收</span><br><span class="line">        System.gc();    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        testGC();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上边代码所示，执行<code>objA = null</code>和<code>objB = null</code>后，它们二者的 instance 域仍然互相是对方的引用。</p>
<h4 id="垃圾检测算法-可达性分析"><a href="#垃圾检测算法-可达性分析" class="headerlink" title="垃圾检测算法 - 可达性分析"></a>垃圾检测算法 - 可达性分析</h4><p>若一个对象没有引用链与任一个 GC Roots 相连时，此对象可回收<br>包括虚拟机栈中引用的对象、方法区中类的静态成员变量引用的对象、方法区中的常量引用的对象、本地方法栈中 Native 方法引用的对象<br><strong>根部（Roots）</strong>：表示引用链的头部<br><strong>引用链（Reference Chain）</strong>：多个引用形成的一条链<br><strong>引用</strong>：是 reference 类型的对象，其中存储的数据代表的是另外一块内存的起始位置，有强引用（Strong）、软引用（Soft）、弱引用（Weak）、虚引用（Phantom）四种。</p>
<p>此算法的基本思想就是选取一系列 GC Roots 对象作为起点，开始向下遍历搜索其他相关的对象，搜索所走过的路径成为引用链，遍历完成后，如果一个对象到 GCRoots 对象没有任何引用链，则证明此对象是不可用的，可以被当做垃圾进行回收。<br>那么问题又来了，如何选取 GCRoots 对象呢？在 Java 语言中，可以作为 GCRoots 的对象包括下面几种：</p>
<ol>
<li>虚拟机栈（栈帧中的局部变量区，也叫做局部变量表）中引用的对象。</li>
<li>方法区中的类静态属性引用的对象。</li>
<li>方法区中常量引用的对象。</li>
<li>本地方法栈中 JNI(Native 方法)引用的对象。</li>
</ol>
<p><img src="/imgs/JVM/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95.png" alt="可达性分析算法" title="可达性分析算法"><br>如上图所示，Obj8、Obj9、Obj10 都没有到 GC Root 的引用链，因此它们会被标记为垃圾，即便 Obj9 和 Obj10 之间有引用关系。</p>
<h4 id="引用与垃圾检测算法"><a href="#引用与垃圾检测算法" class="headerlink" title="引用与垃圾检测算法"></a>引用与垃圾检测算法</h4><p>对于可达性分析算法而言，未到达的对象并非是“非死不可”的，若要宣判一个对象死亡，至少需要经历两次标记阶段。</p>
<ol>
<li>如果对象在进行可达性分析后发现没有与 GCRoots 相连的引用链，则该对象被第一次标记并进行一次筛选，筛选条件为是否有必要执行该对象的<strong>finalize</strong>方法，若对象没有覆盖 finalize 方法或者该 finalize 方法是否已经被虚拟机执行过了，则均视作不必要执行该对象的 finalize 方法，即该对象将会被回收。反之，若对象覆盖了 finalize 方法并且该 finalize 方法并没有被执行过，那么，这个对象会被放置在一个叫<strong>F-Queue</strong>的队列中，之后会由虚拟机自动建立的、优先级低的<strong>Finalizer线程</strong>去执行，而虚拟机不必要等待该线程执行结束，即虚拟机只负责建立线程，其他的事情交给此线程去处理。</li>
<li>对 F-Queue 中对象进行第二次标记，<strong>如果对象在 finalize 方法中拯救了自己，即关联上了 GCRoot 引用链，如把 this 关键字赋值给其他变量，那么在第二次标记的时候该对象将从“即将回收”的集合中移除</strong>，如果对象还是没有拯救自己，那就会被回收。如下代码演示了一个对象如何在 finalize 方法中拯救了自己，然而，它只能拯救自己一次，第二次就被回收了。具体代码如下<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 此代码演示了两点：</span><br><span class="line"> * 1.对象可以再被GC时自我拯救</span><br><span class="line"> * 2.这种自救的机会只有一次，因为一个对象的finalize()方法最多只会被系统自动调用一次</span><br><span class="line"> * */</span><br><span class="line">public class FinalizeEscapeGC &#123;</span><br><span class="line">    public static FinalizeEscapeGC SAVE_HOOK = null;</span><br><span class="line">    @Override</span><br><span class="line">    protected void finalize() throws Throwable &#123;</span><br><span class="line">        super.finalize();</span><br><span class="line">        System.out.println(this + &quot;: finalize method executed!&quot;);</span><br><span class="line">        FinalizeEscapeGC.SAVE_HOOK = this;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        SAVE_HOOK = new FinalizeEscapeGC();</span><br><span class="line">        System.out.println(SAVE_HOOK);</span><br><span class="line">        // 对象第一次拯救自己</span><br><span class="line">        SAVE_HOOK = null;</span><br><span class="line">        System.out.println(SAVE_HOOK);</span><br><span class="line">        System.gc();</span><br><span class="line">        // 因为finalize方法优先级很低，所以暂停0.5秒以等待它</span><br><span class="line">        Thread.sleep(500);</span><br><span class="line">        System.out.println(SAVE_HOOK);</span><br><span class="line">        // 下面这段代码与上面的完全相同,但是这一次自救却失败了</span><br><span class="line">        // 一个对象的finalize方法只会被调用一次</span><br><span class="line">        SAVE_HOOK = null;</span><br><span class="line">        System.gc();</span><br><span class="line">        // 因为finalize方法优先级很低，所以暂停0.5秒以等待它</span><br><span class="line">        Thread.sleep(500);</span><br><span class="line">        System.out.println(SAVE_HOOK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><h4 id="标记清除（Mark-Sweep）"><a href="#标记清除（Mark-Sweep）" class="headerlink" title="标记清除（Mark-Sweep）"></a>标记清除（Mark-Sweep）</h4><p>先标记所有需要清除的对象，再统一回收。是最基础的垃圾回收算法，后续的收集算法都是基于这种思路并对其缺点进行改进而得到的。<br><strong>问题</strong>  </p>
<ul>
<li>效率低，标记和清除都需要一次线性扫描；</li>
<li>产生大量内存碎片，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li>
</ul>
<p>首先标记出所有需要回收的对象，使用可达性分析算法判断一个对象是否为可回收，在标记完成后统一回收所有被标记的对象。下图是算法具体的一次执行过程后的结果对比。<br><img src="/imgs/JVM/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.png" alt="标记清除算法" title="标记清除算法"></p>
<h4 id="复制算法（Copying）"><a href="#复制算法（Copying）" class="headerlink" title="复制算法（Copying）"></a>复制算法（Copying）</h4><p>将可用内存划分为大小相等的两半，对每一块使用<strong>指针碰撞</strong>（从已分配内存向空闲内存空间移动对象大小的空间）的方法为对象分配空间，如果这一块内存用完，就将还存活的对象复制到另一半块上，将原来的这一半一次清理掉。<br>HotSpot 中使用的是 Eden-Survivor 方法，大体上每次使用一个 Eden 和一个 Survivor 来分配对象空间，当回收时，将这两块中还存活的对象一次性复制到另一块 Survivor 中，Eden 和 Survivor 的比例为<code>8:1</code>。如果 Survivor 的空间不够了，就会使用老年代进行<strong>分配担保（Handle Promotion）</strong>。  </p>
<ul>
<li>将现有的内存空间分为两快，每次只使用其中一块；</li>
<li>当其中一块时候完的时候，就将还存活的对象复制到另外一块上去；</li>
<li>再把已使用过的内存空间一次清理掉。</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>由于是每次都对整个半区进行内存回收，内存分配时不必考虑内存碎片问题；</li>
<li>只要移动堆顶指针，按顺序分配内存即可，可以利用<strong>Bump-the-pointer（指针碰撞）</strong>实现，实现简单，运行高效；<blockquote>
<p>像标记-清除算法清理后的内存空间并不规整，可能会有很多碎片，因此只能使用<strong>空闲列表（Free List）</strong>的方式分配内存。</p>
</blockquote>
</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>内存减少为原来的一半，太浪费了（用空间换时间）；</li>
<li>对象存活率较高的时候就要执行较多的复制操作，效率变低；</li>
<li>如果不使用50%的对分策略，老年代需要考虑空间担保策略，复杂度变高。</li>
</ul>
<p><img src="/imgs/JVM/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png" alt="复制算法" title="复制算法"><br>将内存分为两等块，每次使用其中一块。当这一块内存用完后，就将还存活的对象复制到另外一个块上面，然后再把已经使用过的内存空间一次清理掉。图是算法具体的一次执行过程后的结果对比。</p>
<h4 id="标记-整理算法（Mark-Compact）"><a href="#标记-整理算法（Mark-Compact）" class="headerlink" title="标记-整理算法（Mark-Compact）"></a>标记-整理算法（Mark-Compact）</h4><p>标记过程和Mark-Sweep一样，但是不直接清除，而是让存活的对象向前移，再清理端边界外的内存。<br>标记过程还是和标记-清除算法一样，之后让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存，标记 - 整理算法示意图如下<br><img src="/imgs/JVM/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.png" alt="标记整理算法" title="标记整理算法"></p>
<p>标记-整理算法往往与标记-清除同时使用，优先执行标记-清除，当内存空间碎片过多时，才运行标记-整理压缩内存空间。</p>
<h4 id="分代收集算法（Generational-Collection）"><a href="#分代收集算法（Generational-Collection）" class="headerlink" title="分代收集算法（Generational Collection）"></a>分代收集算法（Generational Collection）</h4><p>将 Java 堆分为新生代和老生代，根据各个年代的特点采取最适当的收集算法。在新生代中死得快，就选用复制算法（要复制的少），老生代中对象存活率高，就使用标记整理或标记清除算法。  </p>
<h2 id="Java垃圾回收的基本概念"><a href="#Java垃圾回收的基本概念" class="headerlink" title="Java垃圾回收的基本概念"></a>Java垃圾回收的基本概念</h2><p>GC文章有些常用的概念：</p>
<ul>
<li>Mutator：生产垃圾的对象；</li>
<li>TLAB（Thread Local Allocation Buffer）：线程可以优先将对象分配在Eden区的一块线程独享内存，因为是线程独享的，没有锁竞争，所以分配速度更快。</li>
<li>Card Table：Java中的垃圾收集器以内存页作为分配单位，使用Card Table标记被写入过的卡页为dirty，dirty页面中的对象可达性可能发生变化，因此在像CMS这样的垃圾回收器的重标记阶段会被重新扫描一次。</li>
<li>分代回收<br>JVM中采用的分代回收算法将堆内存划分为年轻代、老年代、元空间和常量池（字符串、常量），以及栈空间、堆外内存。<br>垃圾回收主要处理的是年轻代和老年代的对象。</li>
<li>对象分配<br>JVM通过Unsafe调用C的allocate和free方法分配、释放对象，分配方法有空闲链表（free list）和碰撞指针（bump pointer）两种。</li>
<li>GC<br>垃圾收集需要先识别垃圾，然后再使用垃圾回收算法回收空间。<br>垃圾识别算法主要有引用计数、可达性分析；<br>GC算法常见的主要是Mark-Sweep、Mark-Compact、Copying。</li>
<li>垃圾收集器<br>不同的收集器会有不同的内存负责范围，不同的算法，比如CMS采用标记清除算法清理老年代空间，使用CMS时需要和ParNew搭配回收年轻代。</li>
</ul>
<h2 id="HotSpot-GC-触发时机"><a href="#HotSpot-GC-触发时机" class="headerlink" title="HotSpot GC 触发时机"></a>HotSpot GC 触发时机</h2><h3 id="GC-目标内存区域"><a href="#GC-目标内存区域" class="headerlink" title="GC 目标内存区域"></a>GC 目标内存区域</h3><p>对于虚拟机中<strong>线程私有的区域</strong>，如<strong>程序计数器</strong>、<strong>虚拟机栈</strong>、<strong>本地方法栈</strong>都不需要进行垃圾回收，因为它们是自动进行的，随着线程的消亡而消亡，不需要我们去回收，比如栈的栈帧结构，当进入一个方法时，就会产生一个栈帧，栈帧大小也可以借助类信息确定，然后栈帧入栈，执行方法体，退出方法时，栈帧出栈，于是其所占据的内存空间也就被自动回收了。<br>而对于虚拟机中<strong>线程共享的区域</strong>，则需要进行垃圾回收，如<strong>堆</strong>和<strong>方法区</strong>，线程都会在这两个区域产生自身的数据，占据一定的内存大小，并且这些数据又可能会存在相互关联的关系，所以，这部分的区域不像线程私有的区域那样可以简单自动的进行垃圾回收，此部分区域的垃圾回收非常复杂，而垃圾回收也主要是针对这部分区域。</p>
<h3 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h3><p>对于<strong>可达性分析</strong>而言，我们知道，首先需要选取 GCRoots 结点，而 GCRoots 结点主要在全局性的引用（如常量或类静态属性）与执行上下文（如栈帧中的局部变量表）中。方法区可以很大，这对于寻找 GCRoots 结点来说会非常耗时。当选取了 GCRoots 结点之后，<strong>进行可达性分析时必须要保证一致性</strong>，即在进行分析的过程中整个执行系统看起来就好像被冻结在某个时间点上，不可以在分析的时候，对象的关系还在动态变化，这样的话分析的准确性就得不到保证，所以可达性分析是时间非常敏感的。<br>为了保证分析结果的准确性，就会导致<strong>GC 进行时必须停顿所有 Java 执行线程（Stop the world）</strong>，为了尽可能的减少 Stop the world 的时间，Java 虚拟机使用了一组称为<strong>OopMap</strong>的数据结构，该数据结构用于存放对象引用的地址，这样，<strong>进行可达性分析的时候就可以直接访问 OopMap 就可以获得对象的引用，从而加快分析过程，减少 Stop the world 时间</strong>。<br>OopMap 数据结构有利于进行 GC，是不是虚拟机无论何时想要进行 GC 都可以进行 GC，即无论虚拟机在执行什么指令都可以进行 GC？答案是否定的，因为要想让虚拟机无论在执行什么指令的时候都可以进行 GC 的话，需要为每条指令都生成 OopMap，显然，这样太浪费空间了。为了节约宝贵的空间，虚拟机只在”特定的位置“存放了 OopMap 数据结构，这个特定的位置我们称之为<strong>安全点</strong>。<strong>程序执行时并非在所有地方都能够停顿下来开始 GC（可达性分析），只有到达安全点的时候才能暂停</strong>。<strong>安全点可以由方法调用、循环跳转、异常跳转等指令产生，因为这些指令会让程序长时间执行</strong>。<br>现在我们已经知道了安全点的概念，即进行 GC 必须要到达安全点，那么在发生 GC 时如何让所有线程到达安全点再暂停呢？有两种方法：</p>
<ol>
<li><strong>抢先式中断</strong>，在发生 GC 时，首先把所有线程全部中断，如果发现线程中断的地方不在安全点上，就恢复线程，让它跑到安全点上。</li>
<li><strong>主动式中断</strong>，在发生 GC 时，不中断线程，而是设置一个标志，所有线程执行时主动轮询这个标志，发生标志位真就自己中断挂起，轮询标志的地方和安全点是重合的，也有可能是创建对象需要分配内存的地方。</li>
</ol>
<p>现在问题又来了，当程序不执行的时候，如何让所有线程达到安全点呢？典型的就是线程处于 Sleep 状态或者 Blocked 状态，这时候线程是无法跑到安全点再中断自己的，虚拟机也肯定不可能等待该线程被唤醒并重新分配 CPU 时间后，跑到安全点再暂停。为了解决这个问题，引入<strong>安全区域</strong>的概念。<strong>安全区域是对安全点的扩展，可以看成由很多安全点组成，安全区域是指一段代码片段之中，引用关系不会发生变化</strong>。在这个区域的任何地方开始 GC 都是安全的。当线程执行到安全区域的代码时，首先标示自己已经进入了安全区域，那么，在这段时间里 JVM 发起 GC 时，就不用管标示自己为安全区域状态的线程了。在线程要离开安全区域时，它要检查系统是否已经完成了根节点枚举（或者整个 GC 过程），若完成，线程继续执行；否则，它必须等待直到收到可以安全离开安全区域的信号。</p>
<h3 id="分代回收-GC-类型及对象晋升（新生代-老年代）"><a href="#分代回收-GC-类型及对象晋升（新生代-老年代）" class="headerlink" title="分代回收 GC 类型及对象晋升（新生代 -&gt; 老年代）"></a>分代回收 GC 类型及对象晋升（新生代 -&gt; 老年代）</h3><p>根据作用区域的不同，GC 主要分为 3 种：</p>
<ul>
<li>Minor GC：对象通常在新生代的 Eden 区进行分配，当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC，非常频繁，速度较快；</li>
<li>Major GC：指发生在老年代的 GC，出现 Major GC，经常会伴随一次 Minor GC，同时 Minor GC 也会引起 Major GC，一般在 GC 日志中统称为 GC，不频繁。</li>
<li>Full GC：指发生在老年代和新生代的GC，速度很慢，需要Stop The World。可以用System.gc() 强制执行 Full GC，但这在生产环境中是需要被禁止的。</li>
</ul>
<p>对象的晋升机制：</p>
<ol>
<li>对象优先在新生代区中分配，若没有足够空间，则触发 Minor GC，经过 Minor GC 仍存活的对象年龄 +1，若年龄超过一定限制（默认为 15），则被晋升到老年态；</li>
<li>大对象（需要大量连续内存空间）直接进入老年态；</li>
<li>长期存活的对象进入老年态。</li>
</ol>
<h3 id="GC-Cause"><a href="#GC-Cause" class="headerlink" title="GC Cause"></a>GC Cause</h3><p>定义GC Cause的代码位置：<code>src/share/vm/gc/shared/gcCause.hpp</code> 和 <code>src/share/vm/gc/shared/gcCause.cpp</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">const char* GCCause::to_string(GCCause::Cause cause) &#123;</span><br><span class="line">  switch (cause) &#123;</span><br><span class="line">    // 手动触发</span><br><span class="line">    case _java_lang_system_gc:</span><br><span class="line">      return &quot;System.gc()&quot;;</span><br><span class="line">    </span><br><span class="line">    case _full_gc_alot:</span><br><span class="line">      return &quot;FullGCAlot&quot;;</span><br><span class="line"></span><br><span class="line">    case _scavenge_alot:</span><br><span class="line">      return &quot;ScavengeAlot&quot;;</span><br><span class="line"></span><br><span class="line">    case _allocation_profiler:</span><br><span class="line">      return &quot;Allocation Profiler&quot;;</span><br><span class="line"></span><br><span class="line">    case _jvmti_force_gc:</span><br><span class="line">      return &quot;JvmtiEnv ForceGarbageCollection&quot;;</span><br><span class="line"></span><br><span class="line">    // </span><br><span class="line">    case _gc_locker:</span><br><span class="line">      return &quot;GCLocker Initiated GC&quot;;</span><br><span class="line"></span><br><span class="line">    case _heap_inspection:</span><br><span class="line">      return &quot;Heap Inspection Initiated GC&quot;;</span><br><span class="line"></span><br><span class="line">    case _heap_dump:</span><br><span class="line">      return &quot;Heap Dump Initiated GC&quot;;</span><br><span class="line"></span><br><span class="line">    case _wb_young_gc:</span><br><span class="line">      return &quot;WhiteBox Initiated Young GC&quot;;</span><br><span class="line"></span><br><span class="line">    case _update_allocation_context_stats_inc:</span><br><span class="line">    case _update_allocation_context_stats_full:</span><br><span class="line">      return &quot;Update Allocation Context Stats&quot;;</span><br><span class="line"></span><br><span class="line">    case _no_gc:</span><br><span class="line">      return &quot;No GC&quot;;</span><br><span class="line"></span><br><span class="line">    // 分配对象失败，触发Young GC</span><br><span class="line">    case _allocation_failure:</span><br><span class="line">      return &quot;Allocation Failure&quot;;</span><br><span class="line"></span><br><span class="line">    // 老年代满了</span><br><span class="line">    case _tenured_generation_full:</span><br><span class="line">      return &quot;Tenured Generation Full&quot;;</span><br><span class="line"></span><br><span class="line">    case _metadata_GC_threshold:</span><br><span class="line">      return &quot;Metadata GC Threshold&quot;;</span><br><span class="line"></span><br><span class="line">    // CMS</span><br><span class="line">    case _cms_generation_full:</span><br><span class="line">      return &quot;CMS Generation Full&quot;;</span><br><span class="line"></span><br><span class="line">    case _cms_initial_mark:</span><br><span class="line">      return &quot;CMS Initial Mark&quot;;</span><br><span class="line"></span><br><span class="line">    case _cms_final_remark:</span><br><span class="line">      return &quot;CMS Final Remark&quot;;</span><br><span class="line"></span><br><span class="line">    case _cms_concurrent_mark:</span><br><span class="line">      return &quot;CMS Concurrent Mark&quot;;</span><br><span class="line"></span><br><span class="line">    case _old_generation_expanded_on_last_scavenge:</span><br><span class="line">      return &quot;Old Generation Expanded On Last Scavenge&quot;;</span><br><span class="line"></span><br><span class="line">    case _old_generation_too_full_to_scavenge:</span><br><span class="line">      return &quot;Old Generation Too Full To Scavenge&quot;;</span><br><span class="line"></span><br><span class="line">    case _adaptive_size_policy:</span><br><span class="line">      return &quot;Ergonomics&quot;;</span><br><span class="line"></span><br><span class="line">    case _g1_inc_collection_pause:</span><br><span class="line">      return &quot;G1 Evacuation Pause&quot;;</span><br><span class="line"></span><br><span class="line">    case _g1_humongous_allocation:</span><br><span class="line">      return &quot;G1 Humongous Allocation&quot;;</span><br><span class="line"></span><br><span class="line">    case _last_ditch_collection:</span><br><span class="line">      return &quot;Last ditch collection&quot;;</span><br><span class="line"></span><br><span class="line">    case _last_gc_cause:</span><br><span class="line">      return &quot;ILLEGAL VALUE - last gc cause - ILLEGAL VALUE&quot;;</span><br><span class="line"></span><br><span class="line">    default:</span><br><span class="line">      return &quot;unknown GCCause&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  ShouldNotReachHere();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JVM会因这些Cause触发回收：<br><code>/src/hotspot/share/gc/cms/concurrentMarkSweepGeneration.cpp</code></p>
<p>列举一些经典的GC Cause及参考的解决方案：</p>
<ol>
<li>扩容时发生的GC<br>如果<code>-Xms</code>和<code>-Xmx</code>的值设置得不一样，刚开始只会分配<code>-Xms</code>大小的堆空间，每次不够时再向操作系统申请，这时必须进行一次GC。<br>因此，需要尽量将<code>-Xms</code>和<code>-Xmx</code>、<code>-XX:-MaxNewSize</code>和<code>-XX:NewSize</code>、<code>-XX:MetaSpaceSize</code>和<code>-XX:MaxMetaSpaceSize</code>这样的值设置成一样的。</li>
<li>System.gc()<br>如果扩容缩容、Old区达到回收阈值、Metaspace空间不足、Young区晋升失败、大对象担保失败等几种情况都没有发生，却触发了GC，那有可能是因为代码中显式调用了<code>System.gc()</code>。<br><code>System.gc()</code>一般用于清理DiectBuffer对象，因为DirectBuffer会申请堆外空间。<br>因此<code>System.gc()</code>的去留需要根据即使情况来判断。</li>
<li>Metaspace OOM<br>1.8之后，Java将类、字符串常量等数据保存到了元空间，而元空间又位于堆中，因此GC时会将元空间的数据也一并回收掉。<br>但是元空间大小会受<code>-XX:MaxMetaSpaceSize</code>这个属性限制，如果空间不够且无法继续扩容，则将触发OOM。<br>一般Metaspace OOM是由动态加载类数据造成的，可以dump内存快照观察类数据的Histogram（直方图），或者直接通过命令定位，jcmd打几次Histogram的图，看一下具体是哪个包下的Class增加较多即可定位。</li>
<li>过早晋升<br>如果发生了以下情况，可能是发生了过早晋升：<br>分配速率接近于晋升速率,对象晋升年龄较小。<br>GC 日 志 中 出 现“Desired survivor size 107347968 bytes, new threshold 1(max 6)”等信息,说明此时经历过一次 GC 就会放到 Old 区。<br>Full GC 比较频繁,且经历过一次 GC 之后 Old 区的变化比例非常大。</li>
</ol>
<p>发生过早晋升的根本原因可能是：<strong>Young&#x2F;Eden区过小</strong>；<strong>分配速率过大</strong>。</p>
<p><strong>晋升年龄</strong>受一个阈值<code>MaxTenuringThreshold</code>控制，如果设置得过大，会导致该晋升的对象一直停留在年轻代，每次YoungGC都需要复制大量对象，失去了老年代的作用；如果设置得过小，大量对象被晋升到Old区，失去了年轻代的作用。不同情况下JVM内存成分不同，对象的生命周期分布也不同，因此晋升年龄是动态调整的。<br><code>/src/hotspot/share/gc/shared/ageTable.cpp#compute_tenuring_threshold</code><br>可以看到 Hotspot 遍历所有对象时,从所有年龄为 0 的对象占用的空间开始累加,如果加上年龄等于 n 的所有对象的空间之后,使用 Survivor 区的条件值(Target-SurvivorRatio &#x2F; 100,TargetSurvivorRatio 默认值为 50)进行判断,若大于这个值则结束循环,将 n 和 MaxTenuringThreshold 比较,若 n 小,则阈值为 n,若 n 大,则只能去设置最大阈值为 MaxTenuringThreshold。动态年龄触发后导致更多的对象进入了 Old 区,造成资源浪费。<br>如果是<strong>Young&#x2F;Eden</strong>过小，可以调整比例，一般可以在Heap 内存不变的情况下适当增大 Young 区，一般情况下 Old 的大小应当为活跃对象的 2~3 倍左右,考虑到浮动垃圾问题最好在 3 倍左右,剩下的都可以分给 Young 区。<br>如果是分配速率过大，可以分析一下代码是不是哪些地方动态加载类过快了；或者直接扩大元空间，适应这种速度。</p>
<ol>
<li><p>CMS FullGC频繁<br>CMS的原理是一次Young GC后，负责处理CMS的一个后台线程concurrentMarkSweep会不断地轮询，使用<code>shouldConcurrentCollect()</code>检测是否达到回收条件。如果达到条件则调用<code>collect_in_background()</code>启动一次Background模式GC。<br>判断是否进行回收的代码：<code>/src/hotspot/share/gc/cms/concurrentMarkSweepGeneration.cpp</code><br>比较常见的有：<code>-XX:+UseCMSInitiatingOccupancyFraction</code>触发、上次Young GC失败触发。</p>
</li>
<li><p>单次CMS GC（老年代GC）耗时过长<br>CMS回收主要耗时阶段是Init Mark和Final Remark，因为这两个阶段都需要STW，<br>见Old区垃圾回收细节：<code>CMSCollector::collect_in_background</code>、<code>CMSCollector::collect</code></p>
</li>
</ol>
<h3 id="不同算法触发的时机"><a href="#不同算法触发的时机" class="headerlink" title="不同算法触发的时机"></a>不同算法触发的时机</h3><ol>
<li>Minor GC（年轻代 GC）<br>触发时机：在 Enden 满了之后将被触发<br>GC 在优先级最低的线程中运行，一般在应用程序空闲即没有应用线程在运行时被调用。<br>当发生 Minor GC 后空间仍不够，触发 Major GC</li>
<li>Full GC &#x2F; Major GC（老年代GC）<br>触发时机：<ol>
<li>调用 System.gc 时，系统建议执行 Full GC，但是不必然执行。（可通过通过<code>-XX:+ DisableExplicitGC</code>来禁止 RMI 调用 System.gc。）</li>
<li>方法区空间不足，如果没有动态加载，一般是发生在启动的时候的，但是JDK1.8之后元空间替换了方法区，因此不会有这种情况了。</li>
<li>老年代空间不足，引起FullGC，这种情况比较复杂，有以下几种情况：<br> 3.1、通过对象的正常晋升机制触发对象向老年代移动时，老年代空间不足，由<code>-XX:MaxTenureThreshold</code>参数定义；<br> 3.2、大对象直接进入老年代，此时老年代空间不足，由<code>-XX:PretenureSizeThreshold</code>参数定义；<br> 3.3、动态年龄判定机制会将对象提前转移至老年代。年龄从小到大累加，当加入某个年龄段后，这个年龄对象占用空间大小总和超过survivor区域 * <code>-XX:TargetSurvivorRatio</code>的时候，<strong>从这个年龄段往上年龄的对象进入老年代</strong>；<br> 3.4、由 Eden 区、From Space 区向 To Space 区复制时，对象大小大于 To Space 可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。</li>
</ol>
</li>
</ol>
<p>在进行MinorGC之前，JVM的空间分配担保机制可能会触发3.2、3.3、3.4的发生，也就是触发一次FullGC。<br>所谓的<strong>空间分配担保机制</strong>，就是在MinorGC之前，虚拟机会检查老年代<strong>最大可用连续内存空间</strong>是否大于新生代所有对象的总空间。</p>
<ul>
<li>如果大于，则此次Minor是安全的；</li>
<li>如果小于，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果HandlePromotionFailure&#x3D;true，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小，如果大于，则尝试进行一次MinorGC，但这次MinorGC依然是有风险的，失败后会重新发起一次FullGC，如果小于或者HandlePromotionFailure&#x3D;false，则改为直接进行一次FullGC。</li>
</ul>
<p>最后，当发生 FullGC 之后空间还是不够，将抛出 OutOfMemoryError。</p>
<h3 id="对象分配和回收策略"><a href="#对象分配和回收策略" class="headerlink" title="对象分配和回收策略"></a>对象分配和回收策略</h3><p>对象的内存分配，绝大部分都是在堆上分配，少数经过<strong>JIT</strong>编译后被拆散为标量类型并间接在栈上分配。<br>在堆上的分配又可以有如下分配，主要在新生代的 Eden 区分配，如果启动了本地线程分配缓冲，将按照线程优先在<strong>TLAB</strong>上分配，少数直接在 Tenured 区分配，虚拟机也提供了一些参数供我们来控制对象内存空间的分配。<br>总而言之，对象分配具有以下几种策略：</p>
<h4 id="对象优先在-Eden-区分配"><a href="#对象优先在-Eden-区分配" class="headerlink" title="对象优先在 Eden 区分配"></a>对象优先在 Eden 区分配</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">-Xms20M -Xmx20M -Xmn10M</span><br><span class="line">-XX:SurvivorRatio=8</span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line">-XX:+UseSerialGC</span><br><span class="line">public class AllocEdenTest &#123;</span><br><span class="line">    private static final int _1MB = 1024 * 1024;</span><br><span class="line"></span><br><span class="line">    public static void testAllocation() &#123;</span><br><span class="line">        byte[] alloc1, alloc2, alloc3, alloc4;</span><br><span class="line">        alloc1 = new byte[2 * _1MB];</span><br><span class="line">        alloc2 = new byte[2 * _1MB];</span><br><span class="line">        alloc3 = new byte[2 * _1MB];</span><br><span class="line">        alloc4 = new byte[4 * _1MB];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        testAllocation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">GC日志：</span><br><span class="line">[GC (Allocation Failure) [DefNew: 7223K-&gt;685K(9216K), 0.0125141 secs] 7223K-&gt;4781K(19456K), 0.0125503 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] </span><br><span class="line">Heap</span><br><span class="line"> def new generation   total 9216K, used 7071K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000)</span><br><span class="line">  eden space 8192K,  77% used [0x00000007bec00000, 0x00000007bf23c948, 0x00000007bf400000)</span><br><span class="line">  from space 1024K,  66% used [0x00000007bf500000, 0x00000007bf5ab658, 0x00000007bf600000)</span><br><span class="line">Disconnected from the target VM, address: &#x27;127.0.0.1:58261&#x27;, transport: &#x27;socket&#x27;</span><br><span class="line">  to   space 1024K,   0% used [0x00000007bf400000, 0x00000007bf400000, 0x00000007bf500000)</span><br><span class="line"> tenured generation   total 10240K, used 4096K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000)</span><br><span class="line">   the space 10240K,  40% used [0x00000007bf600000, 0x00000007bfa00020, 0x00000007bfa00200, 0x00000007c0000000)</span><br><span class="line"> Metaspace       used 2989K, capacity 4568K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 318K, capacity 392K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>
<p>新生代可用的空间：9M &#x3D; 8M(Eden 空间容量) + 1M(一个 Survivor 空间的容量)<br>老年代可用的空间：10M<br>分配完 alloc1、alloc2、alloc3 之后，无法再分配 alloc4，会发生分配失败，则需要进行一次 Minor GC，survivor to 区域的容量为 1M，无法容纳总量为 6M 的三个对象，则会通过担保机制将 alloc1、allo2 转移到老年代，然后再将 alloc4 分配在 Eden 区。</p>
<h4 id="大对象直接进入-Tenured-区"><a href="#大对象直接进入-Tenured-区" class="headerlink" title="大对象直接进入 Tenured 区"></a>大对象直接进入 Tenured 区</h4><p>大对象需要大块连续内存空间，大对象的出现容易提前触发 GC 以获取更大的连续空间来供分配大对象，可以设置<code>-XX:PretenureSizeThreshold</code>的值来控制多大的对象直接分配到 Tenured 区，默认是 0，即所有对象不管多大都先在 Eden 区中分配空间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * -Xms20M -Xmx20M -Xmn10M</span><br><span class="line"> * -XX:SurvivorRatio=8</span><br><span class="line"> * -XX:+PrintGCDetails</span><br><span class="line"> * -XX:+UseSerialGC</span><br><span class="line"> * -XX:PretenureSizeThreshold=3145728</span><br><span class="line"> */</span><br><span class="line">public class AllocBigObjectTest &#123;</span><br><span class="line">    private static final int _1MB = 1024 * 1024;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        byte[] alloc = new byte[5 * _1MB];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Heap</span><br><span class="line"> def new generation   total 9216K, used 1180K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000)</span><br><span class="line">  eden space 8192K,  14% used [0x00000007bec00000, 0x00000007bed27010, 0x00000007bf400000)</span><br><span class="line">  from space 1024K,   0% used [0x00000007bf400000, 0x00000007bf400000, 0x00000007bf500000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000007bf500000, 0x00000007bf500000, 0x00000007bf600000)</span><br><span class="line"> tenured generation   total 10240K, used 5120K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000)</span><br><span class="line">   the space 10240K,  50% used [0x00000007bf600000, 0x00000007bfb00010, 0x00000007bfb00200, 0x00000007c0000000)</span><br><span class="line"> Metaspace       used 2662K, capacity 4486K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 287K, capacity 386K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>
<p>因为设置了<code>-XX:PretenureSizeThreshold=3145728</code>控制大小超过 3M 的对象直接进入 Tenured 区，可以看到 5M 的对象直接被分配到了 Tenured 区。</p>
<h4 id="长期存活的对象进入-Tenured-区"><a href="#长期存活的对象进入-Tenured-区" class="headerlink" title="长期存活的对象进入 Tenured 区"></a>长期存活的对象进入 Tenured 区</h4><p>每个对象有一个对象年龄计数器，与前面的对象的存储布局中的 GC 分代年龄对应。对象出生在 Eden 区、经过一次 Minor GC 后仍然存活，并能够被 Survivor 容纳，则设置年龄为 1，对象在 Survivor 区每次经过一次 Minor GC，年龄就加 1，当年龄达到阈值（默认 15），就晋升到老年代，虚拟机提供了<code>-XX:MaxTenuringThreshold</code>来进行设置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * -Xms20M -Xmx20M -Xmn10M </span><br><span class="line"> * -XX:SurvivorRatio=8 </span><br><span class="line"> * -XX:+PrintGCDetails</span><br><span class="line"> * -XX:+UseSerialGC</span><br><span class="line"> * -XX:MaxTenuringThreshold=1</span><br><span class="line"> * -XX:+PrintTenuringDistribution</span><br><span class="line"> */</span><br><span class="line">public class AllocLongTimeTest &#123;</span><br><span class="line">    private static final int _1MB = 1024 * 1024;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        byte[] alloc1, alloc2, alloc3;</span><br><span class="line">        alloc1 = new byte[_1MB / 4];</span><br><span class="line">        alloc2 = new byte[4 * _1MB];</span><br><span class="line">        alloc3 = new byte[4 * _1MB];</span><br><span class="line">        alloc3 = null;</span><br><span class="line">        alloc3 = new byte[4 * _1MB];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[GC (Allocation Failure) [DefNew</span><br><span class="line">Desired survivor size 524288 bytes, new threshold 1 (max 1)</span><br><span class="line">- age   1:     964208 bytes,     964208 total</span><br><span class="line">: 7479K-&gt;941K(9216K), 0.0063212 secs] 7479K-&gt;5037K(19456K), 0.0063540 secs] [Times: user=0.00 sys=0.01, real=0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [DefNew</span><br><span class="line">Desired survivor size 524288 bytes, new threshold 1 (max 1)</span><br><span class="line">: 5037K-&gt;0K(9216K), 0.0014434 secs] 9133K-&gt;4814K(19456K), 0.0014629 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] </span><br><span class="line">Heap</span><br><span class="line"> def new generation   total 9216K, used 4178K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000)</span><br><span class="line">  eden space 8192K,  51% used [0x00000007bec00000, 0x00000007bf014930, 0x00000007bf400000)</span><br><span class="line">  from space 1024K,   0% used [0x00000007bf400000, 0x00000007bf400000, 0x00000007bf500000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000007bf500000, 0x00000007bf500000, 0x00000007bf600000)</span><br><span class="line"> tenured generation   total 10240K, used 4814K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000)</span><br><span class="line">   the space 10240K,  47% used [0x00000007bf600000, 0x00000007bfab3b38, 0x00000007bfab3c00, 0x00000007c0000000)</span><br><span class="line"> Metaspace       used 2988K, capacity 4568K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 318K, capacity 392K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>
<p>如 GC 日志中所示，总共发生了两次 Minor GC：</p>
<ol>
<li>第一次是在给 alloc3 分配的时候，此时 Survivor 区不能容纳 alloc2，但是可以容纳 alloc1，所以 alloc1 进入了 Survivor 区并且年龄变成 1、达到了阈值，将在下一次 GC 时晋升到老年代，而 alloc2 则通过担保机制进入了老年代；</li>
<li>第二次 GC 是在第二次给 alloc3 分配空间时，这时 alloc1 年龄+1，晋升到老年代，此时 GC 也可以清理出原来 alloc3 占据的 4MB 空间，将 alloc3 分配在 Eden 区。</li>
</ol>
<p>因此，最后的结果是 alloc1、alloc2 在老年代，alloc3 在 Eden 区。</p>
<h4 id="动态对象年龄判断"><a href="#动态对象年龄判断" class="headerlink" title="动态对象年龄判断"></a>动态对象年龄判断</h4><p>除了对象年龄自然达到<code>-XX:MaxTenuringThreshold</code>而被转移到 Tenured 区外，如果在 Survivor 区中相同年龄所有对象大小的总和大于 Survivor 区的一半，则年龄大于等于该年龄的对象也可以直接转移到 Tenured 区、而无需等年龄达到<code>-XX:MaxTenuringThreshold</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * -Xms20M -Xmx20M -Xmn10M </span><br><span class="line"> * -XX:SurvivorRatio=8 </span><br><span class="line"> * -XX:+PrintGCDetails</span><br><span class="line"> * -XX:+UseSerialGC</span><br><span class="line"> * -XX:MaxTenuringThreshold=15</span><br><span class="line"> * -XX:+PrintTenuringDistribution</span><br><span class="line"> */</span><br><span class="line">public class AllocDynamicAgeTest &#123;</span><br><span class="line">    private static final int _1MB = 1024 * 1024;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        byte[] alloc1, alloc2, alloc3, alloc4;</span><br><span class="line">        alloc1 = new byte[_1MB / 4];</span><br><span class="line">        alloc2 = new byte[_1MB / 4];</span><br><span class="line">        alloc3 = new byte[4 * _1MB];</span><br><span class="line">        alloc4 = new byte[4 * _1MB];</span><br><span class="line">        alloc4 = null;</span><br><span class="line">        alloc4 = new byte[4 * _1MB];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[GC (Allocation Failure) [DefNew</span><br><span class="line">Desired survivor size 524288 bytes, new threshold 1 (max 15)</span><br><span class="line">- age   1:    1048568 bytes,    1048568 total</span><br><span class="line">: 7735K-&gt;1023K(9216K), 0.0066947 secs] 7735K-&gt;5293K(19456K), 0.0067283 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] </span><br><span class="line">[GC (Allocation Failure) [DefNew</span><br><span class="line">Desired survivor size 524288 bytes, new threshold 15 (max 15)</span><br><span class="line">: 5120K-&gt;0K(9216K), 0.0015566 secs] 9389K-&gt;5244K(19456K), 0.0015767 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">Heap</span><br><span class="line"> def new generation   total 9216K, used 4178K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000)</span><br><span class="line">  eden space 8192K,  51% used [0x00000007bec00000, 0x00000007bf014930, 0x00000007bf400000)</span><br><span class="line">  from space 1024K,   0% used [0x00000007bf400000, 0x00000007bf400000, 0x00000007bf500000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000007bf500000, 0x00000007bf500000, 0x00000007bf600000)</span><br><span class="line"> tenured generation   total 10240K, used 5244K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000)</span><br><span class="line">   the space 10240K,  51% used [0x00000007bf600000, 0x00000007bfb1f248, 0x00000007bfb1f400, 0x00000007c0000000)</span><br><span class="line"> Metaspace       used 2986K, capacity 4568K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 318K, capacity 392K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>
<p>发生了两次 Minor GC：</p>
<ol>
<li>第一次发生在给 alloc4 分配内存时，此时 alloc1、alloc2 将会进入 Survivor 区，而 alloc3 通过担保机制将会进入老年代；</li>
<li>第二次发生在给 alloc4 分配内存时，此时，Survivor 区的 alloc1、alloc2 达到了 Survivor 区容量的一半，将会进入老年代，此时 GC 可以清理出 alloc4 原来的 4MB 空间，并将 alloc4 分配在 Eden 区。</li>
</ol>
<p>最终，alloc1、alloc2、alloc3 在老年代，alloc4 在 Eden 区。</p>
<h4 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h4><p>老年代连续空间大于新生代对象总大小、或者历次晋升的平均大小，就会执行 Minor GC，否则将进行 Full GC。GC 期间，如果 Survivor 区空闲空间小于存活对象，则需要老年代进行分配担保，把 Survivor 区无法容纳的对象直接转移到老年代。<br>例子在上一节中已经给出，这里不再赘述。</p>
<h2 id="HotSpot-GC-实现方式"><a href="#HotSpot-GC-实现方式" class="headerlink" title="HotSpot GC 实现方式"></a>HotSpot GC 实现方式</h2><h3 id="计算所需空间大小"><a href="#计算所需空间大小" class="headerlink" title="计算所需空间大小"></a>计算所需空间大小</h3><p><code>ConcurrentMarkSweepGeneration::compute_new_size()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ConcurrentMarkSweepGeneration::compute_new_size() &#123;</span><br><span class="line">  assert_locked_or_safepoint(Heap_lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If incremental collection failed, we just want to expand</span></span><br><span class="line">  <span class="comment">// to the limit.</span></span><br><span class="line">  <span class="keyword">if</span> (incremental_collection_failed()) &#123;</span><br><span class="line">    clear_incremental_collection_failed();</span><br><span class="line">    grow_to_reserved();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The heap has been compacted but not reset yet.</span></span><br><span class="line">  <span class="comment">// Any metric such as free() or used() will be incorrect.</span></span><br><span class="line"></span><br><span class="line">  CardGeneration::compute_new_size();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Reset again after a possible resizing</span></span><br><span class="line">  <span class="keyword">if</span> (did_compact()) &#123;</span><br><span class="line">    cmsSpace()-&gt;reset_after_compaction();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对垃圾回收算法的改进"><a href="#对垃圾回收算法的改进" class="headerlink" title="对垃圾回收算法的改进"></a>对垃圾回收算法的改进</h3><h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>两个区域 A 和 B，初始对象在 A，继续存活的对象被转移到 B。<br>这两个区域并不需要根据 1:1 划分内存空间，而是将内存划分为一块较大的 Eden Space 和两块较小的 Survivor Space，在 HotSpot 中默认大小比例为 8:1。<br>当执行年轻代回收时会将 Eden 区存活的对象复制到一个空闲的 Survivor，下一次 GC 时将 Eden 区和这个 Survivor 区存活的对象复制到另一个 Survivor 区，因此总是会有一块 Survivor 区是空闲的。<br>当 Survivor 空间不够用的时候，需要依赖于老年代的空间担保。</p>
<h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>一块区域，标记可达对象（可达性分析），然后回收不可达对象，这会引入碎片，因此在空间碎片过多导致无法继续分配时往往会执行一次整理来压缩空间。</p>
<h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p>相对标记清理算法来说多了碎片整理的过程，可以整理出更大的内存放更大的对象。<br>复制收集算法在对象存活率较高时就要执行较多的复制操作，效率将会变低。更关键的是，如果不想浪费 50%的空间，就需要有额外的空间进行<strong>分配担保</strong>，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。<br>根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存（有点 copy 的意思，但是比 copy 省空间。比清理好的一点是没有碎片）。</p>
<h4 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h4><p>新生代：初始对象，生命周期短的<br>永久代：长时间存在的对象<br>整个 java 的垃圾回收是新生代和年老代的协作，这种叫做分代回收。 </p>
<p>在大的分代回收的思想下面，不同的代区可以选择不同的收集器，而不同的收集器在不同的代区又会用到不同的算法。</p>
<h3 id="方法区回收策略"><a href="#方法区回收策略" class="headerlink" title="方法区回收策略"></a>方法区回收策略</h3><p>方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。<br>Java 虚拟机规范对方法区的限制非常宽松，除了和 Java 堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。<br>方法区的垃圾回收主要回收两部分内容：</p>
<ol>
<li>从常量池回收废弃常量。<br>如何判断废弃常量呢？以字面量回收为例，如果一个字符串“abc”已经进入常量池，但是当前系统没有任何一个 String 对象引用了叫做“abc”的字面量，那么，如果发生垃圾回收并且有必要时，“abc”就会被系统移出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。</li>
<li>卸载无用的类。既然进行垃圾回收，就需要判断哪些是废弃常量，哪些是无用的类。<br>如何判断无用的类呢？需要满足以下三个条件<ul>
<li>该类的所有实例都已经被回收，即 Java 堆中不存在该类的任何实例。</li>
<li>加载该类的 ClassLoader 已经被回收。</li>
<li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。<br>满足以上三个条件的类可以进行垃圾回收，但是并不是无用就被回收，虚拟机额外提供了一些参数供我们配置。</li>
</ul>
</li>
</ol>
<h3 id="直接内存（堆外内存）"><a href="#直接内存（堆外内存）" class="headerlink" title="直接内存（堆外内存）"></a>直接内存（堆外内存）</h3><p>直接内存并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致 OutOfMemoryError 异常出现。<br>NIO 类可以直接通过 Native 函数分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。<br>使用堆外内存时需要注意：</p>
<ul>
<li>由于垃圾收集器不涉及堆外内存，因此堆外内存何时分配何时回收都需要用户自己来定义；</li>
<li>直接内存的分配不会受到 Java 堆大小的限制，但是，既然是内存，肯定还是会受到本机总内存（包括 RAM 以及 SWAP 区或者分页文件）大小以及处理器寻址空间的限制。</li>
</ul>
<p>由 DirectMemory 导致的内存溢出，一个明显的特征是在 Heap Dump 文件中不会看见明显的异常，如果我们发现 OOM 之后 Dump 文件很小，而程序中有直接或间接使用了 NIO ，那就可以考虑检查一下是不是这方面的原因。</p>
<h2 id="JVM-垃圾收集器的演进"><a href="#JVM-垃圾收集器的演进" class="headerlink" title="JVM 垃圾收集器的演进"></a>JVM 垃圾收集器的演进</h2><p>垃圾收集器是内存回收算法的具体实现，随着 JDK 的升级我们已经有很多种垃圾收集器可供选择：</p>
<ul>
<li>JDK1.4 &amp;&amp; JDK1.5 很少用了，基本上是 Serial（Serial Old）。</li>
<li>JDK1.6 是ParNew或者Parallel(Parallel Old)。</li>
<li>JDK1.7 Parallel、Parallel Old。</li>
<li>JDK1.8 Parallel Scavenge（新生代）、Parallel Old（老年代） 配合 CMS。</li>
<li>JDK1.9+ G1出现，且为默认收集器</li>
</ul>
<h2 id="在Java中如何配置垃圾收集器"><a href="#在Java中如何配置垃圾收集器" class="headerlink" title="在Java中如何配置垃圾收集器"></a>在Java中如何配置垃圾收集器</h2><h3 id="如何知道-JVM-进程当前使用的是哪种垃圾收集器？"><a href="#如何知道-JVM-进程当前使用的是哪种垃圾收集器？" class="headerlink" title="如何知道 JVM 进程当前使用的是哪种垃圾收集器？"></a>如何知道 JVM 进程当前使用的是哪种垃圾收集器？</h3><ol>
<li>java -XX:+PrintCommandLineFlags<br>打印启动时参数，根据启动时参数可以推断 JVM 进程使用的是什么垃圾收集器，但是这并不准确。</li>
<li>jmap <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -heap &lt;PID&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="垃圾统计配置"><a href="#垃圾统计配置" class="headerlink" title="垃圾统计配置"></a>垃圾统计配置</h3><ul>
<li>-XX:+PrintGC</li>
<li>-XX:+PrintGCDetails</li>
<li>-XX:+PrintGCTimeStamps：可与上面参数一起使用</li>
<li>-XX:+PrintGCApplicationConcurrentTime：打印每次垃圾回收前，程序未中断的执行时间，可与上面参数一起使用</li>
<li>-XX:+PrintGCApplicationStoppedTime：打印垃圾回收期间程序暂停的时间，可与上面参数一起使用</li>
<li>-XX:PrintHeapAtGC：打印 GC 前后的详细堆栈信息</li>
<li>-Xloggc:filename：与上面几个配合使用，把日志信息记录到文件来分析</li>
</ul>
<h3 id="使用什么垃圾回收器"><a href="#使用什么垃圾回收器" class="headerlink" title="使用什么垃圾回收器"></a>使用什么垃圾回收器</h3><ul>
<li>-XX:+UseG1GC 在整个 Java 堆使用 G1 进行垃圾回收</li>
<li>-XX:+UseConcMarkSweepGC 设定新生代使用 ParNew（并发复制）收集器，老年代使用 CMS Concurrent Mark-Sweep（并发标记清除）收集器执行内存回收</li>
<li>-XX:+UseParallelOldGC 手动指定新生代使用 Parallel Scavenge（并行复制）收集器，老年代使用 Parallel Old（并行标记-压缩）收集器执行内存回收</li>
<li>-XX:+UseSerialGC 手动指定新生代使用 Serial Coping（串行复制）收集器，老年代使用 Serial Old （串行标记-清理-压缩）收集器执行内存回收</li>
<li>-XX:+UseParNewGC 手动指定新生代使用 ParNew（并发复制）收集器，老年代使用 Serial Old （串行标记-清理-压缩）收集器执行内存回收</li>
<li>-XX:+UseParallelGC 手动指定新生代使用 Parallel Scavenge（并行复制）收集器，老年代使用 Serial Old （串行标记-清理-压缩）收集器执行内存回收</li>
</ul>
<h2 id="Serial-Serial-Old-收集器"><a href="#Serial-Serial-Old-收集器" class="headerlink" title="Serial &#x2F; Serial Old 收集器"></a>Serial &#x2F; Serial Old 收集器</h2><p>Serial（串行）收集器是最基本、发展历史最悠久的串行收集器，JDK 1.5 之前默认都是此收集器，因为那时候 CPU 都是单核的。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul>
<li>-XX:+UseSerialGC<br>这个配置指定年轻代为 Serial，同时会指定老年代采用 Serial Old。</li>
</ul>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p><img src="/imgs/JVM/Serial%EF%BC%88SerialOld%EF%BC%89%E6%94%B6%E9%9B%86%E5%99%A8%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B.png" alt="Serial（SerialOld）收集器工作过程" title="Serial（SerialOld）收集器工作过程"></p>
<ul>
<li>单线程阻塞队列。</li>
<li>年轻代采用复制算法，老年代采用标记整理算法，作用于老年代时称作 Serial Old 收集器。</li>
</ul>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>简单而高效（与其他收集器的单线程相比），对于限定单个 CPU 的环境来说，Serial 收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得更高的单线程收集效率。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>它是一个单线程收集器，只会使用一个 CPU 或一条收集线程去完成垃圾收集工作，无法有效利用多核 CPU；</li>
<li>它在进行垃圾收集时，必须暂停其他所有的工作线程，直至 Serial 收集器收集结束为止（<strong>Stop The World</strong>）。</li>
</ul>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li>HotSpot 虚拟机运行在 Client 模式下的默认的新生代收集器。</li>
<li>单 CPU 虚拟机里面。</li>
<li>JDK 1.3.1 之前，是虚拟机新生代收集的唯一选择。JDK 1.5.0 之前老年代的唯一选择。</li>
<li>内存比较小的情况下，效率还是很高的。</li>
</ul>
<h2 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h2><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><ul>
<li>-XX:+UseParNewGC<br>如果使用此配置默认年轻代，老年代采用 Serial Old。</li>
<li>-XX:ParallerGCThreads&#x3D;3<br>ParNew 默认开启的收集线程数与 CPU 的数量相同，在 CPU 非常多的情况下可使用 -XX:ParallerGCThreads 参数设置。</li>
</ul>
<h3 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h3><p><img src="/imgs/JVM/ParNew%E6%94%B6%E9%9B%86%E5%99%A8%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B.png" alt="ParNew收集器工作过程" title="ParNew收集器工作过程"><br>ParNew 收集器就是 Serial 收集器的多线程版本（即并发模式），除了使用多线程进行垃圾收集外，其余行为包括 Serial 收集器可用的所有控制参数、收集算法（复制算法）、Stop The World、对象分配规则、回收策略等与 Serial 收集器完全相同，两者共用了相当多的代码。</p>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul>
<li>多 CPU 环境下 GC 时更有效利用系统资源，是 Server 模式下虚拟机的首选新生收集器。</li>
<li>可以与 CMS 搭配使用。</li>
</ul>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>只能用于新生代。</li>
<li>ParNew 收集器在单 CPU 的环境中绝对不会有比 Serial 收集器有更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个 CPU 的环境中都不能百分之百地保证可以超越。</li>
</ul>
<h2 id="Parallel-Scavenge-并行收集器"><a href="#Parallel-Scavenge-并行收集器" class="headerlink" title="Parallel Scavenge 并行收集器"></a>Parallel Scavenge 并行收集器</h2><h3 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h3><ul>
<li>-XX:+UseParallelGC</li>
<li>-XX:+UseParallelOldGC</li>
<li>-XX:+UseAdaptiveSizePolicy<br>这是一个动态调整各个代区的内存大小的开关参数，打开参数后，就不需要手工指定新生代的大小（-Xmn）、Eden 和 Survivor 区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种方式称为 <strong>GC 自适应调节策略（GC Ergonomics）</strong>。</li>
<li>-XX:ParallelGCThreads&#x3D;n<br>并行 GC 线程数。</li>
<li>-XX:MaxGCpauseMillis&#x3D;5<br>默认 GC 最大停留时间。</li>
<li>-xx:GCTimeRatio<br>GC 占用总时间的最大比率。</li>
</ul>
<h3 id="实现原理-2"><a href="#实现原理-2" class="headerlink" title="实现原理"></a>实现原理</h3><p><img src="/imgs/JVM/ParallelScavenge%EF%BC%88ParallelOld%EF%BC%89%E6%94%B6%E9%9B%86%E5%99%A8%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B.png" alt="ParallelScavenge（ParallelOld）收集器工作过程" title="ParallelScavenge（ParallelOld）收集器工作过程"></p>
<ul>
<li>并行</li>
<li>可控的吞吐量<blockquote>
<p>吞吐量（Throughput），即 CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值，即“吞吐量 &#x3D; 运行用户代码时间 &#x2F;（运行用户代码时间 + 垃圾收集时间）”。<br>假设虚拟机总共运行了 100 分钟，其中垃圾收集花掉 1 分钟，那吞吐量就是 99%。</p>
</blockquote>
</li>
<li>自适应调节策略</li>
</ul>
<h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><ul>
<li>可以调整吞吐量，减少停顿时间，从而提升用户体验<br>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</li>
</ul>
<h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><p>Parallel Scavenge 收集器无法与 CMS 收集器配合使用。</p>
<h2 id="并发标记清理（Concurrent-Mark-Sweep，CMS）收集器"><a href="#并发标记清理（Concurrent-Mark-Sweep，CMS）收集器" class="headerlink" title="并发标记清理（Concurrent Mark-Sweep，CMS）收集器"></a>并发标记清理（Concurrent Mark-Sweep，CMS）收集器</h2><h3 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h3><ul>
<li>-XX:+UseConcMarkSweepGC，使用 CMS 收集器；</li>
<li>-XX:CMSInitiatingOccupancyFraction&#x3D;80<br>当老年代的使用率达到80%时，就会触发一次 CMS GC</li>
<li>-XX:+UseCMSCompactAtFullCollection<br>Full GC 后，进行一次碎片整理，整理过程是独占的，会引起停顿时间变长。</li>
<li>-XX:+CMSFullGCsBeforeCompaction<br>设置进行几次 Full GC 后，进行一次碎片整理。</li>
<li>-XX:ParallelCMSThreads，设定 CMS 的线程数量（一般情况约等于可用 CPU 数量）。</li>
</ul>
<h3 id="实现原理-3"><a href="#实现原理-3" class="headerlink" title="实现原理"></a>实现原理</h3><p>CMS 收集器运行过程中各步骤所涉及的并发和所需的停顿时间如下图所示：<br><img src="/imgs/JVM/CMS%E6%94%B6%E9%9B%86%E5%99%A8%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B.png" alt="CMS收集器工作过程" title="CMS收集器工作过程"><br>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。<br>顾名思义，CMS 采用标记清除算法，它的工作流程分为以下 6 个步骤：</p>
<ol>
<li>初始标记（CMS initial mark）：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要<strong>Stop The World（stw）</strong>。<br><img src="/imgs/JVM/CMS-InitialMark.png" alt="CMS-InitialMark" title="CMS-InitialMark"></li>
<li>并发标记（CMS concurrent mark）：进行 GC Roots Tracing 的过程，在整个过程中耗时最长。<br><img src="/imgs/JVM/CMS-ConcurrentMark.png" alt="CMS-ConcurrentMark" title="CMS-ConcurrentMark"><br>根据上个阶段找到的 GC Roots 遍历查找，并不是上一阶段存活的对象都会被标记，因为在标记期间用户的程序可能会改变一些引用，如上图所示。</li>
<li>并发预清理（CMS Concurrent Preclean）：并发过程，标记并发执行过程中的脏区域（Card）。<br><img src="/imgs/JVM/CMS-ConcurrentPreclean.png" alt="CMS-ConcurrentPreclean" title="CMS-ConcurrentPreclean"><br>如上图所示，在并发运行过程中（包括上一阶段），一些对象的引用可能会发生变化，预清理过程将包含这个对象的区域（Card）标记为 Dirty，这也就是<strong>Card Marking</strong>。<br>然后，由这些脏可达的对象也会被重新标记：<br><img src="/imgs/JVM/CMS-ConcurrentPreclean-Mark.png" alt="CMS-ConcurrentPreclean-Mark" title="CMS-ConcurrentPreclean-Mark"></li>
<li>可中断预清理（CMS Concurrent Abortable Preclean）：这也是一个并发阶段，这个阶段的主要目的是尽量承担最终标记阶段的工作。<br>因为重新标记阶段阶段需要全堆扫描，此时如果先进行了MinorGC则可以大大较少需要扫描的对象数量，因此Abortable Preclean阶段的目的就是等一段时间，看看能不能在重新标记前执行一次MinorGC。<br>为什么重新标记阶段需要做全堆扫描？因为判断对象是否可达需要使用根搜索算法，而只有MinorGC时才会使用根搜索算法，否则CMS也不知道之前的并发阶段是否产生了新的不可达对象。</li>
<li>重新标记（CMS remark）：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。此阶段也需要<strong>Stop The World</strong>。<br><img src="/imgs/JVM/CMS-Remark.png" alt="CMS-Remark" title="CMS-Remark"><br>通常 Remark 阶段会在年轻代尽可能干净的时候运行，目的是为了减少连续 STW 发生的可能性。</li>
<li>并发清除（CMS concurrent sweep）：清除不再使用的对象。<br><img src="/imgs/JVM/CMS-ConcurrentSweep.png" alt="CMS-ConcurrentSweep" title="CMS-ConcurrentSweep"></li>
</ol>
<p>下面以一个真实环境中的FullGC日志为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">2020-08-20T04:37:36.159+0800: 638682.623: [GC (CMS Initial Mark) [1 CMS-initial-mark: 1930043K(2097152K)] 2000027K(4793536K), 0.2664430 secs] [Times: user=0.11 sys=0.02, real=0.26 secs]</span><br><span class="line">2020-08-20T04:37:36.426+0800: 638682.890: [CMS-concurrent-mark-start]</span><br><span class="line">2020-08-20T04:37:42.956+0800: 638689.420: [CMS-concurrent-mark: 6.513/6.529 secs] [Times: user=2.11 sys=0.40, real=6.53 secs]</span><br><span class="line">2020-08-20T04:37:42.956+0800: 638689.420: [CMS-concurrent-preclean-start]</span><br><span class="line">2020-08-20T04:37:42.982+0800: 638689.445: [CMS-concurrent-preclean: 0.024/0.026 secs] [Times: user=0.03 sys=0.01, real=0.03 secs]</span><br><span class="line">2020-08-20T04:37:42.982+0800: 638689.446: [CMS-concurrent-abortable-preclean-start]</span><br><span class="line"> CMS: abort preclean due to time 2020-08-20T04:37:48.340+0800: 638694.804: [CMS-concurrent-abortable-preclean: 5.356/5.358 secs] [Times: user=6.26 sys=0.24, real=5.36 secs]</span><br><span class="line">2020-08-20T04:37:48.344+0800: 638694.807: [GC (CMS Final Remark) [YG occupancy: 571811 K (2696384 K)]2020-08-20T04:37:48.344+0800: 638694.808: [Rescan (parallel) , 0.0743374 secs]2020-08-20T04:37:48.418+0800: 638694.882: [weak refs processing, 0.0004330 secs]2020-08-20T04:37:48.419+0800: 638694.882: [class unloading, 3.9423498 secs]2020-08-20T04:37:52.361+0800: 638698.825: [scrub symbol table, 0.5589452 secs]2020-08-20T04:37:52.920+0800: 638699.384: [scrub string table, 0.0015701 secs][1 CMS-remark: 1930043K(2097152K)] 2501855K(4793536K), 4.5824373 secs] [Times: user=0.47 sys=0.04, real=4.58 secs]</span><br><span class="line">2020-08-20T04:37:52.927+0800: 638699.391: [CMS-concurrent-sweep-start]</span><br><span class="line">2020-08-20T04:37:56.807+0800: 638703.271: [CMS-concurrent-sweep: 3.877/3.880 secs] [Times: user=2.69 sys=0.11, real=3.88 secs]</span><br><span class="line">2020-08-20T04:37:56.808+0800: 638703.271: [CMS-concurrent-reset-start]</span><br><span class="line">2020-08-20T04:37:56.815+0800: 638703.279: [CMS-concurrent-reset: 0.007/0.007 secs] [Times: user=0.01 sys=0.00, real=0.00 secs]</span><br></pre></td></tr></table></figure>
<p>上面的GC日志中：</p>
<ul>
<li>第 1 行、初始标记阶段，会发生<strong>STW</strong>，标记GC Root<strong>直接引用</strong>的对象，GC Root直接引用的对象不多，因此很快。<br><code>1930043K</code>：当前老年代使用的容量；<br><code>2097152K</code>：老年代可用的最大容量；<br><code>2000027K</code>：整个堆目前使用的容量；<br><code>4793536K</code>：整个堆的可用容量；<br><code>0.2664430 secs</code>：这个阶段的持续时间；<br><code>[Times: user=0.11 sys=0.02, real=0.26 secs]</code>：对应 user、system 和 real 的时间统计。</li>
<li>第 2~3 行、并发标记阶段，由第一阶段标记过的对象出发所有可达的对象都在本阶段标记。<br><code>6.513/6.529 secs</code>：这个阶段的持续时间与时钟时间；<br><code>[Times: user=2.11 sys=0.40, real=6.53 secs]</code>：时间统计，但是因为是并发执行的，并不仅仅包含 GC 线程的工作。</li>
<li>第 4~5 行、并发预清理阶段，查找前一阶段执行过程中，从新生代晋升或新分配或被更新的对象，通过并发地重新扫描这些对象，可以减少下一个 STW 重新标记阶段的工作量。<br><code>0.024/0.026 secs</code>：持续时间与时钟时间；<br><code>Times: user=0.03 sys=0.01, real=0.03 secs</code>：时间统计。</li>
<li>第 6~7 行、并发可终止的预清理阶段，这个阶段其实跟上一个阶段做的东西一样，也是为了减少下一个 STW 重新标记阶段的工作量。增加这一阶段是为了让我们可以控制这个阶段的结束时机，比如扫描多长时间（默认 5 秒）或者 Eden 区使用占比达到期望比例（默认 50%）就结束本阶段。</li>
<li>第 8 行、<code>Final Remark</code> 重新标记阶段，会发生<strong>STW</strong>，暂停所有用户线程，从 GC Root 开始重新扫描整个堆，标记存活的对象。这一阶段是为了修正并发标记期间因用户线程继续运行而导致标记产生变动的那一部分对象的标记记录。这一阶段停顿时间一般比初始标记阶段稍长，但远比并发标记时间短。需要注意的是，虽然 CMS 只回收老年代的垃圾对象，但是这个阶段依然需要扫描新生代，因为很多 GC Root 都在新生代，而这些 GC Root 指向的对象又在老年代，这称为<strong>跨代引用</strong>。<br><code>YG occupancy: 571811 K (2696384 K)</code>：年轻代当前占用量及容量；<br><code>Rescan (parallel) , 0.0743374 secs</code>：Rescan 是当应用暂停的情况下完成对所有存活对象的标记，这个阶段是并行处理的；<br><code>weak refs processing, 0.0004330 secs</code>：第 1 个子阶段，处理弱引用；<br><code>class unloading, 3.9423498 secs</code>：第 2 个子阶段，卸载不再使用的 class；<br><code>scrub symbol table, 0.5589452 secs ... scrub string table, 0.0015701 secs</code>：最后一个子阶段，清理符号表和字符表。<br><code>1 CMS-remark: 1930043K(2097152K)</code>：这一阶段之后老年代的使用量与总量；<br><code>2501855K(4793536K)</code>：这一阶段后堆的使用量与总量（包括年轻代）；<br><code>4.5824373 secs</code>：这一阶段的持续时间，也就是 STW 的时间。<br><code>[Times: user=0.47 sys=0.04, real=4.58 secs]</code>：这一阶段统计的持续时间。<br>经过这5个阶段之后，老年代所有存活的对象就都被标记过了，之后可以通过清除算法去清理老年代不再使用的对象。</li>
<li>第 9~10 行、并发清除；</li>
<li>第 11~12 行、重置，重新初始化 CMS 内部数据结构，以备下一轮 GC 使用。</li>
</ul>
<p>普通串行标记清除算法与并行标记清除算法（CMS）的比较如下图所示：<br><img src="/imgs/JVM/%E4%B8%B2%E8%A1%8C%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95%E4%B8%8E%E5%B9%B6%E8%A1%8C%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95%E4%B9%8B%E9%97%B4%E7%9A%84%E6%AF%94%E8%BE%83.png" alt="串行标记清除算法与并行标记清除算法之间的比较" title="串行标记清除算法与并行标记清除算法之间的比较"><br>如上图可知，并发标记清除算法与串行标记清除算法之间的区别主要在于，前者将标记过程分成了 3 个部分，其中占用时间最长的<code>Concurrent Mark</code>不需要<code>stw</code>。 <br>由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以从总体上来说，CMS 收集器的内存回收过程是与用户线程一起并发执行的。</p>
<h3 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h3><p>并发收集、低停顿，因此 CMS 收集器也被称为并发低停顿收集器（Concurrent Low Pause Collector）。</p>
<h3 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>对 CPU 资源非常敏感。其实，面向并发设计的程序都对 CPU 资源比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但会因为占用了一部分线程（或者说 CPU 资源）而导致应用程序变慢，总吞吐量会降低。CMS 默认启动的回收线程数是（CPU 数量+3）&#x2F;4，也就是当 CPU 在 4 个以上时，并发回收时垃圾收集线程不少于 25%的 CPU 资源，并且随着 CPU 数量的增加而下降。但是当 CPU 不足 4 个时（比如 2 个），CMS 对用户程序的影响就可能变得很大，如果本来 CPU 负载就比较大，还要分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然降低了 50%，其实也让人无法接受。</li>
<li>标记-清除算法导致的<strong>内存碎片</strong>。<br>CMS 是一款基于“标记-清除”算法实现的收集器，这意味着收集结束时会有大量空间碎片产生，可能会提前触发一次 FullGC。空间碎片过多时，将会给大对象分配带来很大麻烦，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象。<br>可能会引起<strong>Promotion Failed</strong>（空间分配担保失败），即进行Minor GC时，发现Survivor Space放不下，对象只能放到老年代，而老年代也放不下。</li>
<li>无法处理<strong>浮动垃圾（Floating Garbage）</strong>，可能出现<strong>Concurrent Mode Failure</strong>失败而导致另一次 Full GC 的产生。<br>由于 CMS 并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生。这一部分垃圾出现在标记过程之后，CMS 无法在当次收集中处理掉它们，只好留待下一次 GC 时再清理掉。这一部分垃圾就被称为“浮动垃圾”。也是由于在垃圾收集阶段用户线程还需要运行，那也就还需要预留有足够的内存空间给用户线程使用，因此 CMS 收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。</li>
</ul>
<h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li>CMS 以最短回收停顿时间为目标，非常符合那些集中在互联网站或者 B&#x2F;S 系统的服务端上的 Java 应用，这些应用都非常重视服务的响应速度，不能有明显的暂停时间。</li>
<li>当你的应用程序需要有较短的应用程序暂停，而可以接受垃圾收集器与应用程序共享应用程序时，则可以选择 CMS 垃圾收集器。</li>
<li>典型情况下，有很多长时间保持 live 状态的数据对象（一个较大的老年代）的应用程序，和运行在多处理上的应用程序，更适合使用 CMS 垃圾收集器。例如 Web 服务器。</li>
</ul>
<h2 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a>G1 收集器</h2><p>G1（Garbage-First）收集器是当今收集器技术发展最前沿的成果之一。它是一款面向服务端应用的垃圾收集器。</p>
<h3 id="使用-4"><a href="#使用-4" class="headerlink" title="使用"></a>使用</h3><p>G1 可以用于年轻代和老年代，且算法分 3 个步骤，所以配置种类比较多。<br>只作用于年轻代的配置：</p>
<ul>
<li>-XX:G1NewSizePercent<br>年轻代最小值，默认值 5%。</li>
<li>-XX:G1MaxNewSizePercent<br>年轻代最大值，默认值 60%。</li>
</ul>
<p>作用于老年代的配置：</p>
<ul>
<li>-XX:InitiatingHeapOccupancyPercent<br>当老年代大小占整个堆大小百分比达到该阈值时，会触发一次 <strong>Mixed GC</strong>。</li>
<li>-XX:+UseCMSInitiatingOccupancyOnly</li>
</ul>
<p>其他配置：</p>
<ul>
<li>-XX:MaxGCPauseMillis<br>设置 G1 收集过程目标时间，默认值 200ms。</li>
<li>-XX:G1ReservePercent<br>默认值 10%，预留的空闲空间的百分比</li>
<li>-XX:G1HeapRegionSize<br>配置 Region 块的大小，范围 1MB 到 32MB，设置后会根据最小堆 Java 堆内存划分出 2048 个 Region 块</li>
</ul>
<h3 id="实现原理-内存结构与GC算法"><a href="#实现原理-内存结构与GC算法" class="headerlink" title="实现原理 - 内存结构与GC算法"></a>实现原理 - 内存结构与GC算法</h3><p>在 G1 算法中，采用了另外一种完全不同的方式组织堆内存，堆内存被划分为多个大小相等的内存块，称为<strong>Region</strong>，每个 Region 是逻辑连续的一段内存，结构如下：<br><img src="/imgs/JVM/G1%E6%94%B6%E9%9B%86%E5%99%A8%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png" alt="G1收集器内存结构" title="G1收集器内存结构"><br>由上图可见：</p>
<ul>
<li>新生代与老年代并不是连续的，而是一些 Region 的集合；</li>
<li>为了避免全堆扫描，对其他 Region 对象的引用会被记录到一个<strong>Remembered Set</strong>中，每个 Region 都对应一个 Remembered Set，虚拟机发现程序在对 Reference 类型的数据进行写操作时，会插入一个 Write Barrier 暂时中断写操作，检查 Reference 引用的对象是否位于其他 Region 中，如果是则将其引用信息记录到该 Region 对应的 Remembered Set 中，当进行内存回收时，在 GC 根节点的枚举范围中加入 Remembered Set 即可保证即使不对全堆扫描也不会产生遗漏。</li>
<li>一些Regine被标明了H，代表<strong>Humongous</strong>，这表示这些Region存储的是巨大对象（Humongous object，H-obj），即大小大于等于Region一半的对象，对这些大对象有一些特殊的规则。</li>
</ul>
<p>堆内存中一个 Region 的大小可以通过 <code>-XX:G1HeapRegionSize</code> 参数指定，大小区间只能是 1M、2M、4M、8M、16M 和 32M，总之是 2 的幂次方，如果 <code>G1HeapRegionSize</code> 为默认值，则在堆初始化时计算 Region 的实践大小。<br>G1 可以独立管理整个堆空间，但是能够采用不同方式来处理新创建对象和已经存活了一段时间、经历过多次 GC 的老对象，以获取更好的收集效果。G1 中提供了三种模式垃圾回收模式：<strong>Young GC</strong>、<strong>Mixed GC</strong> 和 <strong>Full GC</strong>，在不同的条件下被触发。</p>
<h4 id="Young-GC"><a href="#Young-GC" class="headerlink" title="Young GC"></a>Young GC</h4><p>发生在年轻代的 GC 算法，一般对象（除了巨型对象）都是在 <strong>Eden Region</strong> 中分配内存，当所有 Eden Region 被耗尽无法申请内存时，就会触发一次 Young GC，这种触发机制和之前的 Young GC 差不多，执行完一次 Young GC，活跃对象会被拷贝到 <strong>Survivor Region</strong> 或者晋升到 <strong>Old Region</strong> 中，空闲的 Region 会被放入<strong>空闲列表</strong>中，等待下次被使用。</p>
<h4 id="Mixed-GC"><a href="#Mixed-GC" class="headerlink" title="Mixed GC"></a>Mixed GC</h4><p>当越来越多的对象晋升到老年代 Old Region 时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即 Mixed GC，该算法并不是一个 old gc，除了回收整个 Young Region，还会回收一部分的 Old Region，这里需要注意：是一部分老年代，而不是全部老年代，可以选择哪些 Old Region 进行收集，从而可以对垃圾回收的耗时时间进行控制。<br><img src="/imgs/JVM/G1%E6%94%B6%E9%9B%86%E5%99%A8%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B.png" alt="G1收集器工作过程" title="G1收集器工作过程"><br>Mixed GC 的执行过程有点类似 CMS，主要分为以下几个步骤：</p>
<ul>
<li>initial mark: 初始标记过程，整个过程需要 STW，但耗时比较短，标记了从 GC Root 可达的对象，它们能被 GC Root 直接关联到；</li>
<li>concurrent marking: 并发标记过程，整个过程 gc collector 线程与应用线程可以并行执行，标记出 GC Root 可达对象衍生出去的存活对象，并收集各个 Region 的存活对象信息；</li>
<li>remark: 最终标记过程，整个过程需要 STW，GC 线程与用户线程并行执行，耗时较短，标记出那些在并发标记过程中遗漏的、或者由于用户线程继续运行导致的标记变动，变动记录将被记录在 Remembered Set Logs 中，此阶段会把其整合到 Remembered Set 中；</li>
<li>clean up: 垃圾清除过程，与用户线程并发执行，时间用户可控，对各个 Region 的回收价值和成本进行排序，根据用户期望的 GC 时间进行回收，如果发现一个 Region 中没有存活对象，则把该 Region 加入到空闲列表中。</li>
</ul>
<h4 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h4><p>如果对象内存分配速度过快，Mixed GC 来不及回收，导致老年代被填满，就会触发一次 Full GC，G1 的 Full GC 算法就是单线程执行的 <strong>Serial Old GC</strong>，使用标记-整理算法，会导致异常长时间的暂停时间，需要进行不断的调优，尽可能的避免 Full GC。</p>
<h3 id="实现原理-并行和并发"><a href="#实现原理-并行和并发" class="headerlink" title="实现原理 - 并行和并发"></a>实现原理 - 并行和并发</h3><p>G1 使用多个 CPU 来缩短 Stop The World 停顿时间，与用户线程并发执行。</p>
<h3 id="实现原理-可预测的停顿"><a href="#实现原理-可预测的停顿" class="headerlink" title="实现原理 - 可预测的停顿"></a>实现原理 - 可预测的停顿</h3><p>G1 建立了可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。</p>
<h3 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h3><h3 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h3><h3 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h3><h2 id="各垃圾收集器之间的比较"><a href="#各垃圾收集器之间的比较" class="headerlink" title="各垃圾收集器之间的比较"></a>各垃圾收集器之间的比较</h2><p><img src="/imgs/JVM/%E5%90%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="各垃圾收集器之间的关系" title="各垃圾收集器之间的关系"></p>
<ol>
<li>CMS 与 Serial Old 是可以相互配合的</li>
<li>G1 既可以用于年轻代又可以用于老年代</li>
</ol>
<table>
<thead>
<tr>
<th>收集器</th>
<th>串行、并行or并发</th>
<th>新生代&#x2F;老年代</th>
<th>算法</th>
<th>目标</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>Serial</td>
<td>串行</td>
<td>新生代</td>
<td>复制算法</td>
<td>响应速度优先</td>
<td>单 CPU 环境下的 Client 模式</td>
</tr>
<tr>
<td>Serial Old</td>
<td>串行</td>
<td>老年代</td>
<td>标记-整理</td>
<td>响应速度优先</td>
<td>单 CPU 环境下的 Client 模式、CMS 的后备预案</td>
</tr>
<tr>
<td>ParNew</td>
<td>并行</td>
<td>新生代</td>
<td>复制算法</td>
<td>响应速度优先</td>
<td>多 CPU 环境时在 Server 模式下与 CMS 配合</td>
</tr>
<tr>
<td>Parallel Scavenge</td>
<td>并行</td>
<td>新生代</td>
<td>复制算法</td>
<td>吞吐量优先</td>
<td>在后台运算而不需要太多交互的任务</td>
</tr>
<tr>
<td>Parallel Old</td>
<td>并行</td>
<td>老年代</td>
<td>标记-整理</td>
<td>吞吐量优先</td>
<td>在后台运算而不需要太多交互的任务</td>
</tr>
<tr>
<td>CMS</td>
<td>并发</td>
<td>老年代</td>
<td>标记-清除</td>
<td>响应速度优先</td>
<td>集中在互联网站或 B&#x2F;S 系统服务端上的 Java 应用</td>
</tr>
<tr>
<td>G1</td>
<td>并发</td>
<td>both</td>
<td>标记-整理+复制算法</td>
<td>响应速度优先</td>
<td>面向服务端应用，将来替换 CMS</td>
</tr>
</tbody></table>
<h2 id="如何排查GC问题"><a href="#如何排查GC问题" class="headerlink" title="如何排查GC问题"></a>如何排查GC问题</h2><p>GC问题可能会有很多表象，比如：GC耗时增大、线程Block增多、慢查询增多、CPU负载高等。<br>为了排查根因，有几种比较有效的判断方法：</p>
<ol>
<li>先发生的事件是根因的概率更大，监控各个指标发生异常的时间点，比如如果先观察到CPU负载高，那么整个问题的影响链就有可能是：CPU负载高-&gt;慢查询增多-&gt;GC耗时增大-&gt;线程Block增多-&gt;RT上涨。</li>
<li>结合历史情况，比如之前慢查问题比较多，那么问题影响链就可能是：慢查询增多-&gt;GC耗时增大-&gt;CPU负载高-&gt;线程Block增多-&gt;RT上涨。</li>
<li>实验，比如只触发线程Block就会发生问题，那么问题很有可能就是线程Block引起的。</li>
<li>反证，比如发现其他节点CPU和慢查都正常，但是还是出现了问题，那么问题很有可能和CPU和慢查无关。</li>
</ol>
<h2 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h2><h3 id="哪些对象的引用会被当作-GC-Root-呢"><a href="#哪些对象的引用会被当作-GC-Root-呢" class="headerlink" title="哪些对象的引用会被当作 GC Root 呢"></a>哪些对象的引用会被当作 GC Root 呢</h3><ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象<br>下面的变量a即为一个GC Root。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    int a = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>方法区中类静态属性（类变量）引用的对象<br>下面的b即一个GC Root。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    int b = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>方法区中常量引用的对象<br>下面的字符串”123”会被加载到方法区中的字符串常量表，也是一个GC Root。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    static final String c = &quot;123&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>本地方法栈中 JNI（native 方法）引用的对象<br>实现JNI方法时，在方法体内创建的局部变量。</li>
</ul>
<h3 id="弱引用和软引用有什么区别？"><a href="#弱引用和软引用有什么区别？" class="headerlink" title="弱引用和软引用有什么区别？"></a>弱引用和软引用有什么区别？</h3><p>强引用比较简单，虚引用很少见，容易混淆的是弱引用和软引用：</p>
<ol>
<li>弱引用<br>只要垃圾回收时弱引用对象没有任何其他强引用，则对象会被回收。</li>
<li>软引用<br>在系统将要发生溢出异常之前，将会把这些对象列进回收范围进行第二次回收，如果这次回收没有足够内存，才会抛出内存溢出异常。<blockquote>
<p>JVM 在分配空间时，若果 Heap 空间不足，就会进行相应的 GC，但是这次 GC 并不会收集软引用关联的对象，但是在 JVM 发现就算进行了一次回收后还是不足（Allocation Failure），JVM 会尝试第二次 GC，回收软引用关联的对象。</p>
</blockquote>
</li>
</ol>
<h3 id="为什么新生代采取复制算法而老年代采取标记-整理算法"><a href="#为什么新生代采取复制算法而老年代采取标记-整理算法" class="headerlink" title="为什么新生代采取复制算法而老年代采取标记-整理算法"></a>为什么新生代采取复制算法而老年代采取标记-整理算法</h3><p>这个问题等价于为什么在不同的代中使用不同的垃圾收集器。<br>主要原因来自新生代和老年代的区别，新生代新陈代谢快，采用复制算法，Survivor 区可以相对较小，不会有太大的空间浪费，并且保证了较高的效率；老年代反之。  </p>
<h3 id="为什么不用标记清除算法"><a href="#为什么不用标记清除算法" class="headerlink" title="为什么不用标记清除算法"></a>为什么不用标记清除算法</h3><p>效率低，标记和清除都需要一次线性扫描，相当于比别的算法慢一倍，而且产生大量内存碎片，内存碎片的问题也出现在 C 语言的 malloc&#x2F;free 中。  </p>
<h3 id="垃圾收集器中的并发和并行分别代表什么？"><a href="#垃圾收集器中的并发和并行分别代表什么？" class="headerlink" title="垃圾收集器中的并发和并行分别代表什么？"></a>垃圾收集器中的并发和并行分别代表什么？</h3><p>并行指各垃圾收集器线程可以同时运行，此时用户线程仍然处于等待状态。<br>并发指用户线程可以和垃圾收集器同时（可能是交替）运行，它们不在同一个CPU上执行。  </p>
<h3 id="为什么-CMS-要-3-次标记"><a href="#为什么-CMS-要-3-次标记" class="headerlink" title="为什么 CMS 要 3 次标记"></a>为什么 CMS 要 3 次标记</h3><ul>
<li>第 1 次标记（Initial Mark）：标记 GCRoot 可直达的对象，耗时短。</li>
<li>第 2 次标记（Concurrent Mark）：从上一部分标记对象出发标记引用链。<br>为什么这个阶段可以并发标记？如果新创建了一个 GC Root 引用的对象或者引用链变更了怎么办？实际上这个步骤已经能将绝大多数需要标记的对象标记上了，如果有遗漏都是在下一阶段弥补的。</li>
<li>第 3 次标记（Remark）：重新标记阶段将上一阶段执行过程中用户线程新创建的对象和引用链中新引用的对象都标记上，这个过程相对较短，因此 STW 也可以接受。</li>
</ul>
<p>从 3 次标记过程的特征可以看出，CMS 将耗时长的部分并行化了，从而保证整个 gc 过程的高性能。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a target="_blank" rel="noopener" href="https://www.open-open.com/lib/view/open1429883238291.html">Minor GC、Major GC 和 Full GC 之间的区别</a></li>
<li><a target="_blank" rel="noopener" href="https://plumbr.io/handbook/garbage-collection-algorithms-implementations#concurrent-mark-and-sweep">JAVA GARBAGE COLLECTION HANDBOOK</a><br>图解GC流程</li>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html#concurrent_mark_sweep_cms_collector">Java Platform, Standard Edition HotSpot Virtual Machine Garbage Collection Tuning Guide</a><br>oracle官网对1.8垃圾回收改进的描述。</li>
<li><a target="_blank" rel="noopener" href="https://tech.meituan.com/2017/12/29/jvm-optimize.html">从实际案例聊聊Java应用的GC优化</a></li>
<li><a target="_blank" rel="noopener" href="https://tech.meituan.com/2016/09/23/g1.html">Java Hotspot G1 GC的一些关键技术</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&mid=2653553860&idx=1&sn=f013c374f80b522161af0d203c71b6e5&chksm=8139955cb64e1c4a0de0baed91816aeca877e926267c51bb451a9c73e84cf63ae73e0ea03d31&xtrack=1&scene=90&subscene=93&sessionid=1605608687&clicktime=1605608699&enterid=1605608699&exportkey=A73suSWV7SwdfqpmLn+hH4A=&pass_ticket=IvBa8z/qFIlRT/RhjJM9EHQW0R04pv0L+GqzB6UDHf8MeI9xea3dCX678jA7jm8X&wx_header=0#rd">Java中9种常见的CMS GC问题分析与解决</a></li>
</ol>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/92a28d62.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tallate">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tallate">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/92a28d62.html" class="post-title-link" itemprop="url">SpringCloud 配置总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-09-21 13:09:11" itemprop="dateCreated datePublished" datetime="2019-09-21T13:09:11+08:00">2019-09-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-07 01:56:20" itemprop="dateModified" datetime="2025-07-07T01:56:20+08:00">2025-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%82%B9%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">技术点总结</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Spring Cloud 是一系列框架的有序集合，它利用 Spring Boot 的开发便利性简化了分布式系统的开发，比如服务发现、服务网关、服务路由、链路追踪等。Spring Cloud 并不重复造轮子，而是将市面上开发得比较好的模块集成进去，进行封装，从而减少了各模块的开发成本。换句话说：Spring Cloud 提供了构建分布式系统所需的“全家桶”。<br>Spring Cloud 常常被拿来和 Dubbo 比较，实际上 Dubbo 只实现了服务治理，接入 Dubbo 的服务能够实现自动上下线、能通过 Dubbo 协议（其实 Dubbo 还支持其他很多协议）互联，但是 Dubbo 并不提供网关、配置中心、链路追踪等一系列微服务架构常用的技术，需要单独引入。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/92a28d62.html#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/3e0c4ce6.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tallate">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tallate">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/3e0c4ce6.html" class="post-title-link" itemprop="url">Spring 总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-09-21 13:09:11" itemprop="dateCreated datePublished" datetime="2019-09-21T13:09:11+08:00">2019-09-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-07 01:56:20" itemprop="dateModified" datetime="2025-07-07T01:56:20+08:00">2025-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E7%82%B9%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">技术点总结</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>


<h1 id="Spring-如何加载注解"><a href="#Spring-如何加载注解" class="headerlink" title="Spring 如何加载注解"></a>Spring 如何加载注解</h1><p>很多注解本身只是提供了一个标识，要实现注解所表示的功能，必然还会有一个扫描器扫描这个注解，然后将必须的Bean注入到Spring容器内，而且很多时候会<strong>为被注解的对象生成一个动态代理</strong>，以实现日志记录、接口幂等、限流等功能。<br>要自己实现一个注解，关键是如何扫描及如何生成代理并注入到Spring容器这两个步骤，具体的实现可以参考<code>MapperScannerConfigurer</code>，大体逻辑是：</p>
<ol>
<li>在Spring容器加载完毕后，再对指定包下的类进行一次扫描；</li>
<li></li>
</ol>
<h1 id="Spring-三级缓存"><a href="#Spring-三级缓存" class="headerlink" title="Spring 三级缓存"></a>Spring 三级缓存</h1><h2 id="Spring-中产生循环依赖的三种情况"><a href="#Spring-中产生循环依赖的三种情况" class="headerlink" title="Spring 中产生循环依赖的三种情况"></a>Spring 中产生循环依赖的三种情况</h2><ol>
<li>构造器注入循环依赖 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class A &#123;</span><br><span class="line">    public A(B b) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@Service</span><br><span class="line">public class B &#123;</span><br><span class="line">    public B(A a) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
构造器注入构成的循环依赖，此种循环依赖方式是无法解决的，只能抛出 BeanCurrentlyInCreationException 异常表示循环依赖。<br>不能解决的原因是：Spring 解决循环依赖的原理是实例化 Bean 后先把引用存到一个 Map 中，之后初始化成员变量时，可以直接从这个 Map 中取。但是构造器注入相当于<strong>实例化和初始化是同时进行的</strong>，因此无法解决。</li>
<li>singleton 模式 field 属性注入循环依赖 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class A &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private B b;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">@Service</span><br><span class="line">public class B &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>prototype 模式 field 属性注入循环依赖 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span><br><span class="line">@Service</span><br><span class="line">public class A &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private B b;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span><br><span class="line">@Service</span><br><span class="line">public class B &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Spring-创建-Bean-的流程"><a href="#Spring-创建-Bean-的流程" class="headerlink" title="Spring 创建 Bean 的流程"></a>Spring 创建 Bean 的流程</h2><ol>
<li>createBeanInstance：实例化，其实也就是调用对象的构造方法实例化对象</li>
<li>populateBean：填充属性，这一步主要是对 bean 的依赖属性进行注入(@Autowired)</li>
<li>initializeBean：回到一些形如 initMethod、InitializingBean 等方法</li>
</ol>
<p>其中，循环依赖可能发生在第一步和第二步，其中第一步是因为构造方法中可能会需要传入其他 Bean。</p>
<h2 id="Spring-三级缓存如何解决循环依赖"><a href="#Spring-三级缓存如何解决循环依赖" class="headerlink" title="Spring 三级缓存如何解决循环依赖"></a>Spring 三级缓存如何解决循环依赖</h2><h3 id="缓存生效时间"><a href="#缓存生效时间" class="headerlink" title="缓存生效时间"></a>缓存生效时间</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class DefaultSingletonBeanRegistry extends SimpleAliasRegistry implements SingletonBeanRegistry &#123;</span><br><span class="line"></span><br><span class="line">    // 用于存放完全初始化好的 bean，从该缓存中取出的 bean 可以直接使用</span><br><span class="line">	/** Cache of singleton objects: bean name --&gt; bean instance */</span><br><span class="line">	private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;String, Object&gt;(256);</span><br><span class="line"></span><br><span class="line">    // 提前曝光的单例对象的cache，存放原始的 bean 对象（尚未填充属性），用于解决循环依赖</span><br><span class="line">	/** Cache of early singleton objects: bean name --&gt; bean instance */</span><br><span class="line">	private final Map&lt;String, Object&gt; earlySingletonObjects = new HashMap&lt;String, Object&gt;(16);</span><br><span class="line">	</span><br><span class="line">	// 单例对象工厂的cache，存放 bean 工厂对象，用于解决循环依赖</span><br><span class="line">	/** Cache of singleton factories: bean name --&gt; ObjectFactory */</span><br><span class="line">    private final Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = new HashMap&lt;String, ObjectFactory&lt;?&gt;&gt;(16);</span><br></pre></td></tr></table></figure>
<h3 id="获取单例-Bean-的过程"><a href="#获取单例-Bean-的过程" class="headerlink" title="获取单例 Bean 的过程"></a>获取单例 Bean 的过程</h3><p><code>org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#getSingleton(java.lang.String)</code></p>
<ol>
<li>先从一级缓存 singletonObjects 中去获取，如果获取到就直接 return。</li>
<li>如果获取不到或者对象正在创建中（isSingletonCurrentlyInCreation()），那就再从二级缓存 earlySingletonObjects 中获取，如果获取到就直接 return。</li>
<li>如果还是获取不到，且允许 singletonFactories（allowEarlyReference&#x3D;true）通过 getObject()获取。就从三级缓存 singletonFactory.getObject()获取，如果获取到了就从 singletonFactories 中移除，并且放进 earlySingletonObjects，其实也就是从三级缓存移动到了二级缓存。</li>
</ol>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/485e1bd7.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tallate">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tallate">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/485e1bd7.html" class="post-title-link" itemprop="url">Vim 使用总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-09-14 20:09:11" itemprop="dateCreated datePublished" datetime="2019-09-14T20:09:11+08:00">2019-09-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-07 01:56:20" itemprop="dateModified" datetime="2025-07-07T01:56:20+08:00">2025-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>平时在 Linux 环境下待的久了，免不了和 Vim 打交道。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/485e1bd7.html#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/283c6d00.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tallate">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tallate">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/283c6d00.html" class="post-title-link" itemprop="url">Linux 与文件系统</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-09-14 11:34:43" itemprop="dateCreated datePublished" datetime="2019-09-14T11:34:43+08:00">2019-09-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-07 01:56:20" itemprop="dateModified" datetime="2025-07-07T01:56:20+08:00">2025-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>


<h2 id="文件系统操作"><a href="#文件系统操作" class="headerlink" title="文件系统操作"></a>文件系统操作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ls -F filename # 列出目录，使用*等符号标志文件类型，*表示可执行文件，/为目录文件</span><br><span class="line">ls -i filename # 查看文件inode号</span><br><span class="line">mkdir -p dirname # 创建目录，如果有父目录就创建父目录</span><br><span class="line">stat filename # 查看文件详细信息，包括inode号、链接数</span><br><span class="line">mv # 移动/重命名</span><br><span class="line">ln oldfile newfile # 创建硬链接</span><br><span class="line">ln -s sourcefile/sourcedir targetfile/targetdir # 创建软链接</span><br></pre></td></tr></table></figure>
<h3 id="chroot"><a href="#chroot" class="headerlink" title="chroot"></a>chroot</h3><p><a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/linux/l-cn-chroot/">chroot</a></p>
<h3 id="mount-和-umount"><a href="#mount-和-umount" class="headerlink" title="mount 和 umount"></a>mount 和 umount</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount | column -t # 查看挂载分区信息</span><br></pre></td></tr></table></figure>
<p>制作目录硬链接。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 假设当前目录下有a和b两个目录</span><br><span class="line">mount -o bind a b # b成为a的硬链接，其实就是将a挂载到了b上</span><br><span class="line">mount # 通过mount可以看出是bind这个参数起作用</span><br><span class="line">/dev/sda2 on /home/hgc/Downloads/b type ext4 (rw,relatime,errors=remount-ro,data=ordered)</span><br><span class="line"># 删除时必须先卸载再删除</span><br><span class="line">umount b</span><br><span class="line">rm -rf b</span><br></pre></td></tr></table></figure>
<h3 id="ln"><a href="#ln" class="headerlink" title="ln"></a>ln</h3><h3 id="fdisk"><a href="#fdisk" class="headerlink" title="fdisk"></a>fdisk</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l # 查看硬盘分区信息</span><br></pre></td></tr></table></figure>






<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/10/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/page/19/">19</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/12/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">tallate</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/tallate" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"version":"7.1.2","options":null,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.3.0/mermaid.min.js","integrity":"sha256-9y71g5Lz/KLsHjB8uXwnkuWDtAMDSzD/HdIbqhJfTAI="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>





  





</body>
</html>
