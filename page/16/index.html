<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"tallate.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.18.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Tallate">
<meta property="og:url" content="https://tallate.github.io/page/16/index.html">
<meta property="og:site_name" content="Tallate">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="tallate">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://tallate.github.io/page/16/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/16/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Tallate</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Tallate</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">该吃吃该喝喝 啥事别往心里搁</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签<span class="badge">80</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="th fa-fw"></i>分类<span class="badge">25</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档<span class="badge">186</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">tallate</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">186</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">80</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/b10d1916.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tallate">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tallate">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/b10d1916.html" class="post-title-link" itemprop="url">Linux 环境常用命令</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-07-21 22:18:28" itemprop="dateCreated datePublished" datetime="2019-07-21T22:18:28+08:00">2019-07-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-07 01:56:20" itemprop="dateModified" datetime="2025-07-07T01:56:20+08:00">2025-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>Linux 命令尤其多，没办法一下子全部搞明白，下面来不及看的部分我就用 TODO 标出了。</p>
</blockquote>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/b10d1916.html#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/72161861.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tallate">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tallate">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/72161861.html" class="post-title-link" itemprop="url">Eureka原理分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-07-21 20:27:43" itemprop="dateCreated datePublished" datetime="2019-07-21T20:27:43+08:00">2019-07-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-07 01:56:20" itemprop="dateModified" datetime="2025-07-07T01:56:20+08:00">2025-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">分布式系统</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Eureka-的目标"><a href="#Eureka-的目标" class="headerlink" title="Eureka 的目标"></a>Eureka 的目标</h2><p>原来：负载均衡器会根据配好的 IP 和主机名来进行负载均衡，但是对 AWS cloud 这样体量的系统来说，因为服务实例宕机恢复十分频繁，所以负载均衡器还会有一个更复杂的注册 &#x2F; 注销服务的机制。<br>现在：Eureka 在中间层提供一种负载均衡的可能。</p>
<h2 id="服务发现比较"><a href="#服务发现比较" class="headerlink" title="服务发现比较"></a>服务发现比较</h2><table>
<thead>
<tr>
<th>Feature</th>
<th>Consul</th>
<th>zookeeper</th>
<th>etcd</th>
<th>euerka</th>
</tr>
</thead>
<tbody><tr>
<td>服务健康检查</td>
<td>服务状态，内存，硬盘等</td>
<td>(弱)长连接，keepalive</td>
<td>连接心跳</td>
<td>可配支持</td>
</tr>
<tr>
<td>多数据中心</td>
<td>支持</td>
<td>—</td>
<td>—</td>
<td>—</td>
</tr>
<tr>
<td>kv存储服务</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>—</td>
</tr>
<tr>
<td>一致性</td>
<td>raft</td>
<td>paxos(zab)</td>
<td>raft</td>
<td>—</td>
</tr>
<tr>
<td>cap</td>
<td>ca</td>
<td>cp</td>
<td>cp</td>
<td>ap</td>
</tr>
<tr>
<td>使用接口(多语言能力)</td>
<td>支持http和dns</td>
<td>客户端</td>
<td>http&#x2F;grpc</td>
<td>http（sidecar）</td>
</tr>
<tr>
<td>watch支持</td>
<td>全量&#x2F;支持long polling</td>
<td>支持</td>
<td>支持 long polling</td>
<td>支持 long polling&#x2F;大部分增量</td>
</tr>
<tr>
<td>自身监控</td>
<td>metrics</td>
<td>—</td>
<td>metrics</td>
<td>metrics</td>
</tr>
<tr>
<td>安全</td>
<td>acl &#x2F;https</td>
<td>acl</td>
<td>https支持（弱）</td>
<td>—</td>
</tr>
<tr>
<td>spring cloud集成</td>
<td>已支持</td>
<td>已支持</td>
<td>已支持</td>
<td>已支持</td>
</tr>
</tbody></table>
<h2 id="纵向（功能）比较"><a href="#纵向（功能）比较" class="headerlink" title="纵向（功能）比较"></a>纵向（功能）比较</h2><h3 id="服务的健康检查"><a href="#服务的健康检查" class="headerlink" title="服务的健康检查"></a>服务的健康检查</h3><p>Euraka 使用时需要显式配置健康检查支持；Zookeeper,Etcd 则在失去了和服务进程的连接情况下任务不健康，而 Consul 相对更为详细点，比如内存是否已使用了90%，文件系统的空间是不是快不足了。</p>
<h3 id="多数据中心支持"><a href="#多数据中心支持" class="headerlink" title="多数据中心支持"></a>多数据中心支持</h3><p>Consul 通过 WAN 的 Gossip 协议，完成跨数据中心的同步；而且其他的产品则需要额外的开发工作来实现。</p>
<h3 id="KV-存储服务"><a href="#KV-存储服务" class="headerlink" title="KV 存储服务"></a>KV 存储服务</h3><p>除了 Eureka ,其他几款都能够对外支持 k-v 的存储服务，所以后面会讲到这几款产品追求高一致性的重要原因。而提供存储服务，也能够较好的转化为动态配置服务哦。</p>
<h3 id="产品设计中-CAP-理论的取舍（这一段感觉是瞎说的，博客下面评论产生很多争议）"><a href="#产品设计中-CAP-理论的取舍（这一段感觉是瞎说的，博客下面评论产生很多争议）" class="headerlink" title="产品设计中 CAP 理论的取舍（这一段感觉是瞎说的，博客下面评论产生很多争议）"></a>产品设计中 CAP 理论的取舍（这一段感觉是瞎说的，博客下面评论产生很多争议）</h3><p>Eureka 典型的 AP,作为分布式场景下的服务发现的产品较为合适，服务发现场景的可用性优先级较高，一致性并不是特别致命。其次 CA 类型的场景 Consul,也能提供较高的可用性，并能 k-v store 服务保证一致性。 而Zookeeper,Etcd则是CP类型 牺牲可用性，在服务发现场景并没太大优势。</p>
<h3 id="多语言能力与对外提供服务的接入协议"><a href="#多语言能力与对外提供服务的接入协议" class="headerlink" title="多语言能力与对外提供服务的接入协议"></a>多语言能力与对外提供服务的接入协议</h3><p>Zookeeper的跨语言支持较弱，其他几款支持 http11 提供接入的可能。Euraka 一般通过 sidecar的方式提供多语言客户端的接入支持。Etcd 还提供了Grpc的支持。 Consul除了标准的Rest服务api,还提供了DNS的支持。</p>
<h3 id="Watch的支持（客户端观察到服务提供者变化）"><a href="#Watch的支持（客户端观察到服务提供者变化）" class="headerlink" title="Watch的支持（客户端观察到服务提供者变化）"></a>Watch的支持（客户端观察到服务提供者变化）</h3><p>Zookeeper 支持服务器端推送变化，Eureka 2.0(正在开发中)也计划支持。 Eureka 1,Consul,Etcd则都通过长轮询的方式来实现变化的感知。</p>
<h3 id="自身集群的监控"><a href="#自身集群的监控" class="headerlink" title="自身集群的监控"></a>自身集群的监控</h3><p>除了 Zookeeper ,其他几款都默认支持 metrics，运维者可以搜集并报警这些度量信息达到监控目的。</p>
<h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>Consul,Zookeeper 支持ACL，另外 Consul,Etcd 支持安全通道https。</p>
<h3 id="Spring-Cloud的集成"><a href="#Spring-Cloud的集成" class="headerlink" title="Spring Cloud的集成"></a>Spring Cloud的集成</h3><p>目前都有相对应的 boot starter，提供了集成能力。<br>总的来看，目前Consul 自身功能，和 spring cloud 对其集成的支持都相对较为完善，而且运维的复杂度较为简单（没有详细列出讨论），Eureka 设计上比较符合场景，但还需持续的完善。</p>
<h2 id="Eureka-VS-ZooKeeper"><a href="#Eureka-VS-ZooKeeper" class="headerlink" title="Eureka VS ZooKeeper"></a>Eureka VS ZooKeeper</h2><ul>
<li>Eureka 能提供 REST 接口来动态调整配置、renewals、expiration、cancel 等；</li>
<li>Eureka 倾向于高可用，而不是 ZooKeeper 的高一致性。</li>
<li>Eureka 可以集成到应用中，ZooKeeper 只能作为一个外部组件提供服务，这会增加复杂性、增加系统崩溃的几率。</li>
</ul>
<h2 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h2><p><img src="/imgs/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Eureka%E7%BB%84%E4%BB%B6%E7%BB%93%E6%9E%84.png" alt="Eureka组件结构" title="Eureka组件结构"></p>
<ul>
<li>负载均衡：Eureka Client 提供最简单的轮询<strong>负载均衡</strong>策略，可以封装 Eureka 并根据更多的因素（流量、资源使用、异常发生频次等）来提供一种更好的弹性伸缩特性。</li>
<li>分区：每个 Region 有一个 Eureka 集群用于处理该区域服务失败的情况，各 Region 之间是不会互相通信的。</li>
<li>服务注册到 Eureka Server 后每 30 秒发送一次<strong>心跳（heartbeats）</strong>来刷新<strong>租约（lease）</strong>，如果网络出现分区或者 Eureka 宕机了，这种心跳自然会停止，如果达到了<strong>Renews threshold</strong>（即 Server 期望在每分钟中收到的心跳次数，需要考虑是否禁用服务器的自注册、Server&#x2F;Client 数量等，暂时取默认值 85%就好），Eureka Server 就会将其从服务注册表中移除。</li>
<li>服务注册信息会自动同步到整个 Eureka Server 集群，这也意味着它们是对等的 P2P 集群。</li>
<li>集成到业务服务中的 Eureka Client 可以查询服务注册信息（默认每 30 秒一次）来定位服务及进行远程调用。</li>
</ul>
<h2 id="服务状态机"><a href="#服务状态机" class="headerlink" title="服务状态机"></a>服务状态机</h2><p><img src="/imgs/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Eureka%E5%AE%9E%E4%BE%8B%E7%8A%B6%E6%80%81%E6%9C%BA.png" alt="Eureka实例状态机" title="Eureka实例状态机"></p>
<ul>
<li>STARTING：启动中的状态，应用可以在这个阶段做一些初始化工作</li>
<li>UP：可以正常进行通信；</li>
<li>DOWN：心跳停了，一般是宕机了或者网络出现了分区</li>
<li>OUT_OF_SERVICE：因为某些特殊原因无法提供服务，比如 Elasticsearch 因为没有达到最小可用分片数，或者由于蓝绿发布的需要，新版本如果发布后有问题可以直接将实例状态置为 OUT_OF_SERVICE 来达到回滚的目的。</li>
<li>UNKNOWN：WTF？</li>
</ul>
<h2 id="Client-与-Server-间的交互"><a href="#Client-与-Server-间的交互" class="headerlink" title="Client 与 Server 间的交互"></a>Client 与 Server 间的交互</h2><h3 id="Register"><a href="#Register" class="headerlink" title="Register"></a>Register</h3><p>Eureka Client 将信息注册到 Eureka Server，注册过程发生在第一次心跳时（在 30 秒后）。</p>
<h3 id="Unregister"><a href="#Unregister" class="headerlink" title="Unregister"></a>Unregister</h3><p>正常情况下，Client 必须显式调用 Unregister 来释放自己的注册信息，除非是由于”unclean termination”而导致心跳丢失超过 3 次。</p>
<h3 id="Renew"><a href="#Renew" class="headerlink" title="Renew"></a>Renew</h3><p>客户端每30秒通过发送一次心跳（heartbeats）来续约（renewal），心跳告知Eureka Server本实例仍然存活，如果Server在90秒内没有收到续约请求，它将从服务注册表中移除该实例。</p>
<h3 id="Fetch-Registry"><a href="#Fetch-Registry" class="headerlink" title="Fetch Registry"></a>Fetch Registry</h3><p>Eureka clients fetches the registry information from the server and csort_bufferhes it locally. After that, the clients use that information to find other services. This information is updated periodically (every 30 seconds) by getting the delta updates between the last fetch cycle and the current one. The delta information is held longer (for about 3 mins) in the server, hence the delta fetches may return the same instances again. The Eureka client automatically handles the duplicate information.</p>
<p>After getting the deltas, Eureka client reconciles the information with the server by comparing the instance counts returned by the server and if the information does not match for some reason, the whole registry information is fetched again. Eureka server caches the compressed payload of the deltas, whole registry and also per application as well as the uncompressed information of the same. The payload also supports both JSON&#x2F;XML formats. Eureka client gets the information in compressed JSON format using jersey apache client.</p>
<h3 id="Cancel"><a href="#Cancel" class="headerlink" title="Cancel"></a>Cancel</h3><p>Eureka client sends a cancel request to Eureka server on shutdown. This removes the instance from the server’s instance registry thereby effectively taking the instance out of traffic.</p>
<p>This is done when the Eureka client shuts down and the application should make sure to call the following during its shutdown.<br>     DiscoveryManager.getInstance().shutdownComponent()</p>
<h3 id="Time-Lag"><a href="#Time-Lag" class="headerlink" title="Time Lag"></a>Time Lag</h3><p>All operations from Eureka client may take some time to reflect in the Eureka servers and subsequently in other Eureka clients. This is because of the caching of the payload on the eureka server which is refreshed periodically to reflect new information. Eureka clients also fetch deltas periodically. Hence, it may take up to 2 mins for changes to propagate to all Eureka clients.</p>
<h3 id="Communication-mechanism"><a href="#Communication-mechanism" class="headerlink" title="Communication mechanism"></a>Communication mechanism</h3><p>Eureka Client默认使用Jersey发送基于Jackson封装的JSON数据包给Eureka Server。</p>
<h3 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h3><p>Eureka 不限制通信协议，Thrift、HTTP(S)等均可。</p>
<h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><p>Eureka Client 的高可用设计：</p>
<ul>
<li>Client 中有<strong>服务注册表的缓存</strong>，即使所有 Server 都挂掉了，Client 还是能继续工作。</li>
<li>刚开始，Eureka Client 会尝试与同一 <strong>zone</strong>（可视为同一局域网）中的 Eureka Server 交互，如果交互出现问题或同一 zone 中没有可用的 Eureka Server，则它将转向其他 zone。</li>
</ul>
<p>Eureka Server 的高可用设计：</p>
<ul>
<li>启动 Server 时<strong>从邻居节点获取注册信息</strong>，一个不行换另一个，直到获取成功，如果从邻居节点均无法获取到注册信息，则它会等待几分钟（默认 5 分钟）让 Client 注册它们的信息<br>Server 之间获取服务注册信息的机制和 Client 从 Server 获取的一样。<br>获取成功后，Server 会设置<code>Renewal Threshold</code>并开始接收 Client 的心跳；</li>
<li>保护模式：如果<code>Renews(last min)</code>（上一分钟内收到的心跳次数）达到了<code>Renews threshold</code>（Server 期望在每分钟中收到的心跳次数，一般是 3），或者过去 15 分钟内的统计数据小于<code>eureka.server.renewalPercentThreshold</code>（renews &#x2F; renews threshold 的比值，默认为 0.85，当在 15 分钟内微服务心跳数低于 85%，则 Server 会进入自我保护状态，在这种情况下 Server 不会删除注册信息），则进入<strong>保护模式</strong>，自我保护状态其实是为了防止突发网络不稳定或断电时微服务心跳数剧减，导致微服务注册信息被大量删除的情况。<br>在保护模式下，Client 可能从 Server 得到已经不可用的 IP（服务器已不存在或因某些原因无法响应），因此 Client 必须保证这种情况下的弹性高可用，比如快速地超时并重试其他服务器。</li>
<li>退出保护模式：在保护模式下，Eureka Server 会停止移除服务注册信息，直到满足如下条件中的任意之一：<ol>
<li>心跳<code>Renews</code>达到了<code>Renews threshold</code>；</li>
<li>保护模式被禁用，设置<code>eureka.server.enableSelfPreservation=false</code>。</li>
</ol>
</li>
<li>孤儿 Server：当发生网络分区，一些 Eureka Server 可能会成为<code>orphaned server</code>，一些 Client 会注册到这些 Server 上，导致一些 Client 能看到这些注册信息而其他的一些则不能。<br>当网络恢复后，Server 的 P2P 集群能正常地交互，注册信息会被自动同步到所有 Server 上。</li>
</ul>
<h2 id="异常情况"><a href="#异常情况" class="headerlink" title="异常情况"></a>异常情况</h2><p>比如在测试环境中出现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY&#x27;RE NOT. RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE.</span><br></pre></td></tr></table></figure>
<p>解决办法：</p>
<ul>
<li>在生产上可以开自注册，部署两个 server </li>
<li>在本机器上测试的时候，可以把比值调低，比如 0.49 </li>
<li>或者简单粗暴把自我保护模式关闭：eureka.server.enableSelfPreservation&#x3D;false</li>
</ul>
<h2 id="Eureka-配置"><a href="#Eureka-配置" class="headerlink" title="Eureka 配置"></a>Eureka 配置</h2><p>配置：<br><a target="_blank" rel="noopener" href="https://github.com/Netflix/eureka/wiki/Configuring-Eureka">Configuring Eureka</a><br>Eureka Server 开放的 REST 接口提供动态配置功能：<br><a target="_blank" rel="noopener" href="https://github.com/Netflix/eureka/wiki/Eureka-REST-operations">Eureka REST operations</a></p>
<h3 id="添加自定义元数据"><a href="#添加自定义元数据" class="headerlink" title="添加自定义元数据"></a>添加自定义元数据</h3><p>静态设置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eureka.metadata.mykey=myvalue</span><br></pre></td></tr></table></figure>
<p>设置后，相当于将<code>mykey:myvalue</code>添加到 eureka 的<code>metadata map</code>中。<br>动态设置：<br>需要提供一个自定义的</p>
<p>获取：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String myValue = instanceInfo.getMetadata().get(&quot;myKey&quot;);</span><br></pre></td></tr></table></figure>

<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><h3 id="原生客户端的执行过程"><a href="#原生客户端的执行过程" class="headerlink" title="原生客户端的执行过程"></a>原生客户端的执行过程</h3><p>EurekaClient</p>
<h3 id="通过-DI（依赖注入）使用-EurekaClient"><a href="#通过-DI（依赖注入）使用-EurekaClient" class="headerlink" title="通过 DI（依赖注入）使用 EurekaClient"></a>通过 DI（依赖注入）使用 EurekaClient</h3><p>ExampleEurekaGovernatedService</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>DefaultEurekaClientConfig extends EurekaClientConfig<br>EurekaServerConfig extends DefaultEurekaServerConfig<br>CloudInstanceConfig extends PropertiesInstanceConfig<br>MyDataCenterInstanceConfig extends PropertiesInstanceConfig</p>
<p>To dynamically do this, you will need to first provide your own custom implementation of the <code>EurekaInstanceConfig</code> interface. You can then overload the public Map&lt;String, String&gt; getMetadataMap() method to return a metadata map that contains the desired metadata values. See <code>PropertiesInstanceConfig</code> for an example implementation that provides the configuration based system above.</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a target="_blank" rel="noopener" href="https://github.com/Netflix/eureka">Netflix&#x2F;eureka</a></li>
</ol>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/fe9473bf.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tallate">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tallate">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/fe9473bf.html" class="post-title-link" itemprop="url">微服务中的网络相关组件</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-07-21 20:27:43" itemprop="dateCreated datePublished" datetime="2019-07-21T20:27:43+08:00">2019-07-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-07 01:56:20" itemprop="dateModified" datetime="2025-07-07T01:56:20+08:00">2025-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">分布式系统</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>

<h2 id="网关-Zuul"><a href="#网关-Zuul" class="headerlink" title="网关 - Zuul"></a>网关 - Zuul</h2><h3 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h3><p><img src="/imgs/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Zuul%E7%BB%84%E4%BB%B6%E7%BB%93%E6%9E%84.png" alt="Zuul组件结构" title="Zuul组件结构"><br>Zuul 基于 Netty 开发，使用 filters 包含了核心业务逻辑，Filter 是使用 Groovy 写的，主要是为了提供动态编译加载的能力，filters 主要包含了三类：</p>
<ul>
<li>Inbound Filters execute before routing to the origin and can be used for things like authentication, dynamic routing, rate limiting, DDoS protection, metrics and decorating the request.</li>
<li>Endpoint Filters can be used to return static responses, otherwise the built-in <code>ProxyEndpoint</code> filter will route the request to the origin.</li>
<li>Outbound Filters execute after getting the response from the origin and can be used for metrics, decorating the response to the user or adding custom headers.</li>
<li>Async<br>Filter 可以被同步执行或异步执行。<br>如果 Filter 没有做太重的工作，可以通过继承<code>HttpInboundSyncFilter</code>或<code>HttpOutboundSyncFilter</code>来实现一种同步 Filter，例子见<a target="_blank" rel="noopener" href="https://github.com/Netflix/zuul">Zuul 源码</a>中的<code>Routes.groovy</code>；<br>反之，如果需要从其他服务、缓存获取数据，或做一些复杂的计算工作，则最好继承<code>HttpInboundFilter</code>或<code>HttpOutboundFilter</code>，例子见<a target="_blank" rel="noopener" href="https://github.com/Netflix/zuul">Zuul 源码</a>中的<code>SampleServiceFilter.groovy</code>。</li>
</ul>
<h4 id="Filter属性"><a href="#Filter属性" class="headerlink" title="Filter属性"></a>Filter属性</h4><p>Type: most often defines the stage during the routing flow when the Filter will be applied (although it can be any custom string)<br>Async: define if the filter is sync or async, generally meaning do you need to make an external call or just doing work on-box<br>Execution Order: applied within the Type, defines the order of execution across multiple Filters<br>Criteria: the conditions required in order for the Filter to be executed<br>Action: the action to be executed if the Criteria is met</p>
<h4 id="其他的一些例子"><a href="#其他的一些例子" class="headerlink" title="其他的一些例子"></a>其他的一些例子</h4><p>这些例子是<a target="_blank" rel="noopener" href="https://github.com/Netflix/zuul">zuul-sample</a>中的代码。</p>
<ul>
<li>DebugRequest - look for a query param to add extra debug logging for a request</li>
<li>Healthcheck - simple static endpoint filter that returns 200, if everything is bootstrapped correctly</li>
<li>ZuulResponseFilter - add informational headers to provide extra details on routing, request execution, status and error cause</li>
<li>GZipResponseFilter - can be enabled to gzip outbound responses</li>
<li>SurgicalDebugFilter - can be enabled to route specific requests to different hosts for debugging</li>
</ul>
<h3 id="缓存请求体"><a href="#缓存请求体" class="headerlink" title="缓存请求体"></a>缓存请求体</h3><p>默认情况下 Zuul 不会缓存请求体，因为 Filter 一般用到请求头就够了，但是如果需要在 inbound 中用到请求头或在 outbound 中用到响应头，则需要明确指定 Zuul 缓存，可以重写 Filter 的<code>needsBodyBuffered()</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">boolean needsBodyBuffered(HttpResponseMessage input) &#123;</span><br><span class="line">    return true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h3><p>Zuul 支持修改暴露服务时使用的协议，使用方法见 sample 项目中的<code>SampleServerStartup</code>。</p>
<h3 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h3><p><a target="_blank" rel="noopener" href="https://github.com/Netflix/zuul/wiki/Core-Features">Core Features</a></p>
<h3 id="Push-Messaging"><a href="#Push-Messaging" class="headerlink" title="Push Messaging"></a>Push Messaging</h3><p>Push Messaging 机制可以支持从 Server 端推送消息到 Client 端，支持两种协议：<code>WebSockets</code> 和 <code>Server Sent Events (SSE)</code>。<br><a target="_blank" rel="noopener" href="https://github.com/Netflix/zuul/wiki/Push-Messaging">Push Messaging</a><br>TODO</p>
<h2 id="负载均衡-Ribbon"><a href="#负载均衡-Ribbon" class="headerlink" title="负载均衡 - Ribbon"></a>负载均衡 - Ribbon</h2><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>原生 API 如何使用见：<a target="_blank" rel="noopener" href="https://github.com/Netflix/ribbon/wiki/Getting-Started">Netflix &#x2F; ribbon - Getting Started</a><br>如果是搭配 Spring Boot，可以参考 Spring Could 文档。</p>
<h3 id="组件结构及实现"><a href="#组件结构及实现" class="headerlink" title="组件结构及实现"></a>组件结构及实现</h3><h4 id="Rule"><a href="#Rule" class="headerlink" title="Rule"></a>Rule</h4><p>a logic component to determine which server to return from a list</p>
<ul>
<li>RoundRobinRule<br>简单的轮询策略</li>
<li>AvailabilityFilteringRule<br>这个 Rule 会跳过那些疑似“电路跳闸”或并发连接数已经很高的服务器。<br>比如客户端的最后 3 次连接失败，客户端会认为该服务实例已经出现了类似“电路跳闸”的问题而导致无法提供服务，于是在接下来的 30 秒内均保持这种状态，如果之后还是连接失败，这个等待时间会指数增长（1min、2min、4min…）。</li>
<li>WeightedResponseTimeRule<br>每个 Server 会根据其平均响应时间计算出一个权重，响应时间越长、比重越小，该 Rule 选择 Server 时会根据该权重来计算概率。</li>
</ul>
<h4 id="Ping"><a href="#Ping" class="headerlink" title="Ping"></a>Ping</h4><p>a component running in background to ensure liveness of servers</p>
<h4 id="ServerList"><a href="#ServerList" class="headerlink" title="ServerList"></a>ServerList</h4><p>this can be static or dynamic. If it is dynamic (as used by <code>DynamicServerListLoadBalancer</code>), a background thread will refresh and filter the list at certain interval</p>
<ul>
<li>静态的 Server 列表<br>可以在程序里写一个静态列表，将该列表设置到<code>BaseLoadBalancer.setServerList()</code>中。</li>
<li>ConfigurationBasedServerList<br>默认的 ServerList 实现，可以通过 <code>Archaius ConfigurationManager</code>来设置 Server 列表。</li>
<li>DiscoveryEnabledNIWSServerList<br>可以通过 Eureka Client 获取服务器列表，服务器集群必须通过 VipAddress 来定义：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myClient.ribbon.NIWSServerListClassName=com.netflix.niws.loadbalancer.DiscoveryEnabledNIWSServerList </span><br><span class="line"># the server must register itself with Eureka server with VipAddress &quot;myservice&quot;</span><br><span class="line">myClient.ribbon.DeploymentContextBasedVipAddresses=myservice</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="ServerListFilter"><a href="#ServerListFilter" class="headerlink" title="ServerListFilter"></a>ServerListFilter</h4><p>ServerListFilter 是<code>DynamicServerListLoadBalancer</code>的组件，用于过滤从<code>ServerList</code>返回的服务器列表，现在有两种实现：</p>
<ul>
<li>ZoneAffinityServerListFilter<br>过滤掉不在同一个 zone 内的服务器，除非 zone 内没有可用的服务器，这个 Filter 可以通过设置如下属性来启用（假设客户端名为 myclient、客户端的属性空间为 ribbon）：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myclient.ribbon.EnableZoneAffinity=true</span><br></pre></td></tr></table></figure></li>
<li>ServerListSubsetFilter<br>可以保证客户端只能看到<code>ServerList</code>返回的全体服务器的一个固定子集，如果有服务器可用性较弱，则可以定期用新服务器替换老服务器。可以通过设置以下属性启用该Filter：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">myClient.ribbon.NIWSServerListClassName=com.netflix.niws.loadbalancer.DiscoveryEnabledNIWSServerList </span><br><span class="line"># the server must register itself with Eureka server with VipAddress &quot;myservice&quot;</span><br><span class="line">myClient.ribbon.DeploymentContextBasedVipAddresses=myservice</span><br><span class="line">myClient.ribbon.NIWSServerListFilterClassName=com.netflix.loadbalancer.ServerListSubsetFilter</span><br><span class="line"># only show client 5 servers. default is 20.</span><br><span class="line">myClient.ribbon.ServerListSubsetFilter.size=5</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>com.netflix.loadbalancer.DynamicServerListLoadBalancer#updateListOfServers<br>com.netflix.loadbalancer.ServerList#getUpdatedListOfServers<br>com.netflix.niws.loadbalancer.DiscoveryEnabledNIWSServerList#obtainServersViaDiscovery<br>TODO</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="常见实现"><a href="#常见实现" class="headerlink" title="常见实现"></a>常见实现</h3><ol>
<li><a target="_blank" rel="noopener" href="https://github.com/Netflix/zuul/blob/master/zuul-sample/src/main/java/com/netflix/zuul/sample/SampleServerStartup.java">Netflix&#x2F;zuul</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/Netflix/ribbon">Netflix&#x2F;ribbon</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/Netflix/Turbine">Netflix &#x2F; Turbine</a></li>
</ol>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/b791cedc.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tallate">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tallate">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/b791cedc.html" class="post-title-link" itemprop="url">微服务核心技术总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-07-21 20:27:43" itemprop="dateCreated datePublished" datetime="2019-07-21T20:27:43+08:00">2019-07-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-07 01:56:20" itemprop="dateModified" datetime="2025-07-07T01:56:20+08:00">2025-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">分布式系统</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>虚拟化技术将一台服务器虚拟出多个虚拟机来提供服务。<br>虚拟化技术包括计算虚拟化（服务器虚拟化）、存储虚拟化、网络虚拟化等。<br>在实际讲解虚拟化之前，我们需要先解释一下隔离技术，在隔离的基础上我们才能任意粒度、自由地分配资源。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/b791cedc.html#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/10511d14.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tallate">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tallate">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/10511d14.html" class="post-title-link" itemprop="url">Linux 脚本基础</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-07-21 10:18:28" itemprop="dateCreated datePublished" datetime="2019-07-21T10:18:28+08:00">2019-07-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-07 01:56:20" itemprop="dateModified" datetime="2025-07-07T01:56:20+08:00">2025-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>记录一些平时看到或用过的 shell 脚本技巧和代码片段。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/10511d14.html#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/9acacb00.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tallate">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tallate">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/9acacb00.html" class="post-title-link" itemprop="url">Kubernetes入门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-07-20 20:34:48" itemprop="dateCreated datePublished" datetime="2019-07-20T20:34:48+08:00">2019-07-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-07 01:56:20" itemprop="dateModified" datetime="2025-07-07T01:56:20+08:00">2025-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Docker/" itemprop="url" rel="index"><span itemprop="name">Docker</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>


<h2 id="kubectl-的安装"><a href="#kubectl-的安装" class="headerlink" title="kubectl 的安装"></a>kubectl 的安装</h2><p><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/tasks/tools/install-kubectl/#install-kubectl-on-macos">Install and Set Up kubectl</a></p>
<h2 id="kubernetes-含义"><a href="#kubernetes-含义" class="headerlink" title="kubernetes 含义"></a>kubernetes 含义</h2><h3 id="Kubernetes-Master"><a href="#Kubernetes-Master" class="headerlink" title="Kubernetes Master"></a>Kubernetes Master</h3><p>Kubernetes Master 主要负责管理集群，它会协调集群内的所有活动，包括：scheduling applications, maintaining applications’ desired state, scaling applications, and rolling out new updates。<br>Master 实际上是三个进程的集合，它们运行在集群的一个 Master Node 上，这三个进程包括：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/">kube-apiserver</a>：提供<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/overview/kubernetes-api/">REST-API</a>来操作 Kubernetes Objects，包括 pods、services、replicationcontrollers 等，并可用于控制集群状态。</li>
<li><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-controller-manager/">kube-controller-manager</a>：通过 apiserver 监听集群状态并做状态转移操作。</li>
<li><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-scheduler/">kube-scheduler</a>：scheduler 可以根据集群的拓扑结构、性能、容量等动态分配资源。</li>
</ul>
<h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>Node 是一台虚拟机或物理电脑，在集群中作为 Worker。Master 管理 Cluster，而 Node 则管理应用。<br>每个 Node 都有一个 Kubelet，是管理 Node 的媒介，且负责与 Kubernetes Master 进行交互。<br>每个 Node 还需要有工具来处理容器操作，比如 Docker 或 rkt。<br>一个生产环境的 cluster 必须由至少 3 个 Node 组成。</p>
<h4 id="kubelet"><a href="#kubelet" class="headerlink" title="kubelet"></a><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet/">kubelet</a></h4><p>节点代理，负责和 Kubernetes Master 交互：</p>
<ul>
<li>向 apiserver 注册节点</li>
<li>其他云计算指定逻辑。</li>
</ul>
<h4 id="kube-proxy"><a href="#kube-proxy" class="headerlink" title="kube-proxy"></a><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-proxy/">kube-proxy</a></h4><p>运行于每个 Node 上的一个网络代理，可以执行简单的 TCP、UDP、SCTP 流转发或提供多后端进程的负载均衡。<br>相当于在主机和 Cluster 之间创建了一个连接，让我们能直接访问 API。</p>
<h3 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/">Pod</a></h3><p>一个或多个应用容器集合的抽象，并且包含一些共享资源，包括：</p>
<ul>
<li>共享存储，如 Volumes；</li>
<li>网络连接，每个 Pod 具有 Cluster 中唯一的一个 IP 地址；</li>
<li>运行每个容器所必须的信息，比如容器镜像的版本、端口等。</li>
</ul>
<p>Pod 建模了一种“logical host”，可以同时运行多种不同的容器。<br>当 Pod 所处的 Node 挂了，<code>ReplicaSet</code>会动态地创建新 Pod 来使得 Cluster 回到原来的状态。</p>
<h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/services-networking/service/">Service</a></h3><p>Service 定义了 Pod 的逻辑集合及其访问规则，虽然每个 Pod 都有一个唯一的 IP 地址（Cluster 范围内），但是如果没有 Service 的话这些 IP 也是没法暴露到 Cluster 外的，可以通过指定 ServiceSpec 中的<code>type</code>来指定暴露服务的方式：</p>
<ul>
<li>ClusterIP (default) - Exposes the Service on an internal IP in the cluster. This type makes the Service only reachable from within the cluster.</li>
<li>NodePort - Exposes the Service on the same port of each selected Node in the cluster using NAT. Makes a Service accessible from outside the cluster using <code>&lt;NodeIP&gt;:&lt;NodePort&gt;</code>. Superset of ClusterIP.</li>
<li>LoadBalancer - Creates an external load balancer in the current cloud (if supported) and assigns a fixed, external IP to the Service. Superset of NodePort.</li>
<li>ExternalName - Exposes the Service using an arbitrary name (specified by <code>externalName</code> in the spec) by returning a CNAME record with the name. No proxy is used. This type requires v1.7 or higher of <code>kube-dns</code>.</li>
</ul>
<h3 id="Volumes"><a href="#Volumes" class="headerlink" title="Volumes"></a><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/storage/volumes/">Volumes</a></h3><h3 id="Namespaces"><a href="#Namespaces" class="headerlink" title="Namespaces"></a><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/">Namespaces</a></h3><h3 id="Deployments"><a href="#Deployments" class="headerlink" title="Deployments"></a><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/">Deployments</a></h3><p>负责创建和更新应用实例，创建 Deployment 后，Master 会持续监听并在各 Node 中调度应用实例，一旦有实例挂掉或被删掉，Deployment controller 就会用 Cluster 中另一 Node 上的实例取代之。</p>
<ul>
<li>searched for a suitable node where an instance of the application could be run (we have only 1 available node)</li>
<li>scheduled the application to run on that Node</li>
<li>configured the cluster to reschedule the instance on a new Node when needed</li>
</ul>
<h3 id="DaemonSet"><a href="#DaemonSet" class="headerlink" title="DaemonSet"></a><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/">DaemonSet</a></h3><h3 id="StatefulSets"><a href="#StatefulSets" class="headerlink" title="StatefulSets"></a><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/">StatefulSets</a></h3><h3 id="ReplicaSet"><a href="#ReplicaSet" class="headerlink" title="ReplicaSet"></a><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/">ReplicaSet</a></h3><h3 id="Jobs"><a href="#Jobs" class="headerlink" title="Jobs"></a><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/">Jobs</a></h3><h2 id="kubernetes-使用"><a href="#kubernetes-使用" class="headerlink" title="kubernetes 使用"></a>kubernetes 使用</h2><p>可以采用<code>kubectl</code>命令来和 Cluster 交互，<code>kubectl</code>最常用的操作只有如下 4 种：</p>
<ul>
<li>kubectl get - list resources</li>
<li>kubectl describe - show detailed information about a resource</li>
<li>kubectl logs - print the logs from a container in a pod</li>
<li>kubectl exec - execute a command on a container in a pod</li>
</ul>
<h3 id="创建Cluster"><a href="#创建Cluster" class="headerlink" title="创建Cluster"></a>创建Cluster</h3><p>例子中使用<code>minikube</code>创建 Cluster，然后使用<code>kubectl</code>来和创建的 Cluster 交互：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">minikube version</span><br><span class="line"># 启动一个Cluster</span><br><span class="line">minikube start</span><br><span class="line"># 查看客户端（kubectl的版本）和服务端（Kubernetes的版本）的版本</span><br><span class="line">kubectl version</span><br><span class="line"># Cluster的详细信息</span><br><span class="line">kubectl cluster-info</span><br><span class="line"># 获取Cluster内的Node列表</span><br><span class="line">kubectl get nodes</span><br></pre></td></tr></table></figure>
<ol>
<li>创建部署单元（Deployment）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 创建Deploymnet</span><br><span class="line">kubectl create deployment kubernetes-bootcamp --image=gcr.io/google-samples/kubernetes-bootcamp:v1</span><br><span class="line"># 查看Deployment</span><br><span class="line">kubectl get deployments</span><br><span class="line"></span><br><span class="line"># 查看Pod</span><br><span class="line">kubectl get pods</span><br><span class="line"># 查看Pod内Container的属性，比如使用的是什么镜像</span><br><span class="line">kubectl describe pods</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><ol>
<li>使用 proxy 访问 Service 和 Pod<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 创建proxy实例</span><br><span class="line">kubectl proxy</span><br><span class="line"># 创建proxy后可以在另一个终端调用REST API来查看Cluster信息</span><br><span class="line">curl http://localhost:8001/version</span><br><span class="line"># 查看Pod的名字</span><br><span class="line">export POD_NAME=$(kubectl get pods -o go-template --template &#x27;&#123;&#123;range .items&#125;&#125;&#123;&#123;.metadata.name&#125;&#125;&#123;&#123;&quot;\n&quot;&#125;&#125;&#123;&#123;end&#125;&#125;&#x27;)</span><br><span class="line">echo Name of the Pod: $POD_NAME</span><br><span class="line"># 可以通过proxy直接访问Pod</span><br><span class="line">curl http://localhost:8001/api/v1/namespaces/default/pods/$POD_NAME/proxy/</span><br></pre></td></tr></table></figure></li>
<li>查看日志<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 所有应用发送给STDOUT的信息都会成为Pod容器的日志</span><br><span class="line">kubectl logs $POD_NAME</span><br></pre></td></tr></table></figure></li>
<li>使用 exec 命令访问 Pod<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 查看Pod内的环境变量</span><br><span class="line">kubectl exec $POD_NAME env</span><br><span class="line"># 在Pod中一个容器内启动一个bash会话，相当于登入了该容器</span><br><span class="line">kubectl exec -ti $POD_NAME bash</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Service-1"><a href="#Service-1" class="headerlink" title="Service"></a>Service</h3><ol>
<li>创建 Service<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 查看Service</span><br><span class="line">kubectl get services</span><br><span class="line"># 创建一个新的Service并暴露端口（type=NodePort可以用于占用一个Node上的端口来暴露服务）</span><br><span class="line">kubectl expose deployment/kubernetes-bootcamp --type=&quot;NodePort&quot; --port 8080</span><br><span class="line"># 查看Service信息</span><br><span class="line">kubectl describe services/kubernetes-bootcamp</span><br></pre></td></tr></table></figure></li>
<li>Deployment 与 Service<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 8080其实是集群内的一个逻辑端口，可以通过以下命令获取Node上暴露的端口</span><br><span class="line">export NODE_PORT=$(kubectl get services/kubernetes-bootcamp -o go-template=&#x27;&#123;&#123;(index .spec.ports 0).nodePort&#125;&#125;&#x27;)</span><br><span class="line"># 然后我们可以通过curl访问Node上的端口来确认Service已经被暴露到了Cluster外</span><br><span class="line">echo NODE_PORT=$NODE_PORT</span><br><span class="line"></span><br><span class="line"># Deployment会自动为Pod创建一个label，可以通过如下命令来查看</span><br><span class="line">kubectl describe deployment</span><br><span class="line"># 通过label查看Pod列表和Service列表</span><br><span class="line">kubectl get pods -l run=kubernetes-bootcamp</span><br><span class="line">kubectl get services -l run=kubernetes-bootcamp</span><br></pre></td></tr></table></figure></li>
<li>Service 中的 Pod<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 先获取Pod的名字</span><br><span class="line">export POD_NAME=$(kubectl get pods -o go-template --template &#x27;&#123;&#123;range .items&#125;&#125;&#123;&#123;.metadata.name&#125;&#125;&#123;&#123;&quot;\n&quot;&#125;&#125;&#123;&#123;end&#125;&#125;&#x27;)</span><br><span class="line">echo Name of the Pod: $POD_NAME</span><br><span class="line"># 通过label命令可以设置一个新的label</span><br><span class="line">kubectl label pod $POD_NAME app=v1</span><br><span class="line"># 之后可以使用describe 命令来查看这些label，也可以使用label来查询Pod</span><br><span class="line">kubectl describe pods $POD_NAME</span><br><span class="line">kubectl get pods -l app=v1</span><br></pre></td></tr></table></figure></li>
<li>删除 Service<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 删除一个Service</span><br><span class="line">kubectl delete service -l run=kubernetes-bootcamp</span><br><span class="line"># 查看服务列表，该服务已经被删除</span><br><span class="line">kubectl get services</span><br><span class="line"># curl端口确认不再暴露服务</span><br><span class="line">curl $(minikube ip):$NODE_PORT</span><br><span class="line"># 我们可以在Pod中运行curl来确定应用仍运行于Pod中</span><br><span class="line">kubectl exec -ti $POD_NAME curl localhost:8080</span><br><span class="line"># 如果需要终止应用，则需要同时删除Deployment</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="app-扩展"><a href="#app-扩展" class="headerlink" title="app 扩展"></a>app 扩展</h3><p><img src="/imgs/Kubernetes/scaling.svg" alt="scaling" title="scaling"><br>上图来自<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/tutorials/kubernetes-basics/scale/scale-intro/">官网教程</a>，Scaling 即修改 Deployment 中的 Pod 数。</p>
<ol>
<li>扩展 ReplicaSet（Scale Up）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 先看下部署了几个Pod</span><br><span class="line">kubectl get deployments</span><br><span class="line"># 查看Deployment创建的ReplicaSet，ReplicaSet名的格式为[DEPLOYMENT-NAME]-[RANDOM-STRING]</span><br><span class="line">kubectl get rs</span><br><span class="line"># 将Deployment扩展为4个复制</span><br><span class="line">kubectl scale deployments/kubernetes-bootcamp --replicas=4</span><br><span class="line"># 查看Deployment及其中的Pod</span><br><span class="line">kubectl get deployments</span><br><span class="line">kubectl get pods -o wide</span><br><span class="line"># 查看Deployment的时间日志</span><br><span class="line">kubectl describe deployments/kubernetes-bootcamp</span><br></pre></td></tr></table></figure></li>
<li>Load Balancing<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 使用一个NODE_PORT环境变量来保存Node暴露的端口</span><br><span class="line">export NODE_PORT=$(kubectl get services/kubernetes-bootcamp -o go-template=&#x27;&#123;&#123;(index .spec.ports 0).nodePort&#125;&#125;&#x27;)</span><br><span class="line">echo NODE_PORT=$NODE_PORT</span><br><span class="line"># curl访问多次，会发现请求被负载均衡到了不同的Pod上</span><br><span class="line">curl $(minikube ip):$NODE_PORT</span><br></pre></td></tr></table></figure></li>
<li>缩小（Scale Down）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 再运行一次scale命令来缩小ReplicaSet</span><br><span class="line">kubectl scale deployments/kubernetes-bootcamp --replicas=2</span><br><span class="line"># 查看伸缩结果</span><br><span class="line">kubectl get deployments</span><br><span class="line">kubectl get pods -o wide</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="滚动更新（Rolling-Update）"><a href="#滚动更新（Rolling-Update）" class="headerlink" title="滚动更新（Rolling Update）"></a>滚动更新（Rolling Update）</h3><ol>
<li>更新应用版本<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 先看看Cluster里有啥</span><br><span class="line">kubectl get deployments</span><br><span class="line">kubectl get pods</span><br><span class="line"># 查看应用当前使用的镜像版本</span><br><span class="line">kubectl describe pods</span><br><span class="line"># 使用set image命令设置应用的镜像版本</span><br><span class="line">kubectl set image deployments/kubernetes-bootcamp kubernetes-bootcamp=jocatalin/kubernetes-bootcamp:v2</span><br><span class="line"># 可以通过Pod查看应用的更新过程</span><br><span class="line">kubectl get pods</span><br></pre></td></tr></table></figure></li>
<li>验证更新<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 确认应用正在运行中</span><br><span class="line">kubectl describe services/kubernetes-bootcamp</span><br><span class="line"># 用一个NODE_PORT环境变量保存Node暴露的端口，然后用curl确认暴露的服务可以使用</span><br><span class="line">export NODE_PORT=$(kubectl get services/kubernetes-bootcamp -o go-template=&#x27;&#123;&#123;(index .spec.ports 0).nodePort&#125;&#125;&#x27;)</span><br><span class="line">echo NODE_PORT=$NODE_PORT</span><br><span class="line">curl $(minikube ip):$NODE_PORT</span><br><span class="line"># 更新同样可以使用rollout status命令来确认</span><br><span class="line">kubectl rollout status deployments/kubernetes-bootcamp</span><br><span class="line"># 查看应用当前使用的镜像的版本</span><br><span class="line">kubectl describe pods</span><br></pre></td></tr></table></figure></li>
<li>回滚（Rollback）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 设置镜像进行更新，但是这个镜像的v10版本是不存在的，因此会引起更新失败</span><br><span class="line">kubectl set image deployments/kubernetes-bootcamp kubernetes-bootcamp=gcr.io/google-samples/kubernetes-bootcamp:v10</span><br><span class="line"># 查看Deployment的当前状态，会发现某些Pod运行不正常</span><br><span class="line">kubectl get deployments</span><br><span class="line"># 查看Pod状态，describe能提供更多信息</span><br><span class="line">kubectl get pods</span><br><span class="line">kubectl describe pods</span><br><span class="line"># 发现问题，可以使用rollout undo命令来回滚，rollout命令会复原deployment到上一已知状态。实际上所有更新操作都是版本化的，并且每次更新都可以回滚到之前的任意版本</span><br><span class="line">kubectl rollout undo deployments/kubernetes-bootcamp</span><br><span class="line"># 接下来再查看Pod的状态可以发现所有的Pod都已经恢复运行了</span><br><span class="line">kubectl get pods</span><br><span class="line">kubectl describe pods</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/tutorials/">Tutorials</a><br><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/tutorials/kubernetes-basics/">Learn Kubernetes Basics</a><br><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/tutorials/configuration/configure-redis-using-configmap/">Configuring Redis using a ConfigMap</a><br>使用 k8s 搭建 Redis 集群<br><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/tutorials/stateless-application/expose-external-ip-address/">Exposing an External IP Address to Access an Application in a Cluster</a><br>如何使用 k8s 搭建一个无状态服务<br><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/tutorials/stateful-application/basic-stateful-set/">StatefulSet Basics</a><br>如何使用 k8s 搭建一个有状态服务<br><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/tutorials/clusters/apparmor/">AppArmor</a><br><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/tutorials/services/source-ip/">Using Source IP</a><br><a href="linux.com/tutorials/set-cicd-pipeline-kubernetes-part-1-overview/">CICD</a><br><a target="_blank" rel="noopener" href="https://www.linux.com/tutorials/set-cicd-pipeline-jenkins-pod-kubernetes-part-2/">https://www.linux.com/tutorials/set-cicd-pipeline-jenkins-pod-kubernetes-part-2/</a><br><a target="_blank" rel="noopener" href="https://www.linux.com/tutorials/run-and-scale-distributed-crossword-puzzle-app-cicd-kubernetes-part-3/">https://www.linux.com/tutorials/run-and-scale-distributed-crossword-puzzle-app-cicd-kubernetes-part-3/</a><br><a target="_blank" rel="noopener" href="https://www.linux.com/tutorials/set-cicd-distributed-crossword-puzzle-app-kubernetes-part-4/">https://www.linux.com/tutorials/set-cicd-distributed-crossword-puzzle-app-kubernetes-part-4/</a></li>
</ol>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/59c58f8f.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tallate">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tallate">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/59c58f8f.html" class="post-title-link" itemprop="url">cut、awk 使用总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-07-20 20:34:48" itemprop="dateCreated datePublished" datetime="2019-07-20T20:34:48+08:00">2019-07-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-07 01:56:20" itemprop="dateModified" datetime="2025-07-07T01:56:20+08:00">2025-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在 awk、sed、cut 三个命令中，awk 是功能最强大的，基本能实现所有字符串操作，平时常用于较复杂的日志分析，不过比起别的命令来也会相对复杂一点。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/59c58f8f.html#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/cc86b541.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tallate">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tallate">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/cc86b541.html" class="post-title-link" itemprop="url">TCP协议总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-07-20 14:01:28" itemprop="dateCreated datePublished" datetime="2019-07-20T14:01:28+08:00">2019-07-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-07 01:56:20" itemprop="dateModified" datetime="2025-07-07T01:56:20+08:00">2025-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">网络</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>TCP是<strong>面向连接</strong>的<br><strong>所谓的建立连接，是为了在客户端和服务端维护连接，而建立一定的数据结构来维护双方交互的状态，用这样的数据结构来保证所谓的面向连接的特性</strong>。</li>
<li>TCP 提供<strong>可靠交付</strong><br>通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。</li>
<li>TCP 是<strong>面向字节流</strong><br>发送的时候发的是一个流，没头没尾。</li>
<li>拥塞控制<br>TCP意识到包丢弃了或者网络的环境不好了，就会根据情况调整自己的行为，看看是不是发快了，要不要发慢点。</li>
</ul>
<h3 id="TCP-优点"><a href="#TCP-优点" class="headerlink" title="TCP 优点"></a>TCP 优点</h3><ul>
<li>可靠，稳定<br>TCP 的可靠体现在 TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源。</li>
</ul>
<h3 id="TCP-缺点"><a href="#TCP-缺点" class="headerlink" title="TCP 缺点"></a>TCP 缺点</h3><p>慢，效率低，占用系统资源高，易被攻击<br>TCP 在传递数据之前，要先建连接，这会消耗时间，而且在数据传递时，确认机制、重传机制、拥塞控制机制等都会消耗大量的时间，而且要在每台设备上维护所有的传输连接，事实上，每个连接都会占用系统的 CPU、内存等硬件资源。 而且，因为 TCP 有确认机制、三次握手机制，这些也导致 TCP 容易被人利用，实现 DOS、DDOS、CC 等攻击。</p>
<h3 id="TCP的数据包格式"><a href="#TCP的数据包格式" class="headerlink" title="TCP的数据包格式"></a>TCP的数据包格式</h3><p><img src="/imgs/%E7%BD%91%E7%BB%9C/TCP%E6%95%B0%E6%8D%AE%E5%8C%85%E6%A0%BC%E5%BC%8F.jpg" alt="TCP数据包格式" title="TCP数据包格式"></p>
<ol>
<li>源端口号和目标端口号，用于确定数据应该发给哪个应用；</li>
<li>包序号<br>用于解决乱序问题；</li>
<li>确认序号<br>解决丢包问题，如果没有收到就重新发送，直到送达。</li>
<li>状态位<br>例如SYN是发起一个连接；<br>ACK是回复；<br>RST是重新连接；<br>FIN是结束连接。</li>
<li>窗口大小<br>TCP要做到流量控制，通信双方各声明一个窗口，标识自己当前的处理能力。</li>
</ol>
<h3 id="连接的建立-三次握手"><a href="#连接的建立-三次握手" class="headerlink" title="连接的建立 - 三次握手"></a>连接的建立 - 三次握手</h3><p><img src="/imgs/%E7%BD%91%E7%BB%9C/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.jpg" alt="TCP三次握手" title="TCP三次握手"><br>一开始，客户端和服务端都处于 CLOSED 状态。先是服务端主动监听某个端口，处于 LISTEN 状态。然后客户端主动发起连接 SYN，之后处于 SYN-SENT 状态。服务端收到发起的连接，返回 SYN，并且 ACK 客户端的 SYN，之后处于 SYN-RCVD 状态。客户端收到服务端发送的 SYN 和 ACK 之后，发送 ACK 的 ACK，之后处于 ESTABLISHED 状态，因为它一发一收成功了。服务端收到 ACK 的 ACK 之后，处于 ESTABLISHED 状态，因为它也一发一收了。<br>从连接建立的流程中可见，三次握手除了双方建立连接外，还能确定TCP包的序号问题。</p>
<p>总而言之：</p>
<ol>
<li>首先 Client 端发送连接请求报文，Server 段接受连接后回复 ACK 报文，并为这次连接分配资源。</li>
<li>Client 端接收到 ACK 报文后也向 Server 段发生 ACK 报文，并分配资源，这样 TCP 连接就建立了。<br><img src="/imgs/%E7%BD%91%E7%BB%9C/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.jpg" alt="TCP三次握手" title="TCP三次握手"><br>最初两端的 TCP 进程都处于 CLOSED 关闭状态，A（Client）主动打开连接，而 B（Server）被动打开连接。（A、B 关闭状态 CLOSED——B 创建 TCB，进入 LISTEN 状态，等待 A 请求——A 同步已发送状态 SYN-SENT——B 同步收到状态 SYN-RCVD——A、B 连接已建立状态 ESTABLISHED）</li>
<li>第一次握手：起初两端都处于 CLOSED 关闭状态，A（Client）将标志位 SYN 置为 1，随机产生一个值 seq&#x3D;x，并将该数据包发送给 B（Server），A（Client）进入 SYN-SENT 状态，等待 B（Server）确认；</li>
<li>第二次握手：B（Server）收到连接请求报文段后，如同意建立连接，则向 A（Client）发送确认，在确认报文段中（SYN&#x3D;1，ACK&#x3D;1，确认号 ack&#x3D;x+1，初始序号 seq&#x3D;y），B（Server）TCP 服务器进程进入 SYN-RCVD（同步收到）状态；</li>
<li>第三次握手：TCP 客户进程收到 B（Server）的确认后，要向 B（Server）给出确认报文段（ACK&#x3D;1，确认号 ack&#x3D;y+1，序号 seq&#x3D;x+1）（初始为 seq&#x3D;x，第二个报文段所以要+1），ACK 报文段可以携带数据，不携带数据则不消耗序号。TCP 连接已经建立，A 进入 ESTABLISHED（已建立连接）。<br>当 B 收到 A 的确认后，也进入 ESTABLISHED 状态。<blockquote>
<p><strong>TCB 传输控制块 Transmission Control Block</strong>，存储每一个连接中的重要信息，如 TCP 连接表，到发送和接收缓存的指针，到重传队列的指针，当前的发送和接收序号。</p>
</blockquote>
</li>
</ol>
<p>一些问题：</p>
<ol>
<li>为什么 A 还要发送一次确认呢？可以二次握手吗？<br>主要为了防止已失效的连接请求报文段突然又传送到了 B，因而产生错误。如 A 发出连接请求，但因连接请求报文丢失而未收到确认，于是 A 再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，A 发出了两个连接请求报文段，其中第一个丢失，第二个到达了 B，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达 B，此时 B 误认为 A 又发出一次新的连接请求，于是就向 A 发出确认报文段，同意建立连接，不采用三次握手，只要 B 发出确认，就建立新的连接了，此时 A 不理睬 B 的确认且不发送数据，则 B 一致等待 A 发送数据，浪费资源。</li>
<li>Server 端易受到 SYN 攻击？<br>服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到 SYN 洪泛攻击，SYN 攻击就是 Client 在短时间内伪造大量不存在的 IP 地址，并向 Server 不断地发送 SYN 包，Server 则回复确认包，并等待 Client 确认，由于源地址不存在，因此 Server 需要不断重发直至超时，这些伪造的 SYN 包将长时间占用未连接队列，导致正常的 SYN 请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。<br>防范 SYN 攻击措施：降低主机的等待时间使主机尽快的释放半连接的占用，短时间受到某 IP 的重复 SYN 则丢弃后续请求。</li>
</ol>
<h3 id="连接的断开-四次挥手"><a href="#连接的断开-四次挥手" class="headerlink" title="连接的断开 - 四次挥手"></a>连接的断开 - 四次挥手</h3><p><img src="/imgs/%E7%BD%91%E7%BB%9C/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.jpg" alt="TCP四次挥手" title="TCP四次挥手"><br>假设 Client 端发起中断连接请求，也就是发送 FIN 报文。Server 端接到 FIN 报文后，意思是说”我 Client 端没有数据要发给你了”，但是如果你还有数据没有发送完成，则不必急着关闭 Socket，可以继续发送数据。所以你先发送 ACK，”告诉 Client 端，你的请求我收到了，但是我还没准备好，请继续你等我的消息”。这个时候 Client 端就进入 FIN_WAIT 状态，继续等待 Server 端的 FIN 报文。当 Server 端确定数据已发送完成，则向 Client 端发送 FIN 报文，”告诉 Client 端，好了，我这边数据发完了，准备好关闭连接了”。Client 端收到 FIN 报文后，”就知道可以关闭连接了，但是他还是不相信网络，怕 Server 端不知道要关闭，所以发送 ACK 后进入 TIME_WAIT 状态，如果 Server 端没有收到 ACK 则可以重传。“，Server 端收到 ACK 后，”就知道可以断开连接了”。Client 端等待了 2MSL 后依然没有收到回复，则证明 Server 端已正常关闭，那好，我 Client 端也可以关闭连接了。Ok，TCP 连接就这样关闭了！</p>
<p>数据传输结束后，通信的双方都可释放连接，A 和 B 都处于 ESTABLISHED 状态。（A、B 连接建立状态 ESTABLISHED——A 进入等待 1 状态 FIN-WAIT-1——B 关闭等待状态 CLOSE-WAIT——A 进入等待 2 状态 FIN-WAIT-2——B 最后确认状态 LAST-ACK——A 时间等待状态 TIME-WAIT——B、A 关闭状态 CLOSED）</p>
<ol>
<li>A 的应用进程先向其 TCP 发出连接释放报文段（FIN&#x3D;1，序号 seq&#x3D;u），并停止再发送数据，主动关闭 TCP 连接，进入 FIN-WAIT-1（终止等待 1）状态，等待 B 的确认。</li>
<li>B 收到连接释放报文段后即发出确认报文段，（ACK&#x3D;1，确认号 ack&#x3D;u+1，序号 seq&#x3D;v），B 进入 CLOSE-WAIT（关闭等待）状态，此时的 TCP 处于半关闭状态，A 到 B 的连接释放。</li>
<li>A 收到 B 的确认后，进入 FIN-WAIT-2（终止等待 2）状态，等待 B 发出的连接释放报文段。</li>
<li>B 没有要向 A 发出的数据，B 发出连接释放报文段（FIN&#x3D;1，ACK&#x3D;1，序号 seq&#x3D;w，确认号 ack&#x3D;u+1），B 进入 LAST-ACK（最后确认）状态，等待 A 的确认。</li>
<li>A 收到 B 的连接释放报文段后，对此发出确认报文段（ACK&#x3D;1，seq&#x3D;u+1，ack&#x3D;w+1），A 进入 TIME-WAIT（时间等待）状态。此时 TCP 未释放掉，需要经过时间等待计时器设置的时间 2MSL 后，A 才进入 CLOSED 状态。</li>
</ol>
<p>总而言之：</p>
<ol>
<li>刚开始A发送断开连接请求，进入FIN_WAIT_1状态；</li>
<li>B接收请求进入CLOSED_WAIT状态，并发回响应；</li>
<li>A接收B响应，进入FIN_WAIT_2状态；</li>
<li>B发送断开连接请求，并进入LAST_ACK状态；</li>
<li>A接收请求，进入TIME_WAIT状态，并发回响应；<br>A会在发出响应<code>2MSL</code>后自动进入CLOSED状态。<br>MSL 是 Maximum Segment Lifetime，报文最大生存时间，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为 TCP 报文基于是 IP 协议的，而 IP 头中有一个 TTL 域，是 IP 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。协议规定 MSL 为 2 分钟，实际应用中常用的是 30 秒，1 分钟和 2 分钟等。</li>
<li>B接收响应后进入CLOSED状态。</li>
</ol>
<p>该流程中让人比较困惑的问题是：</p>
<ol>
<li>为什么A断开连接后，第4步还要B在反向发起一次断开连接？<br>不能直接断开，因为A单方面断开连接时，A不知道B是不是还有事情要处理。</li>
<li>如果第4步B没有重新发起断开连接（只有2次挥手），连接怎么断开？<br>如果这期间B宕机了没有重新发起断开连接，A将永远停留在FIN_WAIT_2的状态，TCP 协议里面并没有对这个状态的处理，但是 Linux 有，可以调整 tcp_fin_timeout 这个参数，设置一个超时时间。</li>
<li>第5步如果A响应没有返回给B，B怎么断开？<br>此时B会重新发起一次断开请求，因而TCP要求A最后等待一段时间<code>TIME_WAIT</code>，这个时间要足够长，长到如果B没有收到ACK，B可以重试且时间足够到达。<br>不过，还有一个异常情况就是，B 超过了 2MSL 的时间，依然没有收到它发的 <code>FIN</code> 的 ACK，怎么办呢？按照 TCP 的原理，B 当然还会重发 <code>FIN</code>，这时A再收到这个包后，会直接返回<code>RST</code>，B就知道早已断开连接了。</li>
<li>TIME_WAIT<br>TIME_WAIT 状态容易被人误解，比如当使用三方系统的服务时，看到系统 TIME_WAIT 数量特别高，于是赖对方没有及时把连接释放掉，实际上<strong>TIME_WAIT 产生在主动断开连接的一方</strong>。</li>
<li>为什么 A 在 TIME-WAIT 状态必须等待 2MSL 的时间？（MSL 最长报文段寿命 Maximum Segment Lifetime，MSL&#x3D;2）<br>原因有 2：<br><strong>保证 A 发送的最后一个 ACK 报文段能够到达 B。</strong>这个 ACK 报文段有可能丢失，使得处于 LAST-ACK 状态的 B 收不到对已发送的 FIN+ACK 报文段的确认，B 超时重传 FIN+ACK 报文段，而 A 能在 2MSL 时间内收到这个重传的 FIN+ACK 报文段，接着 A 重传一次确认，重新启动 2MSL 计时器，最后 A 和 B 都进入到 CLOSED 状态，若 A 在 TIME-WAIT 状态不等待一段时间，而是发送完 ACK 报文段后立即释放连接，则无法收到 B 重传的 FIN+ACK 报文段，所以不会再发送一次确认报文段，则 B 无法正常进入到 CLOSED 状态。<br><strong>防止“已失效的连接请求报文段”出现在本连接中。</strong>A 在发送完最后一个 ACK 报文段后，再经过 2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。</li>
<li>为什么连接的时候是三次握手，关闭的时候却是四次握手？<br>因为当 Server 端收到 Client 端的 SYN 连接请求报文后，可以直接发送 SYN+ACK 报文。其中 ACK 报文是用来应答的，SYN 报文是用来同步的。但是关闭连接时，当 Server 端收到 FIN 报文时，很可能并不会立即关闭 SOCKET，所以只能先回复一个 ACK 报文，告诉 Client 端，”你发的 FIN 报文我收到了”。只有等到我 Server 端所有的报文都发送完了，我才能发送 FIN 报文，因此不能一起发送。故需要四步握手。</li>
<li>为什么 TIME_WAIT 状态需要经过 2MSL(最大报文段生存时间)才能返回到 CLOSE 状态？<br>虽然按道理，四个报文都发送完毕，我们可以直接进入 CLOSE 状态了，但是我们必须假象网络是不可靠的，有可能最后一个 ACK 丢失。所以 TIME_WAIT 状态就是用来重发可能丢失的 ACK 报文。</li>
<li>如何优化<br>我们可以通过修改系统参数来优化服务器<br>tcp_tw_reuse: 是否重用处于 TIME_WAIT 状态的 TCP 链接  （设为 true）<br>tcp_max_tw_buckets: 处于 TIME_WAIT 状态的 SOCKET 最大数目 （调大，这个参数千万不要调小了）<br>tcp_fin_timeout: 处于 FIN_WAIT_2 的时间  （调小）</li>
</ol>
<h3 id="TCP状态机"><a href="#TCP状态机" class="headerlink" title="TCP状态机"></a>TCP状态机</h3><p>上面的握手和挥手流程汇总为状态机如下图所示：<br><img src="/imgs/%E7%BD%91%E7%BB%9C/TCP%E7%8A%B6%E6%80%81%E6%9C%BA.jpg" alt="TCP状态机" title="TCP状态机"></p>
<h3 id="累计确认（cumulative-acknowledgment，或称为累计应答）"><a href="#累计确认（cumulative-acknowledgment，或称为累计应答）" class="headerlink" title="累计确认（cumulative acknowledgment，或称为累计应答）"></a>累计确认（cumulative acknowledgment，或称为累计应答）</h3><p>TCP中并不是发1收1，而是使用一个缓冲区保存数据包，这个缓冲区称为<strong>窗口</strong>，发送端的发送窗口如下图所示：<br><img src="/imgs/%E7%BD%91%E7%BB%9C/TCP%E5%8F%91%E9%80%81%E7%AA%97%E5%8F%A3.jpg" alt="TCP发送窗口" title="TCP发送窗口"></p>
<ol>
<li>发送了并且已经确认的。</li>
<li>发送了并且尚未确认的。</li>
<li>没有发送，但是已经等待发送的。</li>
<li>没有发送，并且暂时还不会发送的。</li>
</ol>
<ul>
<li>LastByteAcked：第一部分和第二部分的分界线</li>
<li>LastByteSent：第二部分和第三部分的分界线</li>
<li>LastByteAcked + AdvertisedWindow：第三部分和第四部分的分界线</li>
</ul>
<p>为什么会有第3和第4部分？难道这些不都是等待发送的吗？其实区分第3和第4部分的主要目的是<strong>流量控制</strong>，在 TCP 里，接收端会给发送端报一个窗口的大小，叫 <strong>Advertised window</strong>。这个窗口的大小应该等于上面的第2部分加上第3部分，超过了这个窗口的接收端处理不过来，就不发送了，作为第4部分。</p>
<p>接收端同样也有一个接收窗口：<br><img src="/imgs/%E7%BD%91%E7%BB%9C/TCP%E6%8E%A5%E6%94%B6%E7%AA%97%E5%8F%A3.jpg" alt="TCP接收窗口" title="TCP接收窗口"></p>
<ol>
<li>接受并且确认过的。</li>
<li>还没接收，但是马上就能接收的。</li>
<li>还没接收，也没法接收的。</li>
</ol>
<ul>
<li>MaxRcvBuffer：最大缓存的量；</li>
<li>LastByteRead 之后是已经接收了，但是还没被应用层读取的；</li>
<li>NextByteExpected 是第一部分和第二部分的分界线。</li>
</ul>
<h3 id="顺序问题与丢包问题"><a href="#顺序问题与丢包问题" class="headerlink" title="顺序问题与丢包问题"></a>顺序问题与丢包问题</h3><p>TCP中的重发有两种：</p>
<ol>
<li>超时重试<br>对每一个发送了，但是没有 ACK 的包，都有设一个定时器，超过了一定的时间，就重新尝试。<br>这个时间不宜过短，时间必须大于往返时间 RTT，否则会引起不必要的重传。也不宜过长，这样超时时间变长，访问就变慢了。估计往返时间，需要 TCP 通过采样 RTT 的时间，然后进行加权平均，算出一个值，而且这个值还是要不断变化的，因为网络状况不断地变化。除了采样 RTT，还要采样 RTT 的波动范围，计算出一个估计的超时时间。由于重传时间是不断变化的，我们称为<strong>自适应重传算法（Adaptive Retransmission Algorithm）</strong>。<br><strong>超时间隔加倍</strong>：每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送。</li>
<li>快速重传<br>超时重传存在的问题是超时周期可能会比较长，为了加快重传，TCP采用一种快速重传机制：<br>当接收方收到一个序号大于下一个所期望的报文段时，就会检测到数据流中的一个间隔，于是它就会发送冗余的 ACK，仍然 ACK 的是期望接收的报文段。而当客户端收到三个冗余的 ACK 后，就会在定时器过期之前，重传丢失的报文段。<br>例如，接收方发现 6 收到了，8 也收到了，但是 7 还没来，那肯定是丢了，于是发送 6 的 ACK，要求下一个是 7。接下来，收到后续的包，仍然发送 6 的 ACK，要求下一个是 7。当客户端收到 3 个重复 ACK，就会发现 7 的确丢了，不等超时，马上重发。</li>
<li>Selective Acknowledgment （SACK）<br>接收方可以将缓存的地图发送给发送方，例如发送ACK6、SACK8，SACK8表示已接收但未处理的，有了地图，发送方一下子就能看出来是 7 丢了。</li>
</ol>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>当发送未确认窗口中最早的一个包接收到了确认，则窗口将前移一格：<br><img src="/imgs/%E7%BD%91%E7%BB%9C/TCP%E6%8E%A5%E6%94%B6%E7%AA%97%E5%8F%A3.jpg" alt="TCP接收窗口" title="TCP接收窗口"><br>上图中，5接收到了确认，此时窗口前移一格，第14个包可以发送了。<br><img src="/imgs/%E7%BD%91%E7%BB%9C/TCP%E6%8E%A5%E6%94%B6%E7%AA%97%E5%8F%A3%E7%A7%BB%E5%8A%A8.jpg" alt="TCP接收窗口移动" title="TCP接收窗口移动"><br>如果接收方处理太慢，导致缓存中没有空间了，可以通过确认信息修改窗口的大小，甚至可以设置为 0，则发送方将暂时停止发送。<br>假设一个极端情况，接收端的应用一直不读取缓存中的数据，当数据包 6 确认后，窗口大小就不能再是 9 了，就要缩小一个变为 8。<br>那么缩小后什么时候恢复呢？<strong>发送方会定时发送窗口探测数据包</strong>，看是否有机会调整窗口的大小。</p>
<h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>拥塞控制也是通过控制窗口大小来实现的，前面的滑动窗口 rwnd 是怕发送方把接收方缓存塞满，而拥塞窗口 cwnd，是怕把网络塞满。</p>
<p>TCP的拥塞控制主要是为了避免丢包和超时重传问题：</p>
<ul>
<li><p>如果窗口不经控制——像UDP那样——很有可能发送的数据量超过中间设备的承载能力，多出来的包就会被丢弃，即发生了<strong>丢包</strong>，这是我们不希望看到的。</p>
</li>
<li><p>如果在这些设备上加缓存，处理不过来的先保存在缓存队列里，这样虽然不会丢失，但是会增加时延，如果时延达到一定程度，就会导致<strong>超时重传</strong>。</p>
</li>
<li><p>慢启动（指数增长）<br>刚开始不清楚网络情况，因此发送数据包时一次只能发1个，后来按2、4、8的<strong>指数性增长</strong>速度来增长；</p>
</li>
<li><p>线性增长<br>当超过一个阈值<code>ssthresh=65535</code>时，可能速度达到了网络性能，这时会慢下来，变成线程增长，每收到一个确认后，cwnd才会增加<code>1/cwnd</code>。</p>
</li>
<li><p>指数递减<br>当发生了丢包，需要超时重传时，会设置<code>ssthresh=cwnd/2</code>，并将cwnd设置为1，重新开始慢启动，这种减速方式的问题是太过激进，从原来的高速马上减到1，会造成明显的网络卡顿，因为这个问题，一般会采用<strong>快速重传算法</strong>。</p>
</li>
<li><p>快速重传算法<br>当接收端发现丢了一个中间包的时候，发送三次前一个包的 ACK，于是发送端就会快速地重传，不必等待超时再重传。<br>TCP 认为这种情况不严重，因为大部分没丢，只丢了一小部分，cwnd 减半为 cwnd&#x2F;2，然后 <code>sshthresh = cwnd</code>，当三个包返回的时候，<code>cwnd = sshthresh + 3</code>，也就是说没有立刻减到1。</p>
</li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/e8597381.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tallate">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tallate">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/e8597381.html" class="post-title-link" itemprop="url">网络架构梳理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-07-20 14:01:28" itemprop="dateCreated datePublished" datetime="2019-07-20T14:01:28+08:00">2019-07-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-07 01:56:20" itemprop="dateModified" datetime="2025-07-07T01:56:20+08:00">2025-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">网络</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>不懂很多网络概念，在一些开会、对接场合出了很多洋相，趁机好好补补。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/e8597381.html#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/a4caf2c1.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tallate">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tallate">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/a4caf2c1.html" class="post-title-link" itemprop="url">Nginx 原理总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-07-10 11:32:43" itemprop="dateCreated datePublished" datetime="2019-07-10T11:32:43+08:00">2019-07-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-07 01:56:20" itemprop="dateModified" datetime="2025-07-07T01:56:20+08:00">2025-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Nginx/" itemprop="url" rel="index"><span itemprop="name">Nginx</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>


<h2 id="为什么要使用-Nginx"><a href="#为什么要使用-Nginx" class="headerlink" title="为什么要使用 Nginx"></a>为什么要使用 Nginx</h2><h3 id="Nginx-优点"><a href="#Nginx-优点" class="headerlink" title="Nginx 优点"></a>Nginx 优点</h3><ol>
<li>轻量级，采用 C 进行编写，同样的 web 服务，会占用更少的内存及资源</li>
<li>抗并发，nginx 以 epoll 和 kqueue 作为开发模型，处理请求是异步非阻塞的，负载能力比 apache 高很多，而 apache 则是阻塞型的。在高并发下 nginx 能保持低资源低消耗高性能 ，而 apache 在 PHP 处理慢或者前端压力很大的情况下，很容易出现进程数飙升，从而拒绝服务的现象。</li>
<li>nginx 处理静态文件好，静态处理性能比 apache 高三倍以上</li>
<li>nginx 的设计高度模块化，编写模块相对简单</li>
<li>nginx 配置简洁，正则配置让很多事情变得简单，而且改完配置能使用 -t 测试配置有没有问题，apache 配置复杂 ，重启的时候发现配置出错了，会很崩溃</li>
<li>nginx 作为负载均衡服务器，支持 7 层负载均衡</li>
<li>nginx 本身就是一个反向代理服务器，而且可以作为非常优秀的邮件代理服务器</li>
<li>启动特别容易, 并且几乎可以做到 7*24 不间断运行，即使运行数个月也不需要重新启动，还能够不间断服务的情况下进行软件版本的升级</li>
<li>社区活跃，各种高性能模块出品迅速</li>
</ol>
<h3 id="Nginx-优点（说出原因）"><a href="#Nginx-优点（说出原因）" class="headerlink" title="Nginx 优点（说出原因）"></a>Nginx 优点（说出原因）</h3><ol>
<li>Nginx 在核心代码都使用了与操作系统无关的代码实现，在与操作系统相关的系统调用上则分别针对各个操作系统都有独立实现，这最终造就了 Nginx 的可移植性。</li>
<li>非阻塞、高并发连接：处理 2-3 万并发连接数，官方监测能支持 5 万并发</li>
<li>内存消耗小：开启 10 个 nginx 才占 150M 内存，Nginx 采取了分阶段资源分配技术<br>nginx 处理静态文件好,耗费内存少</li>
<li>内置的健康检查功能：如果有一个服务器宕机，会做一个健康检查，再发送的请求就不会发送到宕机的服务器了。重新将请求提交到其他的节点上。<br>节省宽带：支持 GZIP 压缩，可以添加浏览器本地缓存<br>稳定性高：宕机的概率非常小</li>
<li>master&#x2F;worker 结构：一个 master 进程，生成一个或者多个 worker 进程<br>接收用户请求是异步的：浏览器将请求发送到 nginx 服务器，它先将用户请求全部接收下来，再一次性发送给后端 web 服务器，极大减轻了 web 服务器的压力<br>一边接收 web 服务器的返回数据，一边发送给浏览器客户端<br>网络依赖性比较低，只要 ping 通就可以负载均衡<br>可以有多台 nginx 服务器</li>
<li>事件驱动：通信机制采用 epoll 模型</li>
</ol>
<h3 id="Apache-优点"><a href="#Apache-优点" class="headerlink" title="Apache 优点"></a>Apache 优点</h3><ol>
<li>apache 的 rewrite 比 nginx 强大，在 rewrite 频繁的情况下，用 apache</li>
<li>apache 发展到现在，模块超多，基本想到的都可以找到</li>
<li>apache 更为成熟，少 bug ，nginx 的 bug 相对较多</li>
<li>apache 超稳定</li>
<li>apache 对 PHP 支持比较简单，nginx 需要配合其他后端用</li>
<li>apache 在处理动态请求有优势，nginx 在这方面是鸡肋，一般动态请求要 apache 去做，nginx 适合静态和反向。</li>
<li>apache 仍然是目前的主流，拥有丰富的特性，成熟的技术和开发社区</li>
</ol>
<h3 id="Nginx-和-Apache-区别总结"><a href="#Nginx-和-Apache-区别总结" class="headerlink" title="Nginx 和 Apache 区别总结"></a>Nginx 和 Apache 区别总结</h3><p>两者最核心的区别在于 apache 是同步多进程模型，一个连接对应一个进程，而 nginx 是异步的，多个连接（万级别）可以对应一个进程<br>一般来说，需要性能的 web 服务，用 nginx 。如果不需要性能只求稳定，更考虑 apache ，后者的各种功能模块实现得比前者，例如 ssl 的模块就比前者好，可配置项多。epoll(freebsd 上是 kqueue ) 网络 IO 模型是 nginx 处理性能高的根本理由，但并不是所有的情况下都是 epoll 大获全胜的，如果本身提供静态服务的就只有寥寥几个文件，apache 的 select 模型或许比 epoll 更高性能。当然，这只是根据网络 IO 模型的原理作的一个假设，真正的应用还是需要实测了再说的。<br>更为通用的方案是，前端 nginx 抗并发，后端 apache 集群，配合起来会更好。</p>
<h2 id="接入层演进"><a href="#接入层演进" class="headerlink" title="接入层演进"></a>接入层演进</h2><p>通过研究接入层的发展历程，我们可以一窥 Nginx 在互联网架构中的地位。</p>
<h3 id="接入层结构"><a href="#接入层结构" class="headerlink" title="接入层结构"></a>接入层结构</h3><p><img src="/imgs/Nginx%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/%E6%8E%A5%E5%85%A5%E5%B1%82%E7%BB%93%E6%9E%84.png" alt="接入层结构" title="接入层结构"><br>可以看到，每一个下游都有多个上游调用，只需要做到，<strong>每一个上游都均匀访问每一个下游</strong>，就能实现整体的均匀分摊。</p>
<ol>
<li>客户端层-&gt;反向代理层<br>DNS 轮询<br>DNS-server 对于一个域名配置了多个解析 ip，每次 DNS 解析请求来访问 DNS-server，会轮询返回这些 ip，保证每个 ip 的解析概率是相同的。这些 ip 就是 nginx 的外网 ip，以做到每台 nginx 的请求分配也是均衡的。</li>
<li>反向代理层-&gt;站点层<br>反向代理层到站点层的负载均衡，是通过“nginx”实现的。<br>修改 nginx.conf，可以实现多种均衡策略：<br>2.1 请求轮询：和 DNS 轮询类似，请求依次路由到各个 web-server；<br>2.2 最少连接路由：哪个 web-server 的连接少，路由到哪个 web-server；<br>2.3 ip 哈希：按照访问用户的 ip 哈希值来路由 web-server，只要用户的 ip 分布是均匀的，请求理论上也是均匀的，ip 哈希均衡方法可以做到，同一个用户的请求固定落到同一台 web-server 上，此策略适合有状态服务，例如 session；<blockquote>
<p>session 不推荐放到站点层，后期扩展会有问题，更好的方案是放到数据层。</p>
</blockquote>
</li>
<li>站点层-&gt;服务层<br>站点层到服务层的负载均衡，是通过“服务连接池”实现的。<br>上游连接池会建立与下游服务多个连接，每次请求会“随机”选取连接来访问下游服务。除了负载均衡，服务连接池还能够实现故障转移、超时处理、限流限速、ID 串行化等诸多功能。</li>
<li>服务层-&gt;数据层<br>在数据量很大的情况下，由于数据层（db&#x2F;cache）涉及数据的水平切分，所以数据层的负载均衡更为复杂一些，它分为“数据的均衡”，与“请求的均衡”。<br><strong>数据的均衡</strong>是指：水平切分后的每个服务（db&#x2F;cache），数据量是均匀的。<br><strong>请求的均衡</strong>是指：水平切分后的每个服务（db&#x2F;cache），请求量是均匀的。</li>
</ol>
<h3 id="接入层演进-1"><a href="#接入层演进-1" class="headerlink" title="接入层演进"></a>接入层演进</h3><ol>
<li>单机架构<br>客户端用 DNS 解析出来的 IP 就是 web 服务器的地址。<br>缺点：<ul>
<li>单点；</li>
<li>扩展性差。</li>
</ul>
</li>
<li>DNS 轮询<br>在 DNS 服务器上多配几个 IP，由域名服务器的解析策略实现负载均衡。<br>缺点：<ul>
<li>非高可用，因为一个 web 服务器挂掉后 DNS 服务器仍然会将请求解析到该服务器对应的 IP 上；</li>
<li>扩容非实时，DNS 服务器有一个配置生效的延时时间；</li>
<li>暴露太多外网 IP。</li>
</ul>
</li>
<li>反向代理 Nginx<br>DNS 解析到 Nginx 的 IP，然后由 Nginx 将请求负载均衡到 web 服务器。<br>缺点：基本解决了上一个架构存在的问题，且可以利用 Nginx 的探活机制实现 web 服务器的高可用，但是此时 Nginx 也会成为一个单点。</li>
<li>keepalived<br>两台 Nginx 组成集群，分别部署上 keepalived，设置成相同的虚 IP，保证 Nginx 的高可用。当一台 Nginx 挂了，keepalived 能够探测到并将流量迁移到另一台 Nginx 上，整个过程对调用方透明。<br>缺点：<ul>
<li>资源利用率低；</li>
<li>扩容不方便，如果吞吐量超过 Nginx 性能上线，要加机器配置起来比较麻烦。</li>
</ul>
</li>
<li>lvs&#x2F;f5<br>DNS 解析出来的 IP 是 lvs 的地址。由 lvs 反向代理 Nginx 服务器，lvs 的机器上部署 keepalived+VIP 实现高可用；<br>f5 的性能比 lvs 更高，但是成本也会更高。</li>
<li>DNS 轮询<br>水平扩展才是解决性能问题的根本方案，能够通过加机器扩充性能的方案才具备最好的扩展性。<br><img src="/imgs/Nginx%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/%E5%8F%AF%E6%89%A9%E5%B1%95%E9%AB%98%E5%8F%AF%E7%94%A8%E6%8E%A5%E5%85%A5%E5%B1%82%E6%9E%B6%E6%9E%84.png" alt="可扩展高可用接入层架构" title="可扩展高可用接入层架构"><ul>
<li>通过 DNS 轮询来线性扩展入口 lvs 层的性能；</li>
<li>通过 keepalived 保证高可用；</li>
<li>通过 lvs 来扩展多个 Nginx；</li>
<li>通过 Nginx 实现对业务服务器的七层负载均衡。</li>
</ul>
</li>
</ol>
<h2 id="使用-Nginx"><a href="#使用-Nginx" class="headerlink" title="使用 Nginx"></a>使用 Nginx</h2><h3 id="手动安装-Nginx"><a href="#手动安装-Nginx" class="headerlink" title="手动安装 Nginx"></a>手动安装 Nginx</h3><ol>
<li>配置<br>创建目录<code>/var/temp/nginx</code><br>这个目录保存临时文件，在安装配置中指定：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">./configure \</span><br><span class="line">--prefix=/usr/local/nginx \</span><br><span class="line">--pid-path=/var/run/nginx/nginx.pid \</span><br><span class="line">--lock-path=/var/lock/nginx.lock \</span><br><span class="line">--error-log-path=/var/log/nginx/error.log \</span><br><span class="line">--http-log-path=/var/log/nginx/access.log \</span><br><span class="line">--with-http_gzip_static_module \</span><br><span class="line">--http-client-body-temp-path=/var/temp/nginx/client \</span><br><span class="line">--http-proxy-temp-path=/var/temp/nginx/proxy \</span><br><span class="line">--http-fastcgi-temp-path=/var/temp/nginx/fastcgi \</span><br><span class="line">--http-uwsgi-temp-path=/var/temp/nginx/uwsgi \</span><br><span class="line">--http-scgi-temp-path=/var/temp/nginx/scgi</span><br></pre></td></tr></table></figure></li>
<li>安装<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line">make  install</span><br></pre></td></tr></table></figure></li>
<li>配置环境变量<br>在<code>/etc/profile</code>中编辑，这样就可以直接使用 nginx 命令启动了<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:/usr/local/nginx/sbin</span><br></pre></td></tr></table></figure></li>
<li>启动<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nginx</span><br><span class="line"># 指定配置文件</span><br><span class="line">nginx -c /usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure>
如果不指定-c，nginx 在启动时默认加载 conf&#x2F;nginx.conf 文件，此文件的地址也可以在编译安装 nginx 时指定.&#x2F;configure 的参数（–conf-path&#x3D; 指向配置文件（nginx.conf））</li>
<li>停止<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nginx -s stop # 相当于先查出nginx进程id再kill</span><br><span class="line">nginx -s quit # 建议使用，这种方法是等nginx进程的任务处理完毕后再停止</span><br></pre></td></tr></table></figure></li>
<li>重启<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nginx -s quit</span><br><span class="line">nginx</span><br></pre></td></tr></table></figure>
要想在修改配置文件 nginx.conf 后生效：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="开机自启"><a href="#开机自启" class="headerlink" title="开机自启"></a>开机自启</h3><ol>
<li>创建<code>/etc/init.d/nginx</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># nginx Startup script for the Nginx HTTP Server</span><br><span class="line"># it is v.0.0.2 version.</span><br><span class="line"># chkconfig: - 85 15</span><br><span class="line"># description: Nginx is a high-performance web and proxy server.</span><br><span class="line">#              It has a lot of features, but it&#x27;s not for everyone.</span><br><span class="line"># processname: nginx</span><br><span class="line"># pidfile: /var/run/nginx.pid</span><br><span class="line"># config: /usr/local/nginx/conf/nginx.conf</span><br><span class="line">nginxd=/usr/local/nginx/sbin/nginx</span><br><span class="line">nginx_config=/usr/local/nginx/conf/nginx.conf</span><br><span class="line">nginx_pid=/var/run/nginx.pid</span><br><span class="line">RETVAL=0</span><br><span class="line">prog=&quot;nginx&quot;</span><br><span class="line"># Source function library.</span><br><span class="line">. /etc/rc.d/init.d/functions</span><br><span class="line"># Source networking configuration.</span><br><span class="line">. /etc/sysconfig/network</span><br><span class="line"># Check that networking is up.</span><br><span class="line">[ $&#123;NETWORKING&#125; = &quot;no&quot; ] &amp;&amp; exit 0</span><br><span class="line">[ -x $nginxd ] || exit 0</span><br><span class="line"># Start nginx daemons functions.</span><br><span class="line">start() &#123;</span><br><span class="line">if [ -e $nginx_pid ];then</span><br><span class="line">   echo &quot;nginx already running....&quot;</span><br><span class="line">   exit 1</span><br><span class="line">fi</span><br><span class="line">   echo -n $&quot;Starting $prog: &quot;</span><br><span class="line">   daemon $nginxd -c $&#123;nginx_config&#125;</span><br><span class="line">   RETVAL=$?</span><br><span class="line">   echo</span><br><span class="line">   [ $RETVAL = 0 ] &amp;&amp; touch /var/lock/subsys/nginx</span><br><span class="line">   return $RETVAL</span><br><span class="line">&#125;</span><br><span class="line"># Stop nginx daemons functions.</span><br><span class="line">stop() &#123;</span><br><span class="line">        echo -n $&quot;Stopping $prog: &quot;</span><br><span class="line">        killproc $nginxd</span><br><span class="line">        RETVAL=$?</span><br><span class="line">        echo</span><br><span class="line">        [ $RETVAL = 0 ] &amp;&amp; rm -f /var/lock/subsys/nginx /var/run/nginx.pid</span><br><span class="line">&#125;</span><br><span class="line"># reload nginx service functions.</span><br><span class="line">reload() &#123;</span><br><span class="line">    echo -n $&quot;Reloading $prog: &quot;</span><br><span class="line">    #kill -HUP `cat $&#123;nginx_pid&#125;`</span><br><span class="line">    killproc $nginxd -HUP</span><br><span class="line">    RETVAL=$?</span><br><span class="line">    echo</span><br><span class="line">&#125;</span><br><span class="line"># See how we were called.</span><br><span class="line">case &quot;$1&quot; in</span><br><span class="line">start)</span><br><span class="line">        start</span><br><span class="line">        ;;</span><br><span class="line">stop)</span><br><span class="line">        stop</span><br><span class="line">        ;;</span><br><span class="line">reload)</span><br><span class="line">        reload</span><br><span class="line">        ;;</span><br><span class="line">restart)</span><br><span class="line">        stop</span><br><span class="line">        start</span><br><span class="line">        ;;</span><br><span class="line">status)</span><br><span class="line">        status $prog</span><br><span class="line">        RETVAL=$?</span><br><span class="line">        ;;</span><br><span class="line">*)</span><br><span class="line">        echo $&quot;Usage: $prog &#123;start|stop|restart|reload|status|help&#125;&quot;</span><br><span class="line">        exit 1</span><br><span class="line">esac</span><br><span class="line">exit $RETVAL</span><br></pre></td></tr></table></figure></li>
<li>设置文件访问权限<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod a+x /etc/init.d/nginx</span><br></pre></td></tr></table></figure></li>
<li>设置开机加载<br>在<code>/etc/rc.local</code>中加入一行<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/nginx start</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="通过-Docker-运行-Nginx"><a href="#通过-Docker-运行-Nginx" class="headerlink" title="通过 Docker 运行 Nginx"></a>通过 Docker 运行 Nginx</h3><p>手动进行 Nginx 配置十分繁琐，可以使用 Docker 来简化部署流程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 80:80 nginx</span><br></pre></td></tr></table></figure>


<h2 id="Nginx-原理-进程"><a href="#Nginx-原理-进程" class="headerlink" title="Nginx 原理 - 进程"></a>Nginx 原理 - 进程</h2><h3 id="Nginx-代码的模块化结构"><a href="#Nginx-代码的模块化结构" class="headerlink" title="Nginx 代码的模块化结构"></a>Nginx 代码的模块化结构</h3><p>Nginx 的代码是由一个核心和一系列的模块组成的。<br><strong>核心</strong>主要用于提供 WebServer 的基本功能，以及 Web 和 Mail 反向代理的功能；还用于启用网络协议，创建必要的运行时环境以及确保不同的模块之间平滑地进行交互。<br>不过，大多跟协议相关的功能和应用特有的功能都是由 nginx 的模块实现的。<br>换句话说， <strong>每一个功能或操作都由一个模块来实现</strong>。<br>这些功能模块大致可以分为事件模块、阶段性处理器、输出过滤器、变量处理器、协议、upstream 和负载均衡几个类别，这些共同组成了 nginx 的 http 功能。<br><strong>事件模块</strong>主要用于提供 OS 独立的(不同操作系统的事件机制有所不同)事件通知机制如 kqueue 或 epoll 等。<br><strong>协议模块</strong>则负责实现 nginx 通过 http、tls&#x2F;ssl、smtp、pop3 以及 imap 与对应的客户端建立会话。<br>在 Nginx 内部，进程间的通信是通过模块的 <strong>pipeline</strong> 或 <strong>chain</strong> 实现的。<br>换句话说，每一个功能或操作都由一个模块来实现。例如：压缩、通过 FastCGI 或 uwsgi 协议与 upstream 服务器通信、以及与 memcached 建立会话等。</p>
<h3 id="进程结构"><a href="#进程结构" class="headerlink" title="进程结构"></a>进程结构</h3><p>一个 Nginx 服务器实例由一个 master 进程和多个 worker 进程组成。<br><img src="/imgs/Nginx%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/%E8%BF%9B%E7%A8%8B%E7%BB%93%E6%9E%84.png" alt="进程结构"><br><strong>master</strong>进程主要用来管理 worker 进程，还有一些对整个服务器的初始化和日志记录等工作。<br><strong>管理 worker 的过程</strong>：接收来自外界的信号，向各 worker 进程发送 <strong>信号</strong> ，监控 worker 进程的运行状态，当 worker 进程退出后(异常情况下)，会自动重新启动（fork）新的 worker 进程。  </p>
<p><strong>master 主要功能</strong>：  </p>
<ul>
<li>读取并验证配置信息；</li>
<li>创建、绑定及关闭套接字；</li>
<li>启动、终止 worker 进程及维护 worker 进程的个数；</li>
<li>无须中止服务而重新配置工作；</li>
<li>控制非中断式程序升级，启用新的二进制程序并在需要时回滚至老版本；</li>
<li>重新打开日志文件；</li>
<li>编译嵌入式 perl 脚本</li>
</ul>
<p>对请求的实际处理由 <strong>worker</strong> 负责，且每个请求只能由一个 worker 负责（一对一）。在启动时,创建一组初始的监听套接字，HTTP 请求和响应之时，worker 连续接收、读取和写入套接字。</p>
<p><strong>worker 主要功能</strong>：</p>
<ul>
<li>接收、传入并处理来自客户端的连接；</li>
<li>提供反向代理及过滤功能；</li>
<li>nginx 任何能完成的其它任务</li>
</ul>
<h3 id="Nginx-的启动"><a href="#Nginx-的启动" class="headerlink" title="Nginx 的启动"></a>Nginx 的启动</h3><p>nginx 启动后，在 unix 系统中会以 daemon 的方式在后台运行，后台进程包含一个 master 进程和多个 worker 进程（你可以理解为工人和管理员）。 </p>
<h3 id="Nginx-处理连接过程"><a href="#Nginx-处理连接过程" class="headerlink" title="Nginx 处理连接过程"></a>Nginx 处理连接过程</h3><p>nginx 不会为每个连接派生进程或线程，而是由 worker 进程通过监听共享套接字接受新请求，并且使用高效的 <strong>循环</strong> 来处理数千个连接。<br>Nginx 不使用仲裁器或分发器来分发连接，这个工作由操作系统内核机制完成。 <strong>监听套接字</strong> 在启动时就完成初始化，worker 进程通过这些套接字接受、读取请求和输出响应。  </p>
<p>一次请求过程大概执行过程为：</p>
<ol>
<li>nginx 在启动时，会解析配置文件，得到需要监听的端口与 ip 地址，然后在 nginx 的 master 进程里面先初始化好这个监控的 socket，再进行 listen（listenfd）；</li>
<li>由 master 进程 fork 出多个 worker 进程；</li>
<li>此时客户端可以向 nginx 发起连接了，客户端会与 nginx 进行三次握手（TCP），与 nginx 建立好一个连接；</li>
<li>所有 worker 进程的 listenfd 会在新连接到来时变得可读，为保证只有一个进程处理该连接，所有 worker 进程会在注册 listenfd 读事件前抢 accept_mutex，抢到互斥锁的那个进程注册 listenfd 读事件，然后在读事件里调用 accept 接受该连接</li>
<li>当一个 worker 进程在 accept 这个连接之后，然后创建 nginx 对连接的封装，即 ngx_connection_t 结构体，就开始读取请求、解析请求、处理请求（ <strong>异步非阻塞</strong> ），主要是根据事件调用相应的事件处理模块，如 http 模块与客户端进行数据的交换</li>
<li>产生数据后，再返回给客户端，最后才断开连接，或者由客户端主动关闭连接。</li>
</ol>
<h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p>在 Nginx 内部，进程间的通信是通过模块的 <strong>pipeline</strong> 或 <strong>chain</strong> 实现的，其原理是<strong>信号机制</strong>，master 对 worker 进程采用信号进行控制。</p>
<h3 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h3><p>所谓<strong>事件驱动</strong>架构，简单来说，就是由一些事件发生源来产生事件，由一个或多个事件收集器（epolld 等）来收集、分发事件，然后许多事件处理器会注册自己感兴趣的事件，同时会“消费”这些事件。nginx 不会使用进程或线程作为事件消费者，只能是某个模块，当前进程调用模块。<br>传统 web 服务器（如 Apache）的所谓事件局限在 TCP 连接建立、关闭上，其他读写都不再是事件驱动，这时会退化成按序执行每个操作的批处理模式，这样每个请求在连接建立后都将始终占用系统资源，直到连接关闭才会释放资源。大大浪费了内存、cpu 等资源。并且把一个进程或线程作为事件消费者。 传统 Web 服务器每个事件消费者独占一个进程资源，相对来说，Nginx 只是被事件分发者进程短期调用而已。<br>nginx 采用多 worker 的方式来处理请求，每个 worker 里面只有一个主线程，那能够处理的并发数很有限，多少个 worker 就能处理多少个并发，那么何来的高并发呢？<br>其实，Nginx 是采用了<strong>异步非阻塞</strong>的 IO 模型来处理请求的（epoll），异步的概念是和同步相对的，也就是不同事件之间不是同时发生的。非阻塞的概念是和阻塞对应的，阻塞是事件按顺序执行，每一事件都要等待上一事件的完成，而非阻塞是如果事件没有准备好，这个事件可以直接返回，过一段时间再进行处理询问，这期间可以做其他事情。<br>请求的<strong>多阶段异步处理</strong>只能基于事件驱动框架实现，就是把一个请求的处理过程按照事件的触发方式分为多个阶段，每个阶段都可以有事件收集、分发器（epoll 等）来触发。比如一个 http 请求可以分为七个阶段。<br>每种事件都有一个事件队列，按触发的先后顺序处理。</p>
<h3 id="惊群现象"><a href="#惊群现象" class="headerlink" title="惊群现象"></a>惊群现象</h3><p>惊群是多个子进程在同一时刻监听同一个端口引起的；<br>Nginx 解决方法：同一个时刻只能有唯一一个 worker 子进程监听 web 端口，此时新连接事件只能唤醒唯一正在监听端口的 worker 子进程。这可以通过锁或互斥量实现。</p>
<h3 id="为什么不使用多线程"><a href="#为什么不使用多线程" class="headerlink" title="为什么不使用多线程"></a>为什么不使用多线程</h3><ul>
<li>Apache: 创建多个进程或线程，而每个进程或线程都会为其分配 cpu 和内存（线程要比进程小的多，所以 worker 支持比 perfork 高的并发），并发过大会榨干服务器资源。 </li>
<li>Nginx: 采用单线程来异步非阻塞处理请求（管理员可以配置 Nginx 主进程的工作进程的数量）(epoll)，不会为每个请求分配 cpu 和内存资源，节省了大量资源，同时也减少了大量的 CPU 的上下文切换。所以才使得 Nginx 支持更高的并发。</li>
</ul>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><h3 id="模块命名"><a href="#模块命名" class="headerlink" title="模块命名"></a>模块命名</h3><p><code>ngx_http_[module-name]_[main|srv|loc]_conf_t</code><br>前缀表示模块名，后面表示模块运行在哪一层</p>
<h3 id="模块化结构"><a href="#模块化结构" class="headerlink" title="模块化结构"></a>模块化结构</h3><p>Nginx由内核和一系列模块组成，内核提供web服务的基本功能,如启用网络协议,创建运行环境,接收和分配客户端请求,处理模块之间的交互。Nginx的各种功能和操作都由模块来实现。<br>Nginx的模块从结构上分为核心模块、基础模块和第三方模块。</p>
<ul>
<li>核心模块： HTTP模块、EVENT模块和MAIL模块</li>
<li>基础模块： HTTP Access模块、HTTP FastCGI模块、HTTP Proxy模块和HTTP Rewrite模块</li>
<li>第三方模块： HTTP Upstream Request Hash模块、Notice模块和HTTP Access Key模块及用户自己开发的模块</li>
</ul>
<p>这样的设计使Nginx方便开发和扩展，也正因此才使得Nginx功能如此强大。Nginx的模块默认编译进nginx中，如果需要增加或删除模块，需要重新编译Nginx，这一点不如Apache的动态加载模块方便。如果有需要动态加载模块，可以使用由淘宝网发起的web服务器Tengine，在nginx的基础上增加了很多高级特性，完全兼容Nginx，已被国内很多网站采用。</p>
<p>模块大致结构如下图所示。<br><img src="/imgs/Nginx%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/Nginx%E6%A8%A1%E5%9D%97%E7%BB%93%E6%9E%84.png" alt="Nginx模块结构" title="Nginx模块结构"><br>Nginx模块，简单地讲，就是：在特定地方调用的函数。</p>
<h3 id="模块执行过程"><a href="#模块执行过程" class="headerlink" title="模块执行过程"></a>模块执行过程</h3><p>nginx的配置 <strong>指令作用域</strong> 分为以下几种：main，server，location<br>main作用域的范围为整个配置文件，而server是指某个具体的服务器（通过端口号来区分），而location就是指要访问这个server的哪个location。  </p>
<p>Nginx 本身做的工作实际很少，当它接到一个 HTTP 请求时，它仅仅是通过查找配置文件将此次请求映射到一个 locationblock，而此 location 中所配置的各个指令则会启动不同的模块去完成工作。<br>通常一个 location 中的指令会涉及一个 handler 模块和多个 filter 模块（当然，多个 location 可以复用同一个模块）。handler 模块负责处理请求，完成响应内容的生成，而 filter 模块对响应内容进行处理。<br>模块处理请求的大致过程如下图所示。<br><img src="/imgs/Nginx%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/Nginx%E6%A8%A1%E5%9D%97%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="Nginx模块执行流程" title="Nginx模块执行流程"></p>
<h3 id="http-index模块（ngx-http-index-module）"><a href="#http-index模块（ngx-http-index-module）" class="headerlink" title="http index模块（ngx_http_index_module）"></a>http index模块（ngx_http_index_module）</h3><p>定义将要被作为默认页的文件。 文件的名字可以包含变量。 文件以配置中指定的顺序被 nginx 检查。 列表中的最后一个元素可以是一个带有绝对路径的文件。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    root   /home/ftpuser/www;</span><br><span class="line">    index  index.html index.$haha.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，index 文件会引发内部重定向，请求可能会被其它 location 处理。<br>比如下面的配置，请求”&#x2F;“实际上将会在第二个location中作为”&#x2F;index.html”被处理：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location = / &#123;</span><br><span class="line">    index index.html;</span><br><span class="line">&#125;</span><br><span class="line">location / &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="http-log模块（ngx-http-log-module）"><a href="#http-log模块（ngx-http-log-module）" class="headerlink" title="http log模块（ngx_http_log_module）"></a>http log模块（ngx_http_log_module）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">log_format  gzip &#x27;$remote_addr-$remote_user[$time_local]&#x27;</span><br><span class="line">:&#x27;$request$status $bytes_sent&#x27;</span><br><span class="line">:&#x27;&quot; $ http _ referer&quot; &quot;$http_user_agent&quot; &quot;$gzip_ratio&quot;&#x27;;</span><br><span class="line">access_log  /spool/logs/nginx-access.log  gzip  buffer=32k;</span><br></pre></td></tr></table></figure>
<p>指令 access_log 指派路径、格式和缓存大小：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 格式</span><br><span class="line">access_log path [format [buffer=size | off ]</span><br><span class="line"># 默认</span><br><span class="line">access_log log/access.log combined</span><br></pre></td></tr></table></figure>
<p>其中参数 “off” 将清除当前级别的所有 access_log 指令。如果未指定格式，则使用预置的 “combined” 格式。缓存不能大于能写入磁盘的文件的最大值（在 FreeBSD 3.0-6.0 ，缓存大小无此限制）。<br>指令 log_format 指定日志格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 格式</span><br><span class="line">log_format name format [format ...]</span><br><span class="line"># 默认</span><br><span class="line">log_format combined &quot;...&quot;</span><br></pre></td></tr></table></figure>
<h3 id="Access模块（ngx-http-access-module）"><a href="#Access模块（ngx-http-access-module）" class="headerlink" title="Access模块（ngx_http_access_module）"></a>Access模块（ngx_http_access_module）</h3><p>此模块提供了一个简易的基于主机的访问控制。<br>ngx_http_access_module 模块让我们可以对特定 IP 客户端进行控制。 规则检查按照第一次匹配的顺序，此模块对网络地址有放行和禁止的权利。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 仅允许网段 10.1.1.0/16 和 192.168.1.0/24 中除 192.168.1.1 之外的 ip 访问</span><br><span class="line">location / &#123;</span><br><span class="line">: deny 192.168.1.1;</span><br><span class="line">: allow 192.168.1.0/24;</span><br><span class="line">: allow 10.1.1.0/16;</span><br><span class="line">: deny all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>放行语法 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">allow [ address | CIDR | all ]</span><br></pre></td></tr></table></figure>
作用域: http, server, location, limit_except<br>allow 描述的网络地址有权直接访问</li>
<li>禁止语法 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deny [ address | CIDR | all ]</span><br></pre></td></tr></table></figure>
作用域: http, server, location, limit_except<br>deny 描述的网络地址拒绝访问</li>
</ol>
<h3 id="Rewrite模块（ngx-http-rewrite-module）"><a href="#Rewrite模块（ngx-http-rewrite-module）" class="headerlink" title="Rewrite模块（ngx_http_rewrite_module）"></a>Rewrite模块（ngx_http_rewrite_module）</h3><p>执行 URL 重定向,允许你去掉带有恶意的 URL，包含多个参数（修改）.利用正则的匹配，分组和引用，达到目的 配置范例：该模块允许使用正则表达式改变 URL，并且根据变量来转向以及选择配置</p>
<ol>
<li>if语法 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (condition) &#123; ... &#125;</span><br></pre></td></tr></table></figure>
作用域: server, location <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">if ($http_user_agent ~ MSIE) &#123;</span><br><span class="line">: rewrite ^(.*)$ /msie/$1 break;</span><br><span class="line">&#125;</span><br><span class="line">if ($http_cookie ~* &quot;id=([^;] +)(?:;|$)&quot; ) &#123;</span><br><span class="line">: set $id $1;</span><br><span class="line">&#125;</span><br><span class="line">if ($request_method = POST ) &#123;</span><br><span class="line">: return 405;</span><br><span class="line">&#125;</span><br><span class="line">if (!-f $request_filename) &#123;</span><br><span class="line">: break;</span><br><span class="line">: proxy_pass http://127.0.0.1;</span><br><span class="line">&#125;</span><br><span class="line">if ($slow) &#123;</span><br><span class="line">: limit_rate 10k;</span><br><span class="line">&#125;</span><br><span class="line">if ($invalid_referer) &#123;</span><br><span class="line">: return 403;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>return语法<br>这个指令根据规则的执行情况，返回一个状态值给客户端。可使用值包括：204，400，402-406，408，410，411，413，416 及 500-504。也可以发送非标准的 444 代码-未发送任何头信息下结束连接。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return cod</span><br></pre></td></tr></table></figure>
作用域: server, location, if</li>
<li>rewrite语法<br>这个指令根据正则表达式或者待替换的字符串来更改 URL。指令根据配置文件中的先后顺序执行生效。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rewrite regex replacement flag</span><br></pre></td></tr></table></figure>
flag可以有以下取值：<ul>
<li>last :表示完成 rewrite</li>
<li>break:本规则匹配完成后，终止匹配，不再匹配后面的规则</li>
<li>redirect:返回 302 临时重定向，地址栏会显示跳转后的地址</li>
<li>permanent:返回 301 永久重定向，地址栏会显示跳转后的地址<br>作用域: server, location, if</li>
</ul>
</li>
</ol>
<h3 id="Proxy模块（ngx-http-proxy-module）"><a href="#Proxy模块（ngx-http-proxy-module）" class="headerlink" title="Proxy模块（ngx_http_proxy_module）"></a>Proxy模块（ngx_http_proxy_module）</h3><p>此模块能代理请求到其它服务器.也就是说允许你把客户端的 HTTP 请求转到后端服务器(这部分的指令非常多，但不是全部都会被用到，详细指令列表可以上<a target="_blank" rel="noopener" href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html">官网</a>查看，这里是比较常见的指令简介)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 强制一些被忽略的头传递到客户端</span><br><span class="line">proxy_pass_header Server;</span><br><span class="line"># 允许改写出现在 HTTP 头却被后端服务器触发重定向的 URL,对响应本身不做任何处理</span><br><span class="line">proxy_redirect off;</span><br><span class="line"># 允许你重新定义代理 header 值再转到后端服务器，目标服务器可以看到客户端的原始主机名</span><br><span class="line">proxy_set_header Host $http_host;</span><br><span class="line"># 目标服务器可以看到客户端的真实 ip，而不是转发服务器的 ip</span><br><span class="line">proxy_set_header X-Real-IP $remote_addr;</span><br></pre></td></tr></table></figure>
<h3 id="upstream模块（ngx-http-upstream-module）"><a href="#upstream模块（ngx-http-upstream-module）" class="headerlink" title="upstream模块（ngx_http_upstream_module）"></a>upstream模块（ngx_http_upstream_module）</h3><p>该指令将来自客户端的一个请求分到多个上行服务器上，即我们常说的负载均衡。<br>默认情况下采用<strong>轮询</strong>策略，每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。<br>可以使用<strong>weight</strong>来指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">  server backend1.example.com weight=5;</span><br><span class="line">  server backend2.example.com:8080;</span><br><span class="line">  server unix:/tmp/backend3;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">  location / &#123;</span><br><span class="line">    proxy_pass http://backend;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>upstream指令<br>这个指令描述了一个服务器的集合，该集合可被用于 proxy_pass 和 fastcgi_pass 指令中，作为一个单独的实体。这些服务器可以是监听在不同的端口，另外，并发使用同时监听 TCP 端口和 Unix 套接字的服务器是可能的。 这些服务器能被分配不同的权重。如果没有指定，则都为 1 ，即默认的策略为轮询。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">    server backend1.example.com weight=5;</span><br><span class="line">    server 127.0.0.1:8080 max_fails=3 fail_timeout=30s;</span><br><span class="line">    server unix:/tmp/backend3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
可以通过weight参数指定每个上行服务器的权重，weight和访问比率成正比，用于后端服务器性能不均的情况。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream test&#123;</span><br><span class="line">     server localhost:8080 weight=9;</span><br><span class="line">     server localhost:8081 weight=1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>ip_hash指令<br>请求基于客户端的 IP 地址在服务器间进行分发。 IPv4 地址的前三个字节或者 IPv6 的整个地址，会被用来作为一个散列 key。 这种方法可以确保从同一个客户端过来的请求，会被传给同一台服务器。除了当服务器被认为不可用的时候，这些客户端的请求会被传给其他服务器，而且很有可能也是同一台服务器。<br>如果其中一个服务器想暂时移除，应该加上 down 参数。这样可以保留当前客户端 IP 地址散列分布。<br>作用域：upstream <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">  ip_hash;</span><br><span class="line">  server backend1.example.com;</span><br><span class="line">  server backend2.example.com;</span><br><span class="line">  server backend3.example.com down;</span><br><span class="line">  server backend4.example.com;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>fair（第三方）<br>按后端服务器的响应时间来分配请求，响应时间短的优先分配。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123; </span><br><span class="line">    fair; </span><br><span class="line">    server localhost:8080;</span><br><span class="line">    server localhost:8081;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>url_hash(第三方)<br>按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。 在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">    hash $request_uri;</span><br><span class="line">    hash_method crc32;</span><br><span class="line">    server localhost:8080;</span><br><span class="line">    server localhost:8081;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>server指令<br>定义服务器的地址 address 和其他参数 parameters。 地址可以是域名或者 IP 地址，端口是可选的，或者是指定“unix:”前缀的 UNIX 域套接字的路径。如果没有指定端口，就使用 80 端口。 如果一个域名解析到多个 IP，本质上是定义了多个 server。<br>作用域：upstream <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">  server backend1.example.com weight=5;</span><br><span class="line">  server 127.0.0.1:8080 max_fails=3 fail_timeout=30s;</span><br><span class="line">  server unix:/tmp/backend3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="nginx配置文件优化"><a href="#nginx配置文件优化" class="headerlink" title="nginx配置文件优化"></a>nginx配置文件优化</h2><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>默认配置文件位置在&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf，在configue时决定，也可以在运行nginx时指定配置文件  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx nginx.conf</span><br></pre></td></tr></table></figure>


<h3 id="顶层配置"><a href="#顶层配置" class="headerlink" title="顶层配置"></a>顶层配置</h3><p>顶层配置即nginx.conf中前面、暴露在外面的那几项  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#user  nobody;</span><br><span class="line">worker_processes  1;</span><br><span class="line">#pid        logs/nginx.pid;</span><br></pre></td></tr></table></figure>
<p><strong>worker_processes</strong> 定义了 nginx 在为你的网站提供服务时，worker 进程的数量。<br>这个优化值受到包括 CPU 内核数、存储数据的磁盘数、负载值在内的许多因素的影响。如果不确定的话，将其设置为可用的 CPU 内核的数量是一个不错的选择（设置为“auto”，将会尝试自动检测可用的值）。<br>另外本机的CPU核心信息可以使用下面命令查看  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo | grep processor</span><br></pre></td></tr></table></figure>


<h3 id="events模块"><a href="#events模块" class="headerlink" title="events模块"></a>events模块</h3><p>events模块包括了 nginx 中处理链接的全部设置  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">    # multi_accept on;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>worker_connections</strong> 设置了一个 worker 进程可以同时打开的链接数。<br><strong>multi_accept</strong> 的作用是告诉 nginx 在收到新链接的请求通知时，尽可能接受链接。最好开着  </p>
<h3 id="http模块"><a href="#http模块" class="headerlink" title="http模块"></a>http模块</h3><p>当外部有 http 请求时，nginx 的 http 模块才是处理这个请求的核心。  </p>
<ol>
<li>Basic Settings<br><strong>sendfile</strong> 指向 sendfile()函数。sendfile() 在磁盘和 TCP 端口（或者任意两个文件描述符）之间复制数据。<br>在 sendfile 出现之前，为了传输这样的数据，需要在用户空间上分配一块数据缓存，使用 read() 从源文件读取数据到缓存，然后使用 write() 将缓存写入到网络。<br>sendfile() 直接从磁盘上读取数据到操作系统缓冲。由于这个操作是在内核中完成的，sendfile() 比 read() 和 write() 联合使用要更加有效率。<br><strong>tcp_nopush</strong> 配置 nginx 在一个数据包中发送全部的头文件，而不是一个一个发送。<br><strong>tcp_nodelay</strong> 配置 nginx 不要缓存数据，应该快速的发送小数据——这仅仅应该用于频繁发送小的碎片信息而无需立刻获取响应的、需要实时传递数据的应用中。<br><strong>keepalive_timeout</strong> 指定了与客户端的 keep-alive 链接的超时时间。服务器会在这个时间后关闭链接。我们可以降低这个值，以避免让 worker 过长时间的忙碌。  </li>
<li>Logging Settings<br><strong>access_log</strong> 确定了 nginx 是否保存访问日志。将这个设置为关闭可以降低磁盘 IO 而提升速度。<br><strong>error_log</strong> 设置 nginx 应当记录错误日志。  </li>
<li>Gzip Settings<br><strong>gzip</strong> 设置 nginx gzip 压缩发送的数据。这会减少需要发送的数据的数量。<br><strong>gzip_disable</strong> 为指定的客户端禁用 gzip 功能。<br><strong>gzip_proxied</strong> 允许或禁止基于请求、响应的压缩。设置为 any，就可以 gzip 所有的请求。<br><strong>gzip_comp_level</strong> 设置了数据压缩的等级。等级可以是 1-9 的任意一个值，9 表示最慢但是最高比例的压缩。<br><strong>gzip_types</strong> 设置进行 gzip 的类型。有下面这些，不过还可以添加更多。</li>
</ol>
<h3 id="mail模块"><a href="#mail模块" class="headerlink" title="mail模块"></a>mail模块</h3><p>略…</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">user nginxuser;</span><br><span class="line">worker_processes 4;</span><br><span class="line">pid logs/nginx.pid;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections 1024;</span><br><span class="line">    multi_accept on;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line"></span><br><span class="line">    ##</span><br><span class="line">    # Basic Settings</span><br><span class="line">    ##</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    sendfile on;</span><br><span class="line">    tcp_nopush on;</span><br><span class="line">    tcp_nodelay on;</span><br><span class="line">    keepalive_timeout 15;</span><br><span class="line">    types_hash_max_size 2048;</span><br><span class="line">    # server_tokens off;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # server_names_hash_bucket_size 64;</span><br><span class="line">    # server_name_in_redirect off;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    include /etc/nginx/mime.types;</span><br><span class="line">    default_type application/octet-stream;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ##</span><br><span class="line">    # Logging Settings</span><br><span class="line">    ##</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    access_log off;</span><br><span class="line">    error_log /var/log/nginx/error.log;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ##</span><br><span class="line">    # Gzip Settings</span><br><span class="line">    ##</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    gzip on;</span><br><span class="line">    gzip_disable &quot;msie6&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     gzip_vary on;</span><br><span class="line">     gzip_proxied any;</span><br><span class="line">     gzip_comp_level 9;</span><br><span class="line">     gzip_buffers 16 8k;</span><br><span class="line">     gzip_http_version 1.1;</span><br><span class="line">     gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ##</span><br><span class="line">    # nginx-naxsi config</span><br><span class="line">    ##</span><br><span class="line">    # Uncomment it if you installed nginx-naxsi</span><br><span class="line">    ##</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    #include /etc/nginx/naxsi_core.rules;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ##</span><br><span class="line">    # nginx-passenger config</span><br><span class="line">    ##</span><br><span class="line">    # Uncomment it if you installed nginx-passenger</span><br><span class="line">    ##</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    #passenger_root /usr;</span><br><span class="line">    #passenger_ruby /usr/bin/ruby;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ##</span><br><span class="line">    # Virtual Host Configs</span><br><span class="line">    ##</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    include /etc/nginx/conf.d/*.conf;</span><br><span class="line">    include /etc/nginx/sites-enabled/*;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># mail &#123;</span><br><span class="line">#   # See sample authentication script at:</span><br><span class="line">#   # http://wiki.nginx.org/ImapAuthenticateWithApachePhpScript</span><br><span class="line"># </span><br><span class="line">#   # auth_http localhost/auth.php;</span><br><span class="line">#   # pop3_capabilities &quot;TOP&quot; &quot;USER&quot;;</span><br><span class="line">#   # imap_capabilities &quot;IMAP4rev1&quot; &quot;UIDPLUS&quot;;</span><br><span class="line"># </span><br><span class="line">#   server &#123;</span><br><span class="line">#       listen     localhost:110;</span><br><span class="line">#       protocol   pop3;</span><br><span class="line">#       proxy      on;</span><br><span class="line">#   &#125;</span><br><span class="line"># </span><br><span class="line">#   server &#123;</span><br><span class="line">#       listen     localhost:143;</span><br><span class="line">#       protocol   imap;</span><br><span class="line">#       proxy      on;</span><br><span class="line">#   &#125;</span><br><span class="line">#&#125;</span><br></pre></td></tr></table></figure>


<h2 id="优化-Linux-最大连接数"><a href="#优化-Linux-最大连接数" class="headerlink" title="优化 - Linux 最大连接数"></a>优化 - Linux 最大连接数</h2><h3 id="查看-Linux-连接数"><a href="#查看-Linux-连接数" class="headerlink" title="查看 Linux 连接数"></a>查看 Linux 连接数</h3><p>默认配置下，Linux 只支持有限的连接数。<br>Linux 的线程其实是一个进程，所以 java 的也是，具体来说，叫做“light weight process(LWP)”—轻量级进程。<br>LWP 与其它进程共享所有（或大部分）逻辑地址空间和系统资源，一个进程可以创建多个 LWP，这样它们共享大部分资源；LWP 有它自己的进程标识符，并和其他进程有着父子关系；。LWP 由内核管理并像普通进程一样被调度<br>使用以下命令可以看到某个用户使用了多少进程资源</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -eLf | grep xjjbot(uid)  | wc -l</span><br></pre></td></tr></table></figure>
<p>使用下面命令可以查看具体每个进程开启了多少线程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -o nlwp,pid,lwp,args -u xjjbot(uid)  | sort -n</span><br></pre></td></tr></table></figure>

<p>根据 linux 一切都是文件的规则，首先想到的，是修改 ulimit 的参数，然而也不是，因为它已经足够大了。交叉回想一下 elasticsearch，在安装的时候，需要配置一个叫做 nproc 的东西，问题大概就出在这，是进程资源不够用啦。<br>相关的配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/security/limits.conf</span><br></pre></td></tr></table></figure>
<p>在不同的内核版本上，也有一些小差异。比如：&#x2F;etc&#x2F;security&#x2F;limits.d&#x2F;*<br>下的文件，会在某些时候覆盖 limits.conf 的配置。所以配置不生效的情况下，记得检查一下。<br>鉴于以上原因，可以将 limits.d 中的配置全部注释掉，统一在 limits.conf 中配置。<br>以下是原始配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*          soft    nproc     4096</span><br><span class="line">root       soft    nproc     unlimited</span><br></pre></td></tr></table></figure>
<p>将 4096 改为大点的数字，或者直接改成 unlimited 就可以了。</p>
<p>单机支持 100 万连接是可行的，但带宽问题会成为显著的瓶颈。启用压缩的二进制协议会节省部分带宽，但开发难度增加。</p>
<h3 id="操作系统优化"><a href="#操作系统优化" class="headerlink" title="操作系统优化"></a>操作系统优化</h3><p>更改进程最大文件句柄数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -n 1048576</span><br></pre></td></tr></table></figure>
<p>复制代码修改单个进程可分配的最大文件数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 2097152 &gt; /proc/sys/fs/nr_open</span><br></pre></td></tr></table></figure>
<p>复制代码修改&#x2F;etc&#x2F;security&#x2F;limits.conf 文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*   soft nofile  1048576</span><br><span class="line">*   hard nofile 1048576</span><br><span class="line">*   soft nproc unlimited</span><br><span class="line">root soft nproc unlimited</span><br></pre></td></tr></table></figure>
<p>复制代码记得清理掉&#x2F;etc&#x2F;security&#x2F;limits.d&#x2F;*下的配置</p>
<h3 id="网络优化"><a href="#网络优化" class="headerlink" title="网络优化"></a>网络优化</h3><p>打开&#x2F;etc&#x2F;sysctl.conf，添加配置然后执行，使用 sysctl 生效</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#单个进程可分配的最大文件数</span><br><span class="line">fs.nr_open=2097152</span><br><span class="line"></span><br><span class="line">#系统最大文件句柄数</span><br><span class="line">fs.file-max = 1048576</span><br><span class="line"></span><br><span class="line">#backlog 设置</span><br><span class="line">net.core.somaxconn=32768</span><br><span class="line">net.ipv4.tcp_max_syn_backlog=16384</span><br><span class="line">net.core.netdev_max_backlog=16384</span><br><span class="line"></span><br><span class="line">#可用知名端口范围配置</span><br><span class="line">net.ipv4.ip_local_port_range=&#x27;1000 65535&#x27;</span><br><span class="line"></span><br><span class="line">#TCP Socket 读写 Buffer 设置</span><br><span class="line">net.core.rmem_default=262144</span><br><span class="line">net.core.wmem_default=262144</span><br><span class="line">net.core.rmem_max=16777216</span><br><span class="line">net.core.wmem_max=16777216</span><br><span class="line">net.core.optmem_max=16777216</span><br><span class="line">net.ipv4.tcp_rmem=&#x27;1024 4096 16777216&#x27;</span><br><span class="line">net.ipv4.tcp_wmem=&#x27;1024 4096 16777216&#x27;</span><br><span class="line"></span><br><span class="line">#TCP 连接追踪设置</span><br><span class="line">net.nf_conntrack_max=1000000</span><br><span class="line">net.netfilter.nf_conntrack_max=1000000</span><br><span class="line">net.netfilter.nf_conntrack_tcp_timeout_time_wait=30</span><br><span class="line"></span><br><span class="line">#TIME-WAIT Socket 最大数量、回收与重用设置</span><br><span class="line">net.ipv4.tcp_max_tw_buckets=1048576</span><br><span class="line"></span><br><span class="line"># FIN-WAIT-2 Socket 超时设置</span><br><span class="line">net.ipv4.tcp_fin_timeout = 15</span><br></pre></td></tr></table></figure>



<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a target="_blank" rel="noopener" href="https://www.shiyanlou.com/courses/95">Linux Web 运维（Nginx）实战</a></li>
<li><a target="_blank" rel="noopener" href="http://tengine.taobao.org/book/index.html">Nginx 开发从入门到精通</a></li>
<li><a target="_blank" rel="noopener" href="http://nginx.org/en/docs/">nginx documentation</a></li>
</ol>
<h3 id="config"><a href="#config" class="headerlink" title="config"></a>config</h3><p>nginx.conf配置文件详解 <a target="_blank" rel="noopener" href="http://www.ha97.com/5194.html">http://www.ha97.com/5194.html</a><br>更多配置技巧 <a target="_blank" rel="noopener" href="https://www.nginx.com/resources/wiki/start/">https://www.nginx.com/resources/wiki/start/</a></p>
<h3 id="Nginx-原理"><a href="#Nginx-原理" class="headerlink" title="Nginx 原理"></a>Nginx 原理</h3><ol>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/q/1010000003901360?_ea=416091">Nginx 内部有使用多线程吗？</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/63179839">如果这篇文章说不清 epoll 的本质，那就过来掐死我吧！ （1）</a></li>
</ol>
<h3 id="模块-1"><a href="#模块-1" class="headerlink" title="模块"></a>模块</h3><ol>
<li>log<br><a target="_blank" rel="noopener" href="http://nginx.org/en/docs/http/ngx_http_log_module.html">Module ngx_http_log_module</a><br><a target="_blank" rel="noopener" href="http://nginx.org/en/docs/stream/ngx_stream_log_module.html#log_format">Module ngx_stream_log_module</a><br><a target="_blank" rel="noopener" href="http://blog.chinaunix.net/uid-29179844-id-4433640.html">nginx 日志格式及自定义日志配置</a></li>
<li>proxy<br><a target="_blank" rel="noopener" href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html">Module ngx_http_proxy_module</a></li>
<li>TCP &#x2F; UDP<br><a target="_blank" rel="noopener" href="http://nginx.org/en/docs/stream/stream_processing.html">How nginx processes a TCP&#x2F;UDP session</a></li>
</ol>
<h3 id="Tengine"><a href="#Tengine" class="headerlink" title="Tengine"></a>Tengine</h3><ol>
<li><a target="_blank" rel="noopener" href="http://tengine.taobao.org/documentation.html">Documentation</a></li>
</ol>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/15/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><span class="page-number current">16</span><a class="page-number" href="/page/17/">17</a><span class="space">&hellip;</span><a class="page-number" href="/page/19/">19</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/17/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">tallate</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/tallate" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"version":"7.1.2","options":null,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.3.0/mermaid.min.js","integrity":"sha256-9y71g5Lz/KLsHjB8uXwnkuWDtAMDSzD/HdIbqhJfTAI="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>





  





</body>
</html>
