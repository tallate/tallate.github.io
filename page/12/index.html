<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"tallate.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.18.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Tallate">
<meta property="og:url" content="https://tallate.github.io/page/12/index.html">
<meta property="og:site_name" content="Tallate">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="tallate">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://tallate.github.io/page/12/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/12/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Tallate</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Tallate</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">该吃吃该喝喝 啥事别往心里搁</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签<span class="badge">80</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="th fa-fw"></i>分类<span class="badge">25</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档<span class="badge">187</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">tallate</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">187</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">80</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/1a8406e8.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tallate">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tallate">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/1a8406e8.html" class="post-title-link" itemprop="url">并发和并发安全容器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-09-12 22:12:49" itemprop="dateCreated datePublished" datetime="2019-09-12T22:12:49+08:00">2019-09-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-07 01:56:20" itemprop="dateModified" datetime="2025-07-07T01:56:20+08:00">2025-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>


<h1 id="无锁栈"><a href="#无锁栈" class="headerlink" title="无锁栈"></a>无锁栈</h1><h2 id="Treiber-Stack"><a href="#Treiber-Stack" class="headerlink" title="Treiber Stack"></a>Treiber Stack</h2><h1 id="无锁列表"><a href="#无锁列表" class="headerlink" title="无锁列表"></a>无锁列表</h1><h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><p>CopyOnWriteArrayList 是一个线程安全的 ArrayList，对其进行的修改操作和元素迭代操作都是在底层创建一个拷贝的数组（快照）上进行的，也就是写时拷贝策略。CopyOnWriteArrayList 适合读多写少的场景，但如果应用在写操作频繁的场景下反而会降低性能。<br><img src="/imgs/%E5%B9%B6%E5%8F%91/CopyOnWriteArrayList%E7%B1%BB%E5%9B%BE.png" alt="CopyOnWriteArrayList类图" title="CopyOnWriteArrayList类图"></p>
<ul>
<li>lock：保证写操作时的并发安全；</li>
</ul>
<h3 id="add-E-e"><a href="#add-E-e" class="headerlink" title="add(E e)"></a>add(E e)</h3><p>添加操作拷贝了份快照，在快照上添加元素，最后替代原数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line"></span><br><span class="line">    // 加独占锁</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        // 获取array</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line"></span><br><span class="line">        // 拷贝array到新数组，添加元素到新数组</span><br><span class="line">        // 新数组长度是原数组长度+1，可见CopyOnWriteArrayList是无界的</span><br><span class="line">        int len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + 1);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line"></span><br><span class="line">        // 使用新数组替换添加前的数组</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        return true;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // 释放独占锁</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="get-int-index"><a href="#get-int-index" class="headerlink" title="get(int index)"></a>get(int index)</h3><p>get 操作获取下标处的元素，实际上 get 可以被分解为以下两个步骤：</p>
<ol>
<li>获取 array 的引用；</li>
<li>通过下标访问 array 指定位置的元素。</li>
</ol>
<p>整个过程并没有加锁，如果在访问期间有另一个线程删除了某个元素，实际上因为修改操作是发生在原数组的一个快照上的，get 操作仍然获取的是原数组上的元素，因此不会发生类似数组越界的问题。但同时也不可避免这个过程带来的<strong>弱一致性</strong>，因为元素事实上已经被删除了却仍然可以被访问到。</p>
<h3 id="set-int-index-E-element"><a href="#set-int-index-E-element" class="headerlink" title="set(int index, E element)"></a>set(int index, E element)</h3><p>修改 list 中指定元素的值。</p>
<ul>
<li>如果指定位置的元素不存在则抛出 IndexOutOfBoundsException 异常；</li>
<li>如果指定位置元素与新值不一致，则创建新数组、在新数组上修改，最后设置新数组到 array（COW）。</li>
<li>即使没有变化，也还是需要重新设置一次 array，这主要是因为 array 本身是 volatile 的，set 方法应当提供 volatile 的语义。</li>
</ul>
<h3 id="remove-int-index"><a href="#remove-int-index" class="headerlink" title="remove(int index)"></a>remove(int index)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public E remove(int index) &#123;</span><br><span class="line"></span><br><span class="line">    //获取独占锁</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line"></span><br><span class="line">        //获取数组</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        int len = elements.length;</span><br><span class="line"></span><br><span class="line">        //获取指定元素</span><br><span class="line">        E oldValue = get(elements, index);</span><br><span class="line">        int numMoved = len - index - 1;</span><br><span class="line"></span><br><span class="line">        //如果要删除的是最后一个元素</span><br><span class="line">        if (numMoved == 0)</span><br><span class="line">            setArray(Arrays.copyOf(elements, len - 1));</span><br><span class="line">        else &#123;</span><br><span class="line">            //分两次拷贝除删除后的元素到新数组</span><br><span class="line">            Object[] newElements = new Object[len - 1];</span><br><span class="line">            System.arraycopy(elements, 0, newElements, 0, index);</span><br><span class="line">            System.arraycopy(elements, index + 1, newElements, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">            //使用新数组代替老的                </span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125;</span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        //释放锁</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="remove-Object-o"><a href="#remove-Object-o" class="headerlink" title="remove(Object o)"></a>remove(Object o)</h3><h3 id="remove-Object-o-Object-snapshot-int-index"><a href="#remove-Object-o-Object-snapshot-int-index" class="headerlink" title="remove(Object o, Object[] snapshot, int index)"></a>remove(Object o, Object[] snapshot, int index)</h3><h3 id="iterator"><a href="#iterator" class="headerlink" title="iterator"></a>iterator</h3><p>CopyOnWriteArrayList 中的 iterator 是弱一致性的，其他线程的修改操作对 iterator 不可见的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public Iterator&lt;E&gt; iterator() &#123;</span><br><span class="line">    return new COWIterator&lt;E&gt;(getArray(), 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static final class COWIterator&lt;E&gt; implements ListIterator&lt;E&gt; &#123;</span><br><span class="line">    //array的快照版本</span><br><span class="line">    private final Object[] snapshot;</span><br><span class="line"></span><br><span class="line">    //数组下标</span><br><span class="line">    private int cursor;</span><br><span class="line"></span><br><span class="line">    //构造函数</span><br><span class="line">    private COWIterator(Object[] elements, int initialCursor) &#123;</span><br><span class="line">        cursor = initialCursor;</span><br><span class="line">        snapshot = elements;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //是否遍历结束</span><br><span class="line">    public boolean hasNext() &#123;</span><br><span class="line">        return cursor &lt; snapshot.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取元素</span><br><span class="line">    public E next() &#123;</span><br><span class="line">        if (! hasNext())</span><br><span class="line">            throw new NoSuchElementException();</span><br><span class="line">        return (E) snapshot[cursor++];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果在该线程使用返回的迭代器遍历元素的过程中，其它线程没有对 list 进行增删改，那么 snapshot 本身就是 list 的 array，因为它们是引用关系。</li>
<li>如果在遍历期间存在其他线程对 list 的增删改操作，那么 snapshot 会成为原 array 的快照，此时其他线程对 list 进行的增删改是不可见的，因为它们操作的是两个不同的数组。</li>
</ul>
<h1 id="无锁队列"><a href="#无锁队列" class="headerlink" title="无锁队列"></a>无锁队列</h1><h2 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h2><ul>
<li>线程安全</li>
<li>无界</li>
<li>非阻塞</li>
</ul>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p><img src="/imgs/%E5%B9%B6%E5%8F%91/ConcurrentLinkedQueue%E7%B1%BB%E5%9B%BE.png" alt="ConcurrentLinkedQueue类图" title="ConcurrentLinkedQueue类图"></p>
<ul>
<li>底层队列使用单向链表实现。</li>
<li>两个volatile的Node节点（head和tail）分别存放队列的首尾节点，从下面无参构造函数可知默认头尾节点都是指向 item 为 null 的哨兵节点。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public ConcurrentLinkedQueue() &#123;</span><br><span class="line">    head = tail = new Node(null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Node节点内部为一个volatile修饰的变量item用来存放节点的值，next用来存放链表的下一个节点，从而链接成一个单向无界链表，如下图所示：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/ConcurrentLinkedQueue%E7%9A%84%E9%98%9F%E5%88%97%E7%BB%93%E6%9E%84.png" alt="ConcurrentLinkedQueue的队列结构" title="ConcurrentLinkedQueue的队列结构"></li>
<li>入队和出队操作使用CAS来实现线程安全。</li>
</ul>
<h3 id="入队-offer"><a href="#入队-offer" class="headerlink" title="入队 - offer"></a>入队 - offer</h3><p>offer操作在队列末尾添加一个元素：</p>
<ul>
<li>如果传入的是null，抛出NPE，表明ConcurrentLinkedQueue是不允许插入null值的；</li>
<li>其他情况下插入任何元素都会返回true，因为该队列是无界队列；</li>
<li>使用CAS操作实现线程安全<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    final Node&lt;E&gt; newNode = new Node&lt;E&gt;(e);</span><br><span class="line">    // 从尾节点进行插入</span><br><span class="line">    for (Node&lt;E&gt; t = tail, p = t;;) &#123;</span><br><span class="line">        Node&lt;E&gt; q = p.next;</span><br><span class="line">        </span><br><span class="line">        // 如果q==null说明p是尾节点，则执行插入</span><br><span class="line">        // （1）</span><br><span class="line">        if (q == null) &#123;</span><br><span class="line">            // 使用CAS设置p节点的next节点</span><br><span class="line">            if (p.casNext(null, newNode)) &#123;</span><br><span class="line">                // cas成功，则说明新增节点已经被放入链表，然后设置当前尾节点</span><br><span class="line">                if (p != t)</span><br><span class="line">                    casTail(t, newNode); // Failure is OK.</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // （2）</span><br><span class="line">        else if (p == q)</span><br><span class="line">            // 多线程操作时候，由于poll操作移除元素后有可能会把head变为自引用，然后head的next变为新head，所以这里需要</span><br><span class="line">            // 重新找新的head，因为新的head后面的节点才是正常的节点。</span><br><span class="line">            p = (t != (t = tail)) ? t : head;</span><br><span class="line">        // （3）</span><br><span class="line">        else</span><br><span class="line">            // 寻找尾节点</span><br><span class="line">            p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
注意这里的循环体从队列尾部添加元素：</li>
</ul>
<ol>
<li>刚开始队列为空，代码（1）通过CAS替换p的下一个节点；<br>注意有一个哨兵节点null，刚开始队列的head和tail节点都是指向该哨兵节点，因此队列中至少都会有一个节点；</li>
<li>如果多个线程同时执行插入，总会有一个线程CAS时插入失败，这时会进入下一次循环<br><img src="/imgs/%E5%B9%B6%E5%8F%91/ConcurrentLinkedQueue%E6%8F%92%E5%85%A51.png" alt="ConcurrentLinkedQueue插入1" title="ConcurrentLinkedQueue插入1"><br>这时不满足（1）和（2）的条件，在代码（3）处会将q赋值给p<br><img src="/imgs/%E5%B9%B6%E5%8F%91/ConcurrentLinkedQueue%E6%8F%92%E5%85%A52.png" alt="ConcurrentLinkedQueue插入2" title="ConcurrentLinkedQueue插入2"><br>再到下一次循环时q就会移动到null，这时要么正常插入，要么又被别人通过CAS抢了。</li>
<li>代码（2）是在执行poll时可能出现的情况：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/ConcurrentLinkedQueue%E6%8F%92%E5%85%A53.png" alt="ConcurrentLinkedQueue插入3" title="ConcurrentLinkedQueue插入3"><br>此时由于t&#x3D;&#x3D;tail，所以p被赋值为head，然后继续循环插入元素。</li>
</ol>
<h3 id="出队-poll"><a href="#出队-poll" class="headerlink" title="出队 - poll"></a>出队 - poll</h3><p>poll 操作是在队列头部获取并且移除一个元素，如果队列为空则返回 null。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public E poll() &#123;</span><br><span class="line">    // goto标记</span><br><span class="line">    restartFromHead:</span><br><span class="line"></span><br><span class="line">    // （1）无限循环</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        for (Node&lt;E&gt; h = head, p = h, q;;) &#123;</span><br><span class="line">            // 获取当前队头节点</span><br><span class="line">            E item = p.item;</span><br><span class="line"></span><br><span class="line">            // （2）当前节点有值则cas变为null</span><br><span class="line">            if (item != null &amp;&amp; p.casItem(item, null)) &#123;</span><br><span class="line">                //（6）cas成功标志当前节点以及从链表中移除</span><br><span class="line">                if (p != h) </span><br><span class="line">                    updateHead(h, ((q = p.next) != null) ? q : p);</span><br><span class="line">                return item;</span><br><span class="line">            &#125;</span><br><span class="line">            // （3）当前队列为空则返回null</span><br><span class="line">            else if ((q = p.next) == null) &#123;</span><br><span class="line">                updateHead(h, p);</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            // （4）自引用了，则重新找新的队列头节点</span><br><span class="line">            else if (p == q)</span><br><span class="line">                continue restartFromHead;</span><br><span class="line">            // （5）</span><br><span class="line">            else</span><br><span class="line">                p = q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">final void updateHead(Node&lt;E&gt; h, Node&lt;E&gt; p) &#123;</span><br><span class="line">    if (h != p &amp;&amp; casHead(h, p))</span><br><span class="line">        h.lazySetNext(h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>刚开始队列是空的，内层循环代码（3）判断队列为空就直接返回null了；<br>这时updateHead执行时由于h等于p所以没有设置头节点，poll直接返回null。</li>
<li>如果执行到（3）时已经有其他线程调用了offer方法成功添加一个元素到队列末尾，这时q会指向新增元素的节点<br><img src="/imgs/%E5%B9%B6%E5%8F%91/ConcurrentLinkedQueue%E5%87%BA%E9%98%9F1.png" alt="ConcurrentLinkedQueue出队1" title="ConcurrentLinkedQueue出队1"><br>这时会进入（5），令p也指向新q。<br>然后在下一次循环时，进入代码（2），执行<code>p.casItem(item, null)</code>时会通过CAS操作设置头节点的值为null。<br>代码（6）处，此时h指向哨兵节点，而p指向队列头节点，这时将p设置为新的头节点（这时p里的值已经被清掉了是一个空节点）。<br>此时队列的状态为：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/ConcurrentLinkedQueue%E6%8F%92%E5%85%A53.png" alt="ConcurrentLinkedQueue插入3" title="ConcurrentLinkedQueue插入3"><br>这就是之前讲队列offer时的一种特殊情况。</li>
<li>自引用的情况<br>假设线程A已经执行到（2）将第一个节点值置为null，这时又有一个线程B开始执行poll操作，如下图所示：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/ConcurrentLinkedQueue%E5%87%BA%E9%98%9F2.png" alt="ConcurrentLinkedQueue出队2" title="ConcurrentLinkedQueue出队2"><br>然后线程 A 执行 updateHead 操作，执行完毕后线程 A 退出，这时候队列状态为：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/ConcurrentLinkedQueue%E5%87%BA%E9%98%9F3.png" alt="ConcurrentLinkedQueue出队3" title="ConcurrentLinkedQueue出队3"><br>然后线程 B 继续执行代码（3）q&#x3D;p.next由于该节点是自引用节点所以p&#x3D;&#x3D;q所以会执行代码（4）跳到外层循环 restartFromHead，重新获取当前队列队头 head, 现在状态为：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/ConcurrentLinkedQueue%E5%87%BA%E9%98%9F4.png" alt="ConcurrentLinkedQueue出队4" title="ConcurrentLinkedQueue出队4"></li>
</ol>
<h2 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h2><p>offer是不会阻塞的，如果满了直接返回：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        // 如果已经超过容量阈值，则直接返回false</span><br><span class="line">        if (count == items.length)</span><br><span class="line">            return false;</span><br><span class="line">        else &#123;</span><br><span class="line">            enqueue(e);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void enqueue(E x) &#123;</span><br><span class="line">    // assert lock.getHoldCount() == 1;</span><br><span class="line">    // assert items[putIndex] == null;</span><br><span class="line">    final Object[] items = this.items;</span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">    // 把它看成一个循环数组，如果超出范围就卷回</span><br><span class="line">    if (++putIndex == items.length)</span><br><span class="line">        putIndex = 0;</span><br><span class="line">    count++;</span><br><span class="line">    // 唤醒这个Condition，必须是在加了锁的前提下才能使用</span><br><span class="line">    notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>poll同样也不会阻塞，如果空了直接返回null：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public E poll() &#123;</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        return (count == 0) ? null : dequeue();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private E dequeue() &#123;</span><br><span class="line">    // assert lock.getHoldCount() == 1;</span><br><span class="line">    // assert items[takeIndex] != null;</span><br><span class="line">    final Object[] items = this.items;</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    E x = (E) items[takeIndex];</span><br><span class="line">    items[takeIndex] = null;</span><br><span class="line">    // 回卷</span><br><span class="line">    if (++takeIndex == items.length)</span><br><span class="line">        takeIndex = 0;</span><br><span class="line">    count--;</span><br><span class="line">    if (itrs != null)</span><br><span class="line">        itrs.elementDequeued();</span><br><span class="line">    // 唤醒</span><br><span class="line">    notFull.signal();</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>put操作会等待notFull这个条件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void put(E e) throws InterruptedException &#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    try &#123;</span><br><span class="line">        while (count == items.length)</span><br><span class="line">            notFull.await();</span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>take操作同理，会等待notEmpty这个条件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public E take() throws InterruptedException &#123;</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    try &#123;</span><br><span class="line">        while (count == 0)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        return dequeue();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h2><p>LinkedBlockingQueue 内部是通过单向链表实现，使用头尾节点来进行入队和出队操作，也就是入队操作都是对尾节点进行操作，出队操作都是对头节点进行操作，而头尾节点的操作分别使用了单独的<strong>独占锁</strong>保证了原子性，所以出队和入队操作是可以同时进行的。另外头尾节点的独占锁都配备了一个条件队列，用来存放被阻塞的线程，并结合入队出队操作实现了一个生产消费模型。</p>
<h2 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h2><h2 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h2><h2 id="LinkedTransferQueue"><a href="#LinkedTransferQueue" class="headerlink" title="LinkedTransferQueue"></a>LinkedTransferQueue</h2><h2 id="队列比较"><a href="#队列比较" class="headerlink" title="队列比较"></a>队列比较</h2><h2 id="Disruptor"><a href="#Disruptor" class="headerlink" title="Disruptor"></a>Disruptor</h2><ul>
<li><p>无锁内存队列</p>
</li>
<li><p>优化 CPU 伪共享</p>
</li>
<li><p>RingBuffer<br>环形队列，使用定长数组存储，长度是 2^N，可以使用位运算提升性能。<br>无锁：无锁设计减少了竞争。<br>预热：预先填充好任务&#x2F;事件，不需要像链表那样每次添加&#x2F;删除节点时去创建&#x2F;回收节点，从而可以避免一定的垃圾回收。<br>缓存行填充解决了 CPU 伪共享问题。</p>
</li>
<li><p>WorkPool<br>存储 WorkProcessor 的池子，Disruptor 可以通过 Executor 并发启动每一个 WorkProcessor</p>
</li>
<li><p>WorkProcessor<br>从 RindBuffer 消费事件&#x2F;任务，并交由 WorkHandler 处理。</p>
</li>
<li><p>WorkHandler<br>处理任务的工作者，根据任务类型委托给不同的 EventHandler。</p>
</li>
</ul>
<h2 id="Logback-框架中异步日志打印中-ArrayBlockingQueue-的使用"><a href="#Logback-框架中异步日志打印中-ArrayBlockingQueue-的使用" class="headerlink" title="Logback 框架中异步日志打印中 ArrayBlockingQueue 的使用"></a>Logback 框架中异步日志打印中 ArrayBlockingQueue 的使用</h2><p>异步模型是业务线程把要打印的日志任务写入一个队列后直接返回，然后使用一个线程专门负责从队列中获取日志任务写入磁盘，对用户线程来说，耗时只有将数据写入队列中。</p>
<h1 id="并发安全-Map"><a href="#并发安全-Map" class="headerlink" title="并发安全 Map"></a>并发安全 Map</h1><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p><img src="/imgs/%E5%B9%B6%E5%8F%91/ConcurrentHashMap%E7%BB%93%E6%9E%84.png" alt="ConcurrentHashMap结构" title="ConcurrentHashMap结构"></p>
<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>代码：java.util.concurrent.ConcurrentHashMap.get</p>
<ol>
<li>计算 key 的散列值，可以使用该散列值定位到散列表中的某个槽。<br>如果 key 是自定义类型对象，需要实现重写 hash 方法。</li>
<li>找到对象<br>hash 值是不精确匹配的，hash 值的关键是计算简单而且有一定的区分度，比如取 string 的前 3 位的和作为 hash 值。<br>要精确匹配需要使用对象的 equals 方法。<br>ConcurrentHashMap 中哈希槽的实现方法有两种：链表和红黑树，链表和红黑树的查找过程就不必细说了。</li>
</ol>
<h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><p><img src="/imgs/%E5%B9%B6%E5%8F%91/ConcurrentHashMap%E7%9A%84put%E6%93%8D%E4%BD%9C.png" alt="ConcurrentHashMap的put操作" title="ConcurrentHashMap的put操作"><br>代码：java.util.concurrent.ConcurrentHashMap.put</p>
<ol>
<li>hash</li>
<li>找对象<br>找对象过程与 get 的区别主要是 put 需要并发控制：<ul>
<li>如果槽是空的，则通过 CAS 直接赋值；</li>
<li>如果槽非空，则先用<code>synchronized</code>锁住槽，接下来根据槽的数据结构来插入节点，如果槽是链表，则遍历链表找该 Node 是否已存在，不存在的情况下插入到末尾，如果槽是红黑树，则通过二叉树的遍历找目标 Node，找不到的情况下插入到叶子并重新执行红黑平衡。</li>
</ul>
</li>
</ol>
<h3 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h3><p>扩容的触发条件与HashMap一致。<br>扩容流程大致上是：遍历哈希槽，对每个需要迁移的哈希槽进行<code>synchronized</code>加锁。<br>当扩容开始后，其他线程必须等扩容完成后才能工作，但其他线程也不是就一直阻塞等扩容完成，而是调用<code>helpTransfer</code>方法一起帮助进行扩容，实际上因为扩容的单位是哈希槽，因此多线程并发执行扩容并不会导致明显的冲突增加。</p>
<p>扩容入口：</p>
<ol>
<li>helpTransfer<br>写入操作时协助扩容，即判断hash节点是ForwardingNode则调用helpTransfer将</li>
<li>全量添加时，需要保证</li>
<li></li>
</ol>
<p>扩容代码：<br><code>java.util.concurrent.ConcurrentHashMap.transfer</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Moves and/or copies the nodes in each bin to new table. See</span><br><span class="line"> * above for explanation.</span><br><span class="line"> */</span><br><span class="line">private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) &#123;</span><br><span class="line">    int n = tab.length, stride;</span><br><span class="line">    if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; // subdivide range</span><br><span class="line">    // 创建一个新的两倍大小的新nextTab，将老tab中的元素迁移过去</span><br><span class="line">    if (nextTab == null) &#123;            // initiating</span><br><span class="line">        try &#123;</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; catch (Throwable ex) &#123;      // try to cope with OOME</span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line">    int nextn = nextTab.length;</span><br><span class="line">    // 标记节点</span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = new ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">    boolean advance = true;</span><br><span class="line">    boolean finishing = false; // to ensure sweep before committing nextTab</span><br><span class="line">    for (int i = 0, bound = 0;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; int fh;</span><br><span class="line">        while (advance) &#123;</span><br><span class="line">            int nextIndex, nextBound;</span><br><span class="line">            if (--i &gt;= bound || finishing)</span><br><span class="line">                advance = false;</span><br><span class="line">            else if ((nextIndex = transferIndex) &lt;= 0) &#123;</span><br><span class="line">                i = -1;</span><br><span class="line">                advance = false;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (U.compareAndSwapInt</span><br><span class="line">                     (this, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : 0))) &#123;</span><br><span class="line">                bound = nextBound;</span><br><span class="line">                i = nextIndex - 1;</span><br><span class="line">                advance = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            int sc;</span><br><span class="line">            if (finishing) &#123;</span><br><span class="line">                nextTable = null;</span><br><span class="line">                table = nextTab;</span><br><span class="line">                sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) &#123;</span><br><span class="line">                if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    return;</span><br><span class="line">                finishing = advance = true;</span><br><span class="line">                i = n; // recheck before commit</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果tab当前位置为null，则设置fwd节点</span><br><span class="line">        else if ((f = tabAt(tab, i)) == null)</span><br><span class="line">            advance = casTabAt(tab, i, null, fwd);</span><br><span class="line">        // 已经是fwd节点，则遍历下一个位置</span><br><span class="line">        else if ((fh = f.hash) == MOVED)</span><br><span class="line">            advance = true; // already processed</span><br><span class="line">        else &#123;</span><br><span class="line">        // tab当前位置已有节点，则加锁</span><br><span class="line">            synchronized (f) &#123;</span><br><span class="line">                if (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                    // 表示链表节点，如果是树节点则fh=-2</span><br><span class="line">                    if (fh &gt;= 0) &#123;</span><br><span class="line">                        // 头节点的hash值</span><br><span class="line">                        int runBit = fh &amp; n;</span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                        // 链表的下一节点p</span><br><span class="line">                        for (Node&lt;K,V&gt; p = f.next; p != null; p = p.next) &#123;</span><br><span class="line">                            // p节点的hash值</span><br><span class="line">                            int b = p.hash &amp; n;</span><br><span class="line">                            // 避免成环？</span><br><span class="line">                            if (b != runBit) &#123;</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (runBit == 0) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = null;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = null;</span><br><span class="line">                        &#125;</span><br><span class="line">                        for (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            int ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                            if ((ph &amp; n) == 0)</span><br><span class="line">                                ln = new Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            else</span><br><span class="line">                                hn = new Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line">                        // 将ln和hn转移到nextTab</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        原tab置为fwd，表示已经被转移了</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else if (f instanceof TreeBin) &#123;</span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = null, loTail = null;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = null, hiTail = null;</span><br><span class="line">                        int lc = 0, hc = 0;</span><br><span class="line">                        for (Node&lt;K,V&gt; e = t.first; e != null; e = e.next) &#123;</span><br><span class="line">                            int h = e.hash;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.val, null, null);</span><br><span class="line">                            if ((h &amp; n) == 0) &#123;</span><br><span class="line">                                if ((p.prev = loTail) == null)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                else</span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125;</span><br><span class="line">                            else &#123;</span><br><span class="line">                                if ((p.prev = hiTail) == null)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                else</span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                            (hc != 0) ? new TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                            (lc != 0) ? new TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="size"><a href="#size" class="headerlink" title="size"></a>size</h3><p>size操作返回的是一个不精确的值，因为进行统计的过程中，很有可能会有其他线程正在进行插入和删除操作。</p>
<p>1.8之前的size：</p>
<ol>
<li>遍历segments数组，将每个segment的count加起来作为总数，将modCount加起来作为修改总数；<br>modCount会在每次segment被修改时+1（只增不减），用于比较。</li>
<li>再做一遍遍历，将这次的modCount总数和上一次的比较，如果一致则计数准确直接返回，否则重试；</li>
<li>如果重试了2次都不行，则第三次会对segment加锁再统计。</li>
</ol>
<p>1.8之后，没有了分段锁，size不会每次都遍历segments统计，而是在更新时修改总数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public int size() &#123;</span><br><span class="line">    long n = sumCount();</span><br><span class="line">    return ((n &lt; 0L) ? 0 :</span><br><span class="line">            (n &gt; (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</span><br><span class="line">            (int)n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final long sumCount() &#123;</span><br><span class="line">    CounterCell[] as = counterCells; CounterCell a;</span><br><span class="line">    long sum = baseCount;</span><br><span class="line">    if (as != null) &#123;</span><br><span class="line">        for (int i = 0; i &lt; as.length; ++i) &#123;</span><br><span class="line">            if ((a = as[i]) != null)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从源码中可以看到，<code>ConcurrentHashMap#size</code>的结果就是：<br><code>baseCount + sum(counterCells)</code><br>其中：</p>
<ul>
<li>baseCount：计数，总数发生变化时通过CAS修改</li>
<li>counterCells：如果baseCount CAS修改失败，作为兜底，类似LongAdder的思路。</li>
</ul>
<p>put操作的末尾会调用addCount()更新baseCount的值，如果CAS修改失败了，则使用counterCells，如果CAS修改 counterCells失败了，则使用fullAddCount方法继续死循环操作，直到成功。</p>
<h1 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h1><ol>
<li><p>JUC 并发包中并发组件 CopyOnWriteArrayList 的实现原理，CopyOnWriteArrayList 是如何通过写时拷贝实现并发安全的 List？</p>
</li>
<li><p>什么是弱一致性？</p>
</li>
<li><p>说一下 ConcurrentHashMap。</p>
</li>
<li><p>ConcurrentHashMap 怎么实现并发安全？<br>相对 Hashtable 来说 ConcurrentHashMap 的锁粒度是更小的，Hashtable 中使用 synchronized 实现的一种方法级的悲观锁，相当于把整个散列表锁住了，不利于系统整体吞吐量的提升。<br>JDK1.7 中它使用的是一种分段锁来保证并发安全，是一种粒度较小的锁，写操作每次只锁住一个哈希槽，<br>JDK1.8 之后改为通过实现一种基于 CAS 的乐观锁来保证并发安全，当然，和 HashMap 一样，每个哈希槽在增长到一定程度后会自动转换为红黑树。</p>
</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/leesf456/p/5550043.html">【目录】JUC 集合框架目录</a></li>
<li><a target="_blank" rel="noopener" href="http://ifeve.com/disruptor/">并发框架 Disruptor 译文</a></li>
</ol>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/ba7cab3d.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tallate">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tallate">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/ba7cab3d.html" class="post-title-link" itemprop="url">并发安全容器-Queue</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-09-12 22:12:49" itemprop="dateCreated datePublished" datetime="2019-09-12T22:12:49+08:00">2019-09-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-07 01:56:20" itemprop="dateModified" datetime="2025-07-07T01:56:20+08:00">2025-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="并发安全容器（Queue）"><a href="#并发安全容器（Queue）" class="headerlink" title="并发安全容器（Queue）"></a>并发安全容器（Queue）</h2><h3 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h3><p>ConcurrentLinkedQueue 是线程安全的无界非阻塞队列，底层数据结构使用单向链表实现，入队和出队操作使用 CAS 来实现线程安全。<br>2.1 ConcurrentLinkedQueue 类图结构<br>先简单介绍下 ConcurrentLinkedQueue 的类图结构如下图：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192520988.png" alt="image.png"><br>如上类图 ConcurrentLinkedQueue 内部的队列是使用单向链表方式实现，其中两个 volatile 类型的 Node 节点分别用来存放队列的首尾节点。从下面无参构造函数可知默认头尾节点都是指向 item 为 null 的哨兵节点。<br>public ConcurrentLinkedQueue() {<br>   head &#x3D; tail &#x3D; new Node<E>(null);<br>}<br>Node 节点内部则维护一个 volatile 修饰的变量 item 用来存放节点的值，next 用来存放链表的下一个节点，从而链接为一个单向无界链表。<br>首先一个图来概况该队列构成，读者可以读完本节后在回头体会这个图：<img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192521208.png" alt="image.png"><br>2.2 ConcurrentLinkedQueue 原理介绍<br>本节主要介绍 ConcurrentLinkedQueue 的几个主要的方法的实现原理<br>2.2.1 offer 操作<br>offer 操作是在队列末尾添加一个元素，如果传递的参数是 null 则抛出 NPE 异常，否者由于 ConcurrentLinkedQueue 是无界队列该方法一直会返回 true。另外由于使用 CAS 无阻塞算法，该方法不会阻塞调用线程，下面具体看看实现原理。<br>public boolean offer(E e) {<br>    &#x2F;&#x2F;（1）e为null则抛出空指针异常<br>    checkNotNull(e);</p>
<p>   &#x2F;&#x2F;（2）构造Node节点<br>    final Node<E> newNode &#x3D; new Node<E>(e);</p>
<pre><code>//（3）从尾节点进行插入
for (Node&lt;E&gt; t = tail, p = t;;) &#123;

    Node&lt;E&gt; q = p.next;

    //（4）如果q==null说明p是尾节点，则执行插入
    if (q == null) &#123;

        //（5）使用CAS设置p节点的next节点
        if (p.casNext(null, newNode)) &#123;
            //（6）cas成功，则说明新增节点已经被放入链表，然后设置当前尾节点
            if (p != t)
                casTail(t, newNode);  // Failure is OK.
            return true;
        &#125;
    &#125;
    else if (p == q)//(7）
        //多线程操作时候，由于poll操作移除元素后有可能会把head变为自引用，然后head的next变为新head，所以这里需要
        //重新找新的head，因为新的head后面的节点才是正常的节点。
        p = (t != (t = tail)) ? t : head;
    else
        //（8） 寻找尾节点
        p = (p != t &amp;&amp; t != (t = tail)) ? t : q;
&#125;
</code></pre>
<p>}<br>上节类图结构时候谈到构造队列时候参构造函数创建了一个 item 为 null 的哨兵节点，并且 head 和 tail 都是指向这个节点，下面通过图形结合来讲解下 offer 操作的代码实现。<br>首先看下当一个线程调用 offer（item）时候情况：首先代码（1）对传参判断空检查，如果为 null 则抛出 NPE 异常，然后代码（2）则使用 item 作为构造函数参数创建了一个新的节点，代码（3）从队列尾部节点开始循环，意图是从队列尾部添加元素。<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192521263.png" alt="image.png"><br>上图是执行代码（4）时候队列的情况，这时候节点 p,t,head,tail 同时指向了 item 为 null 的哨兵节点，由于哨兵节点的 next 节点为 null, 所以这里 q 指向也是 null。<br>代码（4）发现q&#x3D;&#x3D;null则执行代码（5）通过 CAS 原子操作判断 p 节点的 next 节点是否为 null，如果为 null 则使用节点 newNode 替换 p 的 next 节点，然后执行代码（6）由于p&#x3D;&#x3D;t所以没有设置尾部节点，然后退出 offer 方法，这时候队列的状态图如下：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192521325.png" alt="image.png"><br>上面讲解的是一个线程调用 offer 方法的情况，如果多个线程同时调用，就会存在多个线程同时执行到代码（5），假设线程 A 调用 offer（item1), 线程 B 调用 offer(item2), 线程 A 和 B 同时执行到 p.casNext(null, newNode)。而 CAS 的比较并设置操作是原子性的，假设线程 A 先执行了比较设置操作则发现当前 p 的 next 节点确实是 null 则会原子性更新 next 节点为 newNode，这时候线程 B 也会判断 p 的 next 节点是否为 null，结果发现不是 null（因为线程 A 已经设置了 p 的 next 为 newNode）则会跳到步骤（3），然后执行到步骤（4）时候队列分布图为：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192521398.png" alt="image.png"><br>根据这个状态图可知线程 B 会去执行代码（8），然后 q 赋值给了 p，这时候队列状态图为：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192521501.png" alt="image.png"><br>然后线程 B 再次跳转到代码（3）执行，当执行到代码（4）时候队列状态图为：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192521579.png" alt="image.png"><br>由于这时候 q&#x3D;&#x3D;null, 所以线程 B 会执行步骤（5），通过 CAS 操作判断当前 p 的 next 节点是否是 null，不是则再次循环后尝试，是则使用 newNode 替换，假设 CAS 成功了，那么执行步骤（6）由于 p!&#x3D;t 所以设置 tail 节点为 newNode，然后退出 offer 方法。这时候队列分布图为：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192521654.png" alt="image.png"><br>分析到现在，offer 代码的执行路径现在就差步骤（7）还没走过，其实这个要在执行 poll 操作后才会出现，这里先看下执行 poll 操作后可能会存在的的一种情况如下图：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192522328.png" alt="image.png"><br>下面分析下当队列处于这种状态时候调用 offer 添加元素代码执行到步骤（4）时候的状态图：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192521811.png" alt="image.png"><br>由于 q 节点不为空并且p&#x3D;&#x3D;q所以执行步骤（7），由于t&#x3D;&#x3D;tail所以 p 被赋值为了 head，然后进入循环，循环后执行到代码（4）时候队列状态为：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192521884.png" alt="image.png"><br>由于q&#x3D;&#x3D;null, 所以执行步骤（5）进行 CAS 操作，如果当前没有其他线程执行 offer 操作，则 CAS 操作会成功，p 的 next 节点被设置为新增节点，然后执行步骤（6），由于p!&#x3D;t所以设置新节点为队列为节点，现在队列状态如下：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192521955.png" alt="image.png"><br>这里自引用的节点会被垃圾回收掉。<br>总结：可见 offer 操作里面关键步骤是代码（5）通过原子 CAS 操作来进行控制同时只有一个线程可以追加元素到队列末尾，进行 cas 竞争失败的线程则会通过循环一次次尝试进行 cas 操作，直到 cas 成功才会返回，也就是通过使用无限循环里面不断进行 CAS 尝试方式来替代阻塞算法挂起调用线程，相比阻塞算法这是使用 CPU 资源换取阻塞所带来的开销。<br>2.2.2 poll 操作<br>poll 操作是在队列头部获取并且移除一个元素，如果队列为空则返回 null，下面看看实现原理。<br>public E poll() {<br>    &#x2F;&#x2F;(1) goto标记<br>    restartFromHead:</p>
<pre><code>//（2）无限循环
for (;;) &#123;
    for (Node&lt;E&gt; h = head, p = h, q;;) &#123;

        //（3）保存当前节点值
        E item = p.item;

        //（4）当前节点有值则cas变为null
        if (item != null &amp;&amp; p.casItem(item, null)) &#123;
            //（5）cas成功标志当前节点以及从链表中移除
            if (p != h) 
                updateHead(h, ((q = p.next) != null) ? q : p);
            return item;
        &#125;
        //（6）当前队列为空则返回null
        else if ((q = p.next) == null) &#123;
            updateHead(h, p);
            return null;
        &#125;
        //（7）自引用了，则重新找新的队列头节点
        else if (p == q)
            continue restartFromHead;
        else//(8）
            p = q;
    &#125;
&#125;
</code></pre>
<p> }<br>    final void updateHead(Node<E> h, Node<E> p) {<br>        if (h !&#x3D; p &amp;&amp; casHead(h, p))<br>            h.lazySetNext(h);<br>    }<br>同理本节也通过图形结合的方式来讲解代码执行逻辑：<br>poll 操作是从队头获取元素，所以代码（2）内层循环是从 head 节点开始迭代，代码（3）获取当前队头的节点，当队列一开始为空时候队列状态为：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192522032.png" alt="image.png"><br>由于 head 节点指向的为 item 为 null 的哨兵节点，所以会执行到代码（6），假设这个过程中没有线程调用 offer 方法，则此时 q 等于 null 如下图：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192522112.png" alt="image.png"><br>所以执行 updateHead 方法，由于 h 等于 p 所以没有设置头结点，poll 方法直接返回 null。<br>假设执行到代码（6）时候已经有其它线程调用了 offer 方法成功添加一个元素到队列，这时候 q 指向的是新增元素的节点，这时候队列状态为：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192522181.png" alt="image.png"><br>所以代码（6）判断结果为 false，然后会转向代码（7）执行，而此时 p 不等于 q，所以转向代码（8）执行，执行结果是 p 指向了节点 q，此时队列状态为：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192522254.png" alt="image.png"><br>然后程序转向代码（3）执行，p 现在指向的元素值不为 null，则执行p.casItem(item, null) 通过 CAS 操作尝试设置 p 的 item 值为 null，如果此时没有其它线程进行 poll 操作，CAS 成功则执行代码（5）由于此时 p!&#x3D;h 所以设置头结点为 p，poll 然后返回被从队列移除的节点值 item。此时队列状态为:<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192522328.png" alt="image.png"><br>这个状态就是讲解 offer 操作时候，offer 代码的执行路径（7）执行的前提状态。<br>假如现在一个线程调用了 poll 操作，则在执行代码（4) 时候队列状态为：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192522382.png" alt="image.png"><br>可知这时候执行代码（6）返回 null.<br>现在 poll 的代码还有个分支（7）没有执行过，那么什么时候会执行那？下面来看看，假设线程 A 执行 poll 操作时候当前队列状态为：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192522444.png" alt="image.png"><br>那么执行p.casItem(item, null) 通过 CAS 操作尝试设置 p 的 item 值为 null。<br>假设 CAS 设置成功则标示该节点从队列中移除了，此时队列状态为：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192522518.png" alt="image.png"><br>然后由于 p!&#x3D;h, 所以会执行 updateHead 方法，假如线程 A 执行 updateHead 前另外一个线程 B 开始 poll 操作这时候线程 B 的 p 指向 head 节点，但是还没有执行到代码（6）这时候队列状态为：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192522583.png" alt="image.png"><br>然后线程 A 执行 updateHead 操作，执行完毕后线程 A 退出，这时候队列状态为：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192522663.png" alt="image.png"><br>然后线程 B 继续执行代码（6）q&#x3D;p.next由于该节点是自引用节点所以p&#x3D;&#x3D;q所以会执行代码（7）跳到外层循环 restartFromHead，重新获取当前队列队头 head, 现在状态为：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192522732.png" alt="image.png"><br>总结：poll 方法移除一个元素时候只是简单的使用 CAS 操作把当前节点的 item 值设置 null，然后通过重新设置头结点让该元素从队列里面摘除，被摘除的节点就成了孤立节点，这个节点会被在垃圾回收的时候会回收掉。另外执行分支中如果发现头节点被修改了要跳到外层循环重新获取新的头节点。<br>2.2.3 peek 操作<br>peek 操作是获取队列头部一个元素（只不获取不移除），如果队列为空则返回 null，下面看看实现原理。<br>public E peek() {<br>   &#x2F;&#x2F;(1)<br>    restartFromHead:<br>    for (;;) {<br>        for (Node<E> h &#x3D; head, p &#x3D; h, q;;) {<br>            &#x2F;&#x2F;(2)<br>            E item &#x3D; p.item;<br>            &#x2F;&#x2F;(3)<br>            if (item !&#x3D; null || (q &#x3D; p.next) &#x3D;&#x3D; null) {<br>                updateHead(h, p);<br>                return item;<br>            }<br>            &#x2F;&#x2F;(4)<br>            else if (p &#x3D;&#x3D; q)<br>                continue restartFromHead;<br>            else<br>            &#x2F;&#x2F;(5)<br>                p &#x3D; q;<br>        }<br>    }<br>}<br>代码结构与 poll 操作类似，不同在于步骤（3）的使用只是少了 castItem 操作，其实这很正常，因为 peek 只是获取队列头元素值并不清空其值，根据前面我们知道第一次执行 offer 后 head 指向的是哨兵节点（也就是 item 为 null 的节点），那么第一次 peek 时候代码（3）中会发现 item&#x3D;&#x3D;null, 然后会执行 q &#x3D; p.next, 这时候 q 节点指向的才是队列里面第一个真正的元素或者如果队列为 null 则 q 指向 null。<br>当队列为空时候这时候队列状态为：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192522799.png" alt="image.png"><br>这时候执行 updateHead 由于 h 节点等于 p 节点所以不进行任何操作，然后 peek 操作会返回 null。<br>当队列至少有一个元素时候（这里假设只有一个）这时候队列状态为：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192522872.png" alt="image.png"><br>这时候执行代码（5）这时候 p 指向了 q 节点，然后执行代码（3）这时候队列状态为：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192522963.png" alt="image.png"><br>执行代码（3）发现 item 不为 null，则执行 updateHead 方法，由于 h!&#x3D;p, 所以设置头结点，设置后队列状态为：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192523042.png" alt="image.png"><br>也就是剔除了哨兵节点。<br>总结：peek 操作代码与 poll 操作类似只是前者只获取队列头元素但是并不从队列里面删除，而后者获取后需要从队列里面删除，另外在第一次调用 peek 操作时候，会删除哨兵节点，并让队列的 head 节点指向队列里面第一个元素或者 null。<br>2.2.4 size 操作<br>获取当前队列元素个数，在并发环境下不是很有用，因为 CAS 没有加锁所以从调用 size 函数到返回结果期间有可能增删元素，导致统计的元素个数不精确。<br>public int size() {<br>    int count &#x3D; 0;<br>    for (Node<E> p &#x3D; first(); p !&#x3D; null; p &#x3D; succ(p))<br>        if (p.item !&#x3D; null)<br>            &#x2F;&#x2F; 最大返回Integer.MAX_VALUE<br>            if (++count &#x3D;&#x3D; Integer.MAX_VALUE)<br>                break;<br>    return count;<br>}</p>
<p>&#x2F;&#x2F;获取第一个队列元素（哨兵元素不算），没有则为null<br>Node<E> first() {<br>    restartFromHead:<br>    for (;;) {<br>        for (Node<E> h &#x3D; head, p &#x3D; h, q;;) {<br>            boolean hasItem &#x3D; (p.item !&#x3D; null);<br>            if (hasItem || (q &#x3D; p.next) &#x3D;&#x3D; null) {<br>                updateHead(h, p);<br>                return hasItem ? p : null;<br>            }<br>            else if (p &#x3D;&#x3D; q)<br>                continue restartFromHead;<br>            else<br>                p &#x3D; q;<br>        }<br>    }<br>}</p>
<p>&#x2F;&#x2F;获取当前节点的next元素，如果是自引入节点则返回真正头节点<br>final Node<E> succ(Node<E> p) {<br>    Node<E> next &#x3D; p.next;<br>    return (p &#x3D;&#x3D; next) ? head : next;<br>}<br>2.2.5 remove 操作<br>如果队列里面存在该元素则删除给元素，如果存在多个则删除第一个，并返回 true，否者返回 false<br>public boolean remove(Object o) {</p>
<pre><code>//查找元素为空，直接返回false
if (o == null) return false;
Node&lt;E&gt; pred = null;
for (Node&lt;E&gt; p = first(); p != null; p = succ(p)) &#123;
    E item = p.item;

    //相等则使用cas值null,同时一个线程成功，失败的线程循环查找队列中其它元素是否有匹配的。
    if (item != null &amp;&amp;
        o.equals(item) &amp;&amp;
        p.casItem(item, null)) &#123;

        //获取next元素
        Node&lt;E&gt; next = succ(p);

        //如果有前驱节点，并且next不为空则链接前驱节点到next,
        if (pred != null &amp;&amp; next != null)
            pred.casNext(p, next);
        return true;
    &#125;
    pred = p;
&#125;
return false;
</code></pre>
<p>}<br>注：ConcurrentLinkedQueue 底层使用单向链表数据结构来保存队列元素，每个元素被包装为了一个 Node 节点，队列是靠头尾节点来维护的，创建队列时候头尾节点指向一个 item 为 null 的哨兵节点，第一次 peek 或者 first 时候会把 head 指向第一个真正的队列元素。由于使用非阻塞 CAS 算法，没有加锁，所以获取 size 的时候有可能进行了 offer，poll 或者 remove 操作，导致获取的元素个数不精确，所以在并发情况下 size 函数不是很有用。</p>
<h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><p>前面介绍了使用 CAS 算法实现的非阻塞队列 ConcurrentLinkedQueue，下面就来介绍下使用独占锁实现的阻塞队列 LinkedBlockingQueue 的实现<br>3.1 LinkedBlockingQueue 类图结构<br>同理首先看下 LinkedBlockingQueue 的类图结构<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192523099.png" alt="image.png"><br>如上类图可知 LinkedBlockingQueue 也是使用单向链表实现，也有两个 Node 分别用来存放首尾节点，并且里面有个初始值为 0 的原子变量 count 用来记录队列元素个数。另外里面有两个 ReentrantLock 的实例，分别用来控制元素入队和出队的原子性，其中 takeLock 用来控制同时只有一个线程可以从队列获取元素，其它线程必须等待，putLock 控制同时只能有一个线程可以获取锁去添加元素，其它线程必须等待。另外 notEmpty 和 notFull 是信号量，内部分别有一个条件队列用来存放进队和出队时候被阻塞的线程，其实这个是个生产者 - 消费者模型。如下是独占锁创建代码：<br>    &#x2F;** 执行take, poll等操作时候需要获取该锁 *&#x2F;<br>    private final ReentrantLock takeLock &#x3D; new ReentrantLock();</p>
<pre><code>/** 当队列为空时候执行出队操作（比如take）的线程会被放入这个条件队列进行等待 */
private final Condition notEmpty = takeLock.newCondition();

/** 执行put, offer等操作时候需要获取该锁*/
private final ReentrantLock putLock = new ReentrantLock();

/**当队列满时候执行进队操作（比如put)的线程会被放入这个条件队列进行等待 */
private final Condition notFull = putLock.newCondition();
</code></pre>
<p> &#x2F;** 当前队列元素个数 *&#x2F;<br>    private final AtomicInteger count &#x3D; new AtomicInteger(0);<br>如下是 LinkedBlockingQueue 无参构造函数代码：<br>public static final int   MAX_VALUE &#x3D; 0x7fffffff;</p>
<p>public LinkedBlockingQueue() {<br>    this(Integer.MAX_VALUE);<br>}</p>
<p>  public LinkedBlockingQueue(int capacity) {<br>    if (capacity &lt;&#x3D; 0) throw new IllegalArgumentException();<br>    this.capacity &#x3D; capacity;<br>    &#x2F;&#x2F;初始化首尾节点,指向哨兵节点<br>    last &#x3D; head &#x3D; new Node<E>(null);<br>}<br>从代码可知默认队列容量为 0x7fffffff; 用户也可以自己指定容量，所以一定程度上 LinkedBlockingQueue 可以说是有界阻塞队列。<br>首先使用一个图来概况该队列，读者在读完本节后在回头体会下:<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192523218.png" alt="image.png"><br>3.2 LinkedBlockingQueue 原理介绍<br>3.2.1 offer 操作<br>向队列尾部插入一个元素，如果队列有空闲容量则插入成功后返回 true，如果队列已满则丢弃当前元素然后返回 false，如果 e 元素为 null 则抛出 NullPointerException 异常，另外该方法是非阻塞的。<br>    public boolean offer(E e) {</p>
<pre><code>    //（1）空元素抛空指针异常
    if (e == null) throw new NullPointerException();

    //(2) 如果当前队列满了则丢弃将要放入的元素，然后返回false
    final AtomicInteger count = this.count;
    if (count.get() == capacity)
        return false;

    //(3) 构造新节点，获取putLock独占锁
    int c = -1;
    Node&lt;E&gt; node = new Node&lt;E&gt;(e);
    final ReentrantLock putLock = this.putLock;
    putLock.lock();
    try &#123;
        //(4)如果队列不满则进队列，并递增元素计数
        if (count.get() &lt; capacity) &#123;
            enqueue(node);
            c = count.getAndIncrement();
            //(5)
            if (c + 1 &lt; capacity)
                notFull.signal();
        &#125;
    &#125; finally &#123;
        //(6)释放锁
        putLock.unlock();
    &#125;
    //(7)
    if (c == 0)
        signalNotEmpty();
    //(8)
    return c &gt;= 0;
&#125;
</code></pre>
<p>private void enqueue(Node<E> node) {<br> last &#x3D; last.next &#x3D; node;<br>}<br>步骤（2）判断如果当前队列已满则丢弃当前元素并返回 false<br>步骤（3）获取到 putLock 锁，当前线程获取到该锁后，则其它调用 put 和 offer 的线程将会被阻塞（阻塞的线程被放到 putLock 锁的 AQS 阻塞队列）。<br>步骤（4）这里有重新判断了下当前队列是否满了，这是因为在执行代码（2）和获取到 putLock 锁期间可能其它线程通过 put 或者 offer 方法向队列里面添加了新元素。重新判断队列确实不满则新元素入队，并递增计数器。<br>步骤（5）判断如果新元素入队后队列还有空闲空间，则唤醒 notFull 的条件队列里面因为调用了 notFull 的 await 操作（比如执行 put 方法而队列满了的时候）而被阻塞的一个线程，因为队列现在有空闲所以这里可以提前唤醒一个入队线程。<br>代码（6) 则释放获取的 putLock 锁，这里要注意锁的释放一定要在 finally 里面做，因为即使 try 块抛异常了，finally 也是会被执行到的。另外释放锁后其它因为调用 put 和 offer 而被阻塞的线程将会有一个获取到该锁。<br>代码（7）c&#x3D;&#x3D;0 说明在执行代码（6）释放锁时候队列里面至少有一个元素，队列里面有元素则执行 signalNotEmpty，下面看看 signalNotEmpty 的代码：<br>    private void signalNotEmpty() {<br>        final ReentrantLock takeLock &#x3D; this.takeLock;<br>        takeLock.lock();<br>        try {<br>            notEmpty.signal();<br>        } finally {<br>            takeLock.unlock();<br>        }<br>    }<br>可知作用是激活 notEmpty 的条件队列中因为调用 notEmpty 的 await 方法（比如调用 take 方法并且队列为空的时候）而被阻塞的一个线程，这里也说明了调用条件变量的方法前要首先获取对应的锁。<br>综上可知 offer 方法中通过使用 putLock 锁保证了在队尾新增元素的原子性和队列元素个数的比较和递增操作的原子性。<br>3.2.2 put 操作<br>向队列尾部插入一个元素，如果队列有空闲则插入后直接返回 true，如果队列已满则阻塞当前线程直到队列有空闲插入成功后返回 true，如果在阻塞的时候被其它线程设置了中断标志，则被阻塞线程会抛出 InterruptedException 异常而返回，另外如果 e 元素为 null 则抛出 NullPointerException 异常。<br>put 操作的代码结构与 offer 操作类似，代码如下：<br>public void put(E e) throws InterruptedException {<br>        &#x2F;&#x2F;（1）空元素抛空指针异常<br>        if (e &#x3D;&#x3D; null) throw new NullPointerException();<br>        &#x2F;&#x2F;(2) 构建新节点，并获取独占锁putLock<br>        int c &#x3D; -1;<br>        Node<E> node &#x3D; new Node<E>(e);<br>        final ReentrantLock putLock &#x3D; this.putLock;<br>        final AtomicInteger count &#x3D; this.count;<br>        putLock.lockInterruptibly();<br>        try {<br>            &#x2F;&#x2F;(3)如果队列满则等待<br>            while (count.get() &#x3D;&#x3D; capacity) {<br>                notFull.await();<br>            }<br>            &#x2F;&#x2F;（4）进队列并递增计数<br>            enqueue(node);<br>            c &#x3D; count.getAndIncrement();<br>            &#x2F;&#x2F;(5)<br>            if (c + 1 &lt; capacity)<br>                notFull.signal();<br>        } finally {<br>            &#x2F;&#x2F;(6)<br>            putLock.unlock();<br>        }<br>        &#x2F;&#x2F;(7)<br>        if (c &#x3D;&#x3D; 0)<br>            signalNotEmpty();<br>    }<br>代码（2）中使用 putLock.lockInterruptibly() 获取独占锁，相比 offer 方法中这个获取独占锁方法意味着可以被中断，具体说是当前线程在获取锁的过程中，如果被其它线程设置了中断标志则当前线程会抛出 InterruptedException 异常，所以 put 操作在获取锁过程中是可被中断的。<br>代码（3）如果当前队列已满，则调用 notFull 的 await() 把当前线程放入 notFull 的条件队列，当前线程被阻塞挂起并释放获取到的 putLock 锁，由于 putLock 锁被释放了，所以现在其它线程就有机会获取到 putLock 锁了。<br>另外考虑下代码（3）判断队列是否为空为何使用 while 循环而不是 if 语句那？其实是考虑到当前线程被虚假唤醒的问题，也就是其它线程没有调用 notFull 的 singal 方法时候 notFull.await() 在某种情况下会自动返回。如果使用 if 语句那么虚假唤醒后会执行代码（4）元素入队，并且递增计数器，而这时候队列已经是满了的，导致队列元素个数大于了队列设置的容量，导致程序出错。而使用 while 循环假如 notFull.await() 被虚假唤醒了，那么循环在检查一下当前队列是否是满的，如果是则再次进行等待。<br>3.2.3 poll 操作<br>从队列头部获取并移除一个元素，如果队列为空则返回 null，该方法是不阻塞的。<br>    public E poll() {<br>        &#x2F;&#x2F;(1)队列为空则返回null<br>        final AtomicInteger count &#x3D; this.count;<br>        if (count.get() &#x3D;&#x3D; 0)<br>            return null;<br>        &#x2F;&#x2F;(2)获取独占锁<br>        E x &#x3D; null;<br>        int c &#x3D; -1;<br>        final ReentrantLock takeLock &#x3D; this.takeLock;<br>        takeLock.lock();<br>        try {<br>            &#x2F;&#x2F;(3)队列不空则出队并递减计数<br>            if (count.get() &gt; 0) {&#x2F;&#x2F;3.1<br>                x &#x3D; dequeue();&#x2F;&#x2F;3.2<br>                c &#x3D; count.getAndDecrement();&#x2F;&#x2F;3.3<br>                &#x2F;&#x2F;(4)<br>                if (c &gt; 1)<br>                    notEmpty.signal();<br>            }<br>        } finally {<br>            &#x2F;&#x2F;(5)<br>            takeLock.unlock();<br>        }<br>        &#x2F;&#x2F;(6)<br>        if (c &#x3D;&#x3D; capacity)<br>            signalNotFull();<br>        &#x2F;&#x2F;(7)返回<br>        return x;<br>    }<br>    private E dequeue() {<br>        Node<E> h &#x3D; head;<br>        Node<E> first &#x3D; h.next;<br>        h.next &#x3D; h; &#x2F;&#x2F; help GC<br>        head &#x3D; first;<br>        E x &#x3D; first.item;<br>        first.item &#x3D; null;<br>        return x;<br>    }<br>代码 (1) 如果当前队列为空，则直接返回 null<br>代码（2）获取独占锁 takeLock，当前线程获取该锁后，其它线程在调用 poll 或者 take 方法会被阻塞挂起<br>代码 (3) 如果当前队列不为空则进行出队操作，然后递减计数器。<br>代码（4）如果 c&gt;1 则说明当前线程移除掉队列里面的一个元素后队列不为空（c 是删除元素前队列元素个数），那么这时候就可以激活因为调用 poll 或者 take 方法而被阻塞到 notEmpty 的条件队列里面的一个线程。<br>代码（6）说明当前线程移除队头元素前当前队列是满的，移除队头元素后队列当前至少有一个空闲位置，那么这时候就可以调用 signalNotFull 激活因为调用 put 或者 offer 而被阻塞放到 notFull 的条件队列里的一个线程，signalNotFull 的代码如下：<br>      private void signalNotFull() {<br>          final ReentrantLock putLock &#x3D; this.putLock;<br>          putLock.lock();<br>          try {<br>              notFull.signal();<br>          } finally {<br>              putLock.unlock();<br>          }<br>      }<br>poll 代码逻辑比较简单，值得注意的是获取元素时候只操作了队列的头节点。<br>3.2.4 peek 操作<br>获取队列头部元素但是不从队列里面移除，如果队列为空则返回 null，该方法是不阻塞的。<br>     public E peek() {<br>        &#x2F;&#x2F;(1)<br>        if (count.get() &#x3D;&#x3D; 0)<br>            return null;<br>        &#x2F;&#x2F;(2)<br>        final ReentrantLock takeLock &#x3D; this.takeLock;<br>        takeLock.lock();<br>        try {<br>            Node<E> first &#x3D; head.next;<br>            &#x2F;&#x2F;(3)<br>            if (first &#x3D;&#x3D; null)<br>                return null;<br>            else<br>            &#x2F;&#x2F;(4)<br>                return first.item;<br>        } finally {<br>           &#x2F;&#x2F;(5)<br>            takeLock.unlock();<br>        }<br>    }<br>peek 操作代码也比较简单，这里需要注意的是代码（3）这里还是需要判断下 first 是否为 null 的，不能直接执行代码（4）。正常情况下执行到代码（2）说明队列不为空，但是代码（1）和（2）不是原子性操作，也就是在执行点（1）判断队列不空后，在代码（2）获取到锁前有可能其它线程执行了 poll 或者 take 操作导致队列变为了空，然后当前线程获取锁后，直接执行 first.item 会抛出空指针异常。<br>3.2.5 take 操作<br>获取当前队列头部元素并从队列里面移除，如果队列为空则阻塞调用线程。如果队列为空则阻塞当前线程直到队列不为空然后返回元素，如果在阻塞的时候被其它线程设置了中断标志，则被阻塞线程会抛出 InterruptedException 异常而返回。<br>    public E take() throws InterruptedException {<br>        E x;<br>        int c &#x3D; -1;<br>        final AtomicInteger count &#x3D; this.count;<br>        &#x2F;&#x2F;(1)获取锁<br>        final ReentrantLock takeLock &#x3D; this.takeLock;<br>        takeLock.lockInterruptibly();<br>        try {<br>            &#x2F;&#x2F;(2)当前队列为空则阻塞挂起<br>            while (count.get() &#x3D;&#x3D; 0) {<br>                notEmpty.await();<br>            }<br>            &#x2F;&#x2F;(3)出队并递减计数<br>            x &#x3D; dequeue();<br>            c &#x3D; count.getAndDecrement();<br>            &#x2F;&#x2F;(4)<br>            if (c &gt; 1)<br>                notEmpty.signal();<br>        } finally {<br>           &#x2F;&#x2F;(5)<br>            takeLock.unlock();<br>        }<br>        &#x2F;&#x2F;(6)<br>        if (c &#x3D;&#x3D; capacity)<br>            signalNotFull();<br>        &#x2F;&#x2F;(7)<br>        return x;<br>    }<br>代码（1）当前线程获取到独占锁，其它调用 take 或者 poll 的线程将会被阻塞挂起。<br>代码（2）如果队列为空则阻塞挂起当前线程，并把当前线程放入 notEmpty 的条件队列。<br>代码（3）进行出队操作并递减计数。<br>代码（4）如果 c&gt;1 说明当前队列不为空，则唤醒 notEmpty 的条件队列的条件队列里面的一个因为调用 take 或者 poll 而被阻塞的线程。<br>代码（5）释放锁。<br>代码（6）如果 c &#x3D;&#x3D; capacity 则说明当前队列至少有一个空闲位置，则激活条件变量 notFull 的条件队列里面的一个因为调用 put 或者 offer 而被阻塞的线程。<br>3.2.6 remove 操作<br>删除队列里面指定元素，有则删除返回 true，没有则返回 false<br>public boolean remove(Object o) {<br>    if (o &#x3D;&#x3D; null) return false;</p>
<pre><code>//（1）双重加锁
fullyLock();
try &#123;

    //（2)遍历队列找则删除返回true
    for (Node&lt;E&gt; trail = head, p = trail.next;
         p != null;
         trail = p, p = p.next) &#123;
         //(3)
        if (o.equals(p.item)) &#123;
            unlink(p, trail);
            return true;
        &#125;
    &#125;
    //(4)找不到返回false
    return false;
&#125; finally &#123;
    //(5)解锁
    fullyUnlock();
&#125;
</code></pre>
<p>}<br>代码（1）通过 fullyLock 获取双重锁，当前线程获取后，其它线程进行入队或者出队的操作时候就会被阻塞挂起。<br>void fullyLock() {<br>    putLock.lock();<br>    takeLock.lock();<br>}<br>代码（2）遍历队列寻找要删除的元素，找不到则直接返回 false，找到则执行 unlink 操作，unlik 操作代码如下：<br>    void unlink(Node<E> p, Node<E> trail) {<br>      p.item &#x3D; null;<br>      trail.next &#x3D; p.next;<br>      if (last &#x3D;&#x3D; p)<br>          last &#x3D; trail;<br>      如果当前队列满，删除后，也不忘记唤醒等待的线程<br>      if (count.getAndDecrement() &#x3D;&#x3D; capacity)<br>          notFull.signal();<br>    }<br>可知删除元素后，如果发现当前队列有空闲空间，则唤醒 notFull 的条件队列中一个因为调 用 put 或者 offer 方法而被阻塞的线程。<br>代码（5）调用 fullyUnlock 方法使用与加锁顺序相反的顺序释放双重锁<br>void fullyUnlock() {<br>    takeLock.unlock();<br>    putLock.unlock();<br>}<br>总结下，由于 remove 方法在删除指定元素前加了两把锁，所以在遍历队列查找指定元素过程中是线程安全的，并且此时其它调用入队出队操作的线程全部会被阻塞，另外获取多个资源锁与释放的顺序是相反的。<br>3.2.7 size 操作<br>int size() : 获取当前队列元素个数。<br>    public int size() {<br>        return count.get();<br>    }<br>由于在操作出队入队时候操作 Count 的时候是加了锁的，所以相比 ConcurrentLinkedQueue 的 size 方法比较准确。这里考虑下为何 ConcurrentLinkedQueue 中需要遍历链表来获取 size 而不适用一个原子变量那？这是因为使用原子变量保存队列元素个数需要保证入队出队操作和操作原子变量是原子性操作，而 ConcurrentLinkedQueue 是使用 CAS 无锁算法的，所以无法做到这个。<br>注：LinkedBlockingQueue 内部是通过单向链表实现，使用头尾节点来进行入队和出队操作，也就是入队操作都是对尾节点进行操作，出队操作都是对头节点进行操作，而头尾节点的操作分别使用了单独的独占锁保证了原子性，所以出队和入队操作是可以同时进行的。另外头尾节点的独占锁都配备了一个条件队列，用来存放被阻塞的线程，并结合入队出队操作实现了一个生产消费模型。</p>
<h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><p>上节介绍了有界链表方式的阻塞队列 LinkedBlockingQueue，本节来研究下有界使用数组方式实现的阻塞队列 ArrayBlockingQueue 的原理<br>4.1 ArrayBlockingQueue 类图结构<br>同理为了能从全局一览 ArrayBlockingQueue 的内部构造，先看下类图：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192523294.png" alt="image.png"><br>如图 ArrayBlockingQueue 内部有个数组 items 用来存放队列元素，putindex 变量标示入队元素下标，takeIndex 是出队下标，count 统计队列元素个数，从定义可知并没有使用 volatile 修饰，这是因为访问这些变量使用都是在锁块内，而加锁已经保证了锁块内变量的内存可见性了。<br>另外有个独占锁 lock 用来保证出入队操作原子性，这保证了同时只有一个线程可以进行入队出队操作，另外 notEmpty，notFull 条件变量用来进行出入队的同步。<br>另外由于 ArrayBlockingQueue 是有界队列，所以构造函数必须传入队列大小参数，构造函数代码如下：<br>  public ArrayBlockingQueue(int capacity) {<br>        this(capacity, false);<br>  }</p>
<pre><code>public ArrayBlockingQueue(int capacity, boolean fair) &#123;
    if (capacity &lt;= 0)
        throw new IllegalArgumentException();
    this.items = new Object[capacity];
    lock = new ReentrantLock(fair);
    notEmpty = lock.newCondition();
    notFull =  lock.newCondition();
&#125;
</code></pre>
<p>可知默认情况下使用的是 ReentrantLock 提供的非非公平独占锁进行出入队操作的加锁。<br>首先一个图概况该队列，读者可以读完本节后在回头体会下：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192523418.png" alt="image.png"><br>4.2 ArrayBlockingQueue 原理介绍<br>本节主要讲解下面几个主要函数的原理。<br>4.2.1 offer 操作<br>向队列尾部插入一个元素，如果队列有空闲容量则插入成功后返回 true，如果队列已满则丢弃当前元素然后返回 false，如果 e 元素为 null 则抛出 NullPointerException 异常，另外该方法是不阻塞的。<br>    public boolean offer(E e) {<br>        &#x2F;&#x2F;（1）e为null，则抛出NullPointerException异常<br>        checkNotNull(e);<br>        &#x2F;&#x2F;（2）获取独占锁<br>        final ReentrantLock lock &#x3D; this.lock;<br>        lock.lock();<br>        try {<br>            &#x2F;&#x2F;（3）如果队列满则返回false<br>            if (count &#x3D;&#x3D; items.length)<br>                return false;<br>            else {<br>                &#x2F;&#x2F;（4）否者插入元素<br>                enqueue(e);<br>                return true;<br>            }<br>        } finally {<br>            lock.unlock();<br>        }<br>    }<br>代码（2）获取独占锁，当前线程获取该锁后，其它入队和出队操作的线程都会被阻塞挂起后放入 lock 锁的 AQS 阻塞队列。<br>代码（3）如果队列满则直接返回 false，否者调用 enqueue 方法后返回 true，enqueue 的代码如下：<br>    private void enqueue(E x) {<br>        &#x2F;&#x2F;（6）元素入队<br>        final Object[] items &#x3D; this.items;<br>        items[putIndex] &#x3D; x;<br>        &#x2F;&#x2F;（7）计算下一个元素应该存放的下标<br>        if (++putIndex &#x3D;&#x3D; items.length)<br>            putIndex &#x3D; 0;<br>        count++;<br>        &#x2F;&#x2F;(8)<br>        notEmpty.signal();<br>    }<br>如上代码首先把当前元素放入 items 数组，然后计算下一个元素应该存放的下标，然后递增元素个数计数器，最后激活 notEmpty 的条件队列中因为调用 poll 或者 take 操作而被阻塞的的一个线程。这里由于在操作共享变量比如 count 前加了锁，所以不存在内存不可见问题，加过锁后获取的共享变量都是从主内存获取的，而不是在 CPU 缓存或者寄存器里面的值。<br>代码（5）释放锁，释放锁后会把修改的共享变量值比如 Count 的值刷新回主内存中，这样其它线程通过加锁在次读取这些共享变量后就可以看到最新的值。<br>4.2.2 put 操作<br>向队列尾部插入一个元素，如果队列有空闲则插入后直接返回 true，如果队列已满则阻塞当前线程直到队列有空闲插入成功后返回 true，如果在阻塞的时候被其它线程设置了中断标志，则被阻塞线程会抛出 InterruptedException 异常而返回，另外如果 e 元素为 null 则抛出 NullPointerException 异常。<br>public void put(E e) throws InterruptedException {<br>    &#x2F;&#x2F;(1)<br>    checkNotNull(e);<br>    final ReentrantLock lock &#x3D; this.lock;</p>
<pre><code>//(2)获取锁（可被中断）
lock.lockInterruptibly();
try &#123;

    //(3)如果队列满，则把当前线程放入notFull管理的条件队列
    while (count == items.length)
        notFull.await();

    //(4)插入元素
    enqueue(e);
&#125; finally &#123;
    //(5)
    lock.unlock();
&#125;
</code></pre>
<p>}<br>代码（2）在获取锁的过程中当前线程被其它线程中断了，则当前线程会抛出 InterruptedException 异常而退出。<br>代码（3）判断如果当前队列满了，则把当前线程阻塞挂起后放入到 notFull 的条件队列，注意这里也是使用了 while 而不是 if。<br>代码（4）如果队列不满则插入当前元素，此处不再累述。<br>4.2.3 poll 操作<br>从队列头部获取并移除一个元素，如果队列为空则返回 null，该方法是不阻塞的。<br>public E poll() {<br>    &#x2F;&#x2F;(1)获取锁<br>    final ReentrantLock lock &#x3D; this.lock;<br>    lock.lock();<br>    try {<br>        &#x2F;&#x2F;（2）当前队列为空则返回null,否者调用dequeue（）获取<br>        return (count &#x3D;&#x3D; 0) ? null : dequeue();<br>    } finally {<br>        &#x2F;&#x2F;(3)释放锁<br>        lock.unlock();<br>    }<br>}<br>代码（1）获取独占锁<br>代码（2）如果队列为空则返回 null，否者调用 dequeue() 方法，dequeue 代码如下：<br>private E dequeue() {<br>    final Object[] items &#x3D; this.items;</p>
<pre><code>//（4）获取元素值
@SuppressWarnings(&quot;unchecked&quot;)
E x = (E) items[takeIndex];
//（5）数组中值值为null;
items[takeIndex] = null;

//（6）队头指针计算，队列元素个数减一
</code></pre>
<p>   if (++takeIndex &#x3D;&#x3D; items.length)<br>            takeIndex &#x3D; 0;<br>    count–;</p>
<pre><code>//（7）发送信号激活notFull条件队列里面的一个线程
notFull.signal();
return x;
</code></pre>
<p>}<br>可知首先获取当前队头元素保存到局部变量，然后重置队头元素为 null，并重新设置队头下标，元素计数器递减，最后发送信号激活 notFull 的条件队列里面一个因为调用 put 或者 offer 而被阻塞的线程。<br>4.2.4 take 操作<br>获取当前队列头部元素并从队列里面移除，如果队列为空则阻塞调用线程。如果队列为空则阻塞当前线程直到队列不为空然后返回元素，如果在阻塞的时候被其它线程设置了中断标志，则被阻塞线程会抛出 InterruptedException 异常而返回。<br>public E take() throws InterruptedException {<br>    &#x2F;&#x2F;(1)获取锁<br>    final ReentrantLock lock &#x3D; this.lock;<br>    lock.lockInterruptibly();<br>    try {</p>
<pre><code>    //（2）队列为空，则等待，直到队列有元素
    while (count == 0)
        notEmpty.await();
    //（3）获取队头元素
    return dequeue();
&#125; finally &#123;
    //(4) 释放锁
    lock.unlock();
&#125;
</code></pre>
<p>}<br>take 操作的代码也比较简单与 poll 相比只是步骤（2）如果队列为空则把当前线程挂起后放入到 notEmpty 的条件队列，等其它线程调用 notEmpty.signal() 方法后在返回，需要注意的是这里也是使用 while 循环进行检测并等待而不是使用 if。<br>4.2.5 peek 操作<br>获取队列头部元素但是不从队列里面移除，如果队列为空则返回 null，该方法是不阻塞的。<br>public E peek() {<br>    &#x2F;&#x2F;(1)获取锁<br>    final ReentrantLock lock &#x3D; this.lock;<br>    lock.lock();<br>    try {<br>        &#x2F;&#x2F;（2）<br>        return itemAt(takeIndex);<br>    } finally {<br>       &#x2F;&#x2F;(3)<br>        lock.unlock();<br>    }<br>}</p>
<p> @SuppressWarnings(“unchecked”)<br>final E itemAt(int i) {<br>        return (E) items[i];<br>}<br>peek 的实现更简单，首先获取独占锁，然后从数组 items 中获取当前队头下标的值并返回，在返回前释放了获取的锁。<br>4.2.6 size 操作<br>获取当前队列元素个数。<br>public int size() {<br>    final ReentrantLock lock &#x3D; this.lock;<br>    lock.lock();<br>    try {<br>        return count;<br>    } finally {<br>        lock.unlock();<br>    }<br>}<br>size 操作是简单的，获取锁后直接返回 count，并在返回前释放锁。也许你会疑问这里有没有修改 Count 的值，只是简单的获取下，为何要加锁那？其实如果 count 声明为 volatile 这里就不需要加锁了，因为 volatile 类型变量保证了内存的可见性，而 ArrayBlockingQueue 的设计中 count 并没有声明为 volatile，是因为 count 的操作都是在获取锁后进行的，而获取锁的语义之一是获取锁后访问的变量都是从主内存获取的，这保证了变量的内存可见性。<br>注：ArrayBlockingQueue 通过使用全局独占锁实现同时只能有一个线程进行入队或者出队操作，这个锁的粒度比较大，有点类似在方法上添加 synchronized 的意味。ArrayBlockingQueue 的 size 操作的结果是精确的，因为计算前加了全局锁。</p>
<h3 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h3><p>PriorityBlockingQueue 是带优先级的无界阻塞队列，每次出队都返回优先级最高或者最低的元素，内部是平衡二叉树堆的实现。<br>5.1 PriorityBlockingQueue 类图结构<br>下面首先通过类图来从全局了解下 PriorityBlockingQueue 的结构<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192523554.png" alt="image.png"><br>如图 PriorityBlockingQueue 内部有个数组 queue 用来存放队列元素，size 用来存放队列元素个数，allocationSpinLock 是个自旋锁，用 CAS 操作来保证同时只有一个线程可以扩容队列，状态为 0 或者 1，其中 0 表示当前没有在进行扩容，1 标示当前正在扩容。<br>如下构造函数，默认队列容量为 11，默认比较器为 null，也就是使用元素的 compareTo 方法进行比较来确定元素的优先级，这意味着队列元素必须实现了 Comparable 接口;<br> private static final int DEFAULT_INITIAL_CAPACITY &#x3D; 11;</p>
<p> public PriorityBlockingQueue() {<br>        this(DEFAULT_INITIAL_CAPACITY, null);<br>    }</p>
<pre><code>public PriorityBlockingQueue(int initialCapacity) &#123;
    this(initialCapacity, null);
&#125;

public PriorityBlockingQueue(int initialCapacity,
                             Comparator&lt;? super E&gt; comparator) &#123;
    if (initialCapacity &lt; 1)
        throw new IllegalArgumentException();
    this.lock = new ReentrantLock();
    this.notEmpty = lock.newCondition();
    this.comparator = comparator;
    this.queue = new Object[initialCapacity];
&#125;
</code></pre>
<p>首先通过一个图来对该队列进行概况，读者读完本机后，可以回头在体会下：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192523703.png" alt="image.png"><br>5.2 原理介绍<br>5.2.1 offer 操作<br>offer 操作作用是在队列插入一个元素，由于是无界队列，所以一直返回 true，如下是 offer 函数的代码：<br>public boolean offer(E e) {</p>
<pre><code>if (e == null)
    throw new NullPointerException();

//获取独占锁
final ReentrantLock lock = this.lock;
lock.lock();

int n, cap;
Object[] array;

//如果当前元素个数&gt;=队列容量，则扩容(1)
while ((n = size) &gt;= (cap = (array = queue).length))
    tryGrow(array, cap);

try &#123;
    Comparator&lt;? super E&gt; cmp = comparator;

    //默认比较器为null (2)
    if (cmp == null)
        siftUpComparable(n, e, array);
    else
        //自定义比较器 (3)
        siftUpUsingComparator(n, e, array, cmp);

    //队列元素增加1，并且激活notEmpty的条件队列里面的一个阻塞线程（9）
    size = n + 1;
    notEmpty.signal();//激活调用take（）方法被阻塞的线程
&#125; finally &#123;
    //释放独占锁
    lock.unlock();
&#125;
return true;
</code></pre>
<p>}<br>如上代码，主流程比较简单，下面主要看看如何进行扩容的和内部如何建堆的，首先看下扩容逻辑：<br>private void tryGrow(Object[] array, int oldCap) {<br>    lock.unlock(); &#x2F;&#x2F;释放获取的锁<br>    Object[] newArray &#x3D; null;</p>
<pre><code>//cas成功则扩容(4)
if (allocationSpinLock == 0 &amp;&amp;
    UNSAFE.compareAndSwapInt(this, allocationSpinLockOffset,
                             0, 1)) &#123;
    try &#123;
        //oldGap&lt;64则扩容新增oldcap+2,否者扩容50%，并且最大为MAX_ARRAY_SIZE
        int newCap = oldCap + ((oldCap &lt; 64) ?
                               (oldCap + 2) : // grow faster if small
                               (oldCap &gt;&gt; 1));
        if (newCap - MAX_ARRAY_SIZE &gt; 0) &#123;    // possible overflow
            int minCap = oldCap + 1;
            if (minCap &lt; 0 || minCap &gt; MAX_ARRAY_SIZE)
                throw new OutOfMemoryError();
            newCap = MAX_ARRAY_SIZE;
        &#125;
        if (newCap &gt; oldCap &amp;&amp; queue == array)
            newArray = new Object[newCap];
    &#125; finally &#123;
        allocationSpinLock = 0;
    &#125;
&#125;

//第一个线程cas成功后，第二个线程会进入这个地方，然后第二个线程让出cpu，尽量让第一个线程执行下面点获取锁，但是这得不到肯定的保证。(5)
if (newArray == null) // back off if another thread is allocating
    Thread.yield();
lock.lock();//(6)
if (newArray != null &amp;&amp; queue == array) &#123;
    queue = newArray;
    System.arraycopy(array, 0, newArray, 0, oldCap);
&#125;
</code></pre>
<p>}<br>tryGrow 目的是扩容，这里要思考下为啥在扩容前要先释放锁，然后使用 cas 控制只有一个线程可以扩容成功。其实这里不先释放锁，也是可行的，也就是在整个扩容期间一直持有锁，但是扩容是需要花时间的，如果扩容时候还占用锁那么其它线程在这个时候是不能进行出队和入队操作的，这大大降低了并发性。所以为了提高性能，使用 CAS 控制只有一个线程可以进行扩容，并且在扩容前释放了锁，让其它线程可以进行入队出队操作。<br>spinlock 锁使用 CAS 控制只有一个线程可以进行扩容，CAS 失败的线程会调用 Thread.yield() 让出 cpu，目的意在让扩容线程扩容后优先调用 lock.lock 重新获取锁，但是这得不到一定的保证。有可能 yield 的线程在扩容线程扩容完成前已经退出，并执行代码（6）获取到了锁，这时候获取到的锁的线程发现 newArray 为 null 就会执行代码（1）。如果当前数组扩容还没完毕，当前线程会再次调用 tryGrow 方法，然后释放锁，这又给扩容线程获取锁提供了机会，如果这时候扩容线程还没扩容完毕，则当前线程释放锁后有调用 yield 方法出让 CPU。可知当扩容线程进行扩容期间，其他线程是原地自旋通过代码（1）检查当前扩容是否完毕，等扩容完毕后才退出代码（1）的循环。<br>当扩容线程扩容完毕后会重置自旋锁变量 allocationSpinLock 为 0，这里并没有使用 UNSAFE 方法的 CAS 进行设置是因为同时只可能有一个线程获取了该锁，并且 allocationSpinLock 被修饰为了 volatile。<br>当扩容线程扩容完毕后会执行代码 (6) 获取锁，获取锁后复制当前 queue 里面的元素到新数组。<br>然后看下具体建堆算法：<br>private static <T> void siftUpComparable(int k, T x, Object[] array) {<br>    Comparable&lt;? super T&gt; key &#x3D; (Comparable&lt;? super T&gt;) x;</p>
<pre><code>//队列元素个数&gt;0则判断插入位置，否者直接入队(7)
while (k &gt; 0) &#123;
    int parent = (k - 1) &gt;&gt;&gt; 1;
    Object e = array[parent];
    if (key.compareTo((T) e) &gt;= 0)
        break;
    array[k] = e;
    k = parent;
&#125;
array[k] = key;(8)
</code></pre>
<p>}<br>下面用图来解释上面算法过程，假设队列初始化容量为 2, 创建的优先级队列的泛型参数为 Integer。<br>首先调用队列的 offer(2) 方法，希望插入元素 2 到队列，插入前队列状态如下图：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192523815.png" alt="image.png"><br>首先执行代码（1)，从上图变量值可知判断值为 false，所以紧接着执行代码（2），由于 k&#x3D;n&#x3D;size&#x3D;0 所以代码（7）判断结果为 false，所以会执行代码（8）直接把元素 2 入队，最后执行代码（9）设置 size 的值加 1，这时候队列的状态如下图：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192523886.png" alt="image.png"><br>然后调用队列的 offer(4) 时候，首先执行代码（1)，从上图变量值可知判断为 false，所以执行代码（2），由于 k&#x3D;1, 所以进入 while 循环，由于 parent&#x3D;0;e&#x3D;2;key&#x3D;4; 默认元素比较器是使用元素的 compareTo 方法，可知 key&gt;e 所以执行 break 退出 siftUpComparable 中的循环; 然后把元素存到数组下标为 1 的地方，最后执行代码（9）设置 size 的值加 1，这时候队列状态为：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192523939.png" alt="image.png"><br>然后调用队列的 offer(6) 时候，首先执行代码（1)，从上图变量值知道这时候判断值为 true, 所以调用 tryGrow 进行数组扩容, 由于 2&lt;64 所以 newCap&#x3D;2 + (2+2)&#x3D;6; 然后创建新数组并拷贝，然后调用 siftUpComparable 方法，由于 k&#x3D;2&gt;0 进入 while 循环，由于 parent&#x3D;0;e&#x3D;2;key&#x3D;6;key&gt;e 所以 break 后退出 while 循环; 并把元素 6 放入数组下标为 2 的地方，最后设置 size 的值加 1，现在队列状态：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192524002.png" alt="image.png"><br>然后调用队列的 offer(1) 时候，首先执行代码（1)，从上图变量值知道这次判断值为 false，所以执行代码（2），由于k&#x3D;3, 所以进入 while 循环，由于parent&#x3D;0;e&#x3D;4;key&#x3D;1; key&lt;e，所以把元素 4 复制到数组下标为 3 的地方，然后 k&#x3D;0 退出 while 循环；然后把元素 1 存放到下标为 0 地方，现在状态：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192524074.png" alt="image.png"><br>这时候二叉树堆的树形图如下：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192524128.png" alt="image.png"><br>可知堆的根元素是 1，也就是这是一个最小堆，那么当调用这个优先级队列的 poll 方法时候，会一次返回堆里面值最小的元素。<br>5.2.2 poll 操作<br>poll 操作作用是获取队列内部堆树的根节点元素，如果队列为空，则返回 null。poll 函数代码如下：<br>public E poll() {<br>    final ReentrantLock lock &#x3D; this.lock;<br>    lock.lock();&#x2F;&#x2F;获取独占锁<br>    try {<br>        return dequeue();<br>    } finally {<br>        lock.unlock();&#x2F;&#x2F;释放独占锁<br>    }<br>}<br>如上代码可知在进行出队操作过程中要先加锁，这意味着，当当前线程进行出队操作时候，其它线程不能再进行入队和出队操作，但是从前面介绍 offer 函数时候知道这时候可以有其它线程进行扩容，下面主要看下具体执行出队操作的 dequeue 方法的代码：<br>private E dequeue() {</p>
<pre><code>//队列为空，则返回null
int n = size - 1;
if (n &lt; 0)
    return null;
else &#123;

    //获取队头元素(1)
    Object[] array = queue;
    E result = (E) array[0];

    //获取队尾元素，并值null(2)
    E x = (E) array[n];
    array[n] = null;

    Comparator&lt;? super E&gt; cmp = comparator;
    if (cmp == null)//(3)
        siftDownComparable(0, x, array, n);
    else
        siftDownUsingComparator(0, x, array, n, cmp);
    size = n;//（4）
    return result;
&#125;
</code></pre>
<p>}<br>如上代码，如果队列为空则直接返回 null，否者执行代码（1）获取数组第一个元素作为返回值存放到变量 Result，这里需要注意下数组里面第一个元素是优先级最小或者最大的元素，出队操作就是返回这个元素。 然后代码（2）获取队列尾部元素存放到变量 x, 并且置空尾部节点，然后执行代码（3）插入变量 x 到数组下标为 0 的位置后，重新调成堆为最大或者最小堆，然后返回。这里重要的是看如何去掉堆的根节点后，使用剩下的节点重新调整为一个最大或者最小堆，下面我们看下 siftDownComparable 的代码实现：<br>    private static <T> void siftDownComparable(int k, T x, Object[] array,<br>                                               int n) {<br>        if (n &gt; 0) {<br>            Comparable&lt;? super T&gt; key &#x3D; (Comparable&lt;? super T&gt;)x;<br>            int half &#x3D; n &gt;&gt;&gt; 1;           &#x2F;&#x2F; loop while a non-leaf<br>            while (k &lt; half) {<br>                int child &#x3D; (k &lt;&lt; 1) + 1; &#x2F;&#x2F; assume left child is least<br>                Object c &#x3D; array[child];（5）<br>                int right &#x3D; child + 1;（6)<br>                if (right &lt; n &amp;&amp;<br>                    ((Comparable&lt;? super T&gt;) c).compareTo((T) array[right]) &gt; 0)(7)<br>                    c &#x3D; array[child &#x3D; right];<br>                if (key.compareTo((T) c) &lt;&#x3D; 0)(8)<br>                    break;<br>                array[k] &#x3D; c;<br>                k &#x3D; child;<br>            }<br>            array[k] &#x3D; key;(9)<br>        }<br>    }<br>同理下面我们结合图来模拟上面调整堆的算法过程，接着上节队列的状态继续讲解，上节队列元素序列为 1，2，6，4：<br>第一次调用队列的 poll() 方法时候，首先执行代码（1）（2），这时候变量 size &#x3D;4;n&#x3D;3;result&#x3D;1；x&#x3D;4; 这时候队列状态<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192524191.png" alt="image.png"><br>然后执行代码（3）调整堆后队列状态为：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192524241.png" alt="image.png"><br>第二次调用队列的 poll() 方法时候，首先执行代码（1）（2），这时候变量 size &#x3D;3;n&#x3D;2;result&#x3D;2；x&#x3D;6; 这时候队列状态：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192524311.png" alt="image.png"><br>然后执行代码（3）调整堆后队列状态为：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192524357.png" alt="image.png"><br>第三次调用队列的 poll() 方法时候，首先执行代码（1）（2），这时候变量 size &#x3D;2;n&#x3D;1;result&#x3D;4；x&#x3D;6; 这时候队列状态：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192524485.png" alt="image.png"><br>然后执行代码（3）调整堆后队列状态为：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192524485.png" alt="image.png"><br>第四次直接返回元素 6.<br>下面重点说说 siftDownComparable 这个调整堆的算法： 首先说下堆调整的思路，由于队列数组第 0 个元素为树根，出队时候要被移除，这时候数组就不在是最小堆了，所以需要调整堆，具体是要从被移除的树根的左右子树中找一个最小的值来当树根，左右子树又会看自己作为根节点的树的左右子树里面那个是最小值，这是一个递归，直到树叶节点结束递归，如果还不明白，没关系，下面结合图来说明下，假如当前队列内容如下：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192524534.png" alt="image.png"><br>其对应的二叉堆树为：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192524594.png" alt="image.png"><br>这时候如果调用了 poll(); 那么 result&#x3D;2;x&#x3D;11；队列末尾的元素设置为 null 后，剩下的元素调整堆的步骤如下图：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192524671.png" alt="image.png"><br>如上图（1）树根的 leftChildVal &#x3D; 4;rightChildVal &#x3D; 6; 4&lt;6; 所以 c&#x3D;4; 然后 11&gt;4 也就是 key&gt;c；所以使用元素 4 覆盖树根节点的值，现在堆对应的树如图（2）。<br>然后树根的左子树树根的左右孩子节点中 leftChildVal &#x3D; 8;rightChildVal &#x3D; 10; 8&lt;10; 所以 c&#x3D;8; 然后发现 11&gt;8 也就是 key&gt;c；所以元素 8 作为树根左子树的根节点，现在树的形状如图（3）, 这时候判断 k&lt;half 为 false 就会退出循环，然后把 x&#x3D;11 设置到数组下标为 3 的地方，这时候堆树如图（4），至此调整堆完毕，siftDownComparable 返回 result&#x3D;2，poll 方法也返回了。<br>5.2.3 put 操作<br>put 操作内部调用的 offer, 由于是无界队列，所以不需要阻塞<br>public void put(E e) {<br>    offer(e); &#x2F;&#x2F; never need to block<br>}<br>5.2.4 take 操作<br>take 操作作用是获取队列内部堆树的根节点元素，如果队列为空则阻塞，如下代码：<br>public E take() throws InterruptedException {<br>    &#x2F;&#x2F;获取锁，可被中断<br>    final ReentrantLock lock &#x3D; this.lock;<br>    lock.lockInterruptibly();<br>    E result;<br>    try {</p>
<pre><code>    //如果队列为空，则阻塞，把当前线程放入notEmpty的条件队列
    while ( (result = dequeue()) == null)
        notEmpty.await();//阻塞当前线程
&#125; finally &#123;
    lock.unlock();//释放锁
&#125;
return result;
</code></pre>
<p>}<br>如上代码，首先通过 lock.lockInterruptibly() 获取独占锁，这个方式获取的锁是对中断进行响应的。然后调用 dequeue 方法返回堆树根节点元素，如果队列为空，则返回 false，然后当前线程调用 notEmpty.await() 阻塞挂起当前线程，直到有线程调用了 offer（）方法（offer 方法内在添加元素成功后调用了 notEmpty.signal 方法会激活一个阻塞在 notEmpty 的条件队列里面的一个线程）。另外这里使用 while 而不是 if 是为了避免虚假唤醒。<br>5.2.5 size 操作<br>获取队列元个数，如下代码，在返回 size 前加了锁，保证在调用 size() 方法时候不会有其它线程进行入队和出队操作，另外由于 size 变量没有被修饰为 volatie，这里加锁也保证了多线程下 size 变量的内存可见性。<br>public int size() {<br>    final ReentrantLock lock &#x3D; this.lock;<br>    lock.lock();<br>    try {<br>        return size;<br>    } finally {<br>        lock.unlock();<br>    }<br>}<br>注：PriorityBlockingQueue 队列内部使用二叉树堆维护元素优先级，内部使用数组作为元素存储的数据结构，这个数组是可扩容的，当当前元素个数 &gt;&#x3D; 最大容量时候会通过算法扩容，出队时候始终保证出队的元素是堆树的根节点，而不是在队列里面停留时间最长的元素，默认元素优先级比较规则是使用元素的 compareTo 方法来做，用户可以自定义优先级的比较规则。</p>
<h3 id="队列对比"><a href="#队列对比" class="headerlink" title="队列对比"></a>队列对比</h3><p>上面介绍的各种队列中只有 ConcurrentLinkedQueue 是使用 UNSAFE 类提供的 CAS 非阻塞算法实现的，其他几个队列内部都是使用锁来保证线程安全的。使用 CAS 算法的效率较好，那么是不是所有场景都用 ConcurrentLinkedQueue 那？<br>其实不然，因为 ConcurrentLinkedQueue 还是无界队列，无界队列使用不当可能造成 OOM。所以当使用 ConcurrentLinkedQueue 的时候在添加元素前应该先判断当前队列元素个数是否已经达到了设定的阈值，如果达到就做一定的处理措施，比如直接丢弃等。这里需要注意判断当前队列元素个数与阈值这个操作不是原子性的，最终会导致队列元素个数比设置的阈值大。<br>ConcurrentLinkedQueue 在 Tomcat 的的 NioEndPoint 中得到了应用，通过使用 ConcurrentLinkedQueue 将同步转换为异步，可以让 tomcat 同时接受更多请求，模型如下图：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192524794.png" alt="image.png"><br>tomcat 的 NioEndPoint 模式中 acceptor 线程负责接受用户请求，接受后把请求放入到 poll 线程对应的队列，poll 线程从队列里面获取任务后委托给 worker 线程具体处理。<br>LinkedBlockingQueue 和 ArrayBlockingQueue 都是有界阻塞队列，不同在于一个底层数据结构是链表，一个是数组；另外前者入队出队使用单独的锁，而后者出入队使用同一个锁，所以前者的并发度比后者高。另外创建前者时候可以不指定队列大小，默认队列元素个数为 Integer.MAX_VALUE，而后者必须要指定数组大小。所以使用 LinkedBlockingQueue 时候要记得指定队列大小。<br>比如比较有名的 LogBack 日志系统的异步日志打印实现中就是用了 ArrayBlockingQueue 作为缓冲队列，如下图，业务检查调用异步 log 进行写入日志时候，实际是把日志放入了 ArrayBlockingQueue 队列就返回了，而具体真正写入日志到磁盘是一个日志线程从队列里面获取任务来做的，这其实是一个多生产单消费模型：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192524971.png" alt="image.png"><br>PriorityBlockingQueue 是无界阻塞队列，是一个队列元素有优先级的队列，前面的队列模式都是 FIFO 先进先出，而 PriorityBlockingQueue 而是优先级最高的元素先出队，而不管谁先进入队列的，所以 PriorityBlockingQueue 经常会用在一些任务具有优先级的场景。还比如上面说的 logback 异步日志模型，如果把日志等级分了优先级，比如 error&gt;warn&gt;info，那么上述模型中队列就可以使用 PriorityBlockingQueue，日志线程会先从队列里面首先获取 error 级别的日志，但是需要注意的是如果业务线程一直向队列里面写入 error 级别日志，那么可能先写入到队列的 warn 和 info 级别的日志将很久甚至永远没机会写入到磁盘。还有一点要注意 PriorityBlockingQueue 是无界限队列，要注意判断队列元素个数不要超过设置的阈值。</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/4e8abc71.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tallate">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tallate">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/4e8abc71.html" class="post-title-link" itemprop="url">Java-线程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-09-10 21:07:49" itemprop="dateCreated datePublished" datetime="2019-09-10T21:07:49+08:00">2019-09-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-07 01:56:20" itemprop="dateModified" datetime="2025-07-07T01:56:20+08:00">2025-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="线程和状态机"><a href="#线程和状态机" class="headerlink" title="线程和状态机"></a>线程和状态机</h2><h3 id="线程和线程任务"><a href="#线程和线程任务" class="headerlink" title="线程和线程任务"></a>线程和线程任务</h3><p>线程任务区别于线程，可以理解为线程需要执行的逻辑，类似 Thread 中要执行的 Runnable。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/4e8abc71.html#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/b13b8cb6.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tallate">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tallate">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/b13b8cb6.html" class="post-title-link" itemprop="url">Docker 与常用中间件</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-09-07 18:51:58" itemprop="dateCreated datePublished" datetime="2019-09-07T18:51:58+08:00">2019-09-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-07 01:56:20" itemprop="dateModified" datetime="2025-07-07T01:56:20+08:00">2025-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Docker/" itemprop="url" rel="index"><span itemprop="name">Docker</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>





<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h3><ol>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/30940981/zookeeper-error-cannot-open-channel-to-x-at-election-address">Zookeeper error: Cannot open channel to X at election address</a></li>
</ol>
<h3 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h3><ol>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docker.html">Install Elasticsearch with Docker</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/sbsujjbcy/article/details/52335325">记一次 Docker 下安装 Logstash+Elasticsearch+Kibana 经历</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/40341346/kibana-on-docker-cannot-connect-to-elasticsearch">Kibana on Docker cannot connect to Elasticsearch</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/aubin/p/8012840.html">Elasticsearch 集群部署</a></li>
</ol>
<h3 id="Docker-MySQL"><a href="#Docker-MySQL" class="headerlink" title="Docker MySQL"></a>Docker MySQL</h3><ol>
<li><a target="_blank" rel="noopener" href="https://hub.docker.com/_/mysql/">Docker MySQL</a></li>
</ol>
<h3 id="Docker-MySQL-双机热备实现"><a href="#Docker-MySQL-双机热备实现" class="headerlink" title="Docker MySQL 双机热备实现"></a>Docker MySQL 双机热备实现</h3><ol>
<li><a target="_blank" rel="noopener" href="https://github.com/Junnplus/blog/issues/1">Mysql Master&#x2F;Slave Replication With Docker</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/huaweitman/article/details/50853075">Mysql 双机热备实现</a></li>
<li><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/linux-installation-docker.html">2.5.6 Deploying MySQL on Linux with Docker</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/boling_cavalry/article/details/71055159">让 docker 中的 mysql 启动时自动执行 sql</a></li>
<li><a target="_blank" rel="noopener" href="https://www.2cto.com/database/201503/386265.html">MySQL 主从复制资料汇总</a></li>
</ol>
<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><ol>
<li><a target="_blank" rel="noopener" href="https://github.com/docker-library/docs/tree/master/redis">docker redis</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/docker-library/redis/blob/master/4.0/Dockerfile">redis&#x2F;4.0&#x2F;Dockerfile</a></li>
<li><a target="_blank" rel="noopener" href="https://yq.aliyun.com/articles/57953">使用Docker Compose部署基于Sentinel的高可用Redis集群</a></li>
</ol>
<h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><ol>
<li><a target="_blank" rel="noopener" href="https://hub.docker.com/_/rabbitmq/">docker rabbitmq</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/bijukunjummen/docker-rabbitmq-cluster">bijukunjummen&#x2F;docker-rabbitmq-cluster</a></li>
<li><a target="_blank" rel="noopener" href="http://www.dockone.io/article/829">RabbitMQ集群 Docker一键部署</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhangningkid/article/details/75258444">Docker中实现RabbitMQ集群</a></li>
</ol>
<h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><ol>
<li><a target="_blank" rel="noopener" href="https://hub.docker.com/r/library/nginx/">docker nginx</a></li>
<li><a target="_blank" rel="noopener" href="https://www.nginx.com/blog/docker-swarm-load-balancing-nginx-plus/">Docker Swarm Load Balancing with NGINX and NGINX Plus</a></li>
</ol>
<h3 id="Visualizer"><a href="#Visualizer" class="headerlink" title="Visualizer"></a>Visualizer</h3><ol>
<li><a target="_blank" rel="noopener" href="https://github.com/ManoMarks/docker-swarm-visualizer?hmsr=toutiao.io&utm_medium=toutiao.io&utm_source=toutiao.io">docker-swarm-visualizer</a></li>
</ol>
<h3 id="ZooKeeper-1"><a href="#ZooKeeper-1" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h3><ol>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000006907443">使用 Docker 一步搞定 ZooKeeper 集群的搭建</a></li>
</ol>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/94ee6da6.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tallate">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tallate">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/94ee6da6.html" class="post-title-link" itemprop="url">Docker官方入门文档</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-09-07 18:51:58" itemprop="dateCreated datePublished" datetime="2019-09-07T18:51:58+08:00">2019-09-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-07 01:56:20" itemprop="dateModified" datetime="2025-07-07T01:56:20+08:00">2025-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Docker/" itemprop="url" rel="index"><span itemprop="name">Docker</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>相当于给官网上的get-started翻译了一下。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/94ee6da6.html#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/89826705.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tallate">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tallate">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/89826705.html" class="post-title-link" itemprop="url">Docker 概述</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-09-07 18:51:58" itemprop="dateCreated datePublished" datetime="2019-09-07T18:51:58+08:00">2019-09-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-07 01:56:20" itemprop="dateModified" datetime="2025-07-07T01:56:20+08:00">2025-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Docker/" itemprop="url" rel="index"><span itemprop="name">Docker</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>

<h2 id="Docker-是什么"><a href="#Docker-是什么" class="headerlink" title="Docker 是什么"></a>Docker 是什么</h2><ul>
<li>Docker 是开源应用容器引擎，轻量级容器技术。</li>
<li>基于 Go 语言，并遵循 Apache2.0 协议开源。</li>
<li>Docker 可以让开发者打包他们的应用、依赖包及配置文件打包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 系统上，也可以实现虚拟化。</li>
<li>容器完全使用沙箱技术，相互之间不会有任何接口。</li>
<li>类似于虚拟机技术（vmware、vitural），但 docker 直接运行在操作系统（Linux）上，而不是运行在虚拟机中，速度快，性能开销极低。<br>Docker 支持将软件编译成一个<strong>镜像</strong>，然后在镜像中对各种软件做好配置，将镜像发布出去（Docker Hub），其他使用者可以直接使用这个镜像。 运行中的这个镜像称为容器，容器启动是非常快速的。类似 windows 里面的 ghost 操 作系统，安装好后什么都有了。<br>docker<strong>容器</strong>可以理解为在沙盒中运行的进程。这个沙盒包含了该进程运行所必须的资源，包括文件系统、系统类库、shell 环境等等。但这个沙盒默认是不会运行任何程序的。你需要在沙盒中运行一个进程来启动某一个容器。这个进程是该容器的唯一进程，所以当该进程结束的时候，容器也会完全的停止。</li>
</ul>
<h3 id="常见应用场景"><a href="#常见应用场景" class="headerlink" title="常见应用场景"></a>常见应用场景</h3><ul>
<li>Web 应用的自动化打包和发布。</li>
<li>自动化测试和持续集成、发布。</li>
<li>在服务型环境中部署和调整数据库或其他的后台应用。</li>
<li>从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。</li>
</ul>
<h3 id="Docker-特点"><a href="#Docker-特点" class="headerlink" title="Docker 特点"></a>Docker 特点</h3><p>Docker 是一个基于容器的应用开发、部署和运行平台，它为开发者和系统管理员们提供了一种新式的应用部署方式，具有灵活（最复杂的应用都能容器化）、轻量（容器共享一个服务器内核）、可替换的（可以在容器运行过程中更新服务器）、可移植的（本地、云上皆可）、可伸缩的（可以轻松地进行复制）、可栈化（指的是可以将多个服务部署在一起，比如用 docker-compose）的特性。<br>Docker is a platform for developers and sysadmins to develop, deploy, and run applications with containers. The use of Linux containers to deploy applications is called containerization. Containers are not new, but their use for easily deploying applications is.<br>Containerization is increasingly popular because containers are:</p>
<ul>
<li>Flexible: Even the most complex applications can be containerized.</li>
<li>Lightweight: Containers leverage and share the host kernel.</li>
<li>Interchangeable: You can deploy updates and upgrades on-the-fly.</li>
<li>Portable: You can build locally, deploy to the cloud, and run anywhere.</li>
<li>Scalable: You can increase and automatically distribute container replicas.</li>
<li>Stackable: You can stack services vertically and on-the-fly.</li>
</ul>
<h3 id="Docker-优势"><a href="#Docker-优势" class="headerlink" title="Docker 优势"></a>Docker 优势</h3><p>容器技术相比虚拟机，主要优势在于性能上，其性能优势可以说达到了一个量级的差距。根据 Boden Russell 在 OpenStack 上做的一次基准测试报告，一个 KVM 实例的平均内存消耗有 292MB，而一个 docker 实例的平均内存消耗在 49MB 左右。在 CPU overhead 和启动时间方面，docker 基本都比 KVM 有一个量级的优势。<br>目前，一个 AWS 上的 micro 实例，每小时的按需使用成本大约在一美分多一些。如果用 docker 来提供实例，那么每小时的按需使用成本很可能会做到 0.1 美分。这一点对于云经济至关重要。正如经济学家 William Stanley Jevons 的理论所呈现的，随着商品的价格越便宜，人们使用它们的场景和频率会越来越多。</p>
<ol>
<li>container 是一种部署单元，用户可以自由决定部署的范围（dev、test、production），即组织容器的方式，换句话说，容器可以简化工作流和软件的开发、部署生命周期；                         </li>
<li>可以从传统的虚拟机环境平滑过渡到裸机生产环境内；<br>保证了线上线下环境的一致性。我们在线下的开发环境使用 Docker 构建好 weaapp 的镜像后，可以直接在线上使用一个镜像，保证了线上线下环境的一致性，再也不会有在线下开发环境中运行正常，而部署到线上各种错误了。</li>
<li>实现了模块化，提高了复用性。<br>我们可以将数据库和 Tomcat 运行在不同的容器中，从某种角度来说，这也降低了模块之间的耦合性，便于拓展。比如我们要把 MySQL 替换为 oracle，只需要再构建一个 oracle 镜像并启动与 Tomcat 连接即可，非常方便。对于我们构建的镜像，在其他 app 中直接拿来用就可以了，不必重复劳动。</li>
<li>提高整体效率；<br>极大的简化了 webapp 的部署流程。在不使用 Docker 时，我们部署 app 时，要先搭建好 app 运行所需环境，这个过程做过的人都知道多么枯燥繁琐，一不小心还出错。而有了 Docker，我们只需要直接构建一个我们 webapp 的镜像然后将其运行即可，无论在多少台服务器中部署，都是如此。再比如，使用 Docker 之前要搭建一个 WordPress 对于新手来说是有些困难的，而有了 Docker，只需要从 DockerHub 上 pull 一个 WordPress 镜像并启动就可以了，非常非常方便。</li>
<li>实现了虚拟化，提高硬件利用率，有了 Docker，我们可以在一台服务器上运行很多 webapp，充分利用闲置资源。<br>这时候，服务器的操作系统就类似于货轮，而一个个 Docker 容器就相当于货轮上的一个个集装箱。现在大热的云服务市场，不少就用了 Docker。举个例子来说，现在我们有一台操作系统为 Ubuntu14.04 的服务器，我们构建不同版本的 ubuntu 镜像并启动，并且为不同的用户分配不同的容器。这样，用一台服务器可以虚拟出 n 个运行着不同操作系统的虚拟服务器，而对于用户来说，这些是透明的––用户则认为自己拥有一台完整的服务器。据我推测，阿里云的服务器就是这么干的。这充分利用了闲置的硬件资源。</li>
<li>Fast<ul>
<li>传统方式慢，传统情况下，应用服务器扩容缩容步骤繁多流程冗长,从服务器申请、初始化、应用部署、测试、加入退出集群、服务器下线。比如，业务遇到突发的流量高峰时,无法进行快速的扩容,当准备好的时候可能流量高峰已经过去了。</li>
<li>传统不稳定，代码上线发布历经多个环境,在某个环境中测试时修复了 bug,代码等无法及时同步各环境中,提升了服务上线的风险。</li>
<li>Runtime performance at near bare metal speeds (typically 97+ percent or bare metal – a few ticks shaven off for bean counters).</li>
<li>Management operations (boot, stop, start, reboot, etc.) in seconds or milliseconds.</li>
</ul>
</li>
<li>Agile<ul>
<li>VM-like agility – it’s still “virtualization”.</li>
<li>Seamlessly move between virtual and bare metal environments permitting new development workflows which reduce costs (e.g. develop on VMs and move to bare metal in the “click of a button” for production).</li>
</ul>
</li>
<li>Flexible<ul>
<li>Containerize a “system” (OS less the kernel).</li>
<li>Containerize “application(s)”.</li>
</ul>
</li>
<li>Lightweight<ul>
<li>Just enough Operating System (JeOS); include only what you need reducing image and container bloat.</li>
<li>Minimal per container penalty which equates to greater density and hence greater returns on existing assets – imagine packing 100s or 1000s of containers on a single host node.</li>
</ul>
</li>
<li>Inexpensive<ul>
<li>Open source – free – lower TCO.</li>
<li>Supported with out-of-the-box modern Linux kernels.</li>
</ul>
</li>
<li>Ecosystem<ul>
<li>Growing in popularity – just checkout the google trends for docker or LXC.</li>
<li>Vibrant community and numerous 3rd party applications (1000s of prebuilt images on docker index and 100s of open source apps on github or other public sources).</li>
</ul>
</li>
<li>Cloudy<ul>
<li>Various Cloud management frameworks provide support for creating and managing Linux Containers – including <strong>OpenStack</strong> my personal favorite.</li>
</ul>
</li>
</ol>
<h3 id="Docker-劣势"><a href="#Docker-劣势" class="headerlink" title="Docker 劣势"></a>Docker 劣势</h3><p>既然容器技术有如此大的优势，为什么基于容器的云现在还没有成为主流？我认为主要还是安全性的问题。虚拟机可以利用来自硬件的信任机制来提升安全性，这些机制在 Intel Virtualization Technology Evolution 的演示中有详细的介绍。即使如此，虚拟机仍然被视为相对不安全，比如前一段时间 Xen（半虚拟化，在硬件层和 OS 层之间的虚拟层）爆出一个漏洞，导致 AWS 不得不大量升级自己的主机。</p>
<ol>
<li>Docker Hub（镜像管理中心）不稳定<br>第一个就是很重要的 Docker Hub 的访问问题。我们知道国内访问一些海外的网站有时候会有稳定性的问题。Docker Hub 在我们的实践中就经常出现访问不了的问题。但这种访问的问题并不是持续的，而是时有时无。由于大量的成熟 Docker 映像（image）都需要从 Docker Hub 下载，很多脚本在执行到这一步时，结果很难预料。一种方案是修改缺省的 Docker Hub 地址，改为采用国内的一些镜像（mirror）。但是在没有官方认证的成熟稳定的镜像网站时，Docker 映像的更新不容易得到保证；另一种方案是自行搭建自己的 Docker Hub。但是一来这样就失去了强大的社区贡献的映像资源，二来要花费很多精力来保持更新和同步。容器技术带来的简单化，又因为映像管理而复杂化，得不偿失。</li>
<li>运维难度大<br>第二个就是容器技术的资源管理和运维。因为容器技术本身更适于解决大规模应用场景，所以通常都是集群基础上的部署、运维，但是目前对这一系列任务的自动化处理尚无统一的或者标准的框架。如果要让 Docker 真正在实际环境中发挥最大的效能并且易于维护，就需要有很成熟稳定的资源编排（orchestration）、资源调度（scheduling）和部署（deployment）的支持，但是这方面暂时还没有很明显的最佳解决方案，所以大多数人都在摸索和搭建自己的解决方案。我们在微软开放技术内部也是在一些开源技术的基础之上，自行开发了容器在微软公有云 Azure 上的资源管理调度和部署运维的系统，传统上的开发运维和持续集成，持续部署的技术，比如 Chef，Puppet，Jenkins 等，都可以很容易的与容器技术一起工作。</li>
</ol>
<h3 id="镜像和容器（Images-and-containers）"><a href="#镜像和容器（Images-and-containers）" class="headerlink" title="镜像和容器（Images and containers）"></a>镜像和容器（Images and containers）</h3><p>A container is launched by running an image. An image is an executable package that includes everything needed to run an application–the code, a runtime, libraries, environment variables, and configuration files.<br>A container is a runtime instance of an image–what the image becomes in memory when executed (that is, an image with state, or a user process). You can see a list of your running containers with the command, docker ps, just as you would in Linux.<br>一个镜像是：</p>
<ul>
<li>一个只读模板，可以用来创建容器，一个镜像可以创建多个容器</li>
<li>Docker 提供了一个很简单的机制来创建和更新现有的镜像，甚至可以直接从其他人那里获取做好的镜像直接使用<br>可以理解为 Java 中的类<br>一个容器是：</li>
<li>容器是从镜像创建的运行实例，也就是镜像启动后的一个实例称为容器，是独立运行的一个或一组应用。</li>
<li>docker 利用容器来运行应用，他可以被启动、开始、停止、删除，每个容器都是相互隔离的、保证安全的平台。</li>
<li>可以把容器看做是一个简易版的 Linux（包括 root 用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。</li>
<li>可以理解为 Java 中通过类创建的实例。</li>
</ul>
<h3 id="服务端和客户端"><a href="#服务端和客户端" class="headerlink" title="服务端和客户端"></a>服务端和客户端</h3><p>Docker系统有两个程序：docker服务端和docker客户端。其中docker服务端是一个服务进程，管理着所有的容器。docker客户端则扮演着docker服务端的远程控制器，可以用来控制docker的服务端进程。大部分情况下，docker服务端和客户端运行在一台机器上。<br>Docker开放的API与Docker的守护进程进行通信。</p>
<h3 id="docker-仓库（Resoisitory）"><a href="#docker-仓库（Resoisitory）" class="headerlink" title="docker 仓库（Resoisitory）"></a>docker 仓库（Resoisitory）</h3><ul>
<li>仓库是集中存放镜像文件的场所，类似 git 代码仓库等。</li>
<li>仓库（Respository）和仓库注册服务器（Registry）是有区别的。仓库注册服务器一般存放多个仓库，每个仓库又有多个镜像，每个镜像又有不同的标签（tag）。</li>
<li>仓库分为公开仓库（public）和私有仓库（private）两种形式。</li>
<li>最大的公开仓库是 <strong>Docker Hub</strong>，国内的公开仓库有阿里云等。</li>
<li>可以在本地网络创建一个私有仓库。</li>
<li>当创建好自己的镜像后，可以通过 push 命令把它上传到公开或私有仓库。</li>
<li>仓库的概念类似 Git，仓库注册服务器可以理解为 GitHub 这种托管服务。</li>
</ul>
<h3 id="Containers-virtual-machines"><a href="#Containers-virtual-machines" class="headerlink" title="Containers &amp; virtual machines"></a>Containers &amp; virtual machines</h3><p>传统的部署云服务的方式是通过虚拟机完成的，虚拟机会在宿主机上运行一个完整的操作系统、通过hypervisor来间接使用宿主机的硬件资源，实际上这远远超出了应用运行所必须的资源。而容器正相反，它在操作系统中作为进程运行，与所有其他容器共享同一内核、占用相同容量的内存空间，相对来说，会更加轻量。<br>A container runs natively on Linux and shares the kernel of the host machine with other containers. It runs a discrete process, taking no more memory than any other executable, making it lightweight.<br>By contrast, a virtual machine (VM) runs a full-blown “guest” operating system with virtualaccess to host resources through a hypervisor. In general, VMs provide an environment with more resources than most applications need.<br>下图是Docker（容器）和传统虚拟机之间运行架构的示意图。<br>Container stack example Virtual machine stack example<br>In reality virtualization and Docker can and are used together in modern dev-ops. Most VPS providers are running bare-metal full virtualization technologies like Xen and Docker usually runs on top of a virtualized Ubuntu instance.</p>
<h3 id="Docker-与-LXC（Linux-Container）"><a href="#Docker-与-LXC（Linux-Container）" class="headerlink" title="Docker 与 LXC（Linux Container）"></a>Docker 与 LXC（Linux Container）</h3><p>LXC利用Linux上相关技术实现容器，Docker则在如下的几个方面进行了改进：<br>移植性：通过抽象容器配置，容器可以实现一个平台移植到另一个平台；<br>镜像系统：基于AUFS的镜像系统为容器的分发带来了很多的便利，同时共同的镜像层只需要存储一份，实现高效率的存储；<br>版本管理：类似于GIT的版本管理理念，用户可以更方面的创建、管理镜像文件；<br>仓库系统：仓库系统大大降低了镜像的分发和管理的成本；<br>周边工具：各种现有的工具（配置管理、云平台）对Docker的支持，以及基于Docker的Pass、CI等系统，让Docker的应用更加方便和多样化。 </p>
<h3 id="Docker与Vagrant"><a href="#Docker与Vagrant" class="headerlink" title="Docker与Vagrant"></a>Docker与Vagrant</h3><p>两者的定位完全不同<br>Vagrant类似于Boot2Docker（一款运行Docker的最小内核），是一套虚拟机的管理环境，Vagrant可以在多种系统上和虚拟机软件中运行，可以在Windows。Mac等非Linux平台上为Docker支持，自身具有较好的包装性和移植性。<br>原生Docker自身只能运行在Linux平台上，但启动和运行的性能都比虚拟机要快，往往更适合快速开发和部署应用的场景。<br>Docker不是虚拟机，而是进程隔离，对于资源的消耗很少，单一开发环境下Vagrant是虚拟机上的封装，虚拟机本身会消耗资源。因此对于开发环境来讲，使用Docker是更好的选择。</p>
<h2 id="开始使用Docker"><a href="#开始使用Docker" class="headerlink" title="开始使用Docker"></a>开始使用Docker</h2><h3 id="查看操作系统版本"><a href="#查看操作系统版本" class="headerlink" title="查看操作系统版本"></a>查看操作系统版本</h3><p>Docker是基于LXC（Linux Container）的，因此最好在Linux环境下使用。<br>Docker要求内核版本高于3.10（如果是Ubuntu则需要高于12.04的发行版）可以使用下面命令查看操作系统版本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -r</span><br></pre></td></tr></table></figure>
<h3 id="安装（Ubuntu）"><a href="#安装（Ubuntu）" class="headerlink" title="安装（Ubuntu）"></a>安装（Ubuntu）</h3><p>最好上官网下载安装最新版docker-ce，命令行下的太旧了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install docker.io</span><br><span class="line">docker version</span><br></pre></td></tr></table></figure>
<p>或者按照官网上的步骤：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 安装插件，可以使用HTTPS来下载仓库软件</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    software-properties-common</span><br><span class="line"># 获取GPG公钥</span><br><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line"># 验证公钥是正确的</span><br><span class="line">sudo apt-key fingerprint 0EBFCD88</span><br><span class="line"># 设置stable仓库</span><br><span class="line">sudo apt-get install software-properties-common python-software-properties # 如果缺少了add-apt-repository命令需要安装一下</span><br><span class="line">sudo add-apt-repository \</span><br><span class="line">   &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \</span><br><span class="line">   $(lsb_release -cs) \</span><br><span class="line">   stable&quot;</span><br><span class="line"># 安装</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install docker-ce</span><br><span class="line"># 安装某个特定版本</span><br><span class="line">#apt-cache madison docker-ce # 列出可用版本</span><br><span class="line">#sudo apt-get install docker-ce=&lt;VERSION&gt;</span><br><span class="line"># 运行hello-world</span><br><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure>
<h3 id="安装（CentOS）"><a href="#安装（CentOS）" class="headerlink" title="安装（CentOS）"></a>安装（CentOS）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yum update</span><br><span class="line">yum install docker</span><br><span class="line">systemctl start docker</span><br><span class="line">systemtctl enable docker # 设定为开机启动</span><br><span class="line">systemtctl stop docker</span><br></pre></td></tr></table></figure>
<h3 id="安装（Mac）"><a href="#安装（Mac）" class="headerlink" title="安装（Mac）"></a>安装（Mac）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 搜索可用的镜像，或者上http://index.docker.io/查找</span><br><span class="line">docker search tutorial</span><br><span class="line"># 下载镜像，在docker的镜像索引网站上面，镜像都是按照用户名/镜像名的方式来存储的。有一组比较特殊的镜像，比如ubuntu这类基础镜像，经过官方的验证，值得信任，可以直接用镜像名来检索到。</span><br><span class="line">docker pull learn/tutorial</span><br></pre></td></tr></table></figure>
<h3 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># docker run命令有两个参数，一个是镜像名，一个是要在镜像中运行的命令。</span><br><span class="line">docker run learn/tutorial echo &quot;hello word&quot;</span><br><span class="line"># 在容器中安装一个软件，在执行apt-get 命令的时候，要带上-y参数。如果不指定-y参数的话，apt-get命令会进入交互模式，需要用户输入命令来进行确认，但在docker环境中是无法响应这种交互的</span><br><span class="line">docker run learn/tutorial apt-get install -y ping</span><br></pre></td></tr></table></figure>
<h3 id="保存对容器的修改"><a href="#保存对容器的修改" class="headerlink" title="保存对容器的修改"></a>保存对容器的修改</h3><p>当你对某一个容器做了修改之后（通过在容器中运行某一个命令），可以把对容器的修改保存下来，这样下次可以从保存后的最新状态运行该容器。docker中保存状态的过程称之为committing，它保存的新旧状态之间的区别，从而产生一个新的版本。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 获得查看正在运行中的、安装完ping命令之后容器的id</span><br><span class="line">docker ps -l</span><br><span class="line">docker container ls --all</span><br><span class="line"># 查看更详细的信息</span><br><span class="line">docker inspect </span><br><span class="line"># 将镜像保存为learn/ping，无需拷贝完整的id，通常来讲最开始的三至四个字母即可区分，比如94b82c71517f可以简写为94b</span><br><span class="line">docker commit [CONTAINER ID] learn/ping</span><br><span class="line"># 查看刚保存的镜像</span><br><span class="line">docker images</span><br><span class="line"># 在新的镜像中运行ping www.baidu.com，旧的镜像中没有安装所以不能运行、会返回奇怪的信息</span><br><span class="line">docker run learn/tutorial ping www.baidu.com</span><br><span class="line">docker run learn/tutorial ping www.baidu.com</span><br></pre></td></tr></table></figure>
<h3 id="发布镜像"><a href="#发布镜像" class="headerlink" title="发布镜像"></a>发布镜像</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 列出本地的所有镜像</span><br><span class="line">docker images</span><br><span class="line"># 将某一个镜像发布到官网</span><br><span class="line">docker push</span><br></pre></td></tr></table></figure>

<h3 id="设置用户"><a href="#设置用户" class="headerlink" title="设置用户"></a>设置用户</h3><ol>
<li>使用root用户运行<br>通常我们使用Docker的时候都是使用root用户身份运行的，官方说法如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The docker daemon binds to a Unix socket instead of a TCP port. By default that Unix socket is owned by the user root and other users can access it with sudo. For this reason, docker daemon always runs as the root user. </span><br><span class="line">To avoid having to use sudo when you use the docker command, create a Unix group called docker and add users to it. When the docker daemon starts, it makes the ownership of the Unix socket read/writable by the docker group.</span><br></pre></td></tr></table></figure></li>
<li>使用普通用户运行<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo groupadd docker # docker组可能已经存在了</span><br><span class="line">sudo gpasswd -a $&#123;USER&#125; docker # 将当前用户加入docker组</span><br><span class="line">sudo systemctl restart docker # 重新启动docker服务（下面是CentOS7的命令）</span><br></pre></td></tr></table></figure>
然后当前用户注销再重新登录就可以正常使用docker命令了：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p>要登录容器进行操作，一种办法是在运行容器的时候开放22端口到外部，然后使用ssh来连接：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker create -it --name=容器别名 -p 20022:22 ics-image</span><br><span class="line">ssh -p 20022 root@localhost</span><br></pre></td></tr></table></figure>
<p>另一种办法是在运行中的容器内执行&#x2F;bin&#x2F;bash：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it 容器名 /bin/bash</span><br></pre></td></tr></table></figure>


<h2 id="Docker-Daemon"><a href="#Docker-Daemon" class="headerlink" title="Docker Daemon"></a>Docker Daemon</h2><h3 id="Docker迁移"><a href="#Docker迁移" class="headerlink" title="Docker迁移"></a>Docker迁移</h3><p>将一台宿主机上的Docker环境迁移到另一台宿主机上是比较方便的，只需停止Docker服务，将整个docker存储文件复制到另外一台宿主机上，然后调整另外一台宿主机的配置即可。</p>
<h2 id="Docker-Hub"><a href="#Docker-Hub" class="headerlink" title="Docker Hub"></a>Docker Hub</h2><h3 id="仓库（Repository）、注册服务器（Registry）、注册索引（Index）"><a href="#仓库（Repository）、注册服务器（Registry）、注册索引（Index）" class="headerlink" title="仓库（Repository）、注册服务器（Registry）、注册索引（Index）"></a>仓库（Repository）、注册服务器（Registry）、注册索引（Index）</h3><p>仓库是存放一组关联镜像的集合，比如同一个应用的不同版本的镜像；<br>注册服务器是存放实际的镜像的地方；<br>注册索引则负责维护用户的账号，权限，搜索，标签等管理。注册服务器利用注册索引来实现认证等管理。 </p>
<h2 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h2><h3 id="Docker-Hub-1"><a href="#Docker-Hub-1" class="headerlink" title="Docker Hub"></a>Docker Hub</h3><ol>
<li>docker pull老超时<br>试试国内的加速：<a target="_blank" rel="noopener" href="https://www.daocloud.io/mirror#accelerator-doc">https://www.daocloud.io/mirror#accelerator-doc</a><br>或连接VPN后试试</li>
<li>pull或push时出现一直Waiting的情况<br>网上没有找到答案，开了VPN也没啥用，最后把环境变量改回来（eval $(docker-machine env -u)）就好了。</li>
<li>从非官方仓库（如：dl.dockerpool.com）下载镜像的时候，有时候会提示“Error：Invaild registry endpoint <a target="_blank" rel="noopener" href="https://dl.docker.com:5000/v1/%E2%80%A6%E2%80%9D">https://dl.docker.com:5000/v1/…”</a>?<br>Docker 自1.3.0版本往后以来，加强了对镜像安全性的验证，需要手动添加对非官方仓库的信任。<br>DOCKER_OPTS&#x3D;”–insecure-registry dl.dockerpool.com:5000”<br>重启docker服务</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a target="_blank" rel="noopener" href="https://github.com/docker-library/official-images">docker-library &#x2F; official-images</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/">Best practices for writing Dockerfiles</a></li>
<li><a target="_blank" rel="noopener" href="http://www.dockone.io/article/932">十分钟带你理解 Kubernetes 核心概念</a></li>
<li>Install Docker <a target="_blank" rel="noopener" href="https://docs.docker.com/install/">https://docs.docker.com/install/</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/install/linux/docker-ce/ubuntu/">Get Docker CE for Ubuntu</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/get-started/">Get Started</a></li>
<li><a target="_blank" rel="noopener" href="http://www.docker.org.cn/book/docker/docker-run-8.html">入门教程 中文</a></li>
<li><a target="_blank" rel="noopener" href="https://hub.docker.com/">Docker Hub</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.docker.com/swarm/tallate/dashboard/onboarding/cloud-registry">Docker Cloud</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/dockerd/">命令行参考文档</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/install/linux/linux-postinstall/">安装后配置</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/config/daemon/systemd/">daemon配置</a></li>
</ol>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ol>
<li><a target="_blank" rel="noopener" href="https://draveness.me/docker">Docker 核心技术与实现原理</a></li>
<li><a target="_blank" rel="noopener" href="https://monkeyvault.net/docker-vs-virtualization/">Docker vs Virtualization</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/16047306/how-is-docker-different-from-a-virtual-machine">How is Docker different from a virtual machine?</a></li>
<li><a target="_blank" rel="noopener" href="http://bodenr.blogspot.com/2014/05/kvm-and-docker-lxc-benchmarking-with.html">KVM and Docker LXC Benchmarking with OpenStack</a></li>
<li><a target="_blank" rel="noopener" href="https://www.mirantis.com/blog/ok-i-give-up-is-docker-now-moby-and-what-is-linuxkit/">OK, I give up. Is Docker now Moby? And what is LinuxKit?</a></li>
<li><a target="_blank" rel="noopener" href="https://www.oschina.net/news/84176/the-reason-of-docker-launches-moby">Docker 切出 Moby 背后的真实原因分析</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/docker/libcontainer">docker&#x2F;libcontainer</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zqg5258423/article/details/53843757">docker最新代码源码编译</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/dghpgyss/article/details/72772834">如何编译docker 1.2.0版本的源码</a></li>
</ol>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/f70f9ab5.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tallate">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tallate">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/f70f9ab5.html" class="post-title-link" itemprop="url">使用 Docker</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-09-07 18:51:58" itemprop="dateCreated datePublished" datetime="2019-09-07T18:51:58+08:00">2019-09-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-07 01:56:20" itemprop="dateModified" datetime="2025-07-07T01:56:20+08:00">2025-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Docker/" itemprop="url" rel="index"><span itemprop="name">Docker</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Docker容器命令"><a href="#Docker容器命令" class="headerlink" title="Docker容器命令"></a>Docker容器命令</h1><p>运行中的镜像我们称之为容器，有点类似程序和进程的概念。</p>
<h2 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name container-name -d image-name</span><br></pre></td></tr></table></figure>
<p>运行一个容器，使用 docker run 命令即可。 另，docker run -参数 含义：</p>
<ul>
<li>– name：为容器起一个名称；</li>
<li>-d：detached，执行完这句命令后，控制台将不会阻塞，可以继续输入命令操作，不会阻塞，也就是启动守护式容器，如果执行 docker run –name mycentos -it centos 会进入启动容器的命令控制台，也就是启动交互式容器；</li>
<li>-i：以交互方式运行容器，通常与 -t搭配使用；</li>
<li>-t：为容器重新分配一个伪输入终端，通常与 -i 搭配使用；</li>
<li>-P：随机端口映射；</li>
<li>-p：指定端口映射，后面会有端口映射详细讲解；</li>
<li>image-name：要运行的镜像名称；<br>如果以守护式方式启动 centos 容器，执行如下命令：docker run –name mycentos -d centos，会正常返回 container-id，但是通过 docker ps 查看，却发现没有在运行，通过 docker ps -a 发现，原来已经停止了，这是为什么呢？<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 接下来我们创建一个守护态的Docker容器</span><br><span class="line">sudo docker run -itd ubuntu:14.04 /bin/bash</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看运行中的容器列表</span><br><span class="line">docker ps</span><br></pre></td></tr></table></figure>
<p>输出内容中：</p>
<ul>
<li>CONTAINER ID：启动时生成的 ID；</li>
<li>IMAGE：该容器使用的镜像；</li>
<li>COMMAND：容器启动时执行的命令；</li>
<li>CREATED：容器创建时间；</li>
<li>STATUS：当前容器状态；</li>
<li>PORTS：当前容器所使用的默认端口号；</li>
<li>NAMES：启动时给容器设置的名称。</li>
</ul>
<p>另外，docker ps -参数，有：</p>
<ul>
<li>-a：查看所有容器，包括已停止运行的；</li>
<li>-q：静默模式，只显示容器编号；</li>
<li>-l：显示最近创建的容器；</li>
<li>-n 3：显示最近创建的 num（此处为 3）个容器；</li>
<li>–no-trunc：不截断输出，显示完整信息。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 可用通过如下命令查看容器中正在运行进程：</span><br><span class="line">docker top container-id/container-top</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 可用通过如下命令查看容器内部细节，返回为 json：</span><br><span class="line">docker insepct container-id</span><br></pre></td></tr></table></figure>

<h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><h4 id="docker-attach"><a href="#docker-attach" class="headerlink" title="docker attach"></a>docker attach</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker attach 44fc0f0582d9</span><br></pre></td></tr></table></figure>
<p>但在，使用该命令有一个问题。当多个窗口同时使用该命令进入该容器时，所有的窗口都会同步显示。如果有一个窗口阻塞了，那么其他窗口也无法再进行操作。<br>另外，官方文档中说 attach 后可以通过 CTRL-C 来 detach，但实际上经过我的测试，如果 container 当前在运行 bash，CTRL-C 自然是当前行的输入，没有退出；如果 container 当前正在前台运行进程，如输出 nginx 的 access.log日志，CTRL-C 不仅会导致退出容器，而且还 stop 了。这不是我们想要的，detach 的意思按理应该是脱离容器终端，但容器依然运行。好在 attach 是可以带上 –sig-proxy&#x3D;false 来确保 CTRL-D 或 CTRL-C 不会关闭容器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker attach --sig-proxy=false 7f237caad43b</span><br></pre></td></tr></table></figure>
<p>因为这些原因，所以docker attach命令不太适合于生产环境，平时自己开发应用时可以使用该命令。</p>
<h4 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h4><p>在生产环境中排除了使用docker attach命令进入容器之后，相信大家第一个想到的就是ssh。在镜像（或容器）中安装<strong>SSH Server</strong>，这样就能保证多人进入容器且相互之间不受干扰了，相信大家在当前的生产环境中（没有使用Docker的情况）也是这样做的。但是使用了Docker容器之后不建议使用ssh进入到Docker容器内。<br>但是不建议，原因在<a target="_blank" rel="noopener" href="https://www.oschina.net/translate/why-you-dont-need-to-run-sshd-in-docker?cmp">这</a>。</p>
<h4 id="nsenter"><a href="#nsenter" class="headerlink" title="nsenter"></a>nsenter</h4><p>在上面两种方式都不适合的情况下，还有一种比较方便的方法，即使用nsenter进入Docker容器。<br>关于什么是nsenter请参考如下文章：<br><a target="_blank" rel="noopener" href="https://github.com/jpetazzo/nsenter">https://github.com/jpetazzo/nsenter</a><br>在了解了什么是nsenter之后，系统默认将我们需要的nsenter安装到主机中<br>如果没有安装的话，按下面步骤安装即可（注意是主机而非容器或镜像）<br>具体的安装命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ wget https://www.kernel.org/pub/linux/utils/util-linux/v2.24/util-linux-2.24.tar.gz  </span><br><span class="line">$ tar -xzvf util-linux-2.24.tar.gz  </span><br><span class="line">$ cd util-linux-2.24/  </span><br><span class="line">$ ./configure --without-ncurses  </span><br><span class="line">$ make nsenter  </span><br><span class="line">$ sudo cp nsenter /usr/local/bin  </span><br></pre></td></tr></table></figure>
<p>安装好nsenter之后可以查看一下该命令的使用。<br>nsenter可以访问另一个进程的名称空间。所以为了连接到某个容器我们还需要获取该容器的第一个进程的PID。可以使用docker inspect命令来拿到该PID。<br>docker inspect命令使用如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker inspect --help   </span><br></pre></td></tr></table></figure>
<p>inspect命令可以分层级显示一个镜像或容器的信息。比如我们当前有一个正在运行的容器</p>
<p>可以使用docker inspect来查看该容器的详细信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker inspect 44fc0f0582d9  </span><br></pre></td></tr></table></figure>

<p>由其该信息非常多，此处只截取了其中一部分进行展示。如果要显示该容器第一个进行的PID可以使用如下方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker inspect -f &#123;&#123;.State.Pid&#125;&#125; 44fc0f0582d9  </span><br></pre></td></tr></table></figure>
<p>在拿到该进程PID之后我们就可以使用nsenter命令访问该容器了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo nsenter --target 3326 --mount --uts --ipc --net --pid  </span><br><span class="line">$ sudo nsenter --target 3326 --mount --uts --ipc --net --pid  </span><br></pre></td></tr></table></figure>
<p>其中的3326即刚才拿到的进程的PID<br>当然，如果你认为每次都输入那么多参数太麻烦的话，网上也有许多做好的脚本供大家使用。<br>地址如下：<br><a target="_blank" rel="noopener" href="http://yeasy.gitbooks.io/docker_practice/content/container/enter.html">http://yeasy.gitbooks.io/docker_practice/content/container/enter.html</a><br><a target="_blank" rel="noopener" href="http://www.tuicool.com/articles/eYnUBrR">http://www.tuicool.com/articles/eYnUBrR</a></p>
<h4 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h4><p>除了上面几种做法之外，docker在1.3.X版本之后还提供了一个新的命令exec用于进入容器，这种方式相对更简单一些。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker exec -it 775c7c9ee1e1 /bin/bash</span><br></pre></td></tr></table></figure>
<p>exec和attach的区别：</p>
<ul>
<li>attach：直接进入容器启动命令的终端，不会启动新的进程；</li>
<li>exec：在容器中打开新的终端，并且可以启动新的进程，可在宿主机中直接执行操作容器的命令，比如<code>docker exec -it 7f237caad43b ls /tmp</code>列出容器 &#x2F;tmp 目录下的文件</li>
</ul>
<h2 id="容器和宿主机互相拷贝文件"><a href="#容器和宿主机互相拷贝文件" class="headerlink" title="容器和宿主机互相拷贝文件"></a>容器和宿主机互相拷贝文件</h2><p>宿主机拷贝文件到容器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker cp 文件 container-id:目标文件/文件夹</span><br><span class="line">eg. </span><br><span class="line">docker cp /tmp/suzhuji.txt 7f237caad43b:/tmp</span><br><span class="line">将宿主机tem文件夹下suzhujia.txt文件拷贝到容器7f237caad43b中tmp目录中</span><br></pre></td></tr></table></figure>
<p>从容器拷贝文件到宿主机：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker cp container-id:目标文件/文件夹 宿主机目标文件/文件夹</span><br><span class="line">eg.</span><br><span class="line">docker cp 7f237caad43b:/tmp/yum.log /tmp</span><br><span class="line">将容器7f237caad43b中tmp目录下yum.log拷贝到宿主机/tmp目录下</span><br></pre></td></tr></table></figure>

<h2 id="停止、启动、重启容器"><a href="#停止、启动、重启容器" class="headerlink" title="停止、启动、重启容器"></a>停止、启动、重启容器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 通过以下命令来停止运行中的容器，停止后需要使用docker start命令来重新启动</span><br><span class="line">docker stop container-name/container-id</span><br><span class="line"># 强制停止容器（类似强制关机）：</span><br><span class="line">docker kill container-name/container-id</span><br><span class="line"># 停止所有正在运行的容器</span><br><span class="line">docker kill $(docker ps -q)</span><br><span class="line"># 通过以下命令启动容器：</span><br><span class="line">docker start container-name/container-id</span><br><span class="line"># 通过以下命令启动容器：</span><br><span class="line">docker restart container-name/container-id</span><br></pre></td></tr></table></figure>
<p>容器退出（或者显示调用docker stop）后会进入终止（exited）状态，此时可以通过 docker ps -a 查看，其中数据不会丢失，还可以通过docker start 来启动，只有删除容器才会清除数据。</p>
<h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 删除单个容器：</span><br><span class="line">docker rm container-id</span><br><span class="line"># 删除多个容器：</span><br><span class="line">docker rm container-id container-id </span><br><span class="line"># 删除所有容器：</span><br><span class="line">docker rm $(docker ps -a -q )</span><br></pre></td></tr></table></figure>
<p>另，docker rm -参数含义：</p>
<ul>
<li>-f：强制删除，如果在运行中，先停止，再删除</li>
</ul>
<h2 id="查看容器日志"><a href="#查看容器日志" class="headerlink" title="查看容器日志"></a>查看容器日志</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看当前容器日志，可通过如下命令：</span><br><span class="line">docker logs container-id/container-name</span><br></pre></td></tr></table></figure>
<p>另，docker logs -参数含义：</p>
<ul>
<li>-t：加入时间戳；</li>
<li>-f：跟随最新的日志打印；</li>
<li>–tail：显示最后多少条。</li>
</ul>
<h1 id="端口映射"><a href="#端口映射" class="headerlink" title="端口映射"></a>端口映射</h1><p>容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 -P（大写） 或 -p （小写） 参数来指定端口映射。启动容器的时候如果不指定对应参数，在容器外部是无法通过网络来访问容器内的网络应用和服务的。<br>Docker 的端口映射通过 -p 或 -P 参数实现，-p 和 -P 区别为：</p>
<ul>
<li>-P : 随机映射一个49000~49900的端口到内部容器开放的网络端口</li>
<li>-p : 可以指定要映射的IP和端口，但是在一个指定端口上只可以绑定一个容器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 把主机端口 8888 请求映射到 Docker 容器内部端口 8080</span><br><span class="line">docker run --name tomcat1 -d tomcat</span><br><span class="line">docker run --name tomcat2 -d -p 8888:8080 tomcat</span><br></pre></td></tr></table></figure>
<p>使用<code>docker ps</code>查看端口映射情况，访问localhost:8080和localhost:8888，发现前者无法访问，后者可以。</p>
<h2 id="端口映射格式"><a href="#端口映射格式" class="headerlink" title="端口映射格式"></a>端口映射格式</h2><ol>
<li>ip:hostport:containerport #指定ip、指定主机port、指定容器port<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 127.0.0.1:5000:5000 training/webapp python app.py</span><br><span class="line">指定映射使用一个特定地址，比如 localhost地址 127.0.0.1</span><br></pre></td></tr></table></figure></li>
<li>ip::containerport #指定ip、未指定主机port、指定容器port<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 127.0.0.1::5000 training/webapp python app.py</span><br><span class="line">绑定 localhost 的任意端口到容器的 5000 端口，本地主机会自动分配一个端口</span><br><span class="line">还可以使用 udp 标记来指定 udp 端口</span><br><span class="line">docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py</span><br></pre></td></tr></table></figure></li>
<li>hostport:container #未指定ip port、指定主机port、指定容器port  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 5000:5000 training/webapp python app.py</span><br><span class="line">将本地的 5000 端口映射到容器的 5000 端口，默认会绑定本地所有接口上的所有地址</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="查看端口映射"><a href="#查看端口映射" class="headerlink" title="查看端口映射"></a>查看端口映射</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 可以通过如下命令查看容器映射了哪些端口及协议：</span><br><span class="line">docker port container-id</span><br></pre></td></tr></table></figure>
<p>如果返回空表示没有进行端口映射。</p>
<h1 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h1><ol>
<li>docker ps（等其他指令）没有响应</li>
</ol>
<p>我的情况比较简单，是因为云主机内存不够了，所以没有响应。但是如果是某个容器出问题了就需要另外想办法了：<a target="_blank" rel="noopener" href="https://phpor.net/blog/post/3759">docker之 docker ps无响应</a>。</p>
<ol>
<li>连接进入docker</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/30172605/how-to-get-into-a-docker-container">https://stackoverflow.com/questions/30172605/how-to-get-into-a-docker-container</a></p>
<ol>
<li>查看Docker日志</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://docs.docker.com/config/daemon/#read-the-logs">https://docs.docker.com/config/daemon/#read-the-logs</a></p>
<p><a target="_blank" rel="noopener" href="https://takacsmark.com/docker-logs/">https://takacsmark.com/docker-logs/</a></p>
<p><code>docker logs &lt;Container-ID&gt;</code> 、<code>docker service logs &lt;Service-ID&gt;</code> 命令能查看某一容器或服务的日志，但是怎么查看Docker守护进程的执行日志？</p>
<blockquote>
<p>docker logs 和 docker service logs 命令会显示类似于终端中交互式运行命令的输出。UNIX 和 Linux 命令在运行时通常会打开三个 I&#x2F;O 流，分别称为 STDIN，STDOUT 和 STDERR。STDIN 是命令的输入流，可能包括来自键盘的输入或来自另一个命令的输入。STDOUT 通常是命令的正常输出，而 STDERR 通常用于输出错误消息。默认情况下，docker logs 显示命令的 STDOUT 和 STDERR。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/30969435/where-is-the-docker-daemon-log">https://stackoverflow.com/questions/30969435/where-is-the-docker-daemon-log</a></p>
<p>比如Ubuntu：sudo journalctl -fu docker.service</p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/q/1010000012954498">查看已经退出的容器的日志</a></p>
<ol>
<li>运行容器直接退出</li>
</ol>
<p>使用docker-logs命令（或者使用docker ps -a查看正在运行中的容器）发现容器启动后直接退出，原因是Docker容器后台运行,就必须有一个前台进程，进程结束，容器就会退出，如果不是那些一直挂起的命令（eg. top, tail等），就会自动退出。</p>
<p>正常情况下，启动服务只需启动相应的service即可，例如：<code>service nginx start &amp;&amp; service php5-fpm start</code>，但是这样做的话nginx和fpm均以后台进程模式运行，就会导致docker前台没有正在运行的应用，因此容器会立即自杀，因为已经没有事情能做了。</p>
<pre><code>* 将要运行的程序以前台进程的形式运行，如果容器需要同时启动多个进程，那么只需要将其中的一个挂起到前台即可，比如对上面所说的 web 容器，只需要将启动指令修改为`service php5-fpm start &amp;&amp; nginx -g &quot;daemon off;&quot;`

* 对于不知道怎么在前台运行的程序，只需要在启动的命令后面添加类似tail、top这种可以前台运行的程序，以上面所说的web容器为例，可以写成`service nginx start &amp;&amp; service php5-fpm start &amp;&amp; tail -f /var/log/nginx/error.log`，又如，在启动centos/ubuntu容器的时候，可以做一个死循环，持续输出任意内容，这样容器就不会认为没事可做而自杀了：`docker run -d centos /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;`。

* 可以加上-it选项，-i 开启了input(输入)功能 -t开启了一个连接容器里边的terminal(终端)（是不是相当于在容器内开启了一个bash进程？），如果希望在后台运行，可以再加上-d选项。
</code></pre>
<p>一般来说我们不推荐在同一个容器内运行多个应用程序，这会影响容器的效率，因此最后一种方法是最好的。</p>
<ol>
<li>日志中出现 not support swap limit capabilities</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/q/1010000002888521">https://segmentfault.com/q/1010000002888521</a></p>
<ol>
<li>开启服务失败（elasticsearch）</li>
</ol>
<p>在查看日志（journalctl -fu docker.service）的时候发现是内存不够用，在docker-compose.yml中去掉resources配置项就可以了。</p>
<p>如果没有设置限制，也有可能是物理机本身内存不够了，实在不行可以创建swap来凑空间。</p>
<ol>
<li>使用远程主机作为docker-machine时“connection refused”</li>
</ol>
<p>调用docker-machine env &lt;docker-machine名&gt;出现连接失败的情况</p>
<p>查看了一些<a target="_blank" rel="noopener" href="http://blog.csdn.net/xiaoliuliu2050/article/details/53447628">资料</a>但并没有什么卵用，&#x2F;etc&#x2F;default&#x2F;docker这个文件根本没有被读进去。</p>
<p>据说是因为<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/34810779/docker-swarm-cannot-connect-to-the-docker-engine-endpoint">docker的daemon默认监听fd</a>，而远程连接时用的是tcp。</p>
<p>根据<a target="_blank" rel="noopener" href="https://docs.docker.com/install/linux/linux-postinstall/#configure-where-the-docker-daemon-listens-for-connections">这里</a>的说明修改配置文件，但是发现无法重启docker服务，查看daemon日志发现-H的配置项重复了，而&#x2F;etc&#x2F;systemd&#x2F;system&#x2F;下并没有发现配置文件，在<a target="_blank" rel="noopener" href="http://blog.csdn.net/liu306487103/article/details/52222000">这里</a>了解到原来配置文件还有一个位置&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;，将相关内容（”-H fd:&#x2F;&#x2F;“）去掉就行了。</p>
<p>但是这样配置完毕后仍然不能在ECS上创建Docker Machine，最后采用了generic驱动成功了，具体配置见我的另一篇[App &amp; Cloud]。</p>
<p>就优先级来说，&#x2F;etc&#x2F;docker&#x2F;daemon.json &gt; &#x2F;etc&#x2F;systemd&#x2F;system&#x2F; &gt; &#x2F;lib&#x2F;systemd&#x2F;system&#x2F;，优先级高的会覆盖低的。</p>
<ol>
<li>对阿里云美西节点 docker-machine create 时 tls: DialWithDialer timed out</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/q/1010000006228638">刚开始我也试着regenerate-certs了，但没什么卵用</a>。</p>
<p>在stackoverflow上<a target="_blank" rel="noopener" href="https://stackoverflow.com/search?q=tls:+DialWithDialer+timed+out">查不到相关的讨论</a>。</p>
<p><a target="_blank" rel="noopener" href="https://docs.docker.com/toolbox/faqs/troubleshoot/#solutions">官网相关页面</a>上也没有。</p>
<p>github上对这个问题的<a target="_blank" rel="noopener" href="https://github.com/docker/machine/issues/3479">讨论</a>，也有了<a target="_blank" rel="noopener" href="https://github.com/docker/machine/issues/3479">解决</a>，在代码里把超时时间改大了，但还是<strong>写死的</strong>，我在连接美国服务器时仍然超时。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/docker/machine/issues/3443">有的人提议</a>提议将超时时间作为一个命令行参数提供出来，但是下面一个傻逼一直坚持说“suggest retrying”。</p>
<p>最后还是放弃了在这个节点上部署docker。</p>
<p>PS：在<a target="_blank" rel="noopener" href="https://github.com/docker/machine/issues/3219">这里</a>看到开发者的想法：用户是愚蠢的，不能把危险的选项公布出来，所以TLS任何方法不能关闭！WTF！！！随便搜索了一遍releases列表，没有发现对TLS的更改，所以我彻底放弃了。</p>
<ol>
<li>如何让Docker启动时执行自定义命令&#x2F;脚本？</li>
</ol>
<p>如果官方提供的Dockerfile已经内置了这个功能是最好的（比如<a target="_blank" rel="noopener" href="https://github.com/docker-library/mysql/blob/7a850980c4b0d5fb5553986d280ebfb43230a6bb/8.0/Dockerfile">MySQL官方Dockerfile</a>），如果没有的话，就需要自定义Dockerfile了（<a target="_blank" rel="noopener" href="https://forums.docker.com/t/how-to-run-bash-command-after-startup/21631">How to run bash command after startup?</a>），ENTRYPOINT和CMD命令都可以用于执行命令，CMD会被接到ENTRYPOINT后面，主要用于提供一些可变的参数，docker run后面的参数其实就是CMD。</p>
<p>在docker-compose.yml文件中不适合自定义执行命令，command命令可以定义启动时命令，但是只能定义一条，我尝试command: a.sh &amp;&amp; b.sh，结果也只是执行了前面的指令，所以就不要白费力气了。</p>
<ol>
<li><p><a target="_blank" rel="noopener" href="https://segmentfault.com/q/1010000003719349">docker 中怎么修改应用的配置？</a></p>
<ul>
<li><p>官方镜像已有提供该功能</p>
</li>
<li><p>使用volumes将宿主机文件夹挂载到容器内</p>
</li>
<li><p>自定义镜像</p>
</li>
</ul>
</li>
<li><p>怎么查看容器的启动命令</p>
<ul>
<li><p>在宿主机上<code>docker inspect</code></p>
</li>
<li><p>在容器内部<code>ps -fe</code>，其中1号进程就是启动命令（有可能出现ps命令找不到的情况）</p>
</li>
<li><p>查看这个镜像的Dockerfile，其中的ENTRYPOINT和CMD指定了容器的运行时执行命令</p>
</li>
</ul>
</li>
<li><p>如何临时退出一个正在交互的容器的终端，而不终止它？</p>
</li>
</ol>
<p>按Ctrl+p，后按Ctrl+q，如果按Ctrl+c会使容器内的应用进程终止，进而会使容器终止。</p>
<ol>
<li>使用docker port 命令映射容器的端口时，系统报错Error: No public port ‘80’ published for …，是什么意思？</li>
</ol>
<p>创建镜像时Dockerfile要指定正确的EXPOSE的端口，容器启动时指定PublishAllport&#x3D;true</p>
<ol>
<li><p>可以在一个容器中同时运行多个应用进程吗？<br>一般不推荐在同一个容器内运行多个应用进程，如果有类似需求，可以通过额外的进程管理机制，比如supervisord来管理所运行的进程</p>
</li>
<li><p>如何控制容器占用系统资源（CPU，内存）的份额？<br>在使用docker create命令创建容器或使用docker run 创建并运行容器的时候，可以使用-c|–cpu-shares[&#x3D;0]参数来调整同期使用CPU的权重，使用-m|–memory参数来调整容器使用内存的大小。</p>
</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><ol>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/docker/">命令</a></li>
<li><a target="_blank" rel="noopener" href="https://mritd.me/2017/05/12/docker-uses-the-host-network-segment-ip/?utm_source=tuicool&utm_medium=referral">Docker 分配宿主机网段 IP</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/yarntime/article/details/51258824">docker容器网络通信原理分析</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.51cto.com/cloudman/2047055">Service 之间如何通信？- 每天5分钟玩转 Docker 容器技术（101）</a></li>
</ol>
<h2 id="容器编排"><a href="#容器编排" class="headerlink" title="容器编排"></a>容器编排</h2><h3 id="Swarm基本使用"><a href="#Swarm基本使用" class="headerlink" title="Swarm基本使用"></a>Swarm基本使用</h3><ol>
<li><p><a target="_blank" rel="noopener" href="https://training.play-with-docker.com/swarm-service-discovery/">Play with Docker classroom: Service Discovery under Docker Swarm Mode</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://www.bubuko.com/infodetail-1969108.html">运维之我的docker-swarm集群中删除节点和服务</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Javame/p/6739184.html">docker swarm 搭建及跨主机网络互连案例分析</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/9eb9995884a5">Docker Swarm 入门一篇文章就够了</a></p>
</li>
</ol>
<h3 id="Swarm运维"><a href="#Swarm运维" class="headerlink" title="Swarm运维"></a>Swarm运维</h3><ol>
<li><p><a target="_blank" rel="noopener" href="https://linux.cn/article-8888-1.html">Docker 引擎的 Swarm 模式：入门教程</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fundebug/p/6823897.html">生产环境中使用Docker Swarm的一些建议</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/cmt/p/8455956.html">云计算之路-阿里云上：重启 manager 节点引发 docker swarm 集群宕机</a></p>
</li>
</ol>
<h3 id="Swarm原理"><a href="#Swarm原理" class="headerlink" title="Swarm原理"></a>Swarm原理</h3><ol>
<li><p><a target="_blank" rel="noopener" href="http://www.php230.com/1494374762.html">Consul入门</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://www.smartjava.org/content/service-discovery-docker-and-consul-part-1">Service Discovery with Docker and Consul: part 1</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://success.docker.com/article/docker-reference-architecture-universal-control-plane-20-service-discovery-and-load-balancing">Docker Reference Architecture: Universal Control Plane 2.0 Service Discovery and Load Balancing</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/readiay/article/details/53538085">浮动IP（FLOAT IP）</a></p>
</li>
</ol>
<h3 id="持续部署"><a href="#持续部署" class="headerlink" title="持续部署"></a>持续部署</h3><ol>
<li><a target="_blank" rel="noopener" href="https://www.csdn.net/article/2015-07-21/2825266">Docker持续部署图文详解</a></li>
</ol>
<h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><ol>
<li><a target="_blank" rel="noopener" href="http://fengyilin.iteye.com/blog/2401156">docker swarm获取客户端IP</a></li>
</ol>
<h3 id="OpenStack（开源云计算平台）"><a href="#OpenStack（开源云计算平台）" class="headerlink" title="OpenStack（开源云计算平台）"></a>OpenStack（开源云计算平台）</h3><ol>
<li><p><a target="_blank" rel="noopener" href="http://bodenr.blogspot.com/2014/05/kvm-and-docker-lxc-benchmarking-with.html">KVM and Docker LXC Benchmarking with OpenStack</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/OpenStack">OpenStack</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://wiki.openstack.org/wiki/Docker">OpenStack-Docker-wiki</a></p>
</li>
</ol>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><ol>
<li><a target="_blank" rel="noopener" href="https://github.com/spotify/docker-client">spotify&#x2F;docker-client</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/spotify/docker-client/issues/943">how to copy file from file system into running container</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/spotify/docker-client/blob/master/src/test/java/com/spotify/docker/client/DefaultDockerClientTest.java">单元测试 DefaultDockerClientTest.java</a></li>
</ol>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/2215add6.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tallate">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tallate">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2215add6.html" class="post-title-link" itemprop="url">Dubbo服务调用过程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-09-07 18:51:58" itemprop="dateCreated datePublished" datetime="2019-09-07T18:51:58+08:00">2019-09-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-07 01:56:20" itemprop="dateModified" datetime="2025-07-07T01:56:20+08:00">2025-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Dubbo/" itemprop="url" rel="index"><span itemprop="name">Dubbo</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>

<p>基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的 IP 地址，使服务提供方可以平滑增加或减少机器。</p>
<h2 id="角色分类"><a href="#角色分类" class="headerlink" title="角色分类"></a>角色分类</h2><p>以功能角度来说服务可以分成以下几种：</p>
<ul>
<li>服务提供者；</li>
<li>服务消费者；</li>
<li>服务提供者兼消费者。</li>
</ul>
<h2 id="注册中心分类"><a href="#注册中心分类" class="headerlink" title="注册中心分类"></a>注册中心分类</h2><p>可以分成以下几种注册中心：</p>
<ul>
<li>Simple 注册中心 点对点直连</li>
<li>Multicast 注册中心 多播</li>
<li>Zookeeper 注册中心</li>
<li>Redis 注册中心</li>
</ul>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>服务提供者（provider）配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 应用名称，可显示依赖关系 --&gt;</span><br><span class="line">&lt;dubbo:application name=&quot;dubbo-order-server&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 注册中心是ZooKeeper，也可以选择Redis做注册中心 --&gt;</span><br><span class="line">&lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot;</span><br><span class="line">    client=&quot;zkclient&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 通过dubbo协议在注册中心（127.0.0.1表示本机）的20880端口暴露服务 --&gt;</span><br><span class="line">&lt;dubbo:protocol name=&quot;dubbo&quot; host=&quot;127.0.0.1&quot; port=&quot;20880&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 提供服务用地的是service标签，将该接口暴露到dubbo中 --&gt;</span><br><span class="line">&lt;dubbo:service interface=&quot;com.dubbo.service.OrderService&quot;</span><br><span class="line">    ref=&quot;orderService&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Spring容器加载具体的实现类--&gt;</span><br><span class="line">&lt;bean id=&quot;orderService&quot; class=&quot;dubbo.service.impl.OrderServiceImpl&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;dubbo:monitor protocol=&quot;registry&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>服务消费者（consumer）配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 应用名称，可显示依赖关系 --&gt;</span><br><span class="line">&lt;dubbo:application name=&quot;dubbo-user-consumer&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- zookeeper作为注册中心 ，也可以选择Redis做注册中心 --&gt;</span><br><span class="line">&lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot;</span><br><span class="line">    client=&quot;zkclient&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;dubbo:protocol host=&quot;127.0.0.1&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 调用服务使用reference标签，从注册中心中查找服务 --&gt;</span><br><span class="line">&lt;dubbo:reference id=&quot;orderService&quot; interface=&quot;com.dubbo.service.OrderService&quot; /&gt;</span><br></pre></td></tr></table></figure>

<h2 id="查看服务注册-暴露结果"><a href="#查看服务注册-暴露结果" class="headerlink" title="查看服务注册&#x2F;暴露结果"></a>查看服务注册&#x2F;暴露结果</h2><p><img src="/imgs/Dubbo/Dubbo%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%BF%A1%E6%81%AF.png" alt="Dubbo服务注册信息" title="Dubbo服务注册信息"><br>Dubbo 在 ZooKeeper 中以树形结构维护服务注册信息：</p>
<ul>
<li>服务提供者启动时: 向 &#x2F;dubbo&#x2F;com.foo.BarService&#x2F;providers 目录下写入自己的 URL 地址；</li>
<li>服务消费者启动时: 订阅 &#x2F;dubbo&#x2F;com.foo.BarService&#x2F;providers 目录下的提供者 URL 地址。并向 &#x2F;dubbo&#x2F;com.foo.BarService&#x2F;consumers 目录下写入自己的 URL 地址；</li>
<li>监控中心启动时: 订阅 &#x2F;dubbo&#x2F;com.foo.BarService 目录下的所有提供者和消费者 URL 地址。</li>
</ul>
<p>ZooKeeper 启动的时候会把配置信息加载进内存并持久化到数据库，然后启动定时器脏数据检查定时器 DirtyCheckTask，分别检查消费者和提供者的地址列表缓存、消费者和提供者地址列表的数据库数据，清理不存活的消费者和提供者数据，对于缓存中的存在的消费者和提供者而数据库不存在，提供者重新注册和消费者重新订阅。</p>
<p>Dubbo 提供了一些异常情况下的兜底方案：</p>
<ul>
<li>当提供者出现断电等异常停机时，注册中心能自动删除提供者信息</li>
<li>当注册中心重启时，能自动恢复注册数据，以及订阅请求</li>
<li>当会话过期时，能自动恢复注册数据，以及订阅请求</li>
<li>当设置 &lt;dubbo:registry check&#x3D;”false” &#x2F;&gt; 时，记录失败注册和订阅请求，后台定时重试</li>
</ul>
<p>在了解 ZooKeeper 基础上，还可以增加一些配置来修改注册细节：<br>可通过 <code>&lt;dubbo:registry username=&quot;admin&quot; password=&quot;1234&quot; /&gt;</code> 设置 ZooKeeper 登录信息<br>可通过 <code>&lt;dubbo:registry group=&quot;dubbo&quot; /&gt;</code> 设置 ZooKeeper 的根节点，不设置将使用无根树<br>支持 * 号通配符 <code>&lt;dubbo:reference group=&quot;*&quot; version=&quot;*&quot; /&gt;</code> ，可订阅服务的所有分组和所有版本的提供者</p>
<p>在 Provider 启动完毕后，可以登录到 ZooKeeper 上查看注册的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 11] ls /</span><br><span class="line">[dubbo, zookeeper]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 12] ls /dubbo</span><br><span class="line">[com.alibaba.dubbo.monitor.MonitorService, com.tallate.UserServiceBo]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 13] ls /dubbo/com.tallate.UserServiceBo</span><br><span class="line">[configurators, consumers, providers, routers]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 14] ls /dubbo/com.tallate.UserServiceBo/providers</span><br><span class="line">[dubbo%3A%2F%2F192.168.96.194%3A20880%2Fcom.tallate.UserServiceBo%3Fanyhost%3Dtrue%26application%3DdubboProvider%26dubbo%3D2.0.2%26generic%3Dfalse%26group%3Ddubbo%26interface%3Dcom.tallate.UserServiceBo%26methods%3DsayHello%2CtestPojo%2CsayHello2%26pid%3D28129%26revision%3D1.0.0%26side%3Dprovider%26timeout%3D3000%26timestamp%3D1575202776615%26version%3D1.0.0]</span><br></pre></td></tr></table></figure>

<h2 id="服务自动发现流程"><a href="#服务自动发现流程" class="headerlink" title="服务自动发现流程"></a>服务自动发现流程</h2><p>服务自动发现功能完成下面这个流程，我们接下来分点概述：</p>
<ol>
<li>服务提供者在启动时，向注册中心注册自己提供的服务。</li>
<li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li>
<li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li>
<li>服务消费者，从提供者地址列表中，基于软负载均衡算法（基于软件的负载均衡，与 F5 相对），选一台提供者进行调用，如果调用失败，再选另一台调用。</li>
</ol>
<h2 id="注册和注销服务（Provider-执行流程）"><a href="#注册和注销服务（Provider-执行流程）" class="headerlink" title="注册和注销服务（Provider 执行流程）"></a>注册和注销服务（Provider 执行流程）</h2><p>服务的注册与注销，是对服务提供方角色而言，大致流程如下所示：<br><img src="/imgs/Dubbo/%E6%B3%A8%E5%86%8C%E5%92%8C%E6%B3%A8%E9%94%80%E6%9C%8D%E5%8A%A1.png" alt="注册和注销服务" title="注册和注销服务"></p>
<ol>
<li>在接口提供者初始化时，每个接口都会创建一个 Invoker 和 Exporter，Exporter 持有 Invoker 实例，通过 Invocation 中的信息就可找到对应的 Exporter 和 Invoker</li>
<li>同 Consumer 的过程类似，调用 Invoker 前会调用 Invoker-Filter。</li>
<li>调用 Invoker.invoke() 时，通过反射调用最终的服务实现执行相关逻辑。</li>
</ol>
<p>ServiceBean 负责了服务的暴露：</p>
<ul>
<li>继承自 ServiceConfig，export 方法实现了服务暴露的逻辑；</li>
<li>实现了 Spring 中的 InitializingBean, DisposableBean, ApplicationContextAware, ApplicationListener<ContextRefreshedEvent>, BeanNameAware</li>
</ul>
<p>启动时，ServiceBean 主要负责以下任务：</p>
<ul>
<li>生成 DubboExporter 对象并缓存起来</li>
<li>添加过滤器和监听器支持</li>
<li>在 zk 上注册相关信息，暴露服务，方便被感知到</li>
<li>监听端口，等待通信的到来</li>
</ul>
<p><img src="/imgs/Dubbo/Dubbo%E6%9C%8D%E5%8A%A1%E5%AF%BC%E5%87%BA.png" alt="Dubbo服务导出" title="Dubbo服务导出"></p>
<ol>
<li>前置工作，主要用于检查参数和组装 URL；<br>ServiceBean#onApplicationEvent: 接收 Spring 上下文刷新事件后执行服务导出操作<br>-&gt; ServiceBean#export: 导出服务<br>-&gt; ProviderConfig.getExport、getDelay 获取配置，如果 export 为 false 则无法提供给其他服务调用、一般只提供给本地调试时使用，如果需要 delay 则将任务交给一个 ScheduledExecutorService 延迟执行，否则调用 doExport 暴露服务<br>-&gt; ServiceConfig.doExport 一堆配置检查</li>
<li>导出服务，包含导出服务到本地（JVM）和导出服务到远程两个过程；<br><code>ServiceConfig.doExportUrls</code><br>导出服务，Dubbo 中所有服务都通过 URL 导出，支持多协议多注册中心导出服务（遍历 ProtocolConfig 集合导出每个服务）<br><code>AbstractInterfaceConfig#loadRegistries</code><br>加载注册中心链接<br><code>ServiceConfig#doExportUrlsFor1Protocol</code><br>组装 URL，将服务注册到注册中心<br><code>JavassistProxyFactory#getInvoker</code><br>获取 Invoker 实例，用于接收请求<br><code>ServiceConfig#exportLocal、DubboProtocol#export</code><br>根据配置信息导出服务到本地或远程，远程默认取Dubbo协议<br><code>DubboProtocol#openServer</code><br>开始监听请求</li>
<li>向注册中心注册服务，用于服务发现<br>Dubbo 服务注册本质是在 zk 指定目录下创建临时节点，路径是<code>&#123;group&#125;/&#123;Interface&#125;/providers/&#123;url&#125;</code>。<br>RegistryProtocol#register<br>-&gt; RegistryFactory#getRegistry<br>-&gt; AbstractRegistry#register</li>
</ol>
<p>因为Dubbo一般使用ZooKeeper作为注册中心，所以完全可以利用ZooKeeper的临时节点自动删除机制来实现服务器下线自动踢出的机制。</p>
<h2 id="服务订阅和取消（Consumer-执行流程）"><a href="#服务订阅和取消（Consumer-执行流程）" class="headerlink" title="服务订阅和取消（Consumer 执行流程）"></a>服务订阅和取消（Consumer 执行流程）</h2><p>为了满足应用系统的需求，服务消费方的可能需要从服务注册中心订阅指定的有服务提供方发布的服务，在得到通知可以使用服务时，就可以直接调用服务。反过来，如果不需要某一个服务了，可以取消该服务。<br><img src="/imgs/Dubbo/%E6%9C%8D%E5%8A%A1%E8%AE%A2%E9%98%85%E5%92%8C%E5%8F%96%E6%B6%88.png" alt="服务订阅和取消" title="服务订阅和取消"></p>
<p>有两种服务引入方式：</p>
<ol>
<li>饿汉式：Spring 容器调用 ReferenceBean 的 afterPropertiesSet 方法时引用服务，可通过配置 <code>&lt;dubbo:reference&gt;</code> 的 init 属性开启。</li>
<li>懒汉式：ReferenceBean 对应的服务被注入到其他类中时引用</li>
</ol>
<p>服务提供的方式有三种：</p>
<ol>
<li>引用本地 (JVM) 服务；</li>
<li>通过直连方式引用远程服务；</li>
<li>通过注册中心引用远程服务。</li>
</ol>
<p>不管是哪种引用方式，最后都会得到一个 Invoker 实例。如果有多个注册中心，多个服务提供者，这个时候会得到一组 Invoker 实例，此时需要通过集群管理类 Cluster 将多个 Invoker 合并成一个实例。</p>
<p>获取客户端Proxy：</p>
<ol>
<li>在 Consumer 初始化的时候，会生成一个代理注册到容器中，该代理回调中持有一个 Invoker 实例，消费调用服务接口时它的 invoke() 方法会被调用。<br>spring.ReferenceBean#getObject<br>ReferenceConfig#createProxy<br>创建代理实例，根据 url 的协议、scope 以及 injvm 等参数检测是否需要本地引用，不是本地引用的情况下默认采用Dubbo协议。<br>Protocol#refer<br> -&gt; DubboProtocol#getClients 获取客户端实例，实例类型为 ExchangeClient，ExchangeClient 不具备通信能力，它需要依赖更底层的客户端实例<br> -&gt; DubboProtocol#getSharedClient 默认获取共享客户端<br> -&gt; DubboProtocol#initClient 创建客户端实例，默认为 Netty<br> -&gt; Exchangers#connect(URL url, ExchangeHandler handler)</li>
<li>使用 Cluster 合并 Invoker<br>org.apache.dubbo.rpc.cluster.Cluster#join<br>如果配置了多个 URL，则使用 Cluster 合并多个 Invoker</li>
<li>创建动态代理<br>-&gt; ProxyFactory#getProxy(Invoker<T> invoker)<br>常用的动态代理技术有 javassist、cglib、jdk，其中 dubbo 使用的是 javassist。<blockquote>
<p>根据早期 Dubbo 作者梁飞（<a target="_blank" rel="noopener" href="http://javatar.iteye.com/blog/814426%EF%BC%89%E7%9A%84%E8%AF%B4%E6%B3%95%EF%BC%8C%E4%BD%BF%E7%94%A8">http://javatar.iteye.com/blog/814426）的说法，使用</a> javassist 是为了性能。</p>
</blockquote>
</li>
</ol>
<h2 id="Consumer端服务调用过程"><a href="#Consumer端服务调用过程" class="headerlink" title="Consumer端服务调用过程"></a>Consumer端服务调用过程</h2><p><img src="/imgs/Dubbo/Dubbo%E7%BB%84%E4%BB%B6.png" alt="Dubbo组件" title="Dubbo组件"></p>
<h3 id="调用代理类的方法"><a href="#调用代理类的方法" class="headerlink" title="调用代理类的方法"></a>调用代理类的方法</h3><p>请求实际调用的是<code>InvokerInvocationHandler.invoke</code>。</p>
<h3 id="Registry-Directory"><a href="#Registry-Directory" class="headerlink" title="Registry &amp; Directory"></a>Registry &amp; Directory</h3><h4 id="Registry-将注册信息保存到本地的Directory"><a href="#Registry-将注册信息保存到本地的Directory" class="headerlink" title="Registry 将注册信息保存到本地的Directory"></a>Registry 将注册信息保存到本地的Directory</h4><p>启动服务时需要给一个Dubbo接口创建代理，这时需要将注册URL转换为Invoker对象：<br><code>org.apache.dubbo.registry.integration.RegistryProtocol#refer</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; Invoker&lt;T&gt; refer(Class&lt;T&gt; type, URL url) throws RpcException &#123;</span><br><span class="line">    url = getRegistryUrl(url);</span><br><span class="line">    Registry registry = registryFactory.getRegistry(url);</span><br><span class="line">    if (RegistryService.class.equals(type)) &#123;</span><br><span class="line">        return proxyFactory.getInvoker((T) registry, type, url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // group=&quot;a,b&quot; or group=&quot;*&quot;</span><br><span class="line">    Map&lt;String, String&gt; qs = StringUtils.parseQueryString(url.getParameterAndDecoded(REFER_KEY));</span><br><span class="line">    String group = qs.get(GROUP_KEY);</span><br><span class="line">    if (group != null &amp;&amp; group.length() &gt; 0) &#123;</span><br><span class="line">        if ((COMMA_SPLIT_PATTERN.split(group)).length &gt; 1 || &quot;*&quot;.equals(group)) &#123;</span><br><span class="line">            return doRefer(getMergeableCluster(), registry, type, url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return doRefer(cluster, registry, type, url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>引用一个服务时，会注册一个<code>zkListener</code>，监听注册服务的命名空间的变更情况。<br><code>org.apache.dubbo.registry.zookeeper.ZookeeperRegistry#doSubscribe</code><br>那么服务是怎么注册的呢？其实就是上边Provider注册服务的过程。<br>监听到注册中心的变更后，更新本地的Invoker列表，同时删除不可用的。<br><code>org.apache.dubbo.registry.integration.RegistryDirectory#refreshInvoker</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private void refreshInvoker(List&lt;URL&gt; invokerUrls) &#123;</span><br><span class="line">    Assert.notNull(invokerUrls, &quot;invokerUrls should not be null&quot;);</span><br><span class="line"></span><br><span class="line">    if (invokerUrls.size() == 1</span><br><span class="line">            &amp;&amp; invokerUrls.get(0) != null</span><br><span class="line">            &amp;&amp; EMPTY_PROTOCOL.equals(invokerUrls.get(0).getProtocol())) &#123;</span><br><span class="line">        this.forbidden = true; // Forbid to access</span><br><span class="line">        this.invokers = Collections.emptyList();</span><br><span class="line">        routerChain.setInvokers(this.invokers);</span><br><span class="line">        destroyAllInvokers(); // Close all invokers</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        this.forbidden = false; // Allow to access</span><br><span class="line">        Map&lt;String, Invoker&lt;T&gt;&gt; oldUrlInvokerMap = this.urlInvokerMap; // local reference</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        Map&lt;String, Invoker&lt;T&gt;&gt; newUrlInvokerMap = toInvokers(invokerUrls);// Translate url list to Invoker map</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            destroyUnusedInvokers(oldUrlInvokerMap, newUrlInvokerMap); // Close the unused Invoker</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            logger.warn(&quot;destroyUnusedInvokers error. &quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Invoker使用Directory"><a href="#Invoker使用Directory" class="headerlink" title="Invoker使用Directory"></a>Invoker使用Directory</h4><p>为了服务高可用同一个服务一般会有多个应用服务器提供，要先挑选一个提供者提供服务。在服务接口消费者初始化时，接口方法和提供者 Invoker 对应关系保存在 Directory。 中，通过调用的方法名称（或方法名称+第一个参数）获取该方法对应的提供者 Invoker 列表，如注册中心设置了路由规则，对这些 Invoker 根据路由规则进行过滤。<br>启动时订阅某个服务：<br><code>org.apache.dubbo.registry.integration.RegistryProtocol#doRefer</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private &lt;T&gt; Invoker&lt;T&gt; doRefer(Cluster cluster, Registry registry, Class&lt;T&gt; type, URL url) &#123;</span><br><span class="line">    RegistryDirectory&lt;T&gt; directory = new RegistryDirectory&lt;T&gt;(type, url);</span><br><span class="line">    directory.setRegistry(registry);</span><br><span class="line">    directory.setProtocol(protocol);</span><br><span class="line">    // all attributes of REFER_KEY</span><br><span class="line">    Map&lt;String, String&gt; parameters = new HashMap&lt;String, String&gt;(directory.getUrl().getParameters());</span><br><span class="line">    URL subscribeUrl = new URL(CONSUMER_PROTOCOL, parameters.remove(REGISTER_IP_KEY), 0, type.getName(), parameters);</span><br><span class="line">    if (!ANY_VALUE.equals(url.getServiceInterface()) &amp;&amp; url.getParameter(REGISTER_KEY, true)) &#123;</span><br><span class="line">        directory.setRegisteredConsumerUrl(getRegisteredConsumerUrl(subscribeUrl, url));</span><br><span class="line">        registry.register(directory.getRegisteredConsumerUrl());</span><br><span class="line">    &#125;</span><br><span class="line">    directory.buildRouterChain(subscribeUrl);</span><br><span class="line">    // 订阅providers、configurators、routers这几个namespace</span><br><span class="line">    directory.subscribe(subscribeUrl.addParameter(CATEGORY_KEY,</span><br><span class="line">            PROVIDERS_CATEGORY + &quot;,&quot; + CONFIGURATORS_CATEGORY + &quot;,&quot; + ROUTERS_CATEGORY));</span><br><span class="line"></span><br><span class="line">    // 使用Cluster组合Invoker</span><br><span class="line">    Invoker invoker = cluster.join(directory);</span><br><span class="line">    return invoker;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加监听器：<br><code>org.apache.dubbo.registry.integration.RegistryDirectory#subscribe</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void subscribe(URL url) &#123;</span><br><span class="line">    setConsumerUrl(url);</span><br><span class="line">    CONSUMER_CONFIGURATION_LISTENER.addNotifyListener(this);</span><br><span class="line">    serviceConfigurationListener = new ReferenceConfigurationListener(this, url);</span><br><span class="line">    registry.subscribe(url, this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Consumer端监听服务变更事件，刷新Invoker列表：<br><code>org.apache.dubbo.registry.integration.RegistryDirectory#refreshInvoker</code></p>
<h4 id="Registry的几种实现"><a href="#Registry的几种实现" class="headerlink" title="Registry的几种实现"></a>Registry的几种实现</h4><ul>
<li>ZooKeeperRegistry</li>
<li>RedisRegistry<br>注册信息的存储，是在启动时调用的：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void doRegister(URL url) &#123;</span><br><span class="line">    // key = dubbo/com.package.to.InterfaceName/providers</span><br><span class="line">    String key = toCategoryPath(url);</span><br><span class="line">    // url的全名</span><br><span class="line">    String value = url.toFullString();</span><br><span class="line">    String expire = String.valueOf(System.currentTimeMillis() + expirePeriod);</span><br><span class="line">    boolean success = false;</span><br><span class="line">    RpcException exception = null;</span><br><span class="line">    for (Map.Entry&lt;String, JedisPool&gt; entry : jedisPools.entrySet()) &#123;</span><br><span class="line">        JedisPool jedisPool = entry.getValue();</span><br><span class="line">        try &#123;</span><br><span class="line">            Jedis jedis = jedisPool.getResource();</span><br><span class="line">            try &#123;</span><br><span class="line">                // 使用hash结构，可以providers一个key下面存多个url</span><br><span class="line">                jedis.hset(key, value, expire);</span><br><span class="line">                jedis.publish(key, Constants.REGISTER);</span><br><span class="line">                success = true;</span><br><span class="line">                if (! replicate) &#123;</span><br><span class="line">                    break; //  如果服务器端已同步数据，只需写入单台机器</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                jedisPool.returnResource(jedis);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            exception = new RpcException(&quot;Failed to register service to redis registry. registry: &quot; + entry.getKey() + &quot;, service: &quot; + url + &quot;, cause: &quot; + t.getMessage(), t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (exception != null) &#123;</span><br><span class="line">        if (success) &#123;</span><br><span class="line">            logger.warn(exception.getMessage(), exception);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw exception;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
注册信息的主动删除，进程关闭时：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Directory的几种实现"><a href="#Directory的几种实现" class="headerlink" title="Directory的几种实现"></a>Directory的几种实现</h4><ul>
<li>RegistryDirectory<br>保存注册中心的服务注册信息，包括routers、configurators、provider。</li>
<li>StaticDirectory<br>Invoker列表是固定的。</li>
</ul>
<h3 id="Cluster"><a href="#Cluster" class="headerlink" title="Cluster"></a>Cluster</h3><p>封装了服务降级和容错机制，比如，如果调用失败则执行其他（<code>FailoverClusterInvoker</code>）、仍然调用失败则降级执行 mock（<code>MockClusterInvoker</code>）。<br>调用的第一层是<code>MockClusterInvoker</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public Result invoke(Invocation invocation) throws RpcException &#123;</span><br><span class="line">    Result result = null;</span><br><span class="line">    </span><br><span class="line">    String value = directory.getUrl().getMethodParameter(invocation.getMethodName(), MOCK_KEY, Boolean.FALSE.toString()).trim();</span><br><span class="line">    // 没有设置mock属性或设置为false，则直接调就完了</span><br><span class="line">    if (value.length() == 0 || &quot;false&quot;.equalsIgnoreCase(value)) &#123;</span><br><span class="line">        //no mock</span><br><span class="line">        result = this.invoker.invoke(invocation);</span><br><span class="line">    &#125;</span><br><span class="line">    // 配成force了，直接调mock方法</span><br><span class="line">    else if (value.startsWith(&quot;force&quot;)) &#123;</span><br><span class="line">        if (logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(&quot;force-mock: &quot; + invocation.getMethodName() + &quot; force-mock enabled , url : &quot; + directory.getUrl());</span><br><span class="line">        &#125;</span><br><span class="line">        //force:direct mock</span><br><span class="line">        result = doMockInvoke(invocation, null);</span><br><span class="line">    &#125;</span><br><span class="line">    // fail-mock的方式</span><br><span class="line">    else &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            result = this.invoker.invoke(invocation);</span><br><span class="line"></span><br><span class="line">            //fix:#4585</span><br><span class="line">            if(result.getException() != null &amp;&amp; result.getException() instanceof RpcException)&#123;</span><br><span class="line">                RpcException rpcException= (RpcException)result.getException();</span><br><span class="line">                if(rpcException.isBiz())&#123;</span><br><span class="line">                    throw  rpcException;</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    result = doMockInvoke(invocation, rpcException);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; catch (RpcException e) &#123;</span><br><span class="line">            if (e.isBiz()) &#123;</span><br><span class="line">                throw e;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(&quot;fail-mock: &quot; + invocation.getMethodName() + &quot; fail-mock enabled , url : &quot; + directory.getUrl(), e);</span><br><span class="line">            &#125;</span><br><span class="line">            result = doMockInvoke(invocation, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际invoke调用的是父类<code>AbstractClusterInvoker</code>的invoke方法，这个方法的主要功能是提供负载均衡：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public Result invoke(final Invocation invocation) throws RpcException &#123;</span><br><span class="line">    checkWhetherDestroyed();</span><br><span class="line"></span><br><span class="line">    // binding attachments into invocation.</span><br><span class="line">    Map&lt;String, String&gt; contextAttachments = RpcContext.getContext().getAttachments();</span><br><span class="line">    if (contextAttachments != null &amp;&amp; contextAttachments.size() != 0) &#123;</span><br><span class="line">        ((RpcInvocation) invocation).addAttachments(contextAttachments);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 找到所有可调用的服务器</span><br><span class="line">    List&lt;Invoker&lt;T&gt;&gt; invokers = list(invocation);</span><br><span class="line">    // 发送时要经过负载均衡</span><br><span class="line">    LoadBalance loadbalance = initLoadBalance(invokers, invocation);</span><br><span class="line">    RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);</span><br><span class="line">    return doInvoke(invocation, invokers, loadbalance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的<code>doInvoke</code>是一个模板方法，由子类实现，默认子类是<code>FailoverClusterInvoker</code>，可以看到，它先通过负载均衡策略得到一个Invoker，再调用该Invoker，Invoker的默认实现是<code>DubboInvoker</code>，表示使用的是Dubbo协议。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">private Result doInvoke(List&lt;Invoker&lt;T&gt;&gt; invokers,</span><br><span class="line">                        final List&lt;Invoker&lt;T&gt;&gt; invoked,</span><br><span class="line">                        Holder&lt;RpcException&gt; lastException,</span><br><span class="line">                        final Set&lt;String&gt; providers,</span><br><span class="line">                        final Invocation invocation,</span><br><span class="line">                        final LoadBalance loadbalance,</span><br><span class="line">                        final int totalRetries,</span><br><span class="line">                        int retries,</span><br><span class="line">                        Holder&lt;Invoker&lt;T&gt;&gt; lastInvoked) throws RpcException &#123;</span><br><span class="line">    if (retries &lt; totalRetries) &#123;</span><br><span class="line">        checkWheatherDestoried();</span><br><span class="line">        invokers = list(invocation);</span><br><span class="line">        checkInvokers(invokers, invocation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 负载均衡</span><br><span class="line">    final Invoker&lt;T&gt; invoker = select(loadbalance, invocation, invokers, invoked);</span><br><span class="line">    invoked.add(invoker);</span><br><span class="line">    lastInvoked.value = invoker;</span><br><span class="line">    RpcContext.getContext().setInvokers((List) invoked);</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        return invoker.invoke(invocation);</span><br><span class="line">    &#125; catch (RpcException e) &#123;</span><br><span class="line">        //业务异常不重试</span><br><span class="line">        if (e.isBiz()) &#123;</span><br><span class="line">            throw e;</span><br><span class="line">        &#125;</span><br><span class="line">        lastException.value = e;</span><br><span class="line">    &#125; catch (Throwable e) &#123;</span><br><span class="line">        lastException.value = new RpcException(e.getMessage(), e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        providers.add(invoker.getUrl().getAddress());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (--retries == 0) &#123;</span><br><span class="line">        throw populateException(invokers, lastException.value, providers, invocation, totalRetries);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return doInvoke(invokers, invoked, lastException, providers, invocation, loadbalance, totalRetries, retries, lastInvoked);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Cluster的实现"><a href="#Cluster的实现" class="headerlink" title="Cluster的实现"></a>Cluster的实现</h4><ul>
<li>MockClusterInvoker<br>调用失败降级到mock接口；</li>
<li>BroadcastClusterInvoker<br>每个Invoker都调一次，忽略了LoadBalance；</li>
<li>AvailableClusterInvoker<br>把处于可用状态的Invoker都调一遍。</li>
<li>FailoverClusterInvoker<br>一个Invoker失败就换个Invoker重试几次。</li>
<li>FailbackClusterInvoker<br>如果调用失败就放到一个线程池中延迟5秒再发，一般用于发消息。</li>
<li>FailfastClusterInvoker<br>失败立刻报错</li>
<li>FailsafeClusterInvoker<br>失败就忽略，一般是用于记日志这种失败了影响也不大的场景。</li>
<li>ForkingClusterInvoker<br>一次性选n个Invoker，并行调用，只要有一个调用成功就返回，线程间通过<code>LinkedBlockingQueue</code>通信。</li>
</ul>
<h3 id="LoadBalance"><a href="#LoadBalance" class="headerlink" title="LoadBalance"></a>LoadBalance</h3><p>Cluster 层包含多个 Invoker，LoadBalance 负责从中选出一个来调用，有多种 LoadBalance 策略，比如随机选一个（<code>RandomLoadBalance</code>）、轮询（<code>RoundRobinLoadBalance</code>）、一致性hash（ConsistentHashLoadBalance）。<br>实例化LoadBalance：<code>com.alibaba.dubbo.rpc.cluster.support.AbstractClusterInvoker#invoke</code><br>使用LoadBalance选择一个Invoker：<code>com.alibaba.dubbo.rpc.cluster.support.AbstractClusterInvoker#select</code></p>
<h4 id="LoadBalance的多种实现"><a href="#LoadBalance的多种实现" class="headerlink" title="LoadBalance的多种实现"></a>LoadBalance的多种实现</h4><ul>
<li>RandomLoadBalance<br>计算权重，然后根据每个Invoker的权重调一个。</li>
<li>LeastActiveLoadBalance<br>找最近最不活跃的Invoker调用，如果这样的Invoker有多个，则按权重来随机选一个。</li>
<li>RoundRobinLoadBalance<br>轮询</li>
<li>ConsistentHashLoadBalance<br>一致性哈希，启动时会将Invoker排列在一个圆环上：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public ConsistentHashSelector(List&lt;Invoker&lt;T&gt;&gt; invokers, String methodName, int identityHashCode) &#123;</span><br><span class="line">    this.virtualInvokers = new TreeMap&lt;Long, Invoker&lt;T&gt;&gt;();</span><br><span class="line">    this.identityHashCode = identityHashCode;</span><br><span class="line">    URL url = invokers.get(0).getUrl();</span><br><span class="line"></span><br><span class="line">    String[] index = Constants.COMMA_SPLIT_PATTERN.split(url.getMethodParameter(methodName, &quot;hash.arguments&quot;, &quot;0&quot;));</span><br><span class="line">    argumentIndex = new int[index.length];</span><br><span class="line">    for (int i = 0; i &lt; index.length; i++) &#123;</span><br><span class="line">        argumentIndex[i] = Integer.parseInt(index[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int replicaNumber = url.getMethodParameter(methodName, &quot;hash.nodes&quot;, 160);</span><br><span class="line">    for (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class="line">        String address = invoker.getUrl().getAddress();</span><br><span class="line">        // 多复制几个，更均匀，避免所有请求都被hash到同一个Invoker</span><br><span class="line">        for (int i = 0; i &lt; replicaNumber / 4; i++) &#123;</span><br><span class="line">            byte[] digest = md5(address + i);</span><br><span class="line">            for (int h = 0; h &lt; 4; h++) &#123;</span><br><span class="line">                long m = hash(digest, h);</span><br><span class="line">                // 放入圆环上</span><br><span class="line">                virtualInvokers.put(m, invoker);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
将Invoker保存到virtualInvokers上，但是virtualInvokers本身是一个HashMap，如果新来的请求不能精确hash到其中的某个Invoker怎么办？是通过tailMap找到的下一个Invoker：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private Invoker&lt;T&gt; selectForKey(long hash) &#123;</span><br><span class="line">    Invoker&lt;T&gt; invoker;</span><br><span class="line">    Long key = hash;</span><br><span class="line"></span><br><span class="line">    if (!virtualInvokers.containsKey(key)) &#123;</span><br><span class="line">        SortedMap&lt;Long, Invoker&lt;T&gt;&gt; tailMap = virtualInvokers.tailMap(key);</span><br><span class="line">        if (tailMap.isEmpty()) &#123;</span><br><span class="line">            key = virtualInvokers.firstKey();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            key = tailMap.firstKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    invoker = virtualInvokers.get(key);</span><br><span class="line">    return invoker;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Filter-Invoker-层"><a href="#Filter-Invoker-层" class="headerlink" title="Filter &amp; Invoker 层"></a>Filter &amp; Invoker 层</h3><p>不过，在实际网络调用之前，Dubbo还提供Filter功能，Cluster会先激活Filter链然后最终调到<code>DubboInvoker.invoke(RpcInvocation)</code>：</p>
<ol>
<li><code>ConsumerContextFilter</code>可以将请求对象<code>Invocation</code>添加到上下文<code>RpcContext</code>中，其实就是存储到一个ThreadLocal变量中。</li>
<li><code>FutureFilter</code>在调用完毕后唤醒调用者线程。</li>
<li>或许还会有一些自定义的Filter，比如增加线程的TraceId、打印一些调用日志之类的，Filter结束后才最终调用到<code>DubboInvoker</code>。</li>
</ol>
<p><code>DubboInvoker</code>封装了同步和异步调用，Dubbo 实现同步和异步调用比较关键的一点就在于由谁调用 ResponseFuture 的 get 方法。同步调用模式下，由框架自身调用 ResponseFuture 的 get 方法。异步调用模式下，则由用户调用该方法。<br>DubboInvoker是通过Netty发送消息的，消息本身如何发送的就不多说了。</p>
<h3 id="Exchange"><a href="#Exchange" class="headerlink" title="Exchange"></a>Exchange</h3><p>封装了网络客户端的发送逻辑，包括：</p>
<ul>
<li>HeaderExchangeChannel<br>对 Request 的序列化</li>
<li>ReferenceCountExchangeClient<br>无引用时自动关闭客户端</li>
<li>HeaderExchangeClient<br>心跳检测</li>
</ul>
<h3 id="数据编码-发送"><a href="#数据编码-发送" class="headerlink" title="数据编码 &amp; 发送"></a>数据编码 &amp; 发送</h3><p>DubboCodec<br>NettyChannel#send</p>
<h2 id="Provider端接受调用的过程"><a href="#Provider端接受调用的过程" class="headerlink" title="Provider端接受调用的过程"></a>Provider端接受调用的过程</h2><ol>
<li>接收请求<br>NettyClient<br>请求被接收后，通过 Netty 调用链向下传递执行<br>NettyHandler#messageReceived<br>NettyChannel</li>
<li>解码<br><code>ExchangeCodec</code></li>
<li>线程派发<br><code>Dispatcher</code><br>IO 线程接收请求后分发给事件处理线程执行，具体的派发逻辑在<code>ChannelHandler</code>中实现，比如<code>AllChannelHandler</code>。</li>
<li>请求分发<br><code>ChannelEventRunnable</code><br>根据请求类型将请求分发给不同的<code>ChannelHandler</code>处理。</li>
</ol>
<p>Provider 端响应</p>
<p>Consumer 端接收响应</p>
<ol>
<li>发送完请求后阻塞<br><code>HeaderExchangeHandler</code><br>用户线程在发送完请求后，会调用 <code>DefaultFuture</code> 的 <code>get</code> 方法等待响应对象的到来，这时每个<code>DefaultFuture</code>都会关联一个<strong>调用编号</strong>，用于在接收到响应时能对应上请求的<code>DefaultFuture</code>。<br>当响应对象到来后，IO 线程根据<strong>调用编号</strong>可以找到<code>DefaultFuture</code>，之后会将响应对象保存到<code>DefaultFuture</code>，并唤醒用户线程。</li>
</ol>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/bf77fad5.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tallate">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tallate">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/bf77fad5.html" class="post-title-link" itemprop="url">自制LinuxContainer</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-09-07 18:51:58" itemprop="dateCreated datePublished" datetime="2019-09-07T18:51:58+08:00">2019-09-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-07 01:56:20" itemprop="dateModified" datetime="2025-07-07T01:56:20+08:00">2025-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Docker/" itemprop="url" rel="index"><span itemprop="name">Docker</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><h3 id="进程和clone系统调用"><a href="#进程和clone系统调用" class="headerlink" title="进程和clone系统调用"></a>进程和clone系统调用</h3><p>进程（Process）是运行中的程序实例，又可以称为任务（Task），进程在Linux内核中使用一个PCB来表示，主要包含运行状态、信号、进程号、父进程号、运行时间累计值、正在使用的文件（文件描述符表）、本任务的局部描述符及任务状态段信息。<br>不同于fork，clone系统调用允许子进程共享部分父进程的上下文，如内存空间、文件描述符表、信号等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* Prototype for the glibc wrapper function */</span><br><span class="line">#define _GNU_SOURCE</span><br><span class="line">#include &lt;sched.h&gt;</span><br><span class="line">int clone(int (*fn)(void *), void *child_stack,</span><br><span class="line">          int flags, void *arg, ...</span><br><span class="line">          /* pid_t *ptid, void *newtls, pid_t *ctid */ );</span><br><span class="line">/* For the prototype of the raw system call, see NOTES */</span><br></pre></td></tr></table></figure>
<p><code>clone</code>常用于实现<strong>多线程</strong>，因为子进程和父进程可以共享内存。<br>不同于<code>fork</code>创建的子进程会从调用的位置开始执行，<code>clone</code>创建的子进程会执行实参传入的<code>fn(arg)</code>，并将实参中的<code>arg</code>传入。<br>当<code>fn(arg)</code>返回后子进程页会终止，返回值即为子进程的exit code，当然子进程在遇到显式的<code>exit</code>调用或终止信号也会立刻退出。<br>子进程与父进程共享内存，它们不能（也不应该）使用同一个栈，因此必须使用<code>child_stack</code>参数指定子进程使用的栈所在的内存空间。栈是从上向下生长的，因此最好指定最顶层的一个地址。<br><code>flags</code>的低位包含子进程退出了发送给父进程的信号，If this signal is specified as anything other than SIGCHLD, then the parent process must specify the __WALL or __WCLONE options when waiting for the child with wait(2). If no signal is specified, then the parent process is not signaled when the child terminates.<br><code>flags</code> 还可以指定子进程和父进程间可以共享的内容，具体内容见<code>man clone</code>。</p>
<h3 id="虚拟网络设备和veth-pair"><a href="#虚拟网络设备和veth-pair" class="headerlink" title="虚拟网络设备和veth pair"></a>虚拟网络设备和veth pair</h3><p>Linux container 中用到一个叫做veth的东西，这是一种新的设备，专门为 container 所建。veth 从名字上来看是 Virtual ETHernet 的缩写，它的作用很简单，就是要把从一个 network namespace 发出的数据包转发到另一个 namespace。veth 设备是成对的，一个是 container 之中，另一个在 container 之外，即在真实机器上能看到的。 </p>
<h4 id="veth设备实现原理"><a href="#veth设备实现原理" class="headerlink" title="veth设备实现原理"></a>veth设备实现原理</h4><p>VETH设备总是成对出现，送到一端请求发送的数据总是从另一端以请求接受的形式出现。创建并配置正确后，向其一端输入数据，VETH会改变数据的方向并将其送入内核网络子系统，完成数据的注入，而在另一端则能读到此数据。（Namespace，其中往veth设备上任意一端上RX到的数据，都会在另一端上以TX的方式发送出去）veth工作在L2数据链路层，veth-pair设备在转发数据包过程中并不串改数据包内容。<br>这里写图片描述<br>显然，仅有veth-pair设备，容器是无法访问网络的。因为容器发出的数据包，实质上直接进入了veth1设备的协议栈里。如果容器需要访问网络，需要使用bridge等技术，将veth1接收到的数据包通过某种方式转发出去。</p>
<blockquote>
<p>VETH: Typically used when you are trying to connect two entities which would want to “get hold of” (for lack of better phrase) an interface to forward&#x2F;receive frames. These entities could be containers&#x2F;bridges&#x2F;ovs-switch etc. Say you want to connect a docker&#x2F;lxc container to OVS. You can create a veth pair and push the first interface to the docker&#x2F;lxc (say, as a phys interface) and push the other interface to OVS. You cannot do this with TAP.</p>
</blockquote>
<h4 id="veth设备特点"><a href="#veth设备特点" class="headerlink" title="veth设备特点"></a>veth设备特点</h4><ul>
<li>veth和其它的网络设备都一样，一端连接的是内核协议栈</li>
<li>veth设备是成对出现的，另一端两个设备彼此相连</li>
<li>一个设备收到协议栈的数据发送请求后，会将数据发送到另一个设备上去</li>
</ul>
<h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 创建veth</span><br><span class="line">ip link add name veth0 type veth0 peer name veth1</span><br></pre></td></tr></table></figure>
<p>其他细节见Linux篇《虚拟化-网络设备》</p>
<h3 id="资源隔离、namespace和cgroup"><a href="#资源隔离、namespace和cgroup" class="headerlink" title="资源隔离、namespace和cgroup"></a>资源隔离、namespace和cgroup</h3><p><strong>namespace</strong>的主要作用是对两个系统内的标识符的命名进行隔离，namespace有以下几种。<br><img src="/imgs/Docker/Linux-namespace%E7%A7%8D%E7%B1%BB.jpg" alt="Linux-namespace种类" title="Linux-namespace种类"><br>这几个flag 可以在调用clone进行进程创建的时候作为参数传入，从而实现namespace的隔离，从这个角度来说，container主要是进程角度的隔离，而不是传统的虚拟机（一些虚拟机实现同样是基于对操作系统层的虚拟化，所以应该和container是类似的，比如普通vmware），因为container底层用的是同一个内核来调度。</p>
<p><strong>cgroup</strong> 是linux 内核的另外一个控制和隔离进程的特性，他分为cpu ，memory，net，io等几个子系统，从而实现对进程cpu，内存，磁盘，网络等资源使用的控制。</p>
<h3 id="虚拟文件系统（VFS）和chroot"><a href="#虚拟文件系统（VFS）和chroot" class="headerlink" title="虚拟文件系统（VFS）和chroot"></a>虚拟文件系统（VFS）和chroot</h3><p>将根目录设置成另外一个目录</p>
<h2 id="自制容器"><a href="#自制容器" class="headerlink" title="自制容器"></a>自制容器</h2><p>docker 只是一个工具，container 技术的核心还是linux 内核的cgroup + chroot + namespace 技术。</p>
<h3 id="制作image"><a href="#制作image" class="headerlink" title="制作image"></a>制作image</h3><p>制作自己容器，需要一个image ，可以从网上下一个，也可以自己制作，制作很简单，新装一个操作系统，安装一些需要用到的软件包，然后用tar 制作 &#x2F; 目录下的压缩包，去掉一些虚拟文件系统的文件，本文用的是自己制作的centos 6.5 的image。</p>
<h3 id="容器实现过程"><a href="#容器实现过程" class="headerlink" title="容器实现过程"></a>容器实现过程</h3><p>容器实现过程可以归纳为</p>
<ol>
<li>用clone系统调用创建子进程，传入namespace的那几个参数，实现namespace的隔离；</li>
<li>父进程中创建veth pair ，一个veth在自己的namespace，将另一个设置为子进程的namespace，实现container和宿主机的网络通信；</li>
<li>父进程创建cgroup memory和cpuset子系统，将子进程attach到cgroup子系统上，实现container 的资源限制和隔离；</li>
<li>子进程在自己的namespace里，设置主机名，mount proc虚拟文件系统，设置veth ip，chroot到centos 6镜像的位置， 最终将进程镜像替换成&#x2F;bin&#x2F;bash；</li>
<li>父进程调用waitpid 等待子进程退出。</li>
</ol>
<h3 id="容器实现"><a href="#容器实现" class="headerlink" title="容器实现"></a>容器实现</h3><p>见下面的《源码》部分</p>
<h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><p>在解压好镜像后，该镜像根目录下可能还没有必须的命令文件及其依赖的动态链接库，主要是由于用<code>chroot</code>改变根目录后，原来路径下的一些文件在当前镜像内都找不到了，一般安装完操作系统后这些文件应该都安装好了，如果需要可以<a target="_blank" rel="noopener" href="https://ubuntuforums.org/showthread.php?t=1434781">通过手动移动来解决</a>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ldd /bin/bash</span><br><span class="line">cp --parents /lib/x86_64-linux-gnu/libtinfo.so.5 ./</span><br></pre></td></tr></table></figure>
<p>编译执行容器代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc lxc_demo.c -o lxc_demo -lcgroup</span><br><span class="line">sudo ./lxc_demo</span><br></pre></td></tr></table></figure>
<p>接下来分别在宿主机和容器内执行命令，可以得出一些结论：</p>
<ol>
<li>容器和宿主机镜像可能不同，但是内核相同；<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># （宿主机内）</span><br><span class="line">hgc@hgc-X555LD:~$ uname -r</span><br><span class="line">4.13.0-45-generic</span><br><span class="line"></span><br><span class="line"># （容器内）</span><br><span class="line">bash-4.4# uname -r</span><br><span class="line">4.13.0-45-generic</span><br></pre></td></tr></table></figure></li>
<li>根目录下的文件不同；<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /</span><br></pre></td></tr></table></figure></li>
<li>hostname，宿主机内为用户设定的主机名，容器内为mydocker，说明UTS namespace隔离成功；<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hostname</span><br></pre></td></tr></table></figure></li>
<li>网络方面有回环网络卡lo和veth1，veth1 169.254.1.2 能ping 通veth0的地址（宿主机上的veth）169.254.2.1，如果在外面加iptables 做nat 转换的话，container里面还可以和外面通信。我们看不到外面宿主机的eth0 和 eth1，说明container 的network namespace 隔离成功。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># （宿主机内）</span><br><span class="line">$ ip addr</span><br><span class="line">......</span><br><span class="line">19: veth0@if18: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000</span><br><span class="line">    link/ether 46:c0:eb:a8:34:8d brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 169.254.1.1/30 scope global veth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::44c0:ebff:fea8:348d/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"></span><br><span class="line"># （容器内）网络方面有回环网络卡lo和veth1</span><br><span class="line">bash-4.4# ip addr</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">18: veth1@if19: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000</span><br><span class="line">    link/ether ce:04:78:b6:5a:2d brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 169.254.1.2/30 scope global veth1</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::cc04:78ff:feb6:5a2d/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"># 尝试ping宿主机上的veth0设备</span><br><span class="line">bash-4.4# ping 169.254.1.1</span><br><span class="line">PING 169.254.1.1 (169.254.1.1) 56(84) bytes of data.</span><br><span class="line">64 bytes from 169.254.1.1: icmp_seq=1 ttl=64 time=0.101 ms</span><br><span class="line">......</span><br></pre></td></tr></table></figure></li>
<li>目前container 里面只有&#x2F;bin&#x2F;bash , 且进程号为 1，不是我们常见的init进程，或者systemd 。因为&#x2F;bin&#x2F;bash 为该namespace 下的第一个进程，说明我们的pid namespace隔离成功。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 查看进程</span><br><span class="line">bash-4.4# ps -aux </span><br><span class="line">USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND</span><br><span class="line">0 1 0.0 0.0 9924 3264 ? S 01:02 0:00 /bin/bash</span><br><span class="line">0 8 0.0 0.0 30524 2820 ? R+ 01:02 0:00 ps -aux</span><br></pre></td></tr></table></figure></li>
<li>mount 显示挂载的文件系统，和宿主机的不一样，说明mount namespace隔离成功。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 查看挂载情况（这里有点问题，原文里还有rootfs、sysfs等）</span><br><span class="line">bash-4.4# mount</span><br><span class="line">proc on /proc type proc (rw,relatime)</span><br><span class="line">......</span><br></pre></td></tr></table></figure></li>
<li>就cgroup的隔离情况来说，在cgroup文件系统内，memory的限制是我们设置的512M，cpu使用的是0-1号。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hgc@hgc-X555LD:~/tools/virtualmachines/ubuntu-16.04$ cd /sys/fs/cgroup/memory/mydocker_1530580167/</span><br><span class="line">hgc@hgc-X555LD:/sys/fs/cgroup/memory/mydocker_1530580167$ cat memory.limit_in_bytes </span><br><span class="line">536870912</span><br><span class="line">hgc@hgc-X555LD:/sys/fs/cgroup/memory/mydocker_1530580167$ cd /sys/fs/cgroup/cpuset/mydocker_1530580167/</span><br><span class="line">hgc@hgc-X555LD:/sys/fs/cgroup/cpuset/mydocker_1530580167$ cat cpuset.cpus </span><br><span class="line">0-1</span><br><span class="line">hgc@hgc-X555LD:/sys/fs/cgroup/cpuset/mydocker_1530580167$ cat cpuset.mems </span><br><span class="line">0</span><br><span class="line">hgc@hgc-X555LD:/sys/fs/cgroup/cpuset/mydocker_1530580167$ top</span><br></pre></td></tr></table></figure>
从下面执行情况可以看出，只有0号和1号cpu idle为0 ，其他的都接近100%，说明cgroup隔离效果是很好的。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"># （宿主机内）执行top命令并点击1查看CPU负载情况</span><br><span class="line">hgc@hgc-X555LD:/sys/fs/cgroup/cpuset/mydocker_1530580167$ top</span><br><span class="line">top - 10:02:22 up 13:19, 1 user, load average: 0.74, 0.68, 0.72</span><br><span class="line">Tasks: 348 total, 1 running, 346 sleeping, 0 stopped, 1 zombi</span><br><span class="line">%Cpu0 : 5.3 us, 2.3 sy, 0.0 ni, 91.7 id, 0.0 wa, 0.0 hi, 0.7</span><br><span class="line">%Cpu1 : 8.3 us, 12.6 sy, 0.0 ni, 78.8 id, 0.0 wa, 0.0 hi, 0.3</span><br><span class="line">%Cpu2 : 4.0 us, 2.0 sy, 0.0 ni, 93.9 id, 0.0 wa, 0.0 hi, 0.0</span><br><span class="line">%Cpu3 : 3.0 us, 2.4 sy, 0.0 ni, 94.6 id, 0.0 wa, 0.0 hi, 0.0</span><br><span class="line">%Cpu4 : 7.1 us, 5.7 sy, 0.0 ni, 87.2 id, 0.0 wa, 0.0 hi, 0.0</span><br><span class="line">%Cpu5 : 4.4 us, 1.4 sy, 0.0 ni, 93.9 id, 0.3 wa, 0.0 hi, 0.0</span><br><span class="line">%Cpu6 : 3.3 us, 2.7 sy, 0.0 ni, 93.7 id, 0.0 wa, 0.0 hi, 0.3</span><br><span class="line">%Cpu7 : 3.7 us, 1.3 sy, 0.0 ni, 94.6 id, 0.0 wa, 0.0 hi, 0.3</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"># （容器内）执行多个死循环任务，强行使CPU忙碌</span><br><span class="line">bash-4.4# while true; do echo &gt; /dev/null; done &amp;                   </span><br><span class="line">[1] 10</span><br><span class="line">bash-4.4# while true; do echo &gt; /dev/null; done &amp;</span><br><span class="line">[2] 11</span><br><span class="line">bash-4.4# while true; do echo &gt; /dev/null; done &amp;</span><br><span class="line">[3] 12</span><br><span class="line">bash-4.4# while true; do echo &gt; /dev/null; done &amp;</span><br><span class="line">[4] 13</span><br><span class="line">bash-4.4# while true; do echo &gt; /dev/null; done &amp;</span><br><span class="line">[5] 14</span><br><span class="line">bash-4.4# while true; do echo &gt; /dev/null; done &amp;</span><br><span class="line">[6] 15</span><br><span class="line">bash-4.4# while true; do echo &gt; /dev/null; done &amp;</span><br><span class="line">[7] 16</span><br><span class="line"></span><br><span class="line"># （宿主机内）同样是执行top命令并点击1，可以看到头两个CPU的负载情况有了明显变化</span><br><span class="line">hgc@hgc-X555LD:/sys/fs/cgroup/cpuset/mydocker_1530580167$ top</span><br><span class="line">top - 10:05:05 up 13:22, 1 user, load average: 4.25, 1.68, 1.06</span><br><span class="line">Tasks: 355 total, 1 running, 353 sleeping, 0 stopped, 1 zombi</span><br><span class="line">%Cpu0 : 9.9 us, 34.8 sy, 0.0 ni, 53.2 id, 2.0 wa, 0.0 hi, 0.0</span><br><span class="line">%Cpu1 : 14.4 us, 43.6 sy, 0.0 ni, 40.2 id, 1.7 wa, 0.0 hi, 0.0</span><br><span class="line">%Cpu2 : 2.2 us, 0.6 sy, 0.0 ni, 92.0 id, 0.0 wa, 0.0 hi, 5.1</span><br><span class="line">%Cpu3 : 2.6 us, 1.3 sy, 0.0 ni, 95.0 id, 0.0 wa, 0.0 hi, 1.0</span><br><span class="line">%Cpu4 : 6.4 us, 10.0 sy, 0.0 ni, 83.6 id, 0.0 wa, 0.0 hi, 0.0</span><br><span class="line">%Cpu5 : 2.3 us, 1.2 sy, 0.0 ni, 95.3 id, 0.0 wa, 0.0 hi, 1.2</span><br><span class="line">%Cpu6 : 1.7 us, 0.7 sy, 0.0 ni, 97.6 id, 0.0 wa, 0.0 hi, 0.0</span><br><span class="line">%Cpu7 : 2.0 us, 2.7 sy, 0.0 ni, 95.3 id, 0.0 wa, 0.0 hi, 0.0</span><br><span class="line">......</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line">#define _GNU_SOURCE</span><br><span class="line"></span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sched.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/mount.h&gt;</span><br><span class="line">// 必须先安装：sudo apt-get install libcgroup-dev</span><br><span class="line">#include &lt;libcgroup.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line">#define STACK_SIZE (1024 * 1024)</span><br><span class="line">#define MEMORY_LIMIT (512*1024*1024)</span><br><span class="line"></span><br><span class="line">//const char *rootfs = &quot;/data1/centos6/rootfs/&quot;; //centos6 镜像位置</span><br><span class="line">//const char *rootfs = &quot;/home/hgc/tools/virtualmachines/ubuntu-16.04/&quot;; // 镜像位置</span><br><span class="line">//const char *hostname = &quot;mydocker&quot;; //container 主机名</span><br><span class="line">static char child_stack[STACK_SIZE];</span><br><span class="line">//char *const child_args[] = &#123;</span><br><span class="line">//    &quot;/bin/bash&quot;,</span><br><span class="line">//    NULL</span><br><span class="line">//&#125;;</span><br><span class="line">int pipe_fd[2]; //父子进程同步</span><br><span class="line"></span><br><span class="line">int child_main(void *args) &#123;</span><br><span class="line">  char c;</span><br><span class="line">  // TODO:子进程里无法使用全局变量rootfs和hostname</span><br><span class="line">  // 镜像位置</span><br><span class="line">  const char *rootfs = &quot;/home/hgc/tools/virtualmachines/ubuntu-16.04/&quot;;</span><br><span class="line">  // container 主机名</span><br><span class="line">  const char *hostname = &quot;mydocker&quot;;</span><br><span class="line">  // 在子进程（容器）内执行的任务</span><br><span class="line">  // TODO:因为chroot改变了根目录的位置，所以在保证目标命令存在容器内的基础上（这里是/bin/bash），</span><br><span class="line">  // TODO:必须保证该命令依赖的资源同样存在于容器内（动态链接库，使用ldd查看）</span><br><span class="line">  char *const child_args[] = &#123;</span><br><span class="line">      &quot;/bin/bash&quot;,</span><br><span class="line">      0</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  printf(&quot;In child process(container)\n&quot;);</span><br><span class="line">  chroot(rootfs); //用chroot 切换根目录</span><br><span class="line">  if (errno != 0) &#123;</span><br><span class="line">    perror(&quot;chroot()&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">  &#125;</span><br><span class="line">  // TODO:这里不能使用sizeof</span><br><span class="line">  //clone 调用中的 CLONE_NEWUTS起隔离主机名和域名的作用</span><br><span class="line">  sethostname(hostname, strlen(hostname));</span><br><span class="line">  if (errno != 0) &#123;</span><br><span class="line">    perror(&quot;sethostname()!&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">  &#125;</span><br><span class="line">  //挂载proc子系统，CLONE_NEWNS 起隔离文件系统作用</span><br><span class="line">  // 需要在rootfs目录下创建proc目录</span><br><span class="line">  mount(&quot;proc&quot;, &quot;/proc&quot;, &quot;proc&quot;, 0, NULL);</span><br><span class="line">  if (errno != 0) &#123;</span><br><span class="line">    perror(&quot;Mount(proc)&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">  &#125;</span><br><span class="line">  //切换的根目录</span><br><span class="line">  chdir(&quot;/&quot;);</span><br><span class="line">  close(pipe_fd[1]);</span><br><span class="line">  read(pipe_fd[0], &amp;c, 1);</span><br><span class="line">  //设置veth1 网络</span><br><span class="line">  system(&quot;ip link set lo up&quot;);</span><br><span class="line">  system(&quot;ip link set veth1 up&quot;);</span><br><span class="line">  system(&quot;ip addr add 169.254.1.2/30 dev veth1&quot;);</span><br><span class="line">  //将子进程的镜像替换成bash</span><br><span class="line">  printf(&quot;[%s]\n&quot;, child_args[0]);</span><br><span class="line">  if (execv(child_args[0], child_args) == -1) &#123;</span><br><span class="line">    perror(&quot;execv(path, argv)&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct cgroup *cgroup_control(pid_t pid) &#123;</span><br><span class="line">  struct cgroup *cgroup = NULL;</span><br><span class="line">  int ret;</span><br><span class="line">  ret = cgroup_init();</span><br><span class="line">  char *cgname = malloc(19 * sizeof(char));</span><br><span class="line">  if (ret) &#123;</span><br><span class="line">    printf(&quot;error occurs while init cgroup.\n&quot;);</span><br><span class="line">    return NULL;</span><br><span class="line">  &#125;</span><br><span class="line">  time_t now_time = time(NULL);</span><br><span class="line">  sprintf(cgname, &quot;mydocker_%d&quot;, (int) now_time);</span><br><span class="line">  printf(&quot;%s\n&quot;, cgname);</span><br><span class="line">  cgroup = cgroup_new_cgroup(cgname);</span><br><span class="line">  if (!cgroup) &#123;</span><br><span class="line">    ret = ECGFAIL;</span><br><span class="line">    printf(&quot;Error new cgroup%s\n&quot;, cgroup_strerror(ret));</span><br><span class="line">    goto out;</span><br><span class="line">  &#125;</span><br><span class="line">  //添加cgroup memory 和 cpuset子系统</span><br><span class="line">  struct cgroup_controller *cgc = cgroup_add_controller(cgroup, &quot;memory&quot;);</span><br><span class="line">  struct cgroup_controller *cgc_cpuset = cgroup_add_controller(cgroup, &quot;cpuset&quot;);</span><br><span class="line">  if (!cgc || !cgc_cpuset) &#123;</span><br><span class="line">    ret = ECGINVAL;</span><br><span class="line">    printf(&quot;Error add controller %s\n&quot;, cgroup_strerror(ret));</span><br><span class="line">    goto out;</span><br><span class="line">  &#125;</span><br><span class="line">  // 内存限制  512M</span><br><span class="line">  if (cgroup_add_value_uint64(cgc, &quot;memory.limit_in_bytes&quot;, MEMORY_LIMIT)) &#123;</span><br><span class="line">    printf(&quot;Error limit memory.\n&quot;);</span><br><span class="line">    goto out;</span><br><span class="line">  &#125;</span><br><span class="line">  //限制只能使用0和1号cpu</span><br><span class="line">  if (cgroup_add_value_string(cgc_cpuset, &quot;cpuset.cpus&quot;, &quot;0-1&quot;)) &#123;</span><br><span class="line">    printf(&quot;Error limit cpuset cpus.\n&quot;);</span><br><span class="line">    goto out;</span><br><span class="line">  &#125;</span><br><span class="line">  //限制只能使用0和1块内存</span><br><span class="line">  // TODO:使用0-1作为参数会报错“Invalid argument”</span><br><span class="line">  if (cgroup_add_value_string(cgc_cpuset, &quot;cpuset.mems&quot;, &quot;0&quot;)) &#123;</span><br><span class="line">    printf(&quot;Error limit cpuset mems.\n&quot;);</span><br><span class="line">    goto out;</span><br><span class="line">  &#125;</span><br><span class="line">  ret = cgroup_create_cgroup(cgroup, 0);</span><br><span class="line">  if (ret) &#123;</span><br><span class="line">    printf(&quot;Error create cgroup%s\n&quot;, cgroup_strerror(ret));</span><br><span class="line">    goto out;</span><br><span class="line">  &#125;</span><br><span class="line">  ret = cgroup_attach_task_pid(cgroup, pid);</span><br><span class="line">  if (ret) &#123;</span><br><span class="line">    printf(&quot;Error attach_task_pid %s\n&quot;, cgroup_strerror(ret));</span><br><span class="line">    goto out;</span><br><span class="line">  &#125;</span><br><span class="line">  return cgroup;</span><br><span class="line">  out:</span><br><span class="line">  if (cgroup) &#123;</span><br><span class="line">    cgroup_delete_cgroup(cgroup, 0);</span><br><span class="line">    cgroup_free(&amp;cgroup);</span><br><span class="line">  &#125;</span><br><span class="line">  return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  char *cmd;</span><br><span class="line">  printf(&quot;main process: \n&quot;);</span><br><span class="line">  pipe(pipe_fd);</span><br><span class="line">  if (errno != 0) &#123;</span><br><span class="line">    perror(&quot;pipe()&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">  &#125;</span><br><span class="line">  // 调用clone创建子进程，传入namespace的几个flag参数，实现namespace的隔离</span><br><span class="line">  // 子进程执行child_main函数，其堆栈空间使用child_stack参数指定</span><br><span class="line">  // clone与线程的实现息息相关：http://www.xuebuyuan.com/1422353.html</span><br><span class="line">  int child_pid = clone(child_main, child_stack + STACK_SIZE, \</span><br><span class="line">            CLONE_NEWNET | CLONE_NEWNS | CLONE_NEWPID | CLONE_NEWIPC | CLONE_NEWUTS | SIGCHLD, NULL);</span><br><span class="line">  struct cgroup *cg = cgroup_control(child_pid);</span><br><span class="line">  // 添加veth pair，设置veth1 在子进程的的namespace，veth0 在父进程的namespace，为了实现container和宿主机之间的网络通信</span><br><span class="line">  // linl3 实现起来太繁琐，借用命令行工具ip 实现</span><br><span class="line">  system(&quot;ip link add veth0 type veth peer name veth1&quot;);</span><br><span class="line">  asprintf(&amp;cmd, &quot;ip link set veth1 netns %d&quot;, child_pid); // asprintf根据字符串长度申请足够的内存空间，但在之后必须手动释放</span><br><span class="line">  system(cmd);</span><br><span class="line">  system(&quot;ip link set veth0 up&quot;);</span><br><span class="line">  system(&quot;ip addr add 169.254.1.1/30 dev veth0&quot;);</span><br><span class="line">  free(cmd);</span><br><span class="line">  //等执行以上命令，通知子进程，子进程设置自己的网络</span><br><span class="line">  close(pipe_fd[1]);</span><br><span class="line">  waitpid(child_pid, NULL, 0);</span><br><span class="line">  if (cg) &#123;</span><br><span class="line">    cgroup_delete_cgroup(cg, 0); //删除cgroup 子系统</span><br><span class="line">  &#125;</span><br><span class="line">  printf(&quot;child process exited.\n&quot;);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="LXC"><a href="#LXC" class="headerlink" title="LXC"></a>LXC</h3><ol>
<li><a target="_blank" rel="noopener" href="https://linuxcontainers.org/">Linux Containers</a></li>
<li><a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/linux/l-cn-chroot/">理解 chroot</a></li>
</ol>
<h3 id="虚拟网络设备"><a href="#虚拟网络设备" class="headerlink" title="虚拟网络设备"></a>虚拟网络设备</h3><ol>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/sld880311/article/details/77650937">Linux-虚拟网络设备-veth pair</a></li>
</ol>
<h3 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h3><ol>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013272948/article/details/69218319">linux的Clone()函数详解</a></li>
</ol>
<h3 id="Linux-namespace"><a href="#Linux-namespace" class="headerlink" title="Linux namespace"></a>Linux namespace</h3><ol>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/preterhuman_peak/article/details/40857117">Linux Namespaces机制</a></li>
<li><a target="_blank" rel="noopener" href="https://linux.cn/article-5019-1.html">介绍 Linux 的命名空间</a></li>
</ol>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/bf6c261d.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tallate">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tallate">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/bf6c261d.html" class="post-title-link" itemprop="url">Dubbo的SPI原理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-09-07 18:51:58" itemprop="dateCreated datePublished" datetime="2019-09-07T18:51:58+08:00">2019-09-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-07 01:56:20" itemprop="dateModified" datetime="2025-07-07T01:56:20+08:00">2025-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Dubbo/" itemprop="url" rel="index"><span itemprop="name">Dubbo</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>



<h2 id="接口扩展策略注解-SPI"><a href="#接口扩展策略注解-SPI" class="headerlink" title="接口扩展策略注解 @SPI"></a>接口扩展策略注解 @SPI</h2><p>Dubbo中的很多扩展接口，如 Protocol、Transporter、Filter 等，都是通过 JDK 的 SPI 机制实现的，也就是说这些功能都可被用户自定义的扩展所替换，接口扩展点由注解<code>@SPI</code>定义。<br>JDK 中 SPI（Service Provider Interface）的设计与策略模式如出一辙，开发者可以替换掉 Dubbo 原扩展接口的默认实现，完成自定义需求，即可以自定义实现策略。<br>Dubbo 在 JDK 现有 SPI 实现的基础上做了如下改进：</p>
<ol>
<li>JDK 标准的 SPI 会一次性实例化扩展点所有实现，如果有扩展实现初始化很耗时，但如果没用上也加载，会很浪费资源。</li>
<li>如果扩展点加载失败，连扩展点的名称都拿不到了。比如：JDK 标准的 ScriptEngine，通过 getName();获取脚本类型的名称，但如果 RubyScriptEngine 因为所依赖的 jruby.jar 不存在，导致 RubyScriptEngine 类加载失败，这个失败原因被吃掉了，和 ruby 对应不起来，当用户执行 ruby 脚本时，会报不支持 ruby，而不是真正失败的原因。</li>
<li>增加了对扩展点 IoC 和 AOP 的支持，一个扩展点可以直接 setter 注入其它扩展点。</li>
</ol>
<p>那么 Dubbo 的 SPI 机制是怎么实现的呢？以协议扩展为例，Dubbo 中协议被抽象为 Protocol 接口。</p>
<h3 id="读取扩展点"><a href="#读取扩展点" class="headerlink" title="读取扩展点"></a>读取扩展点</h3><p>ServiceConfig#protocol</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension()</span><br></pre></td></tr></table></figure>

<p>Dubbo 使用 ExtensionLoader 实现扩展点加载。</p>
<ul>
<li>ExtensionLoader#getExtensionLoader()<br>获取 ExtensionLoader 实现，保证每种扩展点一个单例。</li>
<li>ExtensionLoader#getAdaptiveExtension()<br>根据不同的 SPI 扩展点，即不同的 interface，生成不同的 Adaptive 实例的代码。<br>-&gt; getAdaptiveExtensionClass()<br>-&gt; getExtensionClasses()<br>-&gt; loadExtensionClasses()<br>加载所有的扩展点实现，直到扩展点方法执行时才决定调用是一个扩展点实现，即从众多的实现策略中决定具体使用哪一个策略。<br>ExtensionLoader 会依次从<code>META-INF/dubbo/internal</code>（Dubbo 内部实现）、<code>META-INF/dubbo/</code>（开发者自定义策略）、<code>META-INF/services/</code>这几个目录下读取扩展点实现，目录下的同名文件配置了对应扩展点的实现策略，调用 loadFile 来加载对应的扩展策略。<br>-&gt; loadFile(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, String dir)</li>
</ul>
<h3 id="生成-Adaptive-实例"><a href="#生成-Adaptive-实例" class="headerlink" title="生成 Adaptive 实例"></a>生成 Adaptive 实例</h3><ul>
<li>ExtensionLoader#loadFile<br>-&gt; String fileName &#x3D; dir + type.getName()<br>拼接文件路径<br>-&gt; ClassLoader classLoader &#x3D; findClassLoader()<br>拿到 ExtensionLoader 的类加载器。<br>-&gt; Class&lt;?&gt; clazz &#x3D; Class.forName(line, true, classLoader);<br>文件每行是一个实现类的全路径名，通过反射加载并拿到具体类型。<br>-&gt; extensionClasses.put(n, clazz)<br>添加到 map 里返回。</li>
<li>ExtensionLoader#cachedClasses<br>-&gt; cachedClasses.set(classes)<br>添加到缓存。</li>
<li>ExtensionLoader#createAdaptiveExtensionClass<br>-&gt; ExtensionLoader#createAdaptiveExtensionClassCode<br>生成 Adaptive 类。<br>-&gt; compiler &#x3D; ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.common.compiler.Compiler.class).getAdaptiveExtension()<br>拿到编译接口扩展点的一个具体实现，dubbo 内部支持 jdk 和 javassist，默认是 javassist。<br>-&gt; compiler.compile(code, classLoader)<br>编译代码，生成 Adaptive 实例类。</li>
</ul>
<p>上面提到 Compiler 也是一个扩展点，同样也依赖这个流程来实例化，在运行时生成 Adaptive 实例的时候，需要生成 Compiler 接口的 Adaptive 实例，即运行生成 Adaptive 实例的时候需要先有一个 Compiler 接口的 Adaptive 实例，那这样岂不是陷入了死循环，这里就要提到显示指定 Adaptive 实例的情况。<code>@Adaptive</code>注解支持类级别和方法级别：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、类级别：只能拥有一个，注解打在接口实现类上，显示的注册一个Adaptive实例，在编译期就存在，如`AdaptiveCompiler`，解决了上面的死循环问题，由`AdaptiveCompiler`依据dubbo配置决定使用哪个编译类；</span><br><span class="line">2、方法级别：在运行期动态的生成Adaptive实例。</span><br></pre></td></tr></table></figure>

<h3 id="通过-URL-动态选择协议"><a href="#通过-URL-动态选择协议" class="headerlink" title="通过 URL 动态选择协议"></a>通过 URL 动态选择协议</h3><p>ExtensionLoader#createAdaptiveExtensionClassCode<br>生成的 Protocol 的 Adaptive 实例类，依据 URL 中 protocol key-value 的值，选择对应的 Protocol 策略来暴露和引用服务。<br>扩展点方法调用会有 URL 参数（或是参数有 URL 成员），这样依赖的扩展点可以从 URL 拿到配置信息，所有的扩展点自己定好配置的 Key 后，配置信息从 URL 上从最外层传入，URL 在配置传递上即是一条总线。<br>以 dubbo+zookeeper 为例，暴露和引用远程服务都是注册在 zookeeper 上的，服务注册在 zookeeper 上本质其实是一个 URL，远程服务调用的过程中依据 URL 的 key-value 来动态决定执行 Protocol、Filter 等接口扩展点的执行策略。<br>下面是 Provider 端暴露 HelloService 服务时在 zookeeper 上注册的 URL，在 zookeeper 上的路径为&#x2F;dubbo&#x2F;com.dubbo.test.service.HelloService&#x2F;providers，URL 表示了采用 dubbo 协议，接口为 com.dubbo.test.service.HelloService，方法为 say，要执行的 Filter 为 whiteFilter 等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zk： localhost：2181(CONNECTED) 1] Is /dubbo/com.dubbo.test.service.HelloService/providers</span><br><span class="line">[dubbo://127.0.0.1:2O881/com.dubbo.test.service.HelloService?anyhost=true&amp;application=dubbo-test-service&amp;dubbo=2.4.10&amp;group=test-prod&amp;interface=com.dubbo.test.service.HelloService&amp;methods=say&amp;pid=21242&amp;revision=l.0&amp;service.filter=whiteFilter&amp;side=providerxtamp=1495436105078&amp;version=l.0]</span><br></pre></td></tr></table></figure>

<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><ul>
<li>volatile Class&lt;~&gt; cachedAdaptiveClass<br>这个是缓存 AdaptiveClass，如果一个扩展类的类上面带有 @Adaptive 注解，那么这个类就会被缓存在这个地方，每一种类型的扩展类只有一个 AdaptiveClass，如果发现有多个，则会报错。另外，当通过 getAdaptiveExtensionClass 来获取自适应扩展类时，如果当前还没有 AdaptiveClass，则会自动创建一个（动态生成 Java 代码，再编译，典型的比如 Protocol$Adaptive 就是这么生成的）</li>
<li>Set&lt;~&gt; cachedWrapperClasses<br>这个是缓存包装类的，Dubbo 判断一个扩展类是否是包装类比较简单，通过构造函数来判断，如果这个扩展类有一个构造函数，其中参数是当前扩展类的类型，那么就是包装类，举个例子，ProtocolFilterWrapper 就是 protocol 扩展类的包装类，因为有这个构造函数：<code>public ProtocolFilterWrapper(Protocol protocol)</code></li>
<li>Map&lt;~&gt; cachedActivates<br>这个是缓存激活的扩展类，当然，@Activate 注解还可以规定激活的条件和时机</li>
<li>Holder&lt;~&gt; cachedClasses<br>这个是缓存 Adaptive 和 Wrapper 扩展类之外的普通扩展类</li>
</ul>
<p>扩展类被加载后会根据一定的规则放入以上 4 个缓存中，比如带有 @Adaptive 注解的会被放入 cachedAdaptiveClass。</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/11/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/page/13/">13</a><span class="space">&hellip;</span><a class="page-number" href="/page/19/">19</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/13/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">tallate</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/tallate" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"version":"7.1.2","options":null,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.3.0/mermaid.min.js","integrity":"sha256-9y71g5Lz/KLsHjB8uXwnkuWDtAMDSzD/HdIbqhJfTAI="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>





  





</body>
</html>
