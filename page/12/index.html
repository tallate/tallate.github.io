<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"tallate.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.18.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Tallate">
<meta property="og:url" content="https://tallate.github.io/page/12/index.html">
<meta property="og:site_name" content="Tallate">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="tallate">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://tallate.github.io/page/12/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/12/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Tallate</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Tallate</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">该吃吃该喝喝 啥事别往心里搁</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签<span class="badge">83</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="th fa-fw"></i>分类<span class="badge">25</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档<span class="badge">189</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">tallate</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">189</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">83</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/fca77f63.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tallate">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tallate">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/fca77f63.html" class="post-title-link" itemprop="url">Linux 与 IO</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-09-14 11:34:43" itemprop="dateCreated datePublished" datetime="2019-09-14T11:34:43+08:00">2019-09-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-07 01:56:20" itemprop="dateModified" datetime="2025-07-07T01:56:20+08:00">2025-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>总结Linux中的5种IO模型，其中最常用的是IO多路复用，特别是epoll是各种网络框架的底层IO框架。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/fca77f63.html#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/283c6d00.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tallate">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tallate">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/283c6d00.html" class="post-title-link" itemprop="url">Linux 基本概念</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-09-14 11:34:43" itemprop="dateCreated datePublished" datetime="2019-09-14T11:34:43+08:00">2019-09-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-07 01:56:20" itemprop="dateModified" datetime="2025-07-07T01:56:20+08:00">2025-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>


<h1 id="并发（Concurrency）"><a href="#并发（Concurrency）" class="headerlink" title="并发（Concurrency）"></a>并发（Concurrency）</h1><p>线程、进程，线程安全，进程同步，可见性，一致性，锁，信号量，并发，并行</p>
<h2 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h2><p>从操作系统概念上说，<strong>线程</strong>是最小的可执行单位，也就是系统调度的最小单位。<strong>进程</strong>是资源分配的最小单位。线程是依赖进程存在的，共享进程内的资源，如内存，cpu，io 等。在操作系统的发展过程中，为了提高系统的稳定性、吞吐量和安全性，操作系统内核和用户态做了隔离，例如 Linux 有内核线程，用户线程，内核进程，用户进程，从根本上 Linux 是没有线程的，线程对 Linux 系统来说是个特殊的进程。那么用户线程和内核线程是一一对应呢？从宏观上看是一一对应的，在用户态的每一个线程，都会在内核有对应的执行线程，但是由于资源的限制，用户态的线程和内核线程是多对一的关系。用户进程和内核进程也类似。具体怎样对应的，这里就不探讨了。<br>为了提高操作系统的实时性，操作系统是以时间片轮转来实现任务调度的。理论上时间片内是不可以被中断的，可认为是 cpu 最小的单位执行时间。现代操作系统为了提高用户体验，线程都是抢占式的，而中断一般在时间片用完的时候发生。线程、进程和 CPU 都是多对一的关系，所以存在进程线程切换的问题。<br>线程内部还是有自己内存空间的，所以有个概念叫线程内存模型。线程内部有自己私有的本地内存，故线程和线程之间的本地内存存在可见性问题。例如全局变量 A 在线程 1 修改后，线程 2 并不一定能拿到 A 的修改值，因为线程 1 会把全局变量 A 拷贝到本地内存，修改后并不会马上同步。在编译的时候，编译器为了优化，（例如利用超线程技术）可能会重排指令的执行顺序，这就会存在一致性了。</p>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>在线程安全里面经常要讨论的两个问题就是：可见性和一致性。锁是什么东西呢？锁就是一道内存屏障，保证可见性和一致性的一种策略，由操作系统甚至更底层的硬件提供。加锁是消耗资源的，特别是在多核 CPU 上，现在多核 CPU 一般有 3 级缓存，一级缓存通常是单核独占的，而线程的本地内存很可能就保存在 cpu 的缓存里面，然而加锁就意味着保证可见性和一致性，需要中断同步数据，保证别人拿到的是最新修改值。由于用途不同，锁被设计成各种各样的，如互斥锁，读写锁，自旋锁，同步块，数据库的事务等，如果只要保证可见性的，可以不使用锁，在 java 里面可以使用 volatile 修饰全局变量。虽然在 c／c＋＋，都有同样的修饰符，但是是不是一样的意思呢，请参考其他文章。</p>
<h2 id="死锁（deadlock）"><a href="#死锁（deadlock）" class="headerlink" title="死锁（deadlock）"></a>死锁（deadlock）</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>多个进程竞争资源造成的互相等待情况。  </p>
<h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><p>可重用性资源：可供重复使用多次的资源<br>不可抢占性资源：一旦系统把某资源分配给该进程后，就不能将它强行收回，只能在进程使用完后自动释放<br>可消耗资源:又叫临时性资源，它是在进程运行期间，由进程动态的创建和消耗的  </p>
<h3 id="死锁产生的原因"><a href="#死锁产生的原因" class="headerlink" title="死锁产生的原因"></a>死锁产生的原因</h3><ol>
<li>系统资源的竞争<br>系统资源的竞争导致系统资源不足，以及资源分配不当，导致死锁。<br>主要是竞争可重用不可抢占式的资源和可消耗的资源。  </li>
<li>进程运行推进顺序不合适<br>进程在运行过程中，请求和释放资源的顺序不当，会导致死锁。</li>
</ol>
<h3 id="死锁产生的条件"><a href="#死锁产生的条件" class="headerlink" title="死锁产生的条件"></a>死锁产生的条件</h3><p><strong>互斥条件</strong> 一个资源每次只能被一个进程使用，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。<br><strong>请求与保持条件</strong> 进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。<br><strong>不可剥夺条件</strong> 进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。<br><strong>循环等待条件</strong> 若干进程间形成首尾相接循环等待资源的关系<br><strong>这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。</strong><br>形象地说，就是有两个酒鬼，一个有开瓶器，一个有酒，这两种资源都只能被一个人占有（互斥），且用完之前不能被另一个人抢去（不可剥夺），他们互相等对方手上的资源（循环等待），但又不肯放开自己手上的资源（请求与保持），因此陷入了死锁。  </p>
<h3 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h3><p>系统对进程发出每一个系统能够满足的资源申请进行动态检查,并根据检查结果决定是否分配资源,如果分配后系统可能发生死锁,则不予分配,否则予以分配。<br>书上给出了两种死锁避免策略  </p>
<ol>
<li>进程启动拒绝<br>若对每个资源，能满足现有所有进程再加上新进程的需求，则可以启动这个进程，否则拒绝  </li>
<li>资源分配拒绝（银行家算法）</li>
</ol>
<h3 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h3><p>死锁预防是设法至少破坏产生死锁的四个必要条件之一，严格的防止死锁的出现。  </p>
<ol>
<li>互斥<br>不可能禁止，比如文件只允许互斥的写访问  </li>
<li>占有且等待<br>可以要求进程一次性请求所有需要的资源，并且阻塞这个进程直到所有请求都同时满足，这样就不会再请求新资源了。  </li>
<li>不可抢占</li>
<li>循环等待</li>
</ol>
<h1 id="持久化（Persistent）"><a href="#持久化（Persistent）" class="headerlink" title="持久化（Persistent）"></a>持久化（Persistent）</h1><h2 id="Linux-IO-模型"><a href="#Linux-IO-模型" class="headerlink" title="Linux IO 模型"></a>Linux IO 模型</h2><p><img src="/imgs/Linux/Linux%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84.png" alt="X" title="Linux整体结构"><br>应用程序调用内核 IO 函数的过程如下图所示：<br><img src="/imgs/Linux/IO%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B.png" alt="X" title="IO系统调用过程"><br>处于 OS 的安全性等的考虑，进程无法直接操作 I&#x2F;O 设备，必须通过系统调用来请求内核完成 I&#x2F;O 动作，而内核会为每个 I&#x2F;O 设备维护一个 Buffer。</p>
<ol>
<li>用户进程发起请求；</li>
<li>内核接收到请求后，从 I&#x2F;O 设备中获取数据到 Buffer 中；</li>
<li>将 Buffer 中的数据拷贝到用户进程的地址空间，该用户进程获取到数据后响应给客户端。</li>
</ol>
<p>在整个请求过程中，数据输入至 Buffer 需要时间，从 Buffer 复制数据到进程也需要时间，这个等待时间是限制 I&#x2F;O 效率的罪魁祸首，根据等待方式的不同，I&#x2F;O 动作可以分为以下五种模式：</p>
<ul>
<li>阻塞 I&#x2F;O（Blocking I&#x2F;O）</li>
<li>非阻塞 I&#x2F;O（Non-Blocking I&#x2F;O）</li>
<li>I&#x2F;O 复用（I&#x2F;O Multiplexing）</li>
<li>信号驱动的 I&#x2F;O（Signal Driven I&#x2F;O）</li>
<li>异步 I&#x2F;O（Asynchronous I&#x2F;O）</li>
</ul>
<h2 id="存储器管理"><a href="#存储器管理" class="headerlink" title="存储器管理"></a>存储器管理</h2><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h2 id="IO（pipe）"><a href="#IO（pipe）" class="headerlink" title="IO（pipe）"></a>IO（pipe）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;syscall.h&gt;</span><br><span class="line"></span><br><span class="line">int testPipe()&#123;</span><br><span class="line">    int fd[2];</span><br><span class="line"></span><br><span class="line">    int *read_fd = &amp;fd[0];</span><br><span class="line">    int *write_fd = &amp;fd[1];</span><br><span class="line"></span><br><span class="line">    if(pipe(fd) == -1)&#123;</span><br><span class="line">        printf(&quot;pipe create failed\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int pid = fork();</span><br><span class="line">    if(pid == -1)&#123;</span><br><span class="line">        printf(&quot;fork failed&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(pid == 0)&#123;</span><br><span class="line">        int count;</span><br><span class="line">        char string[] = &quot;hahaha&quot;;</span><br><span class="line">        close(*read_fd);</span><br><span class="line">        count = write(*write_fd, string, sizeof(string));</span><br><span class="line">        printf(&quot;写了%d个字符\n&quot;, count);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        int count;</span><br><span class="line">        char buffer[100];</span><br><span class="line">        close(*write_fd);</span><br><span class="line">        count = read(*read_fd, buffer, sizeof(buffer));</span><br><span class="line">        printf(&quot;父进程接受到%d字节的数据:%s&quot;, count, buffer);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><h3 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h3><h1 id="虚拟化（Virtualization）"><a href="#虚拟化（Virtualization）" class="headerlink" title="虚拟化（Virtualization）"></a>虚拟化（Virtualization）</h1><h2 id="驱动管理"><a href="#驱动管理" class="headerlink" title="驱动管理"></a>驱动管理</h2><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><h2 id="Linux-应用"><a href="#Linux-应用" class="headerlink" title="Linux 应用"></a>Linux 应用</h2><ol>
<li>虚拟内存<br><a target="_blank" rel="noopener" href="https://www.linux.com/news/all-about-linux-swap-space">All about Linux swap space</a><br><a target="_blank" rel="noopener" href="https://wiki.archlinux.org/index.php/swap">Swap</a><br><a target="_blank" rel="noopener" href="https://haydenjames.io/linux-performance-almost-always-add-swap-space/">Linux Performance: Why You Should Almost Always Add Swap Space</a></li>
<li>演进<br><a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/linux/l-kernel-advances/index.html">Linux 内核的发展 介绍 2.6.28 和 2.6.29 版本中的新特性</a><br><a target="_blank" rel="noopener" href="https://linux.cn/article-6179-1.html">对 Linux 内核的发展方向的展望 - Linux 4.2</a></li>
<li>运维<br><a target="_blank" rel="noopener" href="https://juejin.im/entry/5c9780335188252d941493d3">老司机告诉你：正规的运维工作是什么的?</a></li>
<li>并发<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/u011677209/article/details/78082722">Linux 原子操作 atomic_cmpxchg()&#x2F;Atomic_read()&#x2F;Atomic_set()&#x2F;Atomic_add()&#x2F;Atomic_sub()</a></li>
<li>隔离<br><a target="_blank" rel="noopener" href="https://www.v2ex.com/member/jerry017cn/topics">cgroup - jerry017cn</a></li>
</ol>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><ol>
<li>分时和实时操作系统<br><a target="_blank" rel="noopener" href="https://www.osrtos.com/">List of open source real-time operating systems</a></li>
<li>操作系统概念<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/leesf456/p/5375198.html">【操作系统】操作系统综述（一）</a></li>
<li><a target="_blank" rel="noopener" href="http://pages.cs.wisc.edu/~remzi/OSTEP/#book-chapters">Operating Systems: Three Easy Pieces</a></li>
</ol>
<h3 id="Concurrency"><a href="#Concurrency" class="headerlink" title="Concurrency"></a>Concurrency</h3><ol>
<li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/leesf456/p/5413517.html">【操作系统】进程管理（二）</a></li>
<li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/leesf456/p/5605193.html">【操作系统】处理机调度与死锁（三）</a></li>
</ol>
<h3 id="Persistent"><a href="#Persistent" class="headerlink" title="Persistent"></a>Persistent</h3><ol>
<li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/leesf456/p/5616041.html">【操作系统】存储器管理（四）</a></li>
<li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/leesf456/p/5626339.html">【操作系统】文件管理（六）</a></li>
</ol>
<h3 id="Virtualization"><a href="#Virtualization" class="headerlink" title="Virtualization"></a>Virtualization</h3><ol>
<li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/leesf456/p/5622859.html">【操作系统】设备管理（五）</a></li>
</ol>
<h2 id="Linux-内核"><a href="#Linux-内核" class="headerlink" title="Linux 内核"></a>Linux 内核</h2><ol>
<li>哈工大操作系统<br><a target="_blank" rel="noopener" href="https://mooc.study.163.com/course/1000002004?_trace_c_p_k2_=6a6064778bf54c5f98396d86c4146823#/info">操作系统之基础</a><br><a target="_blank" rel="noopener" href="https://www.shiyanlou.com/courses/115">操作系统原理与实践</a></li>
<li>NJU<br><a target="_blank" rel="noopener" href="https://nju-ics.gitbooks.io/ics2016-programming-assignment/content/1.1.html">在开始愉快的 PA 之旅之前</a><br><a target="_blank" rel="noopener" href="https://github.com/NJU-ProjectN/LiteNES">NJU-ProjectN</a></li>
<li><a target="_blank" rel="noopener" href="http://www.linfo.org/index.html">The Linux Information Project</a></li>
<li><a target="_blank" rel="noopener" href="https://www.kernel.org/">The Linux Kernel Archives</a></li>
<li><a target="_blank" rel="noopener" href="https://tinylab.gitbooks.io/linux-doc/content/zh-cn/">Linux 内核文档（中文版）</a></li>
<li><a target="_blank" rel="noopener" href="http://www.superfrink.net/athenaeum/OS-FAQ/os-faq.html">Write Your Own Operating System</a></li>
<li><a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/">6.828: Operating System Engineering</a></li>
</ol>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/1a8406e8.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tallate">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tallate">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/1a8406e8.html" class="post-title-link" itemprop="url">并发和并发安全容器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-09-12 22:12:49" itemprop="dateCreated datePublished" datetime="2019-09-12T22:12:49+08:00">2019-09-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-07 01:56:20" itemprop="dateModified" datetime="2025-07-07T01:56:20+08:00">2025-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>


<h1 id="无锁栈"><a href="#无锁栈" class="headerlink" title="无锁栈"></a>无锁栈</h1><h2 id="Treiber-Stack"><a href="#Treiber-Stack" class="headerlink" title="Treiber Stack"></a>Treiber Stack</h2><h1 id="无锁列表"><a href="#无锁列表" class="headerlink" title="无锁列表"></a>无锁列表</h1><h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><p>CopyOnWriteArrayList 是一个线程安全的 ArrayList，对其进行的修改操作和元素迭代操作都是在底层创建一个拷贝的数组（快照）上进行的，也就是写时拷贝策略。CopyOnWriteArrayList 适合读多写少的场景，但如果应用在写操作频繁的场景下反而会降低性能。<br><img src="/imgs/%E5%B9%B6%E5%8F%91/CopyOnWriteArrayList%E7%B1%BB%E5%9B%BE.png" alt="CopyOnWriteArrayList类图" title="CopyOnWriteArrayList类图"></p>
<ul>
<li>lock：保证写操作时的并发安全；</li>
</ul>
<h3 id="add-E-e"><a href="#add-E-e" class="headerlink" title="add(E e)"></a>add(E e)</h3><p>添加操作拷贝了份快照，在快照上添加元素，最后替代原数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line"></span><br><span class="line">    // 加独占锁</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        // 获取array</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line"></span><br><span class="line">        // 拷贝array到新数组，添加元素到新数组</span><br><span class="line">        // 新数组长度是原数组长度+1，可见CopyOnWriteArrayList是无界的</span><br><span class="line">        int len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + 1);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line"></span><br><span class="line">        // 使用新数组替换添加前的数组</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        return true;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // 释放独占锁</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="get-int-index"><a href="#get-int-index" class="headerlink" title="get(int index)"></a>get(int index)</h3><p>get 操作获取下标处的元素，实际上 get 可以被分解为以下两个步骤：</p>
<ol>
<li>获取 array 的引用；</li>
<li>通过下标访问 array 指定位置的元素。</li>
</ol>
<p>整个过程并没有加锁，如果在访问期间有另一个线程删除了某个元素，实际上因为修改操作是发生在原数组的一个快照上的，get 操作仍然获取的是原数组上的元素，因此不会发生类似数组越界的问题。但同时也不可避免这个过程带来的<strong>弱一致性</strong>，因为元素事实上已经被删除了却仍然可以被访问到。</p>
<h3 id="set-int-index-E-element"><a href="#set-int-index-E-element" class="headerlink" title="set(int index, E element)"></a>set(int index, E element)</h3><p>修改 list 中指定元素的值。</p>
<ul>
<li>如果指定位置的元素不存在则抛出 IndexOutOfBoundsException 异常；</li>
<li>如果指定位置元素与新值不一致，则创建新数组、在新数组上修改，最后设置新数组到 array（COW）。</li>
<li>即使没有变化，也还是需要重新设置一次 array，这主要是因为 array 本身是 volatile 的，set 方法应当提供 volatile 的语义。</li>
</ul>
<h3 id="remove-int-index"><a href="#remove-int-index" class="headerlink" title="remove(int index)"></a>remove(int index)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public E remove(int index) &#123;</span><br><span class="line"></span><br><span class="line">    //获取独占锁</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line"></span><br><span class="line">        //获取数组</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        int len = elements.length;</span><br><span class="line"></span><br><span class="line">        //获取指定元素</span><br><span class="line">        E oldValue = get(elements, index);</span><br><span class="line">        int numMoved = len - index - 1;</span><br><span class="line"></span><br><span class="line">        //如果要删除的是最后一个元素</span><br><span class="line">        if (numMoved == 0)</span><br><span class="line">            setArray(Arrays.copyOf(elements, len - 1));</span><br><span class="line">        else &#123;</span><br><span class="line">            //分两次拷贝除删除后的元素到新数组</span><br><span class="line">            Object[] newElements = new Object[len - 1];</span><br><span class="line">            System.arraycopy(elements, 0, newElements, 0, index);</span><br><span class="line">            System.arraycopy(elements, index + 1, newElements, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">            //使用新数组代替老的                </span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125;</span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        //释放锁</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="remove-Object-o"><a href="#remove-Object-o" class="headerlink" title="remove(Object o)"></a>remove(Object o)</h3><h3 id="remove-Object-o-Object-snapshot-int-index"><a href="#remove-Object-o-Object-snapshot-int-index" class="headerlink" title="remove(Object o, Object[] snapshot, int index)"></a>remove(Object o, Object[] snapshot, int index)</h3><h3 id="iterator"><a href="#iterator" class="headerlink" title="iterator"></a>iterator</h3><p>CopyOnWriteArrayList 中的 iterator 是弱一致性的，其他线程的修改操作对 iterator 不可见的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public Iterator&lt;E&gt; iterator() &#123;</span><br><span class="line">    return new COWIterator&lt;E&gt;(getArray(), 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static final class COWIterator&lt;E&gt; implements ListIterator&lt;E&gt; &#123;</span><br><span class="line">    //array的快照版本</span><br><span class="line">    private final Object[] snapshot;</span><br><span class="line"></span><br><span class="line">    //数组下标</span><br><span class="line">    private int cursor;</span><br><span class="line"></span><br><span class="line">    //构造函数</span><br><span class="line">    private COWIterator(Object[] elements, int initialCursor) &#123;</span><br><span class="line">        cursor = initialCursor;</span><br><span class="line">        snapshot = elements;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //是否遍历结束</span><br><span class="line">    public boolean hasNext() &#123;</span><br><span class="line">        return cursor &lt; snapshot.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取元素</span><br><span class="line">    public E next() &#123;</span><br><span class="line">        if (! hasNext())</span><br><span class="line">            throw new NoSuchElementException();</span><br><span class="line">        return (E) snapshot[cursor++];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果在该线程使用返回的迭代器遍历元素的过程中，其它线程没有对 list 进行增删改，那么 snapshot 本身就是 list 的 array，因为它们是引用关系。</li>
<li>如果在遍历期间存在其他线程对 list 的增删改操作，那么 snapshot 会成为原 array 的快照，此时其他线程对 list 进行的增删改是不可见的，因为它们操作的是两个不同的数组。</li>
</ul>
<h1 id="无锁队列"><a href="#无锁队列" class="headerlink" title="无锁队列"></a>无锁队列</h1><h2 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h2><ul>
<li>线程安全</li>
<li>无界</li>
<li>非阻塞</li>
</ul>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p><img src="/imgs/%E5%B9%B6%E5%8F%91/ConcurrentLinkedQueue%E7%B1%BB%E5%9B%BE.png" alt="ConcurrentLinkedQueue类图" title="ConcurrentLinkedQueue类图"></p>
<ul>
<li>底层队列使用单向链表实现。</li>
<li>两个volatile的Node节点（head和tail）分别存放队列的首尾节点，从下面无参构造函数可知默认头尾节点都是指向 item 为 null 的哨兵节点。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public ConcurrentLinkedQueue() &#123;</span><br><span class="line">    head = tail = new Node(null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Node节点内部为一个volatile修饰的变量item用来存放节点的值，next用来存放链表的下一个节点，从而链接成一个单向无界链表，如下图所示：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/ConcurrentLinkedQueue%E7%9A%84%E9%98%9F%E5%88%97%E7%BB%93%E6%9E%84.png" alt="ConcurrentLinkedQueue的队列结构" title="ConcurrentLinkedQueue的队列结构"></li>
<li>入队和出队操作使用CAS来实现线程安全。</li>
</ul>
<h3 id="入队-offer"><a href="#入队-offer" class="headerlink" title="入队 - offer"></a>入队 - offer</h3><p>offer操作在队列末尾添加一个元素：</p>
<ul>
<li>如果传入的是null，抛出NPE，表明ConcurrentLinkedQueue是不允许插入null值的；</li>
<li>其他情况下插入任何元素都会返回true，因为该队列是无界队列；</li>
<li>使用CAS操作实现线程安全<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    final Node&lt;E&gt; newNode = new Node&lt;E&gt;(e);</span><br><span class="line">    // 从尾节点进行插入</span><br><span class="line">    for (Node&lt;E&gt; t = tail, p = t;;) &#123;</span><br><span class="line">        Node&lt;E&gt; q = p.next;</span><br><span class="line">        </span><br><span class="line">        // 如果q==null说明p是尾节点，则执行插入</span><br><span class="line">        // （1）</span><br><span class="line">        if (q == null) &#123;</span><br><span class="line">            // 使用CAS设置p节点的next节点</span><br><span class="line">            if (p.casNext(null, newNode)) &#123;</span><br><span class="line">                // cas成功，则说明新增节点已经被放入链表，然后设置当前尾节点</span><br><span class="line">                if (p != t)</span><br><span class="line">                    casTail(t, newNode); // Failure is OK.</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // （2）</span><br><span class="line">        else if (p == q)</span><br><span class="line">            // 多线程操作时候，由于poll操作移除元素后有可能会把head变为自引用，然后head的next变为新head，所以这里需要</span><br><span class="line">            // 重新找新的head，因为新的head后面的节点才是正常的节点。</span><br><span class="line">            p = (t != (t = tail)) ? t : head;</span><br><span class="line">        // （3）</span><br><span class="line">        else</span><br><span class="line">            // 寻找尾节点</span><br><span class="line">            p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
注意这里的循环体从队列尾部添加元素：</li>
</ul>
<ol>
<li>刚开始队列为空，代码（1）通过CAS替换p的下一个节点；<br>注意有一个哨兵节点null，刚开始队列的head和tail节点都是指向该哨兵节点，因此队列中至少都会有一个节点；</li>
<li>如果多个线程同时执行插入，总会有一个线程CAS时插入失败，这时会进入下一次循环<br><img src="/imgs/%E5%B9%B6%E5%8F%91/ConcurrentLinkedQueue%E6%8F%92%E5%85%A51.png" alt="ConcurrentLinkedQueue插入1" title="ConcurrentLinkedQueue插入1"><br>这时不满足（1）和（2）的条件，在代码（3）处会将q赋值给p<br><img src="/imgs/%E5%B9%B6%E5%8F%91/ConcurrentLinkedQueue%E6%8F%92%E5%85%A52.png" alt="ConcurrentLinkedQueue插入2" title="ConcurrentLinkedQueue插入2"><br>再到下一次循环时q就会移动到null，这时要么正常插入，要么又被别人通过CAS抢了。</li>
<li>代码（2）是在执行poll时可能出现的情况：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/ConcurrentLinkedQueue%E6%8F%92%E5%85%A53.png" alt="ConcurrentLinkedQueue插入3" title="ConcurrentLinkedQueue插入3"><br>此时由于t&#x3D;&#x3D;tail，所以p被赋值为head，然后继续循环插入元素。</li>
</ol>
<h3 id="出队-poll"><a href="#出队-poll" class="headerlink" title="出队 - poll"></a>出队 - poll</h3><p>poll 操作是在队列头部获取并且移除一个元素，如果队列为空则返回 null。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public E poll() &#123;</span><br><span class="line">    // goto标记</span><br><span class="line">    restartFromHead:</span><br><span class="line"></span><br><span class="line">    // （1）无限循环</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        for (Node&lt;E&gt; h = head, p = h, q;;) &#123;</span><br><span class="line">            // 获取当前队头节点</span><br><span class="line">            E item = p.item;</span><br><span class="line"></span><br><span class="line">            // （2）当前节点有值则cas变为null</span><br><span class="line">            if (item != null &amp;&amp; p.casItem(item, null)) &#123;</span><br><span class="line">                //（6）cas成功标志当前节点以及从链表中移除</span><br><span class="line">                if (p != h) </span><br><span class="line">                    updateHead(h, ((q = p.next) != null) ? q : p);</span><br><span class="line">                return item;</span><br><span class="line">            &#125;</span><br><span class="line">            // （3）当前队列为空则返回null</span><br><span class="line">            else if ((q = p.next) == null) &#123;</span><br><span class="line">                updateHead(h, p);</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            // （4）自引用了，则重新找新的队列头节点</span><br><span class="line">            else if (p == q)</span><br><span class="line">                continue restartFromHead;</span><br><span class="line">            // （5）</span><br><span class="line">            else</span><br><span class="line">                p = q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">final void updateHead(Node&lt;E&gt; h, Node&lt;E&gt; p) &#123;</span><br><span class="line">    if (h != p &amp;&amp; casHead(h, p))</span><br><span class="line">        h.lazySetNext(h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>刚开始队列是空的，内层循环代码（3）判断队列为空就直接返回null了；<br>这时updateHead执行时由于h等于p所以没有设置头节点，poll直接返回null。</li>
<li>如果执行到（3）时已经有其他线程调用了offer方法成功添加一个元素到队列末尾，这时q会指向新增元素的节点<br><img src="/imgs/%E5%B9%B6%E5%8F%91/ConcurrentLinkedQueue%E5%87%BA%E9%98%9F1.png" alt="ConcurrentLinkedQueue出队1" title="ConcurrentLinkedQueue出队1"><br>这时会进入（5），令p也指向新q。<br>然后在下一次循环时，进入代码（2），执行<code>p.casItem(item, null)</code>时会通过CAS操作设置头节点的值为null。<br>代码（6）处，此时h指向哨兵节点，而p指向队列头节点，这时将p设置为新的头节点（这时p里的值已经被清掉了是一个空节点）。<br>此时队列的状态为：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/ConcurrentLinkedQueue%E6%8F%92%E5%85%A53.png" alt="ConcurrentLinkedQueue插入3" title="ConcurrentLinkedQueue插入3"><br>这就是之前讲队列offer时的一种特殊情况。</li>
<li>自引用的情况<br>假设线程A已经执行到（2）将第一个节点值置为null，这时又有一个线程B开始执行poll操作，如下图所示：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/ConcurrentLinkedQueue%E5%87%BA%E9%98%9F2.png" alt="ConcurrentLinkedQueue出队2" title="ConcurrentLinkedQueue出队2"><br>然后线程 A 执行 updateHead 操作，执行完毕后线程 A 退出，这时候队列状态为：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/ConcurrentLinkedQueue%E5%87%BA%E9%98%9F3.png" alt="ConcurrentLinkedQueue出队3" title="ConcurrentLinkedQueue出队3"><br>然后线程 B 继续执行代码（3）q&#x3D;p.next由于该节点是自引用节点所以p&#x3D;&#x3D;q所以会执行代码（4）跳到外层循环 restartFromHead，重新获取当前队列队头 head, 现在状态为：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/ConcurrentLinkedQueue%E5%87%BA%E9%98%9F4.png" alt="ConcurrentLinkedQueue出队4" title="ConcurrentLinkedQueue出队4"></li>
</ol>
<h2 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h2><p>offer是不会阻塞的，如果满了直接返回：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        // 如果已经超过容量阈值，则直接返回false</span><br><span class="line">        if (count == items.length)</span><br><span class="line">            return false;</span><br><span class="line">        else &#123;</span><br><span class="line">            enqueue(e);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void enqueue(E x) &#123;</span><br><span class="line">    // assert lock.getHoldCount() == 1;</span><br><span class="line">    // assert items[putIndex] == null;</span><br><span class="line">    final Object[] items = this.items;</span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">    // 把它看成一个循环数组，如果超出范围就卷回</span><br><span class="line">    if (++putIndex == items.length)</span><br><span class="line">        putIndex = 0;</span><br><span class="line">    count++;</span><br><span class="line">    // 唤醒这个Condition，必须是在加了锁的前提下才能使用</span><br><span class="line">    notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>poll同样也不会阻塞，如果空了直接返回null：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public E poll() &#123;</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        return (count == 0) ? null : dequeue();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private E dequeue() &#123;</span><br><span class="line">    // assert lock.getHoldCount() == 1;</span><br><span class="line">    // assert items[takeIndex] != null;</span><br><span class="line">    final Object[] items = this.items;</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    E x = (E) items[takeIndex];</span><br><span class="line">    items[takeIndex] = null;</span><br><span class="line">    // 回卷</span><br><span class="line">    if (++takeIndex == items.length)</span><br><span class="line">        takeIndex = 0;</span><br><span class="line">    count--;</span><br><span class="line">    if (itrs != null)</span><br><span class="line">        itrs.elementDequeued();</span><br><span class="line">    // 唤醒</span><br><span class="line">    notFull.signal();</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>put操作会等待notFull这个条件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void put(E e) throws InterruptedException &#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    try &#123;</span><br><span class="line">        while (count == items.length)</span><br><span class="line">            notFull.await();</span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>take操作同理，会等待notEmpty这个条件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public E take() throws InterruptedException &#123;</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    try &#123;</span><br><span class="line">        while (count == 0)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        return dequeue();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h2><p>LinkedBlockingQueue 内部是通过单向链表实现，使用头尾节点来进行入队和出队操作，也就是入队操作都是对尾节点进行操作，出队操作都是对头节点进行操作，而头尾节点的操作分别使用了单独的<strong>独占锁</strong>保证了原子性，所以出队和入队操作是可以同时进行的。另外头尾节点的独占锁都配备了一个条件队列，用来存放被阻塞的线程，并结合入队出队操作实现了一个生产消费模型。</p>
<h2 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h2><h2 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h2><h2 id="LinkedTransferQueue"><a href="#LinkedTransferQueue" class="headerlink" title="LinkedTransferQueue"></a>LinkedTransferQueue</h2><h2 id="队列比较"><a href="#队列比较" class="headerlink" title="队列比较"></a>队列比较</h2><h2 id="Disruptor"><a href="#Disruptor" class="headerlink" title="Disruptor"></a>Disruptor</h2><ul>
<li><p>无锁内存队列</p>
</li>
<li><p>优化 CPU 伪共享</p>
</li>
<li><p>RingBuffer<br>环形队列，使用定长数组存储，长度是 2^N，可以使用位运算提升性能。<br>无锁：无锁设计减少了竞争。<br>预热：预先填充好任务&#x2F;事件，不需要像链表那样每次添加&#x2F;删除节点时去创建&#x2F;回收节点，从而可以避免一定的垃圾回收。<br>缓存行填充解决了 CPU 伪共享问题。</p>
</li>
<li><p>WorkPool<br>存储 WorkProcessor 的池子，Disruptor 可以通过 Executor 并发启动每一个 WorkProcessor</p>
</li>
<li><p>WorkProcessor<br>从 RindBuffer 消费事件&#x2F;任务，并交由 WorkHandler 处理。</p>
</li>
<li><p>WorkHandler<br>处理任务的工作者，根据任务类型委托给不同的 EventHandler。</p>
</li>
</ul>
<h2 id="Logback-框架中异步日志打印中-ArrayBlockingQueue-的使用"><a href="#Logback-框架中异步日志打印中-ArrayBlockingQueue-的使用" class="headerlink" title="Logback 框架中异步日志打印中 ArrayBlockingQueue 的使用"></a>Logback 框架中异步日志打印中 ArrayBlockingQueue 的使用</h2><p>异步模型是业务线程把要打印的日志任务写入一个队列后直接返回，然后使用一个线程专门负责从队列中获取日志任务写入磁盘，对用户线程来说，耗时只有将数据写入队列中。</p>
<h1 id="并发安全-Map"><a href="#并发安全-Map" class="headerlink" title="并发安全 Map"></a>并发安全 Map</h1><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p><img src="/imgs/%E5%B9%B6%E5%8F%91/ConcurrentHashMap%E7%BB%93%E6%9E%84.png" alt="ConcurrentHashMap结构" title="ConcurrentHashMap结构"></p>
<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>代码：java.util.concurrent.ConcurrentHashMap.get</p>
<ol>
<li>计算 key 的散列值，可以使用该散列值定位到散列表中的某个槽。<br>如果 key 是自定义类型对象，需要实现重写 hash 方法。</li>
<li>找到对象<br>hash 值是不精确匹配的，hash 值的关键是计算简单而且有一定的区分度，比如取 string 的前 3 位的和作为 hash 值。<br>要精确匹配需要使用对象的 equals 方法。<br>ConcurrentHashMap 中哈希槽的实现方法有两种：链表和红黑树，链表和红黑树的查找过程就不必细说了。</li>
</ol>
<h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><p><img src="/imgs/%E5%B9%B6%E5%8F%91/ConcurrentHashMap%E7%9A%84put%E6%93%8D%E4%BD%9C.png" alt="ConcurrentHashMap的put操作" title="ConcurrentHashMap的put操作"><br>代码：java.util.concurrent.ConcurrentHashMap.put</p>
<ol>
<li>hash</li>
<li>找对象<br>找对象过程与 get 的区别主要是 put 需要并发控制：<ul>
<li>如果槽是空的，则通过 CAS 直接赋值；</li>
<li>如果槽非空，则先用<code>synchronized</code>锁住槽，接下来根据槽的数据结构来插入节点，如果槽是链表，则遍历链表找该 Node 是否已存在，不存在的情况下插入到末尾，如果槽是红黑树，则通过二叉树的遍历找目标 Node，找不到的情况下插入到叶子并重新执行红黑平衡。</li>
</ul>
</li>
</ol>
<h3 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h3><p>扩容的触发条件与HashMap一致。<br>扩容流程大致上是：遍历哈希槽，对每个需要迁移的哈希槽进行<code>synchronized</code>加锁。<br>当扩容开始后，其他线程必须等扩容完成后才能工作，但其他线程也不是就一直阻塞等扩容完成，而是调用<code>helpTransfer</code>方法一起帮助进行扩容，实际上因为扩容的单位是哈希槽，因此多线程并发执行扩容并不会导致明显的冲突增加。</p>
<p>扩容入口：</p>
<ol>
<li>helpTransfer<br>写入操作时协助扩容，即判断hash节点是ForwardingNode则调用helpTransfer将</li>
<li>全量添加时，需要保证</li>
<li></li>
</ol>
<p>扩容代码：<br><code>java.util.concurrent.ConcurrentHashMap.transfer</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Moves and/or copies the nodes in each bin to new table. See</span><br><span class="line"> * above for explanation.</span><br><span class="line"> */</span><br><span class="line">private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) &#123;</span><br><span class="line">    int n = tab.length, stride;</span><br><span class="line">    if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; // subdivide range</span><br><span class="line">    // 创建一个新的两倍大小的新nextTab，将老tab中的元素迁移过去</span><br><span class="line">    if (nextTab == null) &#123;            // initiating</span><br><span class="line">        try &#123;</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; catch (Throwable ex) &#123;      // try to cope with OOME</span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line">    int nextn = nextTab.length;</span><br><span class="line">    // 标记节点</span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = new ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">    boolean advance = true;</span><br><span class="line">    boolean finishing = false; // to ensure sweep before committing nextTab</span><br><span class="line">    for (int i = 0, bound = 0;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; int fh;</span><br><span class="line">        while (advance) &#123;</span><br><span class="line">            int nextIndex, nextBound;</span><br><span class="line">            if (--i &gt;= bound || finishing)</span><br><span class="line">                advance = false;</span><br><span class="line">            else if ((nextIndex = transferIndex) &lt;= 0) &#123;</span><br><span class="line">                i = -1;</span><br><span class="line">                advance = false;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (U.compareAndSwapInt</span><br><span class="line">                     (this, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : 0))) &#123;</span><br><span class="line">                bound = nextBound;</span><br><span class="line">                i = nextIndex - 1;</span><br><span class="line">                advance = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            int sc;</span><br><span class="line">            if (finishing) &#123;</span><br><span class="line">                nextTable = null;</span><br><span class="line">                table = nextTab;</span><br><span class="line">                sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) &#123;</span><br><span class="line">                if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    return;</span><br><span class="line">                finishing = advance = true;</span><br><span class="line">                i = n; // recheck before commit</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果tab当前位置为null，则设置fwd节点</span><br><span class="line">        else if ((f = tabAt(tab, i)) == null)</span><br><span class="line">            advance = casTabAt(tab, i, null, fwd);</span><br><span class="line">        // 已经是fwd节点，则遍历下一个位置</span><br><span class="line">        else if ((fh = f.hash) == MOVED)</span><br><span class="line">            advance = true; // already processed</span><br><span class="line">        else &#123;</span><br><span class="line">        // tab当前位置已有节点，则加锁</span><br><span class="line">            synchronized (f) &#123;</span><br><span class="line">                if (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                    // 表示链表节点，如果是树节点则fh=-2</span><br><span class="line">                    if (fh &gt;= 0) &#123;</span><br><span class="line">                        // 头节点的hash值</span><br><span class="line">                        int runBit = fh &amp; n;</span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                        // 链表的下一节点p</span><br><span class="line">                        for (Node&lt;K,V&gt; p = f.next; p != null; p = p.next) &#123;</span><br><span class="line">                            // p节点的hash值</span><br><span class="line">                            int b = p.hash &amp; n;</span><br><span class="line">                            // 避免成环？</span><br><span class="line">                            if (b != runBit) &#123;</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (runBit == 0) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = null;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = null;</span><br><span class="line">                        &#125;</span><br><span class="line">                        for (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            int ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                            if ((ph &amp; n) == 0)</span><br><span class="line">                                ln = new Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            else</span><br><span class="line">                                hn = new Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line">                        // 将ln和hn转移到nextTab</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        原tab置为fwd，表示已经被转移了</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else if (f instanceof TreeBin) &#123;</span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = null, loTail = null;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = null, hiTail = null;</span><br><span class="line">                        int lc = 0, hc = 0;</span><br><span class="line">                        for (Node&lt;K,V&gt; e = t.first; e != null; e = e.next) &#123;</span><br><span class="line">                            int h = e.hash;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.val, null, null);</span><br><span class="line">                            if ((h &amp; n) == 0) &#123;</span><br><span class="line">                                if ((p.prev = loTail) == null)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                else</span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125;</span><br><span class="line">                            else &#123;</span><br><span class="line">                                if ((p.prev = hiTail) == null)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                else</span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                            (hc != 0) ? new TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                            (lc != 0) ? new TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="size"><a href="#size" class="headerlink" title="size"></a>size</h3><p>size操作返回的是一个不精确的值，因为进行统计的过程中，很有可能会有其他线程正在进行插入和删除操作。</p>
<p>1.8之前的size：</p>
<ol>
<li>遍历segments数组，将每个segment的count加起来作为总数，将modCount加起来作为修改总数；<br>modCount会在每次segment被修改时+1（只增不减），用于比较。</li>
<li>再做一遍遍历，将这次的modCount总数和上一次的比较，如果一致则计数准确直接返回，否则重试；</li>
<li>如果重试了2次都不行，则第三次会对segment加锁再统计。</li>
</ol>
<p>1.8之后，没有了分段锁，size不会每次都遍历segments统计，而是在更新时修改总数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public int size() &#123;</span><br><span class="line">    long n = sumCount();</span><br><span class="line">    return ((n &lt; 0L) ? 0 :</span><br><span class="line">            (n &gt; (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</span><br><span class="line">            (int)n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final long sumCount() &#123;</span><br><span class="line">    CounterCell[] as = counterCells; CounterCell a;</span><br><span class="line">    long sum = baseCount;</span><br><span class="line">    if (as != null) &#123;</span><br><span class="line">        for (int i = 0; i &lt; as.length; ++i) &#123;</span><br><span class="line">            if ((a = as[i]) != null)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从源码中可以看到，<code>ConcurrentHashMap#size</code>的结果就是：<br><code>baseCount + sum(counterCells)</code><br>其中：</p>
<ul>
<li>baseCount：计数，总数发生变化时通过CAS修改</li>
<li>counterCells：如果baseCount CAS修改失败，作为兜底，类似LongAdder的思路。</li>
</ul>
<p>put操作的末尾会调用addCount()更新baseCount的值，如果CAS修改失败了，则使用counterCells，如果CAS修改 counterCells失败了，则使用fullAddCount方法继续死循环操作，直到成功。</p>
<h1 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h1><ol>
<li><p>JUC 并发包中并发组件 CopyOnWriteArrayList 的实现原理，CopyOnWriteArrayList 是如何通过写时拷贝实现并发安全的 List？</p>
</li>
<li><p>什么是弱一致性？</p>
</li>
<li><p>说一下 ConcurrentHashMap。</p>
</li>
<li><p>ConcurrentHashMap 怎么实现并发安全？<br>相对 Hashtable 来说 ConcurrentHashMap 的锁粒度是更小的，Hashtable 中使用 synchronized 实现的一种方法级的悲观锁，相当于把整个散列表锁住了，不利于系统整体吞吐量的提升。<br>JDK1.7 中它使用的是一种分段锁来保证并发安全，是一种粒度较小的锁，写操作每次只锁住一个哈希槽，<br>JDK1.8 之后改为通过实现一种基于 CAS 的乐观锁来保证并发安全，当然，和 HashMap 一样，每个哈希槽在增长到一定程度后会自动转换为红黑树。</p>
</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/leesf456/p/5550043.html">【目录】JUC 集合框架目录</a></li>
<li><a target="_blank" rel="noopener" href="http://ifeve.com/disruptor/">并发框架 Disruptor 译文</a></li>
</ol>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/ba7cab3d.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tallate">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tallate">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/ba7cab3d.html" class="post-title-link" itemprop="url">并发安全容器-Queue</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-09-12 22:12:49" itemprop="dateCreated datePublished" datetime="2019-09-12T22:12:49+08:00">2019-09-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-07 01:56:20" itemprop="dateModified" datetime="2025-07-07T01:56:20+08:00">2025-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="并发安全容器（Queue）"><a href="#并发安全容器（Queue）" class="headerlink" title="并发安全容器（Queue）"></a>并发安全容器（Queue）</h2><h3 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h3><p>ConcurrentLinkedQueue 是线程安全的无界非阻塞队列，底层数据结构使用单向链表实现，入队和出队操作使用 CAS 来实现线程安全。<br>2.1 ConcurrentLinkedQueue 类图结构<br>先简单介绍下 ConcurrentLinkedQueue 的类图结构如下图：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192520988.png" alt="image.png"><br>如上类图 ConcurrentLinkedQueue 内部的队列是使用单向链表方式实现，其中两个 volatile 类型的 Node 节点分别用来存放队列的首尾节点。从下面无参构造函数可知默认头尾节点都是指向 item 为 null 的哨兵节点。<br>public ConcurrentLinkedQueue() {<br>   head &#x3D; tail &#x3D; new Node<E>(null);<br>}<br>Node 节点内部则维护一个 volatile 修饰的变量 item 用来存放节点的值，next 用来存放链表的下一个节点，从而链接为一个单向无界链表。<br>首先一个图来概况该队列构成，读者可以读完本节后在回头体会这个图：<img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192521208.png" alt="image.png"><br>2.2 ConcurrentLinkedQueue 原理介绍<br>本节主要介绍 ConcurrentLinkedQueue 的几个主要的方法的实现原理<br>2.2.1 offer 操作<br>offer 操作是在队列末尾添加一个元素，如果传递的参数是 null 则抛出 NPE 异常，否者由于 ConcurrentLinkedQueue 是无界队列该方法一直会返回 true。另外由于使用 CAS 无阻塞算法，该方法不会阻塞调用线程，下面具体看看实现原理。<br>public boolean offer(E e) {<br>    &#x2F;&#x2F;（1）e为null则抛出空指针异常<br>    checkNotNull(e);</p>
<p>   &#x2F;&#x2F;（2）构造Node节点<br>    final Node<E> newNode &#x3D; new Node<E>(e);</p>
<pre><code>//（3）从尾节点进行插入
for (Node&lt;E&gt; t = tail, p = t;;) &#123;

    Node&lt;E&gt; q = p.next;

    //（4）如果q==null说明p是尾节点，则执行插入
    if (q == null) &#123;

        //（5）使用CAS设置p节点的next节点
        if (p.casNext(null, newNode)) &#123;
            //（6）cas成功，则说明新增节点已经被放入链表，然后设置当前尾节点
            if (p != t)
                casTail(t, newNode);  // Failure is OK.
            return true;
        &#125;
    &#125;
    else if (p == q)//(7）
        //多线程操作时候，由于poll操作移除元素后有可能会把head变为自引用，然后head的next变为新head，所以这里需要
        //重新找新的head，因为新的head后面的节点才是正常的节点。
        p = (t != (t = tail)) ? t : head;
    else
        //（8） 寻找尾节点
        p = (p != t &amp;&amp; t != (t = tail)) ? t : q;
&#125;
</code></pre>
<p>}<br>上节类图结构时候谈到构造队列时候参构造函数创建了一个 item 为 null 的哨兵节点，并且 head 和 tail 都是指向这个节点，下面通过图形结合来讲解下 offer 操作的代码实现。<br>首先看下当一个线程调用 offer（item）时候情况：首先代码（1）对传参判断空检查，如果为 null 则抛出 NPE 异常，然后代码（2）则使用 item 作为构造函数参数创建了一个新的节点，代码（3）从队列尾部节点开始循环，意图是从队列尾部添加元素。<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192521263.png" alt="image.png"><br>上图是执行代码（4）时候队列的情况，这时候节点 p,t,head,tail 同时指向了 item 为 null 的哨兵节点，由于哨兵节点的 next 节点为 null, 所以这里 q 指向也是 null。<br>代码（4）发现q&#x3D;&#x3D;null则执行代码（5）通过 CAS 原子操作判断 p 节点的 next 节点是否为 null，如果为 null 则使用节点 newNode 替换 p 的 next 节点，然后执行代码（6）由于p&#x3D;&#x3D;t所以没有设置尾部节点，然后退出 offer 方法，这时候队列的状态图如下：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192521325.png" alt="image.png"><br>上面讲解的是一个线程调用 offer 方法的情况，如果多个线程同时调用，就会存在多个线程同时执行到代码（5），假设线程 A 调用 offer（item1), 线程 B 调用 offer(item2), 线程 A 和 B 同时执行到 p.casNext(null, newNode)。而 CAS 的比较并设置操作是原子性的，假设线程 A 先执行了比较设置操作则发现当前 p 的 next 节点确实是 null 则会原子性更新 next 节点为 newNode，这时候线程 B 也会判断 p 的 next 节点是否为 null，结果发现不是 null（因为线程 A 已经设置了 p 的 next 为 newNode）则会跳到步骤（3），然后执行到步骤（4）时候队列分布图为：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192521398.png" alt="image.png"><br>根据这个状态图可知线程 B 会去执行代码（8），然后 q 赋值给了 p，这时候队列状态图为：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192521501.png" alt="image.png"><br>然后线程 B 再次跳转到代码（3）执行，当执行到代码（4）时候队列状态图为：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192521579.png" alt="image.png"><br>由于这时候 q&#x3D;&#x3D;null, 所以线程 B 会执行步骤（5），通过 CAS 操作判断当前 p 的 next 节点是否是 null，不是则再次循环后尝试，是则使用 newNode 替换，假设 CAS 成功了，那么执行步骤（6）由于 p!&#x3D;t 所以设置 tail 节点为 newNode，然后退出 offer 方法。这时候队列分布图为：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192521654.png" alt="image.png"><br>分析到现在，offer 代码的执行路径现在就差步骤（7）还没走过，其实这个要在执行 poll 操作后才会出现，这里先看下执行 poll 操作后可能会存在的的一种情况如下图：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192522328.png" alt="image.png"><br>下面分析下当队列处于这种状态时候调用 offer 添加元素代码执行到步骤（4）时候的状态图：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192521811.png" alt="image.png"><br>由于 q 节点不为空并且p&#x3D;&#x3D;q所以执行步骤（7），由于t&#x3D;&#x3D;tail所以 p 被赋值为了 head，然后进入循环，循环后执行到代码（4）时候队列状态为：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192521884.png" alt="image.png"><br>由于q&#x3D;&#x3D;null, 所以执行步骤（5）进行 CAS 操作，如果当前没有其他线程执行 offer 操作，则 CAS 操作会成功，p 的 next 节点被设置为新增节点，然后执行步骤（6），由于p!&#x3D;t所以设置新节点为队列为节点，现在队列状态如下：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192521955.png" alt="image.png"><br>这里自引用的节点会被垃圾回收掉。<br>总结：可见 offer 操作里面关键步骤是代码（5）通过原子 CAS 操作来进行控制同时只有一个线程可以追加元素到队列末尾，进行 cas 竞争失败的线程则会通过循环一次次尝试进行 cas 操作，直到 cas 成功才会返回，也就是通过使用无限循环里面不断进行 CAS 尝试方式来替代阻塞算法挂起调用线程，相比阻塞算法这是使用 CPU 资源换取阻塞所带来的开销。<br>2.2.2 poll 操作<br>poll 操作是在队列头部获取并且移除一个元素，如果队列为空则返回 null，下面看看实现原理。<br>public E poll() {<br>    &#x2F;&#x2F;(1) goto标记<br>    restartFromHead:</p>
<pre><code>//（2）无限循环
for (;;) &#123;
    for (Node&lt;E&gt; h = head, p = h, q;;) &#123;

        //（3）保存当前节点值
        E item = p.item;

        //（4）当前节点有值则cas变为null
        if (item != null &amp;&amp; p.casItem(item, null)) &#123;
            //（5）cas成功标志当前节点以及从链表中移除
            if (p != h) 
                updateHead(h, ((q = p.next) != null) ? q : p);
            return item;
        &#125;
        //（6）当前队列为空则返回null
        else if ((q = p.next) == null) &#123;
            updateHead(h, p);
            return null;
        &#125;
        //（7）自引用了，则重新找新的队列头节点
        else if (p == q)
            continue restartFromHead;
        else//(8）
            p = q;
    &#125;
&#125;
</code></pre>
<p> }<br>    final void updateHead(Node<E> h, Node<E> p) {<br>        if (h !&#x3D; p &amp;&amp; casHead(h, p))<br>            h.lazySetNext(h);<br>    }<br>同理本节也通过图形结合的方式来讲解代码执行逻辑：<br>poll 操作是从队头获取元素，所以代码（2）内层循环是从 head 节点开始迭代，代码（3）获取当前队头的节点，当队列一开始为空时候队列状态为：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192522032.png" alt="image.png"><br>由于 head 节点指向的为 item 为 null 的哨兵节点，所以会执行到代码（6），假设这个过程中没有线程调用 offer 方法，则此时 q 等于 null 如下图：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192522112.png" alt="image.png"><br>所以执行 updateHead 方法，由于 h 等于 p 所以没有设置头结点，poll 方法直接返回 null。<br>假设执行到代码（6）时候已经有其它线程调用了 offer 方法成功添加一个元素到队列，这时候 q 指向的是新增元素的节点，这时候队列状态为：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192522181.png" alt="image.png"><br>所以代码（6）判断结果为 false，然后会转向代码（7）执行，而此时 p 不等于 q，所以转向代码（8）执行，执行结果是 p 指向了节点 q，此时队列状态为：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192522254.png" alt="image.png"><br>然后程序转向代码（3）执行，p 现在指向的元素值不为 null，则执行p.casItem(item, null) 通过 CAS 操作尝试设置 p 的 item 值为 null，如果此时没有其它线程进行 poll 操作，CAS 成功则执行代码（5）由于此时 p!&#x3D;h 所以设置头结点为 p，poll 然后返回被从队列移除的节点值 item。此时队列状态为:<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192522328.png" alt="image.png"><br>这个状态就是讲解 offer 操作时候，offer 代码的执行路径（7）执行的前提状态。<br>假如现在一个线程调用了 poll 操作，则在执行代码（4) 时候队列状态为：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192522382.png" alt="image.png"><br>可知这时候执行代码（6）返回 null.<br>现在 poll 的代码还有个分支（7）没有执行过，那么什么时候会执行那？下面来看看，假设线程 A 执行 poll 操作时候当前队列状态为：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192522444.png" alt="image.png"><br>那么执行p.casItem(item, null) 通过 CAS 操作尝试设置 p 的 item 值为 null。<br>假设 CAS 设置成功则标示该节点从队列中移除了，此时队列状态为：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192522518.png" alt="image.png"><br>然后由于 p!&#x3D;h, 所以会执行 updateHead 方法，假如线程 A 执行 updateHead 前另外一个线程 B 开始 poll 操作这时候线程 B 的 p 指向 head 节点，但是还没有执行到代码（6）这时候队列状态为：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192522583.png" alt="image.png"><br>然后线程 A 执行 updateHead 操作，执行完毕后线程 A 退出，这时候队列状态为：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192522663.png" alt="image.png"><br>然后线程 B 继续执行代码（6）q&#x3D;p.next由于该节点是自引用节点所以p&#x3D;&#x3D;q所以会执行代码（7）跳到外层循环 restartFromHead，重新获取当前队列队头 head, 现在状态为：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192522732.png" alt="image.png"><br>总结：poll 方法移除一个元素时候只是简单的使用 CAS 操作把当前节点的 item 值设置 null，然后通过重新设置头结点让该元素从队列里面摘除，被摘除的节点就成了孤立节点，这个节点会被在垃圾回收的时候会回收掉。另外执行分支中如果发现头节点被修改了要跳到外层循环重新获取新的头节点。<br>2.2.3 peek 操作<br>peek 操作是获取队列头部一个元素（只不获取不移除），如果队列为空则返回 null，下面看看实现原理。<br>public E peek() {<br>   &#x2F;&#x2F;(1)<br>    restartFromHead:<br>    for (;;) {<br>        for (Node<E> h &#x3D; head, p &#x3D; h, q;;) {<br>            &#x2F;&#x2F;(2)<br>            E item &#x3D; p.item;<br>            &#x2F;&#x2F;(3)<br>            if (item !&#x3D; null || (q &#x3D; p.next) &#x3D;&#x3D; null) {<br>                updateHead(h, p);<br>                return item;<br>            }<br>            &#x2F;&#x2F;(4)<br>            else if (p &#x3D;&#x3D; q)<br>                continue restartFromHead;<br>            else<br>            &#x2F;&#x2F;(5)<br>                p &#x3D; q;<br>        }<br>    }<br>}<br>代码结构与 poll 操作类似，不同在于步骤（3）的使用只是少了 castItem 操作，其实这很正常，因为 peek 只是获取队列头元素值并不清空其值，根据前面我们知道第一次执行 offer 后 head 指向的是哨兵节点（也就是 item 为 null 的节点），那么第一次 peek 时候代码（3）中会发现 item&#x3D;&#x3D;null, 然后会执行 q &#x3D; p.next, 这时候 q 节点指向的才是队列里面第一个真正的元素或者如果队列为 null 则 q 指向 null。<br>当队列为空时候这时候队列状态为：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192522799.png" alt="image.png"><br>这时候执行 updateHead 由于 h 节点等于 p 节点所以不进行任何操作，然后 peek 操作会返回 null。<br>当队列至少有一个元素时候（这里假设只有一个）这时候队列状态为：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192522872.png" alt="image.png"><br>这时候执行代码（5）这时候 p 指向了 q 节点，然后执行代码（3）这时候队列状态为：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192522963.png" alt="image.png"><br>执行代码（3）发现 item 不为 null，则执行 updateHead 方法，由于 h!&#x3D;p, 所以设置头结点，设置后队列状态为：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192523042.png" alt="image.png"><br>也就是剔除了哨兵节点。<br>总结：peek 操作代码与 poll 操作类似只是前者只获取队列头元素但是并不从队列里面删除，而后者获取后需要从队列里面删除，另外在第一次调用 peek 操作时候，会删除哨兵节点，并让队列的 head 节点指向队列里面第一个元素或者 null。<br>2.2.4 size 操作<br>获取当前队列元素个数，在并发环境下不是很有用，因为 CAS 没有加锁所以从调用 size 函数到返回结果期间有可能增删元素，导致统计的元素个数不精确。<br>public int size() {<br>    int count &#x3D; 0;<br>    for (Node<E> p &#x3D; first(); p !&#x3D; null; p &#x3D; succ(p))<br>        if (p.item !&#x3D; null)<br>            &#x2F;&#x2F; 最大返回Integer.MAX_VALUE<br>            if (++count &#x3D;&#x3D; Integer.MAX_VALUE)<br>                break;<br>    return count;<br>}</p>
<p>&#x2F;&#x2F;获取第一个队列元素（哨兵元素不算），没有则为null<br>Node<E> first() {<br>    restartFromHead:<br>    for (;;) {<br>        for (Node<E> h &#x3D; head, p &#x3D; h, q;;) {<br>            boolean hasItem &#x3D; (p.item !&#x3D; null);<br>            if (hasItem || (q &#x3D; p.next) &#x3D;&#x3D; null) {<br>                updateHead(h, p);<br>                return hasItem ? p : null;<br>            }<br>            else if (p &#x3D;&#x3D; q)<br>                continue restartFromHead;<br>            else<br>                p &#x3D; q;<br>        }<br>    }<br>}</p>
<p>&#x2F;&#x2F;获取当前节点的next元素，如果是自引入节点则返回真正头节点<br>final Node<E> succ(Node<E> p) {<br>    Node<E> next &#x3D; p.next;<br>    return (p &#x3D;&#x3D; next) ? head : next;<br>}<br>2.2.5 remove 操作<br>如果队列里面存在该元素则删除给元素，如果存在多个则删除第一个，并返回 true，否者返回 false<br>public boolean remove(Object o) {</p>
<pre><code>//查找元素为空，直接返回false
if (o == null) return false;
Node&lt;E&gt; pred = null;
for (Node&lt;E&gt; p = first(); p != null; p = succ(p)) &#123;
    E item = p.item;

    //相等则使用cas值null,同时一个线程成功，失败的线程循环查找队列中其它元素是否有匹配的。
    if (item != null &amp;&amp;
        o.equals(item) &amp;&amp;
        p.casItem(item, null)) &#123;

        //获取next元素
        Node&lt;E&gt; next = succ(p);

        //如果有前驱节点，并且next不为空则链接前驱节点到next,
        if (pred != null &amp;&amp; next != null)
            pred.casNext(p, next);
        return true;
    &#125;
    pred = p;
&#125;
return false;
</code></pre>
<p>}<br>注：ConcurrentLinkedQueue 底层使用单向链表数据结构来保存队列元素，每个元素被包装为了一个 Node 节点，队列是靠头尾节点来维护的，创建队列时候头尾节点指向一个 item 为 null 的哨兵节点，第一次 peek 或者 first 时候会把 head 指向第一个真正的队列元素。由于使用非阻塞 CAS 算法，没有加锁，所以获取 size 的时候有可能进行了 offer，poll 或者 remove 操作，导致获取的元素个数不精确，所以在并发情况下 size 函数不是很有用。</p>
<h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><p>前面介绍了使用 CAS 算法实现的非阻塞队列 ConcurrentLinkedQueue，下面就来介绍下使用独占锁实现的阻塞队列 LinkedBlockingQueue 的实现<br>3.1 LinkedBlockingQueue 类图结构<br>同理首先看下 LinkedBlockingQueue 的类图结构<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192523099.png" alt="image.png"><br>如上类图可知 LinkedBlockingQueue 也是使用单向链表实现，也有两个 Node 分别用来存放首尾节点，并且里面有个初始值为 0 的原子变量 count 用来记录队列元素个数。另外里面有两个 ReentrantLock 的实例，分别用来控制元素入队和出队的原子性，其中 takeLock 用来控制同时只有一个线程可以从队列获取元素，其它线程必须等待，putLock 控制同时只能有一个线程可以获取锁去添加元素，其它线程必须等待。另外 notEmpty 和 notFull 是信号量，内部分别有一个条件队列用来存放进队和出队时候被阻塞的线程，其实这个是个生产者 - 消费者模型。如下是独占锁创建代码：<br>    &#x2F;** 执行take, poll等操作时候需要获取该锁 *&#x2F;<br>    private final ReentrantLock takeLock &#x3D; new ReentrantLock();</p>
<pre><code>/** 当队列为空时候执行出队操作（比如take）的线程会被放入这个条件队列进行等待 */
private final Condition notEmpty = takeLock.newCondition();

/** 执行put, offer等操作时候需要获取该锁*/
private final ReentrantLock putLock = new ReentrantLock();

/**当队列满时候执行进队操作（比如put)的线程会被放入这个条件队列进行等待 */
private final Condition notFull = putLock.newCondition();
</code></pre>
<p> &#x2F;** 当前队列元素个数 *&#x2F;<br>    private final AtomicInteger count &#x3D; new AtomicInteger(0);<br>如下是 LinkedBlockingQueue 无参构造函数代码：<br>public static final int   MAX_VALUE &#x3D; 0x7fffffff;</p>
<p>public LinkedBlockingQueue() {<br>    this(Integer.MAX_VALUE);<br>}</p>
<p>  public LinkedBlockingQueue(int capacity) {<br>    if (capacity &lt;&#x3D; 0) throw new IllegalArgumentException();<br>    this.capacity &#x3D; capacity;<br>    &#x2F;&#x2F;初始化首尾节点,指向哨兵节点<br>    last &#x3D; head &#x3D; new Node<E>(null);<br>}<br>从代码可知默认队列容量为 0x7fffffff; 用户也可以自己指定容量，所以一定程度上 LinkedBlockingQueue 可以说是有界阻塞队列。<br>首先使用一个图来概况该队列，读者在读完本节后在回头体会下:<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192523218.png" alt="image.png"><br>3.2 LinkedBlockingQueue 原理介绍<br>3.2.1 offer 操作<br>向队列尾部插入一个元素，如果队列有空闲容量则插入成功后返回 true，如果队列已满则丢弃当前元素然后返回 false，如果 e 元素为 null 则抛出 NullPointerException 异常，另外该方法是非阻塞的。<br>    public boolean offer(E e) {</p>
<pre><code>    //（1）空元素抛空指针异常
    if (e == null) throw new NullPointerException();

    //(2) 如果当前队列满了则丢弃将要放入的元素，然后返回false
    final AtomicInteger count = this.count;
    if (count.get() == capacity)
        return false;

    //(3) 构造新节点，获取putLock独占锁
    int c = -1;
    Node&lt;E&gt; node = new Node&lt;E&gt;(e);
    final ReentrantLock putLock = this.putLock;
    putLock.lock();
    try &#123;
        //(4)如果队列不满则进队列，并递增元素计数
        if (count.get() &lt; capacity) &#123;
            enqueue(node);
            c = count.getAndIncrement();
            //(5)
            if (c + 1 &lt; capacity)
                notFull.signal();
        &#125;
    &#125; finally &#123;
        //(6)释放锁
        putLock.unlock();
    &#125;
    //(7)
    if (c == 0)
        signalNotEmpty();
    //(8)
    return c &gt;= 0;
&#125;
</code></pre>
<p>private void enqueue(Node<E> node) {<br> last &#x3D; last.next &#x3D; node;<br>}<br>步骤（2）判断如果当前队列已满则丢弃当前元素并返回 false<br>步骤（3）获取到 putLock 锁，当前线程获取到该锁后，则其它调用 put 和 offer 的线程将会被阻塞（阻塞的线程被放到 putLock 锁的 AQS 阻塞队列）。<br>步骤（4）这里有重新判断了下当前队列是否满了，这是因为在执行代码（2）和获取到 putLock 锁期间可能其它线程通过 put 或者 offer 方法向队列里面添加了新元素。重新判断队列确实不满则新元素入队，并递增计数器。<br>步骤（5）判断如果新元素入队后队列还有空闲空间，则唤醒 notFull 的条件队列里面因为调用了 notFull 的 await 操作（比如执行 put 方法而队列满了的时候）而被阻塞的一个线程，因为队列现在有空闲所以这里可以提前唤醒一个入队线程。<br>代码（6) 则释放获取的 putLock 锁，这里要注意锁的释放一定要在 finally 里面做，因为即使 try 块抛异常了，finally 也是会被执行到的。另外释放锁后其它因为调用 put 和 offer 而被阻塞的线程将会有一个获取到该锁。<br>代码（7）c&#x3D;&#x3D;0 说明在执行代码（6）释放锁时候队列里面至少有一个元素，队列里面有元素则执行 signalNotEmpty，下面看看 signalNotEmpty 的代码：<br>    private void signalNotEmpty() {<br>        final ReentrantLock takeLock &#x3D; this.takeLock;<br>        takeLock.lock();<br>        try {<br>            notEmpty.signal();<br>        } finally {<br>            takeLock.unlock();<br>        }<br>    }<br>可知作用是激活 notEmpty 的条件队列中因为调用 notEmpty 的 await 方法（比如调用 take 方法并且队列为空的时候）而被阻塞的一个线程，这里也说明了调用条件变量的方法前要首先获取对应的锁。<br>综上可知 offer 方法中通过使用 putLock 锁保证了在队尾新增元素的原子性和队列元素个数的比较和递增操作的原子性。<br>3.2.2 put 操作<br>向队列尾部插入一个元素，如果队列有空闲则插入后直接返回 true，如果队列已满则阻塞当前线程直到队列有空闲插入成功后返回 true，如果在阻塞的时候被其它线程设置了中断标志，则被阻塞线程会抛出 InterruptedException 异常而返回，另外如果 e 元素为 null 则抛出 NullPointerException 异常。<br>put 操作的代码结构与 offer 操作类似，代码如下：<br>public void put(E e) throws InterruptedException {<br>        &#x2F;&#x2F;（1）空元素抛空指针异常<br>        if (e &#x3D;&#x3D; null) throw new NullPointerException();<br>        &#x2F;&#x2F;(2) 构建新节点，并获取独占锁putLock<br>        int c &#x3D; -1;<br>        Node<E> node &#x3D; new Node<E>(e);<br>        final ReentrantLock putLock &#x3D; this.putLock;<br>        final AtomicInteger count &#x3D; this.count;<br>        putLock.lockInterruptibly();<br>        try {<br>            &#x2F;&#x2F;(3)如果队列满则等待<br>            while (count.get() &#x3D;&#x3D; capacity) {<br>                notFull.await();<br>            }<br>            &#x2F;&#x2F;（4）进队列并递增计数<br>            enqueue(node);<br>            c &#x3D; count.getAndIncrement();<br>            &#x2F;&#x2F;(5)<br>            if (c + 1 &lt; capacity)<br>                notFull.signal();<br>        } finally {<br>            &#x2F;&#x2F;(6)<br>            putLock.unlock();<br>        }<br>        &#x2F;&#x2F;(7)<br>        if (c &#x3D;&#x3D; 0)<br>            signalNotEmpty();<br>    }<br>代码（2）中使用 putLock.lockInterruptibly() 获取独占锁，相比 offer 方法中这个获取独占锁方法意味着可以被中断，具体说是当前线程在获取锁的过程中，如果被其它线程设置了中断标志则当前线程会抛出 InterruptedException 异常，所以 put 操作在获取锁过程中是可被中断的。<br>代码（3）如果当前队列已满，则调用 notFull 的 await() 把当前线程放入 notFull 的条件队列，当前线程被阻塞挂起并释放获取到的 putLock 锁，由于 putLock 锁被释放了，所以现在其它线程就有机会获取到 putLock 锁了。<br>另外考虑下代码（3）判断队列是否为空为何使用 while 循环而不是 if 语句那？其实是考虑到当前线程被虚假唤醒的问题，也就是其它线程没有调用 notFull 的 singal 方法时候 notFull.await() 在某种情况下会自动返回。如果使用 if 语句那么虚假唤醒后会执行代码（4）元素入队，并且递增计数器，而这时候队列已经是满了的，导致队列元素个数大于了队列设置的容量，导致程序出错。而使用 while 循环假如 notFull.await() 被虚假唤醒了，那么循环在检查一下当前队列是否是满的，如果是则再次进行等待。<br>3.2.3 poll 操作<br>从队列头部获取并移除一个元素，如果队列为空则返回 null，该方法是不阻塞的。<br>    public E poll() {<br>        &#x2F;&#x2F;(1)队列为空则返回null<br>        final AtomicInteger count &#x3D; this.count;<br>        if (count.get() &#x3D;&#x3D; 0)<br>            return null;<br>        &#x2F;&#x2F;(2)获取独占锁<br>        E x &#x3D; null;<br>        int c &#x3D; -1;<br>        final ReentrantLock takeLock &#x3D; this.takeLock;<br>        takeLock.lock();<br>        try {<br>            &#x2F;&#x2F;(3)队列不空则出队并递减计数<br>            if (count.get() &gt; 0) {&#x2F;&#x2F;3.1<br>                x &#x3D; dequeue();&#x2F;&#x2F;3.2<br>                c &#x3D; count.getAndDecrement();&#x2F;&#x2F;3.3<br>                &#x2F;&#x2F;(4)<br>                if (c &gt; 1)<br>                    notEmpty.signal();<br>            }<br>        } finally {<br>            &#x2F;&#x2F;(5)<br>            takeLock.unlock();<br>        }<br>        &#x2F;&#x2F;(6)<br>        if (c &#x3D;&#x3D; capacity)<br>            signalNotFull();<br>        &#x2F;&#x2F;(7)返回<br>        return x;<br>    }<br>    private E dequeue() {<br>        Node<E> h &#x3D; head;<br>        Node<E> first &#x3D; h.next;<br>        h.next &#x3D; h; &#x2F;&#x2F; help GC<br>        head &#x3D; first;<br>        E x &#x3D; first.item;<br>        first.item &#x3D; null;<br>        return x;<br>    }<br>代码 (1) 如果当前队列为空，则直接返回 null<br>代码（2）获取独占锁 takeLock，当前线程获取该锁后，其它线程在调用 poll 或者 take 方法会被阻塞挂起<br>代码 (3) 如果当前队列不为空则进行出队操作，然后递减计数器。<br>代码（4）如果 c&gt;1 则说明当前线程移除掉队列里面的一个元素后队列不为空（c 是删除元素前队列元素个数），那么这时候就可以激活因为调用 poll 或者 take 方法而被阻塞到 notEmpty 的条件队列里面的一个线程。<br>代码（6）说明当前线程移除队头元素前当前队列是满的，移除队头元素后队列当前至少有一个空闲位置，那么这时候就可以调用 signalNotFull 激活因为调用 put 或者 offer 而被阻塞放到 notFull 的条件队列里的一个线程，signalNotFull 的代码如下：<br>      private void signalNotFull() {<br>          final ReentrantLock putLock &#x3D; this.putLock;<br>          putLock.lock();<br>          try {<br>              notFull.signal();<br>          } finally {<br>              putLock.unlock();<br>          }<br>      }<br>poll 代码逻辑比较简单，值得注意的是获取元素时候只操作了队列的头节点。<br>3.2.4 peek 操作<br>获取队列头部元素但是不从队列里面移除，如果队列为空则返回 null，该方法是不阻塞的。<br>     public E peek() {<br>        &#x2F;&#x2F;(1)<br>        if (count.get() &#x3D;&#x3D; 0)<br>            return null;<br>        &#x2F;&#x2F;(2)<br>        final ReentrantLock takeLock &#x3D; this.takeLock;<br>        takeLock.lock();<br>        try {<br>            Node<E> first &#x3D; head.next;<br>            &#x2F;&#x2F;(3)<br>            if (first &#x3D;&#x3D; null)<br>                return null;<br>            else<br>            &#x2F;&#x2F;(4)<br>                return first.item;<br>        } finally {<br>           &#x2F;&#x2F;(5)<br>            takeLock.unlock();<br>        }<br>    }<br>peek 操作代码也比较简单，这里需要注意的是代码（3）这里还是需要判断下 first 是否为 null 的，不能直接执行代码（4）。正常情况下执行到代码（2）说明队列不为空，但是代码（1）和（2）不是原子性操作，也就是在执行点（1）判断队列不空后，在代码（2）获取到锁前有可能其它线程执行了 poll 或者 take 操作导致队列变为了空，然后当前线程获取锁后，直接执行 first.item 会抛出空指针异常。<br>3.2.5 take 操作<br>获取当前队列头部元素并从队列里面移除，如果队列为空则阻塞调用线程。如果队列为空则阻塞当前线程直到队列不为空然后返回元素，如果在阻塞的时候被其它线程设置了中断标志，则被阻塞线程会抛出 InterruptedException 异常而返回。<br>    public E take() throws InterruptedException {<br>        E x;<br>        int c &#x3D; -1;<br>        final AtomicInteger count &#x3D; this.count;<br>        &#x2F;&#x2F;(1)获取锁<br>        final ReentrantLock takeLock &#x3D; this.takeLock;<br>        takeLock.lockInterruptibly();<br>        try {<br>            &#x2F;&#x2F;(2)当前队列为空则阻塞挂起<br>            while (count.get() &#x3D;&#x3D; 0) {<br>                notEmpty.await();<br>            }<br>            &#x2F;&#x2F;(3)出队并递减计数<br>            x &#x3D; dequeue();<br>            c &#x3D; count.getAndDecrement();<br>            &#x2F;&#x2F;(4)<br>            if (c &gt; 1)<br>                notEmpty.signal();<br>        } finally {<br>           &#x2F;&#x2F;(5)<br>            takeLock.unlock();<br>        }<br>        &#x2F;&#x2F;(6)<br>        if (c &#x3D;&#x3D; capacity)<br>            signalNotFull();<br>        &#x2F;&#x2F;(7)<br>        return x;<br>    }<br>代码（1）当前线程获取到独占锁，其它调用 take 或者 poll 的线程将会被阻塞挂起。<br>代码（2）如果队列为空则阻塞挂起当前线程，并把当前线程放入 notEmpty 的条件队列。<br>代码（3）进行出队操作并递减计数。<br>代码（4）如果 c&gt;1 说明当前队列不为空，则唤醒 notEmpty 的条件队列的条件队列里面的一个因为调用 take 或者 poll 而被阻塞的线程。<br>代码（5）释放锁。<br>代码（6）如果 c &#x3D;&#x3D; capacity 则说明当前队列至少有一个空闲位置，则激活条件变量 notFull 的条件队列里面的一个因为调用 put 或者 offer 而被阻塞的线程。<br>3.2.6 remove 操作<br>删除队列里面指定元素，有则删除返回 true，没有则返回 false<br>public boolean remove(Object o) {<br>    if (o &#x3D;&#x3D; null) return false;</p>
<pre><code>//（1）双重加锁
fullyLock();
try &#123;

    //（2)遍历队列找则删除返回true
    for (Node&lt;E&gt; trail = head, p = trail.next;
         p != null;
         trail = p, p = p.next) &#123;
         //(3)
        if (o.equals(p.item)) &#123;
            unlink(p, trail);
            return true;
        &#125;
    &#125;
    //(4)找不到返回false
    return false;
&#125; finally &#123;
    //(5)解锁
    fullyUnlock();
&#125;
</code></pre>
<p>}<br>代码（1）通过 fullyLock 获取双重锁，当前线程获取后，其它线程进行入队或者出队的操作时候就会被阻塞挂起。<br>void fullyLock() {<br>    putLock.lock();<br>    takeLock.lock();<br>}<br>代码（2）遍历队列寻找要删除的元素，找不到则直接返回 false，找到则执行 unlink 操作，unlik 操作代码如下：<br>    void unlink(Node<E> p, Node<E> trail) {<br>      p.item &#x3D; null;<br>      trail.next &#x3D; p.next;<br>      if (last &#x3D;&#x3D; p)<br>          last &#x3D; trail;<br>      如果当前队列满，删除后，也不忘记唤醒等待的线程<br>      if (count.getAndDecrement() &#x3D;&#x3D; capacity)<br>          notFull.signal();<br>    }<br>可知删除元素后，如果发现当前队列有空闲空间，则唤醒 notFull 的条件队列中一个因为调 用 put 或者 offer 方法而被阻塞的线程。<br>代码（5）调用 fullyUnlock 方法使用与加锁顺序相反的顺序释放双重锁<br>void fullyUnlock() {<br>    takeLock.unlock();<br>    putLock.unlock();<br>}<br>总结下，由于 remove 方法在删除指定元素前加了两把锁，所以在遍历队列查找指定元素过程中是线程安全的，并且此时其它调用入队出队操作的线程全部会被阻塞，另外获取多个资源锁与释放的顺序是相反的。<br>3.2.7 size 操作<br>int size() : 获取当前队列元素个数。<br>    public int size() {<br>        return count.get();<br>    }<br>由于在操作出队入队时候操作 Count 的时候是加了锁的，所以相比 ConcurrentLinkedQueue 的 size 方法比较准确。这里考虑下为何 ConcurrentLinkedQueue 中需要遍历链表来获取 size 而不适用一个原子变量那？这是因为使用原子变量保存队列元素个数需要保证入队出队操作和操作原子变量是原子性操作，而 ConcurrentLinkedQueue 是使用 CAS 无锁算法的，所以无法做到这个。<br>注：LinkedBlockingQueue 内部是通过单向链表实现，使用头尾节点来进行入队和出队操作，也就是入队操作都是对尾节点进行操作，出队操作都是对头节点进行操作，而头尾节点的操作分别使用了单独的独占锁保证了原子性，所以出队和入队操作是可以同时进行的。另外头尾节点的独占锁都配备了一个条件队列，用来存放被阻塞的线程，并结合入队出队操作实现了一个生产消费模型。</p>
<h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><p>上节介绍了有界链表方式的阻塞队列 LinkedBlockingQueue，本节来研究下有界使用数组方式实现的阻塞队列 ArrayBlockingQueue 的原理<br>4.1 ArrayBlockingQueue 类图结构<br>同理为了能从全局一览 ArrayBlockingQueue 的内部构造，先看下类图：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192523294.png" alt="image.png"><br>如图 ArrayBlockingQueue 内部有个数组 items 用来存放队列元素，putindex 变量标示入队元素下标，takeIndex 是出队下标，count 统计队列元素个数，从定义可知并没有使用 volatile 修饰，这是因为访问这些变量使用都是在锁块内，而加锁已经保证了锁块内变量的内存可见性了。<br>另外有个独占锁 lock 用来保证出入队操作原子性，这保证了同时只有一个线程可以进行入队出队操作，另外 notEmpty，notFull 条件变量用来进行出入队的同步。<br>另外由于 ArrayBlockingQueue 是有界队列，所以构造函数必须传入队列大小参数，构造函数代码如下：<br>  public ArrayBlockingQueue(int capacity) {<br>        this(capacity, false);<br>  }</p>
<pre><code>public ArrayBlockingQueue(int capacity, boolean fair) &#123;
    if (capacity &lt;= 0)
        throw new IllegalArgumentException();
    this.items = new Object[capacity];
    lock = new ReentrantLock(fair);
    notEmpty = lock.newCondition();
    notFull =  lock.newCondition();
&#125;
</code></pre>
<p>可知默认情况下使用的是 ReentrantLock 提供的非非公平独占锁进行出入队操作的加锁。<br>首先一个图概况该队列，读者可以读完本节后在回头体会下：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192523418.png" alt="image.png"><br>4.2 ArrayBlockingQueue 原理介绍<br>本节主要讲解下面几个主要函数的原理。<br>4.2.1 offer 操作<br>向队列尾部插入一个元素，如果队列有空闲容量则插入成功后返回 true，如果队列已满则丢弃当前元素然后返回 false，如果 e 元素为 null 则抛出 NullPointerException 异常，另外该方法是不阻塞的。<br>    public boolean offer(E e) {<br>        &#x2F;&#x2F;（1）e为null，则抛出NullPointerException异常<br>        checkNotNull(e);<br>        &#x2F;&#x2F;（2）获取独占锁<br>        final ReentrantLock lock &#x3D; this.lock;<br>        lock.lock();<br>        try {<br>            &#x2F;&#x2F;（3）如果队列满则返回false<br>            if (count &#x3D;&#x3D; items.length)<br>                return false;<br>            else {<br>                &#x2F;&#x2F;（4）否者插入元素<br>                enqueue(e);<br>                return true;<br>            }<br>        } finally {<br>            lock.unlock();<br>        }<br>    }<br>代码（2）获取独占锁，当前线程获取该锁后，其它入队和出队操作的线程都会被阻塞挂起后放入 lock 锁的 AQS 阻塞队列。<br>代码（3）如果队列满则直接返回 false，否者调用 enqueue 方法后返回 true，enqueue 的代码如下：<br>    private void enqueue(E x) {<br>        &#x2F;&#x2F;（6）元素入队<br>        final Object[] items &#x3D; this.items;<br>        items[putIndex] &#x3D; x;<br>        &#x2F;&#x2F;（7）计算下一个元素应该存放的下标<br>        if (++putIndex &#x3D;&#x3D; items.length)<br>            putIndex &#x3D; 0;<br>        count++;<br>        &#x2F;&#x2F;(8)<br>        notEmpty.signal();<br>    }<br>如上代码首先把当前元素放入 items 数组，然后计算下一个元素应该存放的下标，然后递增元素个数计数器，最后激活 notEmpty 的条件队列中因为调用 poll 或者 take 操作而被阻塞的的一个线程。这里由于在操作共享变量比如 count 前加了锁，所以不存在内存不可见问题，加过锁后获取的共享变量都是从主内存获取的，而不是在 CPU 缓存或者寄存器里面的值。<br>代码（5）释放锁，释放锁后会把修改的共享变量值比如 Count 的值刷新回主内存中，这样其它线程通过加锁在次读取这些共享变量后就可以看到最新的值。<br>4.2.2 put 操作<br>向队列尾部插入一个元素，如果队列有空闲则插入后直接返回 true，如果队列已满则阻塞当前线程直到队列有空闲插入成功后返回 true，如果在阻塞的时候被其它线程设置了中断标志，则被阻塞线程会抛出 InterruptedException 异常而返回，另外如果 e 元素为 null 则抛出 NullPointerException 异常。<br>public void put(E e) throws InterruptedException {<br>    &#x2F;&#x2F;(1)<br>    checkNotNull(e);<br>    final ReentrantLock lock &#x3D; this.lock;</p>
<pre><code>//(2)获取锁（可被中断）
lock.lockInterruptibly();
try &#123;

    //(3)如果队列满，则把当前线程放入notFull管理的条件队列
    while (count == items.length)
        notFull.await();

    //(4)插入元素
    enqueue(e);
&#125; finally &#123;
    //(5)
    lock.unlock();
&#125;
</code></pre>
<p>}<br>代码（2）在获取锁的过程中当前线程被其它线程中断了，则当前线程会抛出 InterruptedException 异常而退出。<br>代码（3）判断如果当前队列满了，则把当前线程阻塞挂起后放入到 notFull 的条件队列，注意这里也是使用了 while 而不是 if。<br>代码（4）如果队列不满则插入当前元素，此处不再累述。<br>4.2.3 poll 操作<br>从队列头部获取并移除一个元素，如果队列为空则返回 null，该方法是不阻塞的。<br>public E poll() {<br>    &#x2F;&#x2F;(1)获取锁<br>    final ReentrantLock lock &#x3D; this.lock;<br>    lock.lock();<br>    try {<br>        &#x2F;&#x2F;（2）当前队列为空则返回null,否者调用dequeue（）获取<br>        return (count &#x3D;&#x3D; 0) ? null : dequeue();<br>    } finally {<br>        &#x2F;&#x2F;(3)释放锁<br>        lock.unlock();<br>    }<br>}<br>代码（1）获取独占锁<br>代码（2）如果队列为空则返回 null，否者调用 dequeue() 方法，dequeue 代码如下：<br>private E dequeue() {<br>    final Object[] items &#x3D; this.items;</p>
<pre><code>//（4）获取元素值
@SuppressWarnings(&quot;unchecked&quot;)
E x = (E) items[takeIndex];
//（5）数组中值值为null;
items[takeIndex] = null;

//（6）队头指针计算，队列元素个数减一
</code></pre>
<p>   if (++takeIndex &#x3D;&#x3D; items.length)<br>            takeIndex &#x3D; 0;<br>    count–;</p>
<pre><code>//（7）发送信号激活notFull条件队列里面的一个线程
notFull.signal();
return x;
</code></pre>
<p>}<br>可知首先获取当前队头元素保存到局部变量，然后重置队头元素为 null，并重新设置队头下标，元素计数器递减，最后发送信号激活 notFull 的条件队列里面一个因为调用 put 或者 offer 而被阻塞的线程。<br>4.2.4 take 操作<br>获取当前队列头部元素并从队列里面移除，如果队列为空则阻塞调用线程。如果队列为空则阻塞当前线程直到队列不为空然后返回元素，如果在阻塞的时候被其它线程设置了中断标志，则被阻塞线程会抛出 InterruptedException 异常而返回。<br>public E take() throws InterruptedException {<br>    &#x2F;&#x2F;(1)获取锁<br>    final ReentrantLock lock &#x3D; this.lock;<br>    lock.lockInterruptibly();<br>    try {</p>
<pre><code>    //（2）队列为空，则等待，直到队列有元素
    while (count == 0)
        notEmpty.await();
    //（3）获取队头元素
    return dequeue();
&#125; finally &#123;
    //(4) 释放锁
    lock.unlock();
&#125;
</code></pre>
<p>}<br>take 操作的代码也比较简单与 poll 相比只是步骤（2）如果队列为空则把当前线程挂起后放入到 notEmpty 的条件队列，等其它线程调用 notEmpty.signal() 方法后在返回，需要注意的是这里也是使用 while 循环进行检测并等待而不是使用 if。<br>4.2.5 peek 操作<br>获取队列头部元素但是不从队列里面移除，如果队列为空则返回 null，该方法是不阻塞的。<br>public E peek() {<br>    &#x2F;&#x2F;(1)获取锁<br>    final ReentrantLock lock &#x3D; this.lock;<br>    lock.lock();<br>    try {<br>        &#x2F;&#x2F;（2）<br>        return itemAt(takeIndex);<br>    } finally {<br>       &#x2F;&#x2F;(3)<br>        lock.unlock();<br>    }<br>}</p>
<p> @SuppressWarnings(“unchecked”)<br>final E itemAt(int i) {<br>        return (E) items[i];<br>}<br>peek 的实现更简单，首先获取独占锁，然后从数组 items 中获取当前队头下标的值并返回，在返回前释放了获取的锁。<br>4.2.6 size 操作<br>获取当前队列元素个数。<br>public int size() {<br>    final ReentrantLock lock &#x3D; this.lock;<br>    lock.lock();<br>    try {<br>        return count;<br>    } finally {<br>        lock.unlock();<br>    }<br>}<br>size 操作是简单的，获取锁后直接返回 count，并在返回前释放锁。也许你会疑问这里有没有修改 Count 的值，只是简单的获取下，为何要加锁那？其实如果 count 声明为 volatile 这里就不需要加锁了，因为 volatile 类型变量保证了内存的可见性，而 ArrayBlockingQueue 的设计中 count 并没有声明为 volatile，是因为 count 的操作都是在获取锁后进行的，而获取锁的语义之一是获取锁后访问的变量都是从主内存获取的，这保证了变量的内存可见性。<br>注：ArrayBlockingQueue 通过使用全局独占锁实现同时只能有一个线程进行入队或者出队操作，这个锁的粒度比较大，有点类似在方法上添加 synchronized 的意味。ArrayBlockingQueue 的 size 操作的结果是精确的，因为计算前加了全局锁。</p>
<h3 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h3><p>PriorityBlockingQueue 是带优先级的无界阻塞队列，每次出队都返回优先级最高或者最低的元素，内部是平衡二叉树堆的实现。<br>5.1 PriorityBlockingQueue 类图结构<br>下面首先通过类图来从全局了解下 PriorityBlockingQueue 的结构<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192523554.png" alt="image.png"><br>如图 PriorityBlockingQueue 内部有个数组 queue 用来存放队列元素，size 用来存放队列元素个数，allocationSpinLock 是个自旋锁，用 CAS 操作来保证同时只有一个线程可以扩容队列，状态为 0 或者 1，其中 0 表示当前没有在进行扩容，1 标示当前正在扩容。<br>如下构造函数，默认队列容量为 11，默认比较器为 null，也就是使用元素的 compareTo 方法进行比较来确定元素的优先级，这意味着队列元素必须实现了 Comparable 接口;<br> private static final int DEFAULT_INITIAL_CAPACITY &#x3D; 11;</p>
<p> public PriorityBlockingQueue() {<br>        this(DEFAULT_INITIAL_CAPACITY, null);<br>    }</p>
<pre><code>public PriorityBlockingQueue(int initialCapacity) &#123;
    this(initialCapacity, null);
&#125;

public PriorityBlockingQueue(int initialCapacity,
                             Comparator&lt;? super E&gt; comparator) &#123;
    if (initialCapacity &lt; 1)
        throw new IllegalArgumentException();
    this.lock = new ReentrantLock();
    this.notEmpty = lock.newCondition();
    this.comparator = comparator;
    this.queue = new Object[initialCapacity];
&#125;
</code></pre>
<p>首先通过一个图来对该队列进行概况，读者读完本机后，可以回头在体会下：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192523703.png" alt="image.png"><br>5.2 原理介绍<br>5.2.1 offer 操作<br>offer 操作作用是在队列插入一个元素，由于是无界队列，所以一直返回 true，如下是 offer 函数的代码：<br>public boolean offer(E e) {</p>
<pre><code>if (e == null)
    throw new NullPointerException();

//获取独占锁
final ReentrantLock lock = this.lock;
lock.lock();

int n, cap;
Object[] array;

//如果当前元素个数&gt;=队列容量，则扩容(1)
while ((n = size) &gt;= (cap = (array = queue).length))
    tryGrow(array, cap);

try &#123;
    Comparator&lt;? super E&gt; cmp = comparator;

    //默认比较器为null (2)
    if (cmp == null)
        siftUpComparable(n, e, array);
    else
        //自定义比较器 (3)
        siftUpUsingComparator(n, e, array, cmp);

    //队列元素增加1，并且激活notEmpty的条件队列里面的一个阻塞线程（9）
    size = n + 1;
    notEmpty.signal();//激活调用take（）方法被阻塞的线程
&#125; finally &#123;
    //释放独占锁
    lock.unlock();
&#125;
return true;
</code></pre>
<p>}<br>如上代码，主流程比较简单，下面主要看看如何进行扩容的和内部如何建堆的，首先看下扩容逻辑：<br>private void tryGrow(Object[] array, int oldCap) {<br>    lock.unlock(); &#x2F;&#x2F;释放获取的锁<br>    Object[] newArray &#x3D; null;</p>
<pre><code>//cas成功则扩容(4)
if (allocationSpinLock == 0 &amp;&amp;
    UNSAFE.compareAndSwapInt(this, allocationSpinLockOffset,
                             0, 1)) &#123;
    try &#123;
        //oldGap&lt;64则扩容新增oldcap+2,否者扩容50%，并且最大为MAX_ARRAY_SIZE
        int newCap = oldCap + ((oldCap &lt; 64) ?
                               (oldCap + 2) : // grow faster if small
                               (oldCap &gt;&gt; 1));
        if (newCap - MAX_ARRAY_SIZE &gt; 0) &#123;    // possible overflow
            int minCap = oldCap + 1;
            if (minCap &lt; 0 || minCap &gt; MAX_ARRAY_SIZE)
                throw new OutOfMemoryError();
            newCap = MAX_ARRAY_SIZE;
        &#125;
        if (newCap &gt; oldCap &amp;&amp; queue == array)
            newArray = new Object[newCap];
    &#125; finally &#123;
        allocationSpinLock = 0;
    &#125;
&#125;

//第一个线程cas成功后，第二个线程会进入这个地方，然后第二个线程让出cpu，尽量让第一个线程执行下面点获取锁，但是这得不到肯定的保证。(5)
if (newArray == null) // back off if another thread is allocating
    Thread.yield();
lock.lock();//(6)
if (newArray != null &amp;&amp; queue == array) &#123;
    queue = newArray;
    System.arraycopy(array, 0, newArray, 0, oldCap);
&#125;
</code></pre>
<p>}<br>tryGrow 目的是扩容，这里要思考下为啥在扩容前要先释放锁，然后使用 cas 控制只有一个线程可以扩容成功。其实这里不先释放锁，也是可行的，也就是在整个扩容期间一直持有锁，但是扩容是需要花时间的，如果扩容时候还占用锁那么其它线程在这个时候是不能进行出队和入队操作的，这大大降低了并发性。所以为了提高性能，使用 CAS 控制只有一个线程可以进行扩容，并且在扩容前释放了锁，让其它线程可以进行入队出队操作。<br>spinlock 锁使用 CAS 控制只有一个线程可以进行扩容，CAS 失败的线程会调用 Thread.yield() 让出 cpu，目的意在让扩容线程扩容后优先调用 lock.lock 重新获取锁，但是这得不到一定的保证。有可能 yield 的线程在扩容线程扩容完成前已经退出，并执行代码（6）获取到了锁，这时候获取到的锁的线程发现 newArray 为 null 就会执行代码（1）。如果当前数组扩容还没完毕，当前线程会再次调用 tryGrow 方法，然后释放锁，这又给扩容线程获取锁提供了机会，如果这时候扩容线程还没扩容完毕，则当前线程释放锁后有调用 yield 方法出让 CPU。可知当扩容线程进行扩容期间，其他线程是原地自旋通过代码（1）检查当前扩容是否完毕，等扩容完毕后才退出代码（1）的循环。<br>当扩容线程扩容完毕后会重置自旋锁变量 allocationSpinLock 为 0，这里并没有使用 UNSAFE 方法的 CAS 进行设置是因为同时只可能有一个线程获取了该锁，并且 allocationSpinLock 被修饰为了 volatile。<br>当扩容线程扩容完毕后会执行代码 (6) 获取锁，获取锁后复制当前 queue 里面的元素到新数组。<br>然后看下具体建堆算法：<br>private static <T> void siftUpComparable(int k, T x, Object[] array) {<br>    Comparable&lt;? super T&gt; key &#x3D; (Comparable&lt;? super T&gt;) x;</p>
<pre><code>//队列元素个数&gt;0则判断插入位置，否者直接入队(7)
while (k &gt; 0) &#123;
    int parent = (k - 1) &gt;&gt;&gt; 1;
    Object e = array[parent];
    if (key.compareTo((T) e) &gt;= 0)
        break;
    array[k] = e;
    k = parent;
&#125;
array[k] = key;(8)
</code></pre>
<p>}<br>下面用图来解释上面算法过程，假设队列初始化容量为 2, 创建的优先级队列的泛型参数为 Integer。<br>首先调用队列的 offer(2) 方法，希望插入元素 2 到队列，插入前队列状态如下图：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192523815.png" alt="image.png"><br>首先执行代码（1)，从上图变量值可知判断值为 false，所以紧接着执行代码（2），由于 k&#x3D;n&#x3D;size&#x3D;0 所以代码（7）判断结果为 false，所以会执行代码（8）直接把元素 2 入队，最后执行代码（9）设置 size 的值加 1，这时候队列的状态如下图：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192523886.png" alt="image.png"><br>然后调用队列的 offer(4) 时候，首先执行代码（1)，从上图变量值可知判断为 false，所以执行代码（2），由于 k&#x3D;1, 所以进入 while 循环，由于 parent&#x3D;0;e&#x3D;2;key&#x3D;4; 默认元素比较器是使用元素的 compareTo 方法，可知 key&gt;e 所以执行 break 退出 siftUpComparable 中的循环; 然后把元素存到数组下标为 1 的地方，最后执行代码（9）设置 size 的值加 1，这时候队列状态为：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192523939.png" alt="image.png"><br>然后调用队列的 offer(6) 时候，首先执行代码（1)，从上图变量值知道这时候判断值为 true, 所以调用 tryGrow 进行数组扩容, 由于 2&lt;64 所以 newCap&#x3D;2 + (2+2)&#x3D;6; 然后创建新数组并拷贝，然后调用 siftUpComparable 方法，由于 k&#x3D;2&gt;0 进入 while 循环，由于 parent&#x3D;0;e&#x3D;2;key&#x3D;6;key&gt;e 所以 break 后退出 while 循环; 并把元素 6 放入数组下标为 2 的地方，最后设置 size 的值加 1，现在队列状态：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192524002.png" alt="image.png"><br>然后调用队列的 offer(1) 时候，首先执行代码（1)，从上图变量值知道这次判断值为 false，所以执行代码（2），由于k&#x3D;3, 所以进入 while 循环，由于parent&#x3D;0;e&#x3D;4;key&#x3D;1; key&lt;e，所以把元素 4 复制到数组下标为 3 的地方，然后 k&#x3D;0 退出 while 循环；然后把元素 1 存放到下标为 0 地方，现在状态：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192524074.png" alt="image.png"><br>这时候二叉树堆的树形图如下：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192524128.png" alt="image.png"><br>可知堆的根元素是 1，也就是这是一个最小堆，那么当调用这个优先级队列的 poll 方法时候，会一次返回堆里面值最小的元素。<br>5.2.2 poll 操作<br>poll 操作作用是获取队列内部堆树的根节点元素，如果队列为空，则返回 null。poll 函数代码如下：<br>public E poll() {<br>    final ReentrantLock lock &#x3D; this.lock;<br>    lock.lock();&#x2F;&#x2F;获取独占锁<br>    try {<br>        return dequeue();<br>    } finally {<br>        lock.unlock();&#x2F;&#x2F;释放独占锁<br>    }<br>}<br>如上代码可知在进行出队操作过程中要先加锁，这意味着，当当前线程进行出队操作时候，其它线程不能再进行入队和出队操作，但是从前面介绍 offer 函数时候知道这时候可以有其它线程进行扩容，下面主要看下具体执行出队操作的 dequeue 方法的代码：<br>private E dequeue() {</p>
<pre><code>//队列为空，则返回null
int n = size - 1;
if (n &lt; 0)
    return null;
else &#123;

    //获取队头元素(1)
    Object[] array = queue;
    E result = (E) array[0];

    //获取队尾元素，并值null(2)
    E x = (E) array[n];
    array[n] = null;

    Comparator&lt;? super E&gt; cmp = comparator;
    if (cmp == null)//(3)
        siftDownComparable(0, x, array, n);
    else
        siftDownUsingComparator(0, x, array, n, cmp);
    size = n;//（4）
    return result;
&#125;
</code></pre>
<p>}<br>如上代码，如果队列为空则直接返回 null，否者执行代码（1）获取数组第一个元素作为返回值存放到变量 Result，这里需要注意下数组里面第一个元素是优先级最小或者最大的元素，出队操作就是返回这个元素。 然后代码（2）获取队列尾部元素存放到变量 x, 并且置空尾部节点，然后执行代码（3）插入变量 x 到数组下标为 0 的位置后，重新调成堆为最大或者最小堆，然后返回。这里重要的是看如何去掉堆的根节点后，使用剩下的节点重新调整为一个最大或者最小堆，下面我们看下 siftDownComparable 的代码实现：<br>    private static <T> void siftDownComparable(int k, T x, Object[] array,<br>                                               int n) {<br>        if (n &gt; 0) {<br>            Comparable&lt;? super T&gt; key &#x3D; (Comparable&lt;? super T&gt;)x;<br>            int half &#x3D; n &gt;&gt;&gt; 1;           &#x2F;&#x2F; loop while a non-leaf<br>            while (k &lt; half) {<br>                int child &#x3D; (k &lt;&lt; 1) + 1; &#x2F;&#x2F; assume left child is least<br>                Object c &#x3D; array[child];（5）<br>                int right &#x3D; child + 1;（6)<br>                if (right &lt; n &amp;&amp;<br>                    ((Comparable&lt;? super T&gt;) c).compareTo((T) array[right]) &gt; 0)(7)<br>                    c &#x3D; array[child &#x3D; right];<br>                if (key.compareTo((T) c) &lt;&#x3D; 0)(8)<br>                    break;<br>                array[k] &#x3D; c;<br>                k &#x3D; child;<br>            }<br>            array[k] &#x3D; key;(9)<br>        }<br>    }<br>同理下面我们结合图来模拟上面调整堆的算法过程，接着上节队列的状态继续讲解，上节队列元素序列为 1，2，6，4：<br>第一次调用队列的 poll() 方法时候，首先执行代码（1）（2），这时候变量 size &#x3D;4;n&#x3D;3;result&#x3D;1；x&#x3D;4; 这时候队列状态<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192524191.png" alt="image.png"><br>然后执行代码（3）调整堆后队列状态为：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192524241.png" alt="image.png"><br>第二次调用队列的 poll() 方法时候，首先执行代码（1）（2），这时候变量 size &#x3D;3;n&#x3D;2;result&#x3D;2；x&#x3D;6; 这时候队列状态：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192524311.png" alt="image.png"><br>然后执行代码（3）调整堆后队列状态为：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192524357.png" alt="image.png"><br>第三次调用队列的 poll() 方法时候，首先执行代码（1）（2），这时候变量 size &#x3D;2;n&#x3D;1;result&#x3D;4；x&#x3D;6; 这时候队列状态：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192524485.png" alt="image.png"><br>然后执行代码（3）调整堆后队列状态为：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192524485.png" alt="image.png"><br>第四次直接返回元素 6.<br>下面重点说说 siftDownComparable 这个调整堆的算法： 首先说下堆调整的思路，由于队列数组第 0 个元素为树根，出队时候要被移除，这时候数组就不在是最小堆了，所以需要调整堆，具体是要从被移除的树根的左右子树中找一个最小的值来当树根，左右子树又会看自己作为根节点的树的左右子树里面那个是最小值，这是一个递归，直到树叶节点结束递归，如果还不明白，没关系，下面结合图来说明下，假如当前队列内容如下：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192524534.png" alt="image.png"><br>其对应的二叉堆树为：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192524594.png" alt="image.png"><br>这时候如果调用了 poll(); 那么 result&#x3D;2;x&#x3D;11；队列末尾的元素设置为 null 后，剩下的元素调整堆的步骤如下图：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192524671.png" alt="image.png"><br>如上图（1）树根的 leftChildVal &#x3D; 4;rightChildVal &#x3D; 6; 4&lt;6; 所以 c&#x3D;4; 然后 11&gt;4 也就是 key&gt;c；所以使用元素 4 覆盖树根节点的值，现在堆对应的树如图（2）。<br>然后树根的左子树树根的左右孩子节点中 leftChildVal &#x3D; 8;rightChildVal &#x3D; 10; 8&lt;10; 所以 c&#x3D;8; 然后发现 11&gt;8 也就是 key&gt;c；所以元素 8 作为树根左子树的根节点，现在树的形状如图（3）, 这时候判断 k&lt;half 为 false 就会退出循环，然后把 x&#x3D;11 设置到数组下标为 3 的地方，这时候堆树如图（4），至此调整堆完毕，siftDownComparable 返回 result&#x3D;2，poll 方法也返回了。<br>5.2.3 put 操作<br>put 操作内部调用的 offer, 由于是无界队列，所以不需要阻塞<br>public void put(E e) {<br>    offer(e); &#x2F;&#x2F; never need to block<br>}<br>5.2.4 take 操作<br>take 操作作用是获取队列内部堆树的根节点元素，如果队列为空则阻塞，如下代码：<br>public E take() throws InterruptedException {<br>    &#x2F;&#x2F;获取锁，可被中断<br>    final ReentrantLock lock &#x3D; this.lock;<br>    lock.lockInterruptibly();<br>    E result;<br>    try {</p>
<pre><code>    //如果队列为空，则阻塞，把当前线程放入notEmpty的条件队列
    while ( (result = dequeue()) == null)
        notEmpty.await();//阻塞当前线程
&#125; finally &#123;
    lock.unlock();//释放锁
&#125;
return result;
</code></pre>
<p>}<br>如上代码，首先通过 lock.lockInterruptibly() 获取独占锁，这个方式获取的锁是对中断进行响应的。然后调用 dequeue 方法返回堆树根节点元素，如果队列为空，则返回 false，然后当前线程调用 notEmpty.await() 阻塞挂起当前线程，直到有线程调用了 offer（）方法（offer 方法内在添加元素成功后调用了 notEmpty.signal 方法会激活一个阻塞在 notEmpty 的条件队列里面的一个线程）。另外这里使用 while 而不是 if 是为了避免虚假唤醒。<br>5.2.5 size 操作<br>获取队列元个数，如下代码，在返回 size 前加了锁，保证在调用 size() 方法时候不会有其它线程进行入队和出队操作，另外由于 size 变量没有被修饰为 volatie，这里加锁也保证了多线程下 size 变量的内存可见性。<br>public int size() {<br>    final ReentrantLock lock &#x3D; this.lock;<br>    lock.lock();<br>    try {<br>        return size;<br>    } finally {<br>        lock.unlock();<br>    }<br>}<br>注：PriorityBlockingQueue 队列内部使用二叉树堆维护元素优先级，内部使用数组作为元素存储的数据结构，这个数组是可扩容的，当当前元素个数 &gt;&#x3D; 最大容量时候会通过算法扩容，出队时候始终保证出队的元素是堆树的根节点，而不是在队列里面停留时间最长的元素，默认元素优先级比较规则是使用元素的 compareTo 方法来做，用户可以自定义优先级的比较规则。</p>
<h3 id="队列对比"><a href="#队列对比" class="headerlink" title="队列对比"></a>队列对比</h3><p>上面介绍的各种队列中只有 ConcurrentLinkedQueue 是使用 UNSAFE 类提供的 CAS 非阻塞算法实现的，其他几个队列内部都是使用锁来保证线程安全的。使用 CAS 算法的效率较好，那么是不是所有场景都用 ConcurrentLinkedQueue 那？<br>其实不然，因为 ConcurrentLinkedQueue 还是无界队列，无界队列使用不当可能造成 OOM。所以当使用 ConcurrentLinkedQueue 的时候在添加元素前应该先判断当前队列元素个数是否已经达到了设定的阈值，如果达到就做一定的处理措施，比如直接丢弃等。这里需要注意判断当前队列元素个数与阈值这个操作不是原子性的，最终会导致队列元素个数比设置的阈值大。<br>ConcurrentLinkedQueue 在 Tomcat 的的 NioEndPoint 中得到了应用，通过使用 ConcurrentLinkedQueue 将同步转换为异步，可以让 tomcat 同时接受更多请求，模型如下图：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192524794.png" alt="image.png"><br>tomcat 的 NioEndPoint 模式中 acceptor 线程负责接受用户请求，接受后把请求放入到 poll 线程对应的队列，poll 线程从队列里面获取任务后委托给 worker 线程具体处理。<br>LinkedBlockingQueue 和 ArrayBlockingQueue 都是有界阻塞队列，不同在于一个底层数据结构是链表，一个是数组；另外前者入队出队使用单独的锁，而后者出入队使用同一个锁，所以前者的并发度比后者高。另外创建前者时候可以不指定队列大小，默认队列元素个数为 Integer.MAX_VALUE，而后者必须要指定数组大小。所以使用 LinkedBlockingQueue 时候要记得指定队列大小。<br>比如比较有名的 LogBack 日志系统的异步日志打印实现中就是用了 ArrayBlockingQueue 作为缓冲队列，如下图，业务检查调用异步 log 进行写入日志时候，实际是把日志放入了 ArrayBlockingQueue 队列就返回了，而具体真正写入日志到磁盘是一个日志线程从队列里面获取任务来做的，这其实是一个多生产单消费模型：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/20180707192524971.png" alt="image.png"><br>PriorityBlockingQueue 是无界阻塞队列，是一个队列元素有优先级的队列，前面的队列模式都是 FIFO 先进先出，而 PriorityBlockingQueue 而是优先级最高的元素先出队，而不管谁先进入队列的，所以 PriorityBlockingQueue 经常会用在一些任务具有优先级的场景。还比如上面说的 logback 异步日志模型，如果把日志等级分了优先级，比如 error&gt;warn&gt;info，那么上述模型中队列就可以使用 PriorityBlockingQueue，日志线程会先从队列里面首先获取 error 级别的日志，但是需要注意的是如果业务线程一直向队列里面写入 error 级别日志，那么可能先写入到队列的 warn 和 info 级别的日志将很久甚至永远没机会写入到磁盘。还有一点要注意 PriorityBlockingQueue 是无界限队列，要注意判断队列元素个数不要超过设置的阈值。</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/4e8abc71.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tallate">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tallate">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/4e8abc71.html" class="post-title-link" itemprop="url">Java-线程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-09-10 21:07:49" itemprop="dateCreated datePublished" datetime="2019-09-10T21:07:49+08:00">2019-09-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-07 01:56:20" itemprop="dateModified" datetime="2025-07-07T01:56:20+08:00">2025-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="线程和状态机"><a href="#线程和状态机" class="headerlink" title="线程和状态机"></a>线程和状态机</h2><h3 id="线程和线程任务"><a href="#线程和线程任务" class="headerlink" title="线程和线程任务"></a>线程和线程任务</h3><p>线程任务区别于线程，可以理解为线程需要执行的逻辑，类似 Thread 中要执行的 Runnable。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/4e8abc71.html#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/2215add6.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tallate">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tallate">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2215add6.html" class="post-title-link" itemprop="url">Dubbo服务调用过程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-09-07 18:51:58" itemprop="dateCreated datePublished" datetime="2019-09-07T18:51:58+08:00">2019-09-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-07 01:56:20" itemprop="dateModified" datetime="2025-07-07T01:56:20+08:00">2025-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Dubbo/" itemprop="url" rel="index"><span itemprop="name">Dubbo</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>

<p>基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的 IP 地址，使服务提供方可以平滑增加或减少机器。</p>
<h2 id="角色分类"><a href="#角色分类" class="headerlink" title="角色分类"></a>角色分类</h2><p>以功能角度来说服务可以分成以下几种：</p>
<ul>
<li>服务提供者；</li>
<li>服务消费者；</li>
<li>服务提供者兼消费者。</li>
</ul>
<h2 id="注册中心分类"><a href="#注册中心分类" class="headerlink" title="注册中心分类"></a>注册中心分类</h2><p>可以分成以下几种注册中心：</p>
<ul>
<li>Simple 注册中心 点对点直连</li>
<li>Multicast 注册中心 多播</li>
<li>Zookeeper 注册中心</li>
<li>Redis 注册中心</li>
</ul>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>服务提供者（provider）配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 应用名称，可显示依赖关系 --&gt;</span><br><span class="line">&lt;dubbo:application name=&quot;dubbo-order-server&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 注册中心是ZooKeeper，也可以选择Redis做注册中心 --&gt;</span><br><span class="line">&lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot;</span><br><span class="line">    client=&quot;zkclient&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 通过dubbo协议在注册中心（127.0.0.1表示本机）的20880端口暴露服务 --&gt;</span><br><span class="line">&lt;dubbo:protocol name=&quot;dubbo&quot; host=&quot;127.0.0.1&quot; port=&quot;20880&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 提供服务用地的是service标签，将该接口暴露到dubbo中 --&gt;</span><br><span class="line">&lt;dubbo:service interface=&quot;com.dubbo.service.OrderService&quot;</span><br><span class="line">    ref=&quot;orderService&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Spring容器加载具体的实现类--&gt;</span><br><span class="line">&lt;bean id=&quot;orderService&quot; class=&quot;dubbo.service.impl.OrderServiceImpl&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;dubbo:monitor protocol=&quot;registry&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>服务消费者（consumer）配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 应用名称，可显示依赖关系 --&gt;</span><br><span class="line">&lt;dubbo:application name=&quot;dubbo-user-consumer&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- zookeeper作为注册中心 ，也可以选择Redis做注册中心 --&gt;</span><br><span class="line">&lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot;</span><br><span class="line">    client=&quot;zkclient&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;dubbo:protocol host=&quot;127.0.0.1&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 调用服务使用reference标签，从注册中心中查找服务 --&gt;</span><br><span class="line">&lt;dubbo:reference id=&quot;orderService&quot; interface=&quot;com.dubbo.service.OrderService&quot; /&gt;</span><br></pre></td></tr></table></figure>

<h2 id="查看服务注册-暴露结果"><a href="#查看服务注册-暴露结果" class="headerlink" title="查看服务注册&#x2F;暴露结果"></a>查看服务注册&#x2F;暴露结果</h2><p><img src="/imgs/Dubbo/Dubbo%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%BF%A1%E6%81%AF.png" alt="Dubbo服务注册信息" title="Dubbo服务注册信息"><br>Dubbo 在 ZooKeeper 中以树形结构维护服务注册信息：</p>
<ul>
<li>服务提供者启动时: 向 &#x2F;dubbo&#x2F;com.foo.BarService&#x2F;providers 目录下写入自己的 URL 地址；</li>
<li>服务消费者启动时: 订阅 &#x2F;dubbo&#x2F;com.foo.BarService&#x2F;providers 目录下的提供者 URL 地址。并向 &#x2F;dubbo&#x2F;com.foo.BarService&#x2F;consumers 目录下写入自己的 URL 地址；</li>
<li>监控中心启动时: 订阅 &#x2F;dubbo&#x2F;com.foo.BarService 目录下的所有提供者和消费者 URL 地址。</li>
</ul>
<p>ZooKeeper 启动的时候会把配置信息加载进内存并持久化到数据库，然后启动定时器脏数据检查定时器 DirtyCheckTask，分别检查消费者和提供者的地址列表缓存、消费者和提供者地址列表的数据库数据，清理不存活的消费者和提供者数据，对于缓存中的存在的消费者和提供者而数据库不存在，提供者重新注册和消费者重新订阅。</p>
<p>Dubbo 提供了一些异常情况下的兜底方案：</p>
<ul>
<li>当提供者出现断电等异常停机时，注册中心能自动删除提供者信息</li>
<li>当注册中心重启时，能自动恢复注册数据，以及订阅请求</li>
<li>当会话过期时，能自动恢复注册数据，以及订阅请求</li>
<li>当设置 &lt;dubbo:registry check&#x3D;”false” &#x2F;&gt; 时，记录失败注册和订阅请求，后台定时重试</li>
</ul>
<p>在了解 ZooKeeper 基础上，还可以增加一些配置来修改注册细节：<br>可通过 <code>&lt;dubbo:registry username=&quot;admin&quot; password=&quot;1234&quot; /&gt;</code> 设置 ZooKeeper 登录信息<br>可通过 <code>&lt;dubbo:registry group=&quot;dubbo&quot; /&gt;</code> 设置 ZooKeeper 的根节点，不设置将使用无根树<br>支持 * 号通配符 <code>&lt;dubbo:reference group=&quot;*&quot; version=&quot;*&quot; /&gt;</code> ，可订阅服务的所有分组和所有版本的提供者</p>
<p>在 Provider 启动完毕后，可以登录到 ZooKeeper 上查看注册的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 11] ls /</span><br><span class="line">[dubbo, zookeeper]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 12] ls /dubbo</span><br><span class="line">[com.alibaba.dubbo.monitor.MonitorService, com.tallate.UserServiceBo]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 13] ls /dubbo/com.tallate.UserServiceBo</span><br><span class="line">[configurators, consumers, providers, routers]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 14] ls /dubbo/com.tallate.UserServiceBo/providers</span><br><span class="line">[dubbo%3A%2F%2F192.168.96.194%3A20880%2Fcom.tallate.UserServiceBo%3Fanyhost%3Dtrue%26application%3DdubboProvider%26dubbo%3D2.0.2%26generic%3Dfalse%26group%3Ddubbo%26interface%3Dcom.tallate.UserServiceBo%26methods%3DsayHello%2CtestPojo%2CsayHello2%26pid%3D28129%26revision%3D1.0.0%26side%3Dprovider%26timeout%3D3000%26timestamp%3D1575202776615%26version%3D1.0.0]</span><br></pre></td></tr></table></figure>

<h2 id="服务自动发现流程"><a href="#服务自动发现流程" class="headerlink" title="服务自动发现流程"></a>服务自动发现流程</h2><p>服务自动发现功能完成下面这个流程，我们接下来分点概述：</p>
<ol>
<li>服务提供者在启动时，向注册中心注册自己提供的服务。</li>
<li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li>
<li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li>
<li>服务消费者，从提供者地址列表中，基于软负载均衡算法（基于软件的负载均衡，与 F5 相对），选一台提供者进行调用，如果调用失败，再选另一台调用。</li>
</ol>
<h2 id="注册和注销服务（Provider-执行流程）"><a href="#注册和注销服务（Provider-执行流程）" class="headerlink" title="注册和注销服务（Provider 执行流程）"></a>注册和注销服务（Provider 执行流程）</h2><p>服务的注册与注销，是对服务提供方角色而言，大致流程如下所示：<br><img src="/imgs/Dubbo/%E6%B3%A8%E5%86%8C%E5%92%8C%E6%B3%A8%E9%94%80%E6%9C%8D%E5%8A%A1.png" alt="注册和注销服务" title="注册和注销服务"></p>
<ol>
<li>在接口提供者初始化时，每个接口都会创建一个 Invoker 和 Exporter，Exporter 持有 Invoker 实例，通过 Invocation 中的信息就可找到对应的 Exporter 和 Invoker</li>
<li>同 Consumer 的过程类似，调用 Invoker 前会调用 Invoker-Filter。</li>
<li>调用 Invoker.invoke() 时，通过反射调用最终的服务实现执行相关逻辑。</li>
</ol>
<p>ServiceBean 负责了服务的暴露：</p>
<ul>
<li>继承自 ServiceConfig，export 方法实现了服务暴露的逻辑；</li>
<li>实现了 Spring 中的 InitializingBean, DisposableBean, ApplicationContextAware, ApplicationListener<ContextRefreshedEvent>, BeanNameAware</li>
</ul>
<p>启动时，ServiceBean 主要负责以下任务：</p>
<ul>
<li>生成 DubboExporter 对象并缓存起来</li>
<li>添加过滤器和监听器支持</li>
<li>在 zk 上注册相关信息，暴露服务，方便被感知到</li>
<li>监听端口，等待通信的到来</li>
</ul>
<p><img src="/imgs/Dubbo/Dubbo%E6%9C%8D%E5%8A%A1%E5%AF%BC%E5%87%BA.png" alt="Dubbo服务导出" title="Dubbo服务导出"></p>
<ol>
<li>前置工作，主要用于检查参数和组装 URL；<br>ServiceBean#onApplicationEvent: 接收 Spring 上下文刷新事件后执行服务导出操作<br>-&gt; ServiceBean#export: 导出服务<br>-&gt; ProviderConfig.getExport、getDelay 获取配置，如果 export 为 false 则无法提供给其他服务调用、一般只提供给本地调试时使用，如果需要 delay 则将任务交给一个 ScheduledExecutorService 延迟执行，否则调用 doExport 暴露服务<br>-&gt; ServiceConfig.doExport 一堆配置检查</li>
<li>导出服务，包含导出服务到本地（JVM）和导出服务到远程两个过程；<br><code>ServiceConfig.doExportUrls</code><br>导出服务，Dubbo 中所有服务都通过 URL 导出，支持多协议多注册中心导出服务（遍历 ProtocolConfig 集合导出每个服务）<br><code>AbstractInterfaceConfig#loadRegistries</code><br>加载注册中心链接<br><code>ServiceConfig#doExportUrlsFor1Protocol</code><br>组装 URL，将服务注册到注册中心<br><code>JavassistProxyFactory#getInvoker</code><br>获取 Invoker 实例，用于接收请求<br><code>ServiceConfig#exportLocal、DubboProtocol#export</code><br>根据配置信息导出服务到本地或远程，远程默认取Dubbo协议<br><code>DubboProtocol#openServer</code><br>开始监听请求</li>
<li>向注册中心注册服务，用于服务发现<br>Dubbo 服务注册本质是在 zk 指定目录下创建临时节点，路径是<code>&#123;group&#125;/&#123;Interface&#125;/providers/&#123;url&#125;</code>。<br>RegistryProtocol#register<br>-&gt; RegistryFactory#getRegistry<br>-&gt; AbstractRegistry#register</li>
</ol>
<p>因为Dubbo一般使用ZooKeeper作为注册中心，所以完全可以利用ZooKeeper的临时节点自动删除机制来实现服务器下线自动踢出的机制。</p>
<h2 id="服务订阅和取消（Consumer-执行流程）"><a href="#服务订阅和取消（Consumer-执行流程）" class="headerlink" title="服务订阅和取消（Consumer 执行流程）"></a>服务订阅和取消（Consumer 执行流程）</h2><p>为了满足应用系统的需求，服务消费方的可能需要从服务注册中心订阅指定的有服务提供方发布的服务，在得到通知可以使用服务时，就可以直接调用服务。反过来，如果不需要某一个服务了，可以取消该服务。<br><img src="/imgs/Dubbo/%E6%9C%8D%E5%8A%A1%E8%AE%A2%E9%98%85%E5%92%8C%E5%8F%96%E6%B6%88.png" alt="服务订阅和取消" title="服务订阅和取消"></p>
<p>有两种服务引入方式：</p>
<ol>
<li>饿汉式：Spring 容器调用 ReferenceBean 的 afterPropertiesSet 方法时引用服务，可通过配置 <code>&lt;dubbo:reference&gt;</code> 的 init 属性开启。</li>
<li>懒汉式：ReferenceBean 对应的服务被注入到其他类中时引用</li>
</ol>
<p>服务提供的方式有三种：</p>
<ol>
<li>引用本地 (JVM) 服务；</li>
<li>通过直连方式引用远程服务；</li>
<li>通过注册中心引用远程服务。</li>
</ol>
<p>不管是哪种引用方式，最后都会得到一个 Invoker 实例。如果有多个注册中心，多个服务提供者，这个时候会得到一组 Invoker 实例，此时需要通过集群管理类 Cluster 将多个 Invoker 合并成一个实例。</p>
<p>获取客户端Proxy：</p>
<ol>
<li>在 Consumer 初始化的时候，会生成一个代理注册到容器中，该代理回调中持有一个 Invoker 实例，消费调用服务接口时它的 invoke() 方法会被调用。<br>spring.ReferenceBean#getObject<br>ReferenceConfig#createProxy<br>创建代理实例，根据 url 的协议、scope 以及 injvm 等参数检测是否需要本地引用，不是本地引用的情况下默认采用Dubbo协议。<br>Protocol#refer<br> -&gt; DubboProtocol#getClients 获取客户端实例，实例类型为 ExchangeClient，ExchangeClient 不具备通信能力，它需要依赖更底层的客户端实例<br> -&gt; DubboProtocol#getSharedClient 默认获取共享客户端<br> -&gt; DubboProtocol#initClient 创建客户端实例，默认为 Netty<br> -&gt; Exchangers#connect(URL url, ExchangeHandler handler)</li>
<li>使用 Cluster 合并 Invoker<br>org.apache.dubbo.rpc.cluster.Cluster#join<br>如果配置了多个 URL，则使用 Cluster 合并多个 Invoker</li>
<li>创建动态代理<br>-&gt; ProxyFactory#getProxy(Invoker<T> invoker)<br>常用的动态代理技术有 javassist、cglib、jdk，其中 dubbo 使用的是 javassist。<blockquote>
<p>根据早期 Dubbo 作者梁飞（<a target="_blank" rel="noopener" href="http://javatar.iteye.com/blog/814426%EF%BC%89%E7%9A%84%E8%AF%B4%E6%B3%95%EF%BC%8C%E4%BD%BF%E7%94%A8">http://javatar.iteye.com/blog/814426）的说法，使用</a> javassist 是为了性能。</p>
</blockquote>
</li>
</ol>
<h2 id="Consumer端服务调用过程"><a href="#Consumer端服务调用过程" class="headerlink" title="Consumer端服务调用过程"></a>Consumer端服务调用过程</h2><p><img src="/imgs/Dubbo/Dubbo%E7%BB%84%E4%BB%B6.png" alt="Dubbo组件" title="Dubbo组件"></p>
<h3 id="调用代理类的方法"><a href="#调用代理类的方法" class="headerlink" title="调用代理类的方法"></a>调用代理类的方法</h3><p>请求实际调用的是<code>InvokerInvocationHandler.invoke</code>。</p>
<h3 id="Registry-Directory"><a href="#Registry-Directory" class="headerlink" title="Registry &amp; Directory"></a>Registry &amp; Directory</h3><h4 id="Registry-将注册信息保存到本地的Directory"><a href="#Registry-将注册信息保存到本地的Directory" class="headerlink" title="Registry 将注册信息保存到本地的Directory"></a>Registry 将注册信息保存到本地的Directory</h4><p>启动服务时需要给一个Dubbo接口创建代理，这时需要将注册URL转换为Invoker对象：<br><code>org.apache.dubbo.registry.integration.RegistryProtocol#refer</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; Invoker&lt;T&gt; refer(Class&lt;T&gt; type, URL url) throws RpcException &#123;</span><br><span class="line">    url = getRegistryUrl(url);</span><br><span class="line">    Registry registry = registryFactory.getRegistry(url);</span><br><span class="line">    if (RegistryService.class.equals(type)) &#123;</span><br><span class="line">        return proxyFactory.getInvoker((T) registry, type, url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // group=&quot;a,b&quot; or group=&quot;*&quot;</span><br><span class="line">    Map&lt;String, String&gt; qs = StringUtils.parseQueryString(url.getParameterAndDecoded(REFER_KEY));</span><br><span class="line">    String group = qs.get(GROUP_KEY);</span><br><span class="line">    if (group != null &amp;&amp; group.length() &gt; 0) &#123;</span><br><span class="line">        if ((COMMA_SPLIT_PATTERN.split(group)).length &gt; 1 || &quot;*&quot;.equals(group)) &#123;</span><br><span class="line">            return doRefer(getMergeableCluster(), registry, type, url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return doRefer(cluster, registry, type, url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>引用一个服务时，会注册一个<code>zkListener</code>，监听注册服务的命名空间的变更情况。<br><code>org.apache.dubbo.registry.zookeeper.ZookeeperRegistry#doSubscribe</code><br>那么服务是怎么注册的呢？其实就是上边Provider注册服务的过程。<br>监听到注册中心的变更后，更新本地的Invoker列表，同时删除不可用的。<br><code>org.apache.dubbo.registry.integration.RegistryDirectory#refreshInvoker</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private void refreshInvoker(List&lt;URL&gt; invokerUrls) &#123;</span><br><span class="line">    Assert.notNull(invokerUrls, &quot;invokerUrls should not be null&quot;);</span><br><span class="line"></span><br><span class="line">    if (invokerUrls.size() == 1</span><br><span class="line">            &amp;&amp; invokerUrls.get(0) != null</span><br><span class="line">            &amp;&amp; EMPTY_PROTOCOL.equals(invokerUrls.get(0).getProtocol())) &#123;</span><br><span class="line">        this.forbidden = true; // Forbid to access</span><br><span class="line">        this.invokers = Collections.emptyList();</span><br><span class="line">        routerChain.setInvokers(this.invokers);</span><br><span class="line">        destroyAllInvokers(); // Close all invokers</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        this.forbidden = false; // Allow to access</span><br><span class="line">        Map&lt;String, Invoker&lt;T&gt;&gt; oldUrlInvokerMap = this.urlInvokerMap; // local reference</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        Map&lt;String, Invoker&lt;T&gt;&gt; newUrlInvokerMap = toInvokers(invokerUrls);// Translate url list to Invoker map</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            destroyUnusedInvokers(oldUrlInvokerMap, newUrlInvokerMap); // Close the unused Invoker</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            logger.warn(&quot;destroyUnusedInvokers error. &quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Invoker使用Directory"><a href="#Invoker使用Directory" class="headerlink" title="Invoker使用Directory"></a>Invoker使用Directory</h4><p>为了服务高可用同一个服务一般会有多个应用服务器提供，要先挑选一个提供者提供服务。在服务接口消费者初始化时，接口方法和提供者 Invoker 对应关系保存在 Directory。 中，通过调用的方法名称（或方法名称+第一个参数）获取该方法对应的提供者 Invoker 列表，如注册中心设置了路由规则，对这些 Invoker 根据路由规则进行过滤。<br>启动时订阅某个服务：<br><code>org.apache.dubbo.registry.integration.RegistryProtocol#doRefer</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private &lt;T&gt; Invoker&lt;T&gt; doRefer(Cluster cluster, Registry registry, Class&lt;T&gt; type, URL url) &#123;</span><br><span class="line">    RegistryDirectory&lt;T&gt; directory = new RegistryDirectory&lt;T&gt;(type, url);</span><br><span class="line">    directory.setRegistry(registry);</span><br><span class="line">    directory.setProtocol(protocol);</span><br><span class="line">    // all attributes of REFER_KEY</span><br><span class="line">    Map&lt;String, String&gt; parameters = new HashMap&lt;String, String&gt;(directory.getUrl().getParameters());</span><br><span class="line">    URL subscribeUrl = new URL(CONSUMER_PROTOCOL, parameters.remove(REGISTER_IP_KEY), 0, type.getName(), parameters);</span><br><span class="line">    if (!ANY_VALUE.equals(url.getServiceInterface()) &amp;&amp; url.getParameter(REGISTER_KEY, true)) &#123;</span><br><span class="line">        directory.setRegisteredConsumerUrl(getRegisteredConsumerUrl(subscribeUrl, url));</span><br><span class="line">        registry.register(directory.getRegisteredConsumerUrl());</span><br><span class="line">    &#125;</span><br><span class="line">    directory.buildRouterChain(subscribeUrl);</span><br><span class="line">    // 订阅providers、configurators、routers这几个namespace</span><br><span class="line">    directory.subscribe(subscribeUrl.addParameter(CATEGORY_KEY,</span><br><span class="line">            PROVIDERS_CATEGORY + &quot;,&quot; + CONFIGURATORS_CATEGORY + &quot;,&quot; + ROUTERS_CATEGORY));</span><br><span class="line"></span><br><span class="line">    // 使用Cluster组合Invoker</span><br><span class="line">    Invoker invoker = cluster.join(directory);</span><br><span class="line">    return invoker;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加监听器：<br><code>org.apache.dubbo.registry.integration.RegistryDirectory#subscribe</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void subscribe(URL url) &#123;</span><br><span class="line">    setConsumerUrl(url);</span><br><span class="line">    CONSUMER_CONFIGURATION_LISTENER.addNotifyListener(this);</span><br><span class="line">    serviceConfigurationListener = new ReferenceConfigurationListener(this, url);</span><br><span class="line">    registry.subscribe(url, this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Consumer端监听服务变更事件，刷新Invoker列表：<br><code>org.apache.dubbo.registry.integration.RegistryDirectory#refreshInvoker</code></p>
<h4 id="Registry的几种实现"><a href="#Registry的几种实现" class="headerlink" title="Registry的几种实现"></a>Registry的几种实现</h4><ul>
<li>ZooKeeperRegistry</li>
<li>RedisRegistry<br>注册信息的存储，是在启动时调用的：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void doRegister(URL url) &#123;</span><br><span class="line">    // key = dubbo/com.package.to.InterfaceName/providers</span><br><span class="line">    String key = toCategoryPath(url);</span><br><span class="line">    // url的全名</span><br><span class="line">    String value = url.toFullString();</span><br><span class="line">    String expire = String.valueOf(System.currentTimeMillis() + expirePeriod);</span><br><span class="line">    boolean success = false;</span><br><span class="line">    RpcException exception = null;</span><br><span class="line">    for (Map.Entry&lt;String, JedisPool&gt; entry : jedisPools.entrySet()) &#123;</span><br><span class="line">        JedisPool jedisPool = entry.getValue();</span><br><span class="line">        try &#123;</span><br><span class="line">            Jedis jedis = jedisPool.getResource();</span><br><span class="line">            try &#123;</span><br><span class="line">                // 使用hash结构，可以providers一个key下面存多个url</span><br><span class="line">                jedis.hset(key, value, expire);</span><br><span class="line">                jedis.publish(key, Constants.REGISTER);</span><br><span class="line">                success = true;</span><br><span class="line">                if (! replicate) &#123;</span><br><span class="line">                    break; //  如果服务器端已同步数据，只需写入单台机器</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                jedisPool.returnResource(jedis);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            exception = new RpcException(&quot;Failed to register service to redis registry. registry: &quot; + entry.getKey() + &quot;, service: &quot; + url + &quot;, cause: &quot; + t.getMessage(), t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (exception != null) &#123;</span><br><span class="line">        if (success) &#123;</span><br><span class="line">            logger.warn(exception.getMessage(), exception);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw exception;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
注册信息的主动删除，进程关闭时：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Directory的几种实现"><a href="#Directory的几种实现" class="headerlink" title="Directory的几种实现"></a>Directory的几种实现</h4><ul>
<li>RegistryDirectory<br>保存注册中心的服务注册信息，包括routers、configurators、provider。</li>
<li>StaticDirectory<br>Invoker列表是固定的。</li>
</ul>
<h3 id="Cluster"><a href="#Cluster" class="headerlink" title="Cluster"></a>Cluster</h3><p>封装了服务降级和容错机制，比如，如果调用失败则执行其他（<code>FailoverClusterInvoker</code>）、仍然调用失败则降级执行 mock（<code>MockClusterInvoker</code>）。<br>调用的第一层是<code>MockClusterInvoker</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public Result invoke(Invocation invocation) throws RpcException &#123;</span><br><span class="line">    Result result = null;</span><br><span class="line">    </span><br><span class="line">    String value = directory.getUrl().getMethodParameter(invocation.getMethodName(), MOCK_KEY, Boolean.FALSE.toString()).trim();</span><br><span class="line">    // 没有设置mock属性或设置为false，则直接调就完了</span><br><span class="line">    if (value.length() == 0 || &quot;false&quot;.equalsIgnoreCase(value)) &#123;</span><br><span class="line">        //no mock</span><br><span class="line">        result = this.invoker.invoke(invocation);</span><br><span class="line">    &#125;</span><br><span class="line">    // 配成force了，直接调mock方法</span><br><span class="line">    else if (value.startsWith(&quot;force&quot;)) &#123;</span><br><span class="line">        if (logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(&quot;force-mock: &quot; + invocation.getMethodName() + &quot; force-mock enabled , url : &quot; + directory.getUrl());</span><br><span class="line">        &#125;</span><br><span class="line">        //force:direct mock</span><br><span class="line">        result = doMockInvoke(invocation, null);</span><br><span class="line">    &#125;</span><br><span class="line">    // fail-mock的方式</span><br><span class="line">    else &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            result = this.invoker.invoke(invocation);</span><br><span class="line"></span><br><span class="line">            //fix:#4585</span><br><span class="line">            if(result.getException() != null &amp;&amp; result.getException() instanceof RpcException)&#123;</span><br><span class="line">                RpcException rpcException= (RpcException)result.getException();</span><br><span class="line">                if(rpcException.isBiz())&#123;</span><br><span class="line">                    throw  rpcException;</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    result = doMockInvoke(invocation, rpcException);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; catch (RpcException e) &#123;</span><br><span class="line">            if (e.isBiz()) &#123;</span><br><span class="line">                throw e;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(&quot;fail-mock: &quot; + invocation.getMethodName() + &quot; fail-mock enabled , url : &quot; + directory.getUrl(), e);</span><br><span class="line">            &#125;</span><br><span class="line">            result = doMockInvoke(invocation, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际invoke调用的是父类<code>AbstractClusterInvoker</code>的invoke方法，这个方法的主要功能是提供负载均衡：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public Result invoke(final Invocation invocation) throws RpcException &#123;</span><br><span class="line">    checkWhetherDestroyed();</span><br><span class="line"></span><br><span class="line">    // binding attachments into invocation.</span><br><span class="line">    Map&lt;String, String&gt; contextAttachments = RpcContext.getContext().getAttachments();</span><br><span class="line">    if (contextAttachments != null &amp;&amp; contextAttachments.size() != 0) &#123;</span><br><span class="line">        ((RpcInvocation) invocation).addAttachments(contextAttachments);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 找到所有可调用的服务器</span><br><span class="line">    List&lt;Invoker&lt;T&gt;&gt; invokers = list(invocation);</span><br><span class="line">    // 发送时要经过负载均衡</span><br><span class="line">    LoadBalance loadbalance = initLoadBalance(invokers, invocation);</span><br><span class="line">    RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);</span><br><span class="line">    return doInvoke(invocation, invokers, loadbalance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的<code>doInvoke</code>是一个模板方法，由子类实现，默认子类是<code>FailoverClusterInvoker</code>，可以看到，它先通过负载均衡策略得到一个Invoker，再调用该Invoker，Invoker的默认实现是<code>DubboInvoker</code>，表示使用的是Dubbo协议。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">private Result doInvoke(List&lt;Invoker&lt;T&gt;&gt; invokers,</span><br><span class="line">                        final List&lt;Invoker&lt;T&gt;&gt; invoked,</span><br><span class="line">                        Holder&lt;RpcException&gt; lastException,</span><br><span class="line">                        final Set&lt;String&gt; providers,</span><br><span class="line">                        final Invocation invocation,</span><br><span class="line">                        final LoadBalance loadbalance,</span><br><span class="line">                        final int totalRetries,</span><br><span class="line">                        int retries,</span><br><span class="line">                        Holder&lt;Invoker&lt;T&gt;&gt; lastInvoked) throws RpcException &#123;</span><br><span class="line">    if (retries &lt; totalRetries) &#123;</span><br><span class="line">        checkWheatherDestoried();</span><br><span class="line">        invokers = list(invocation);</span><br><span class="line">        checkInvokers(invokers, invocation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 负载均衡</span><br><span class="line">    final Invoker&lt;T&gt; invoker = select(loadbalance, invocation, invokers, invoked);</span><br><span class="line">    invoked.add(invoker);</span><br><span class="line">    lastInvoked.value = invoker;</span><br><span class="line">    RpcContext.getContext().setInvokers((List) invoked);</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        return invoker.invoke(invocation);</span><br><span class="line">    &#125; catch (RpcException e) &#123;</span><br><span class="line">        //业务异常不重试</span><br><span class="line">        if (e.isBiz()) &#123;</span><br><span class="line">            throw e;</span><br><span class="line">        &#125;</span><br><span class="line">        lastException.value = e;</span><br><span class="line">    &#125; catch (Throwable e) &#123;</span><br><span class="line">        lastException.value = new RpcException(e.getMessage(), e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        providers.add(invoker.getUrl().getAddress());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (--retries == 0) &#123;</span><br><span class="line">        throw populateException(invokers, lastException.value, providers, invocation, totalRetries);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return doInvoke(invokers, invoked, lastException, providers, invocation, loadbalance, totalRetries, retries, lastInvoked);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Cluster的实现"><a href="#Cluster的实现" class="headerlink" title="Cluster的实现"></a>Cluster的实现</h4><ul>
<li>MockClusterInvoker<br>调用失败降级到mock接口；</li>
<li>BroadcastClusterInvoker<br>每个Invoker都调一次，忽略了LoadBalance；</li>
<li>AvailableClusterInvoker<br>把处于可用状态的Invoker都调一遍。</li>
<li>FailoverClusterInvoker<br>一个Invoker失败就换个Invoker重试几次。</li>
<li>FailbackClusterInvoker<br>如果调用失败就放到一个线程池中延迟5秒再发，一般用于发消息。</li>
<li>FailfastClusterInvoker<br>失败立刻报错</li>
<li>FailsafeClusterInvoker<br>失败就忽略，一般是用于记日志这种失败了影响也不大的场景。</li>
<li>ForkingClusterInvoker<br>一次性选n个Invoker，并行调用，只要有一个调用成功就返回，线程间通过<code>LinkedBlockingQueue</code>通信。</li>
</ul>
<h3 id="LoadBalance"><a href="#LoadBalance" class="headerlink" title="LoadBalance"></a>LoadBalance</h3><p>Cluster 层包含多个 Invoker，LoadBalance 负责从中选出一个来调用，有多种 LoadBalance 策略，比如随机选一个（<code>RandomLoadBalance</code>）、轮询（<code>RoundRobinLoadBalance</code>）、一致性hash（ConsistentHashLoadBalance）。<br>实例化LoadBalance：<code>com.alibaba.dubbo.rpc.cluster.support.AbstractClusterInvoker#invoke</code><br>使用LoadBalance选择一个Invoker：<code>com.alibaba.dubbo.rpc.cluster.support.AbstractClusterInvoker#select</code></p>
<h4 id="LoadBalance的多种实现"><a href="#LoadBalance的多种实现" class="headerlink" title="LoadBalance的多种实现"></a>LoadBalance的多种实现</h4><ul>
<li>RandomLoadBalance<br>计算权重，然后根据每个Invoker的权重调一个。</li>
<li>LeastActiveLoadBalance<br>找最近最不活跃的Invoker调用，如果这样的Invoker有多个，则按权重来随机选一个。</li>
<li>RoundRobinLoadBalance<br>轮询</li>
<li>ConsistentHashLoadBalance<br>一致性哈希，启动时会将Invoker排列在一个圆环上：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public ConsistentHashSelector(List&lt;Invoker&lt;T&gt;&gt; invokers, String methodName, int identityHashCode) &#123;</span><br><span class="line">    this.virtualInvokers = new TreeMap&lt;Long, Invoker&lt;T&gt;&gt;();</span><br><span class="line">    this.identityHashCode = identityHashCode;</span><br><span class="line">    URL url = invokers.get(0).getUrl();</span><br><span class="line"></span><br><span class="line">    String[] index = Constants.COMMA_SPLIT_PATTERN.split(url.getMethodParameter(methodName, &quot;hash.arguments&quot;, &quot;0&quot;));</span><br><span class="line">    argumentIndex = new int[index.length];</span><br><span class="line">    for (int i = 0; i &lt; index.length; i++) &#123;</span><br><span class="line">        argumentIndex[i] = Integer.parseInt(index[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int replicaNumber = url.getMethodParameter(methodName, &quot;hash.nodes&quot;, 160);</span><br><span class="line">    for (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class="line">        String address = invoker.getUrl().getAddress();</span><br><span class="line">        // 多复制几个，更均匀，避免所有请求都被hash到同一个Invoker</span><br><span class="line">        for (int i = 0; i &lt; replicaNumber / 4; i++) &#123;</span><br><span class="line">            byte[] digest = md5(address + i);</span><br><span class="line">            for (int h = 0; h &lt; 4; h++) &#123;</span><br><span class="line">                long m = hash(digest, h);</span><br><span class="line">                // 放入圆环上</span><br><span class="line">                virtualInvokers.put(m, invoker);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
将Invoker保存到virtualInvokers上，但是virtualInvokers本身是一个HashMap，如果新来的请求不能精确hash到其中的某个Invoker怎么办？是通过tailMap找到的下一个Invoker：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private Invoker&lt;T&gt; selectForKey(long hash) &#123;</span><br><span class="line">    Invoker&lt;T&gt; invoker;</span><br><span class="line">    Long key = hash;</span><br><span class="line"></span><br><span class="line">    if (!virtualInvokers.containsKey(key)) &#123;</span><br><span class="line">        SortedMap&lt;Long, Invoker&lt;T&gt;&gt; tailMap = virtualInvokers.tailMap(key);</span><br><span class="line">        if (tailMap.isEmpty()) &#123;</span><br><span class="line">            key = virtualInvokers.firstKey();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            key = tailMap.firstKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    invoker = virtualInvokers.get(key);</span><br><span class="line">    return invoker;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Filter-Invoker-层"><a href="#Filter-Invoker-层" class="headerlink" title="Filter &amp; Invoker 层"></a>Filter &amp; Invoker 层</h3><p>不过，在实际网络调用之前，Dubbo还提供Filter功能，Cluster会先激活Filter链然后最终调到<code>DubboInvoker.invoke(RpcInvocation)</code>：</p>
<ol>
<li><code>ConsumerContextFilter</code>可以将请求对象<code>Invocation</code>添加到上下文<code>RpcContext</code>中，其实就是存储到一个ThreadLocal变量中。</li>
<li><code>FutureFilter</code>在调用完毕后唤醒调用者线程。</li>
<li>或许还会有一些自定义的Filter，比如增加线程的TraceId、打印一些调用日志之类的，Filter结束后才最终调用到<code>DubboInvoker</code>。</li>
</ol>
<p><code>DubboInvoker</code>封装了同步和异步调用，Dubbo 实现同步和异步调用比较关键的一点就在于由谁调用 ResponseFuture 的 get 方法。同步调用模式下，由框架自身调用 ResponseFuture 的 get 方法。异步调用模式下，则由用户调用该方法。<br>DubboInvoker是通过Netty发送消息的，消息本身如何发送的就不多说了。</p>
<h3 id="Exchange"><a href="#Exchange" class="headerlink" title="Exchange"></a>Exchange</h3><p>封装了网络客户端的发送逻辑，包括：</p>
<ul>
<li>HeaderExchangeChannel<br>对 Request 的序列化</li>
<li>ReferenceCountExchangeClient<br>无引用时自动关闭客户端</li>
<li>HeaderExchangeClient<br>心跳检测</li>
</ul>
<h3 id="数据编码-发送"><a href="#数据编码-发送" class="headerlink" title="数据编码 &amp; 发送"></a>数据编码 &amp; 发送</h3><p>DubboCodec<br>NettyChannel#send</p>
<h2 id="Provider端接受调用的过程"><a href="#Provider端接受调用的过程" class="headerlink" title="Provider端接受调用的过程"></a>Provider端接受调用的过程</h2><ol>
<li>接收请求<br>NettyClient<br>请求被接收后，通过 Netty 调用链向下传递执行<br>NettyHandler#messageReceived<br>NettyChannel</li>
<li>解码<br><code>ExchangeCodec</code></li>
<li>线程派发<br><code>Dispatcher</code><br>IO 线程接收请求后分发给事件处理线程执行，具体的派发逻辑在<code>ChannelHandler</code>中实现，比如<code>AllChannelHandler</code>。</li>
<li>请求分发<br><code>ChannelEventRunnable</code><br>根据请求类型将请求分发给不同的<code>ChannelHandler</code>处理。</li>
</ol>
<p>Provider 端响应</p>
<p>Consumer 端接收响应</p>
<ol>
<li>发送完请求后阻塞<br><code>HeaderExchangeHandler</code><br>用户线程在发送完请求后，会调用 <code>DefaultFuture</code> 的 <code>get</code> 方法等待响应对象的到来，这时每个<code>DefaultFuture</code>都会关联一个<strong>调用编号</strong>，用于在接收到响应时能对应上请求的<code>DefaultFuture</code>。<br>当响应对象到来后，IO 线程根据<strong>调用编号</strong>可以找到<code>DefaultFuture</code>，之后会将响应对象保存到<code>DefaultFuture</code>，并唤醒用户线程。</li>
</ol>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/353ec849.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tallate">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tallate">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/353ec849.html" class="post-title-link" itemprop="url">Dubbo 概述</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-09-07 18:51:58" itemprop="dateCreated datePublished" datetime="2019-09-07T18:51:58+08:00">2019-09-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-07 01:56:20" itemprop="dateModified" datetime="2025-07-07T01:56:20+08:00">2025-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Dubbo/" itemprop="url" rel="index"><span itemprop="name">Dubbo</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>

<h2 id="为什么使用-Dubbo"><a href="#为什么使用-Dubbo" class="headerlink" title="为什么使用 Dubbo"></a>为什么使用 Dubbo</h2><p>选型时一般需要考虑：</p>
<ol>
<li>业务特点及可预见的后续的发展。</li>
<li>可用性要求。</li>
<li>团队的成熟度。一个成熟的团队可以很好地 Hold 住复杂的开源框架，甚至做定制化开发。</li>
</ol>
<p>在选择使用 Dubbo 之后，又需要考虑很多细节，比如：</p>
<ol>
<li>Dubbo 底层走什么协议？如何对对象进行序列化，用了哪些序列化方式？如何处理异步转同步？</li>
<li>高并发高可用性。Dubbo 依赖了 ZooKeeper，但是万一 ZooKeeper 宕机了怎么办？<br>如果 ZooKeeper 假死，客户端对服务端的调用是否会全部下线？如果是该如何避免？<br>如何监控 Dubbo 的调用，并做到优雅的客户端无感发布？</li>
</ol>
<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><ol>
<li>模块化<br>推荐将服务接口、实体、异常等都放到 API 包内，它们都是 API 的一部分。</li>
<li>粗粒度<br>暴露的 Dubbo 接口的粒度应尽可能得粗，代表一个完整的功能，而不是其中的某一步，否则就不得不面对分布式事务问题了，而 Dubbo 当前并没有提供分布式事务支持。</li>
<li>版本<br>某露服务接口的配置最好增加版本，当有不兼容的升级（比如接口定义要加个参数）时，版本可以方便地实现平滑发布，而又不用引入多余的代码。<br>版本只需要两位即可，比如<code>&quot;1.0&quot;</code>，因为升级并不是频繁的操作，因为不兼容的升级不会那么频繁。<br>升级时，先将一半的 provider 升级到新版本，然后将所有 consumer 升级，最后将其余的 provider 升级。</li>
<li>兼容性<br>向后兼容：接口加方法、对象加字段；<br>不兼容：删除方法、删除字段、枚举类型加字段。<br>不兼容的情况下，可以通过升级版本来实现平滑发布。</li>
<li>枚举类型<br>枚举是类型安全的，但是作为 Dubbo 接口的参数 &#x2F; 返回值却不合适，因为 provider 会将枚举转换为字符串传输，接收方会尝试寻找该字符串所属的枚举 field，找不到就会直接报错。</li>
<li>序列化<br>传值没必要使用接口抽象，因为序列化需要接口实现类的元信息（包括 getter、setter），无法隐藏实现。<br>参数和返回值必须 byValue 而不是 byReference，因为 Dubbo 不支持远程对象，provider 引用的对象 consumer 就找不到了。</li>
<li>异常<br>最好直接抛异常而不是返回异常码，因为异常可以携带更多信息、语法上也更加友好。<br>provider 不要将 DAO 层的异常抛给 consumer 端，consumer 端不应该关注 provider 对服务是如何实现的。</li>
</ol>
<h2 id="开始使用-Dubbo"><a href="#开始使用-Dubbo" class="headerlink" title="开始使用 Dubbo"></a>开始使用 Dubbo</h2><h3 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h3><p>ZooKeeper 在 Dubbo 中可以作为注册中心使用。<br>下载 ZooKeeper，修改配置，配置文件位于{ZOOKEEPER_HOME}&#x2F;conf&#x2F;zoo.cfg：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dataDir = /tmp/zk/data</span><br><span class="line">clientPort = 2181</span><br><span class="line">tickTime = 2000</span><br><span class="line">initLimit = 5</span><br><span class="line">syncLimit = 2</span><br></pre></td></tr></table></figure>
<ul>
<li>dataDir：数据保存的目录</li>
<li>clientPort：监听的端口</li>
<li>tickTime：心跳检查间隔</li>
<li>initLimit：Follower 启动从 Leader 同步数据时能忍受多少个心跳的时间间隔</li>
<li>syncLimit：Leader 同步到 Follower 后，如果超过 syncLimit 个 tickTime 的时间过去，还没有收到 Follower 的响应，那么就认为该 Follower 已下线。</li>
</ul>
<p>后台启动：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/zkServer.sh start-foreground</span><br></pre></td></tr></table></figure>
<h3 id="SDK"><a href="#SDK" class="headerlink" title="SDK"></a>SDK</h3><p>SDK 是一个被 provider 和 consumer 同时依赖的 jar 包，它的作用包括：</p>
<ul>
<li>提供实体类的定义；  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>提供接口的定义；  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface UserServiceBo &#123;</span><br><span class="line">    String sayHello(String name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>在设计 SDK 时包含一些注意要点，比如：</p>
<ul>
<li>不要使用枚举，用字符串常量来替代，因为 Dubbo 反序列化时如果碰到不存在的枚举就会抛出异常，这个问题编译期无法发现，可能造成线上故障；</li>
<li>升级时不要随意修改接口定义，provider 和 consumer 接口定义不同会导致运行时故障，最佳实践是提升<code>dubbo:reference</code>和<code>dubbo:service</code>的版本号，或者直接增加一个接口。</li>
</ul>
<h3 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h3><ol>
<li>声明依赖 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;dubbo&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.6.6&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.netty&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;netty-all&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.0.35.Final&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.2.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.47&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li>Dubbo 配置文件 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">  xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot;</span><br><span class="line">  xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">    http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">    http://code.alibabatech.com/schema/dubbo</span><br><span class="line">    http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 提供方应用信息，用于计算依赖关系 --&gt;</span><br><span class="line">    &lt;dubbo:application name=&quot;dubboProvider&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 使用zookeeper注册中心暴露服务地址 --&gt;</span><br><span class="line">    &lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 用dubbo协议在20880端口暴露服务 --&gt;</span><br><span class="line">    &lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot;/&gt;</span><br><span class="line">    &lt;!-- 启用monitor模块 --&gt;</span><br><span class="line">    &lt;dubbo:monitor protocol=&quot;registry&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;userService&quot; class=&quot;com.tallate.provider.UserServiceImpl&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 声明需要暴露的服务接口 --&gt;</span><br><span class="line">    &lt;dubbo:service interface=&quot;com.tallate.UserServiceBo&quot; ref=&quot;userService&quot;</span><br><span class="line">      group=&quot;dubbo&quot; version=&quot;1.0.0&quot; timeout=&quot;3000&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></li>
<li>接口的实现 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class UserServiceImpl implements UserServiceBo &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String sayHello(String name) &#123;</span><br><span class="line">        //让当前当前线程休眠2s</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(2000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>启动<br>原生 Spring 的启动方式： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] arg) throws InterruptedException &#123;</span><br><span class="line">    ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:provider.xml&quot;);</span><br><span class="line">    //挂起当前线程，如果没有改行代码，服务提供者进程会消亡，服务消费者就发现不了提供者了</span><br><span class="line">    Thread.currentThread().join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果需要以 SpringBoot 或 Docker 方式启动可以参考官方的示例</p>
</blockquote>
</li>
</ol>
<h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><ol>
<li>声明依赖<br>同 Provider</li>
<li>Dubbo 配置文件 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">  xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot;</span><br><span class="line">  xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">    http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">    http://code.alibabatech.com/schema/dubbo</span><br><span class="line">    http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 消费方应用名，用于计算依赖关系，不是匹配条件，不要与提供方一样 --&gt;</span><br><span class="line">    &lt;dubbo:application name=&quot;dubboConsumer&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 使用multicast广播注册中心暴露发现服务地址 --&gt;</span><br><span class="line">    &lt;dubbo:registry  protocol=&quot;zookeeper&quot; address=&quot;zookeeper://127.0.0.1:2181&quot; /&gt;</span><br><span class="line">    &lt;!-- 启动monitor--&gt;</span><br><span class="line">    &lt;dubbo:monitor protocol=&quot;registry&quot; /&gt;</span><br><span class="line">    &lt;!-- 生成远程服务代理，可以和本地bean一样使用demoService --&gt;</span><br><span class="line">    &lt;dubbo:reference id=&quot;userService&quot; interface=&quot;com.tallate.UserServiceBo&quot; group=&quot;dubbo&quot; version=&quot;1.0.0&quot; timeout=&quot;3000&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里出现了一些以 dubbo 作为前缀的标签，它们是由 Dubbo 的扩展 DubboNamespaceHandler 来处理的，DubboBeanDefinitionParser 在解析完后会得到对应 BeanDefinition，然后生成对象放到 BeanFactory 中。</p>
</blockquote>
</li>
<li>启动 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(</span><br><span class="line">            new String[]&#123;&quot;classpath:consumer.xml&quot;&#125;);</span><br><span class="line"></span><br><span class="line">    final UserServiceBo demoService = (UserServiceBo) context.getBean(&quot;userService&quot;);</span><br><span class="line"></span><br><span class="line">    System.out.println(demoService.sayHello(&quot;Hello World&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="调用-Dubbo-原生-API-启动"><a href="#调用-Dubbo-原生-API-启动" class="headerlink" title="调用 Dubbo 原生 API 启动"></a>调用 Dubbo 原生 API 启动</h3><ol>
<li>Provider <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// 等价于&lt;bean id=&quot;userService&quot; class=&quot;com.test.UserServiceImpl&quot; /&gt;</span><br><span class="line">UserServiceBo userService = new UserServiceImpl();</span><br><span class="line">// 等价于&lt;dubbo:application name=&quot;dubboProvider&quot; /&gt;</span><br><span class="line">ApplicationConfig application = new ApplicationConfig();</span><br><span class="line">application.setName(&quot;dubboProvider&quot;);</span><br><span class="line"></span><br><span class="line">// 等价于&lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot; /&gt;</span><br><span class="line">RegistryConfig registry = new RegistryConfig();</span><br><span class="line">registry.setAddress(&quot;127.0.0.1:2181&quot;);</span><br><span class="line">registry.setProtocol(&quot;zookeeper&quot;);</span><br><span class="line"></span><br><span class="line">// 等价于&lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot; /&gt;</span><br><span class="line">ProtocolConfig protocol = new ProtocolConfig();</span><br><span class="line">protocol.setName(&quot;dubbo&quot;);</span><br><span class="line">protocol.setPort(20880);</span><br><span class="line"></span><br><span class="line">// 等价于&lt;dubbo:monitor protocol=&quot;registry&quot; /&gt;</span><br><span class="line">MonitorConfig monitorConfig = new MonitorConfig();</span><br><span class="line">monitorConfig.setProtocol(&quot;registry&quot;);</span><br><span class="line"></span><br><span class="line">// 等价于&lt;dubbo:service interface=&quot;com.test.UserServiceBo&quot; ref=&quot;userService&quot;</span><br><span class="line">//      group=&quot;dubbo&quot;  version=&quot;1.0.0&quot; timeout=&quot;3000&quot;/&gt;</span><br><span class="line">// 此实例很重，封装了与注册中心的连接，请自行缓存，否则可能造成内存和连接泄漏</span><br><span class="line">ServiceConfig&lt;UserServiceBo&gt; service = new ServiceConfig&lt;&gt;();</span><br><span class="line">service.setApplication(application);</span><br><span class="line">service.setMonitor(monitorConfig);</span><br><span class="line">// 多个注册中心可以用setRegistries()</span><br><span class="line">service.setRegistry(registry);</span><br><span class="line">// 多个协议可以用setProtocols()</span><br><span class="line">service.setProtocol(protocol);</span><br><span class="line">service.setInterface(UserServiceBo.class);</span><br><span class="line">service.setRef(userService);</span><br><span class="line">service.setVersion(&quot;1.0.0&quot;);</span><br><span class="line">service.setGroup(&quot;dubbo&quot;);</span><br><span class="line">service.setTimeout(3000);</span><br><span class="line">service.export();</span><br><span class="line"></span><br><span class="line">// 挂起当前线程</span><br><span class="line">Thread.currentThread().join();</span><br></pre></td></tr></table></figure></li>
<li>Consumer <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 等价于&lt;dubbo:application name=&quot;dubboConsumer&quot; /&gt;</span><br><span class="line">ApplicationConfig application = new ApplicationConfig();</span><br><span class="line">application.setName(&quot;dubboConsumer&quot;);</span><br><span class="line"></span><br><span class="line">// 等价于&lt;dubbo:registry  protocol=&quot;zookeeper&quot; address=&quot;zookeeper://127.0.0.1:2181&quot; /&gt;</span><br><span class="line">RegistryConfig registry = new RegistryConfig();</span><br><span class="line">registry.setAddress(&quot;127.0.0.1:2181&quot;);</span><br><span class="line">registry.setProtocol(&quot;zookeeper&quot;);</span><br><span class="line"></span><br><span class="line">// 等价于 &lt;dubbo:monitor protocol=&quot;registry&quot; /&gt;</span><br><span class="line">MonitorConfig monitorConfig = new MonitorConfig();</span><br><span class="line">monitorConfig.setProtocol(&quot;registry&quot;);</span><br><span class="line"></span><br><span class="line">//等价于&lt;dubbo:reference id=&quot;userService&quot; interface=&quot;com.test.UserServiceBo&quot;</span><br><span class="line">//group=&quot;dubbo&quot; version=&quot;1.0.0&quot; timeout=&quot;3000&quot; /&gt;</span><br><span class="line">// 此实例很重，封装了与注册中心的连接以及与提供者的连接，最好放缓存，否则可能造成内存和连接泄漏</span><br><span class="line">ReferenceConfig&lt;UserServiceBo&gt; reference = new ReferenceConfig&lt;&gt;();</span><br><span class="line">reference.setApplication(application);</span><br><span class="line">// 多个注册中心可以用setRegistries()</span><br><span class="line">reference.setRegistry(registry);</span><br><span class="line">reference.setInterface(UserServiceBo.class);</span><br><span class="line">reference.setVersion(&quot;1.0.0&quot;);</span><br><span class="line">reference.setGroup(&quot;dubbo&quot;);</span><br><span class="line">reference.setTimeout(3000);</span><br><span class="line">reference.setInjvm(false);</span><br><span class="line">reference.setMonitor(monitorConfig);</span><br><span class="line"></span><br><span class="line">UserServiceBo userService = reference.get();</span><br><span class="line">System.out.println(userService.sayHello(&quot;哈哈哈&quot;));</span><br><span class="line">Thread.currentThread().join();</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="泛化调用"><a href="#泛化调用" class="headerlink" title="泛化调用"></a>泛化调用</h3><p>正常情况下我们使用 Dubbo 时会将实体类和接口定义放到一个 SDK 包内，其实也可以不加入这个包、直接将要传的参数放到一个 Map 对象内，称为泛化调用，但是这种方式没有什么实践价值，在此就不赘述了。</p>
<h2 id="Dubbo-架构"><a href="#Dubbo-架构" class="headerlink" title="Dubbo 架构"></a>Dubbo 架构</h2><blockquote>
<p>Dubbo 是一个分布式服务框架，是阿里巴巴 SOA 服务化治理方案的核心框架，致力于提供高性能和透明化的 RPC 远程服务调用方案，以及 SOA 服务治理方案。简而言之，Dubbo 是个远程服务调用的分布式框架（告别 Web Service 模式中的 WSdl，以服务提供者与消费者的方式在 dubbo 上注册）。</p>
</blockquote>
<p>Apache Dubbo 是一款高性能、轻量级的开源 Java RPC 框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。<br>Dubbo 的架构基本上可以概括为 RPC+服务发现，或者可以称之为弹性 RPC 框架。</p>
<h3 id="CP-三大中心"><a href="#CP-三大中心" class="headerlink" title="CP+三大中心"></a>CP+三大中心</h3><p><img src="/imgs/Dubbo/Dubbo%E6%9E%B6%E6%9E%84.png" alt="Dubbo架构" title="Dubbo架构"></p>
<blockquote>
<p>图中的 Consumer 和 Provider 是抽象概念，只是想让看图者更直观的了解哪些类分属于客户端与服务器端，不用 Client 和 Server 的原因是 Dubbo 在很多场景下都使用 Provider、Consumer、Registry、Monitor 划分逻辑拓普节点，保持统一概念。</p>
</blockquote>
<p>Provider: 暴露服务的服务提供方，启动时会注册自己提供的服务到注册中心。<br>Consumer: 调用远程服务的服务消费方，启动时会去注册中心订阅自己需要的服务，服务注册中心异步提供 Provider 的地址列表，Consumer 根据路由规则和预设的负载均衡算法选择一个 Provider 的 IP 进行调用，调用是直连的，失败后会调用另外一个。<br>Registry: 服务注册与发现的注册中心。<br>Monitor: 统计服务的调用次调和调用时间的监控中心，Provider 和 Consumer 在内存中累计调用次数和耗时，并定时每分钟发送一次统计数据到监控中心。<br>Container: 服务运行容器。</p>
<p>大数据量传输时适合用短连接，小数据量高并发适合用长连接。从上图中可以得知，Provider 和 Consumer 均通过长连接与注册中心通信，当消费方调用服务时，会创建一个连接，然后同时会创建一个心跳发送的定时线程池，每一分钟发送一次心跳包到注册中心，通过 ping-pong 来检查连接的存活性，同时还会启动断线重连定时线程池，每两秒钟检查一次连接状态，如果断开就重连，而当注册中心断开连接后，会回调通知 Consumer 销毁连接，同理，Provider 也是通过长连接与注册中心通信。</p>
<h4 id="元数据中心"><a href="#元数据中心" class="headerlink" title="元数据中心"></a>元数据中心</h4><p>2.7 之后提供的一个新组件，容易和注册中心混淆，元数据和注册中心中的注册信息之间的区别如下：</p>
<ul>
<li><strong>元数据（Metadata）</strong>指的是服务分组、服务版本、服务名、方法列表、方法参数列表、超时时间等</li>
<li><strong>注册信息</strong>指服务分组、服务版本、服务名、地址列表等。</li>
</ul>
<p>元数据中心和注册中心包含了一些公共数据，另外，元数据中心还会存储方法列表即参数列表，注册中心存储了服务地址，其他的一些区别如下所示：</p>
<ul>
<li>| 元数据 | 注册信息</li>
<li>| - | -<br>职责 | 描述服务，定义服务的基本属性 | 存储地址列表<br>变化频繁度 | 基本不变 | 随着服务上下线而不断变更<br>数据量 | 大 | 小<br>数据交互&#x2F;存储模型 | 消费者&#x2F;提供者上报，控制台查询 | PubSub 模型，提供者上报，消费者订阅<br>主要使用场景 | 服务测试、服务 | MOCK 服务调用<br>可用性要求 | 元数据中心可用性要求不高，不影响主流程 | 注册中心可用性要求高，影响到服务调用的主流程</li>
</ul>
<h3 id="Dubbo-层次化结构"><a href="#Dubbo-层次化结构" class="headerlink" title="Dubbo 层次化结构"></a>Dubbo 层次化结构</h3><p><img src="/imgs/Dubbo/Dubbo%E6%A1%86%E6%9E%B6.png" alt="Dubbo框架" title="Dubbo框架"><br>Dubbo 的架构是分层的，使用这种方式可以使各个层之间解耦合（或者最大限度地松耦合）。从服务模型的角度来看，Dubbo 采用的是一种非常简单的模型，要么是提供方提供服务，要么是消费方消费服务。</p>
<p><img src="/imgs/Dubbo/Dubbo%E6%89%A9%E5%B1%95.jpg" alt="Dubbo扩展" title="Dubbo扩展"></p>
<ul>
<li>服务接口层（Service）：该层是与实际业务逻辑相关的，根据服务提供方和服务消费方的业务设计对应的接口和实现。</li>
</ul>
<p>RPC 是 Dubbo 的核心：</p>
<ul>
<li>配置层（Config）<br>对外配置接口，以 <strong>ServiceConfig</strong> 和 <strong>ReferenceConfig</strong> 为中心，可以直接 new 配置类，也可以通过 Spring 解析配置生成配置类。</li>
<li>服务代理层（Proxy）<br>服务接口透明代理。Proxy 层封装了所有接口的透明化代理，而在其它层都以 <strong>Invoker</strong> 为中心，只有到了暴露给用户使用时，才用 <strong>Proxy</strong> 将 <strong>Invoker</strong> 转成接口，或将接口实现转成 <strong>Invoker</strong>，也就是去掉 Proxy 层 RPC 是可以 Run 的，只是不那么透明，不那么看起来像调本地服务一样调远程服务。<br>Proxy 层封装了所有接口的透明化代理，而在其它层都以 Invoker 为中心，只有到了暴露给用户使用时，才用 Proxy 将 Invoker 转成接口，或将接口实现转成 Invoker，也就是去掉 Proxy 层 RPC 是可以 Run 的，只是不那么透明，不那么看起来像调本地服务一样调远程服务。</li>
<li>服务注册层（Registry）<br>封装服务地址的注册与发现，以服务 URL 为中心，扩展接口为 <strong>RegistryFactory</strong>、<strong>Registry</strong> 和 <strong>RegistryService</strong>。可能没有服务注册中心，此时服务提供方直接暴露服务。</li>
<li>集群层（Cluster）<br>封装多个提供者的路由及负载均衡，并桥接注册中心，以 Invoker 为中心，扩展接口为 <strong>Cluster</strong>、<strong>Directory</strong>、<strong>Router</strong> 和 <strong>LoadBalance</strong>。将多个服务提供方组合为一个服务提供方，实现对服务消费方来透明，只需要与一个服务提供方进行交互。</li>
<li>监控层（Monitor）<br>RPC 调用次数和调用时间监控，以 <strong>Statistics</strong> 为中心，扩展接口为 <strong>MonitorFactory</strong>、<strong>Monitor</strong>和 <strong>MonitorService</strong>。</li>
<li>远程调用层（Protocol）<br>封装 RPC 调用，扩展接口为 <strong>Protocol</strong>、<strong>Invoker</strong> 和 <strong>Exporter</strong>。Protocol 是服务域，它是 Invoker 暴露和引用的主功能入口，它负责 Invoker 的生命周期管理。Invoker 是实体域，它是 Dubbo 的核心模型，其它模型都向它靠扰，或转换成它，它代表一个可执行体，可向它发起 invoke 调用，它有可能是一个本地的实现，也可能是一个远程的实现，也可能一个集群实现。Protocol 是核心层，也就是只要有 Protocol + Invoker + Exporter 就可以完成非透明的 RPC 调用，然后在 Invoker 的主过程上 Filter 拦截点。</li>
</ul>
<blockquote>
<p>Registry 和 Monitor 实际上不算一层，而是一个独立的节点，只是为了全局概览，用层的方式画在一起。<br>Cluster 是外围概念，Cluster 的目的是将多个 Invoker 伪装成一个 Invoker，这样其它人只要关注 Protocol 层 Invoker 即可，加上 Cluster 或者去掉 Cluster 对其它层都不会造成影响，因为只有一个提供者时，是不需要 Cluster 的。</p>
</blockquote>
<p>Remoting 实现是 Dubbo 协议的实现，如果你选择 RMI 协议，整个 Remoting 都不会用上，Remoting 内部再划为 Transport 传输层和 Exchange 信息交换层，Transport 层只负责单向消息传输，是对 Mina、Netty、Grizzly 的抽象，它也可以扩展 UDP 传输，而 Exchange 层是在传输层之上封装了 Request-Response 语义。</p>
<ul>
<li>交换层（Exchange）：封装请求响应模式，同步转异步，以 Request 和 Response 为中心，扩展接口为<strong>Exchanger</strong>、<strong>ExchangeChannel</strong>、<strong>ExchangeClient</strong>和<strong>ExchangeServer</strong>。</li>
<li>网络传输层（Transport）：抽象 mina 和 netty 为统一接口，以 Message 为中心，扩展接口为<strong>Channel</strong>、<strong>Transporter</strong>、<strong>Client</strong>、<strong>Server</strong>和<strong>Codec</strong>。</li>
<li>数据序列化层（Serialize）：可复用的一些工具，扩展接口为<strong>Serialization</strong>、 <strong>ObjectInput</strong>、<strong>ObjectOutput</strong>和<strong>ThreadPool</strong>。</li>
</ul>
<p><img src="/imgs/Dubbo/Dubbo%E5%8C%85%E7%BB%93%E6%9E%84.png" alt="Dubbo包结构" title="Dubbo包结构"></p>
<ul>
<li>dubbo-common 公共逻辑模块，包括 Util 类和通用模型。</li>
<li>dubbo-remoting 远程通讯模块，相当于 Dubbo 协议的实现，如果 RPC 用 RMI 协议则不需要使用此包。</li>
<li>dubbo-rpc 远程调用模块，抽象各种协议，以及动态代理，只包含一对一的调用，不关心集群的管理。</li>
<li>dubbo-cluster 集群模块，将多个服务提供方伪装为一个提供方，包括：负载均衡、容错、路由等，集群的地址列表可以是静态配置的，也可以是由注册中心下发。</li>
<li>dubbo-registry 注册中心模块，基于注册中心下发地址的集群方式，以及对各种注册中心的抽象。</li>
<li>dubbo-monitor 监控模块，统计服务调用次数，调用时间的，调用链跟踪的服务。</li>
<li>dubbo-config 配置模块，是 Dubbo 对外的 API，用户通过 Config 使用 Dubbo，隐藏 Dubbo 所有细节。</li>
<li>dubbo-container 容器模块，是一个 Standalone 的容器，以简单的 Main 加载 Spring 启动，因为服务通常不需要 Tomcat&#x2F;JBoss 等 Web 容器的特性，没必要用 Web 容器去加载服务。</li>
</ul>
<h2 id="集群-Cluster"><a href="#集群-Cluster" class="headerlink" title="集群 - Cluster"></a>集群 - Cluster</h2><p>提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。</p>
<h3 id="服务目录（Directory）"><a href="#服务目录（Directory）" class="headerlink" title="服务目录（Directory）"></a>服务目录（Directory）</h3><p><strong>服务目录</strong>中存储了一些和服务提供者有关的信息，通过服务目录，服务消费者可获取到服务提供者的信息，比如 ip、端口、服务协议等。通过这些信息，服务消费者就可通过 Netty 等客户端进行远程调用。<br>服务目录与注册中心之间的区别：</p>
<ul>
<li>注册中心存储服务提供者信息，在 Dubbo 中通过 ZooKeeper 实现；</li>
<li>服务目录是 Invoker 的集合，且这个集合中的元素会随注册中心的变化而进行动态调整。</li>
</ul>
<p>服务目录会在客户端启动时初始化完成，并订阅注册中心的更新：<br><code>com.alibaba.dubbo.registry.support.FailbackRegistry#FailbackRegistry</code><br><code>com.alibaba.dubbo.registry.support.FailbackRegistry#subscribe</code></p>
<h4 id="Directory-继承结构"><a href="#Directory-继承结构" class="headerlink" title="Directory 继承结构"></a>Directory 继承结构</h4><p>Directory 接口包含了一个获取配置信息的方法 getUrl，实现该接口的类可以向外提供配置信息。Directory 有多个实现。</p>
<ul>
<li>StaticDirectory<br>获取一次 Invoker 列表后就不变了。</li>
<li>RegistryDirectory<br>实现了 NotifyListener 接口，当注册中心服务配置发生变化后，RegistryDirectory 可收到与当前服务相关的变化，然后根据配置变更信息刷新 Invoker 列表。<br>刷新 Invoker 列表代码：com.alibaba.dubbo.registry.integration.RegistryDirectory#refreshInvoker</li>
</ul>
<h3 id="路由（Router）"><a href="#路由（Router）" class="headerlink" title="路由（Router）"></a>路由（Router）</h3><p>服务目录中包含多个 Invoker，需要通过路由规则来选择调用哪个，Dubbo 提供了 3 种路由实现：<strong>条件路由 ConditionRouter</strong>、<strong>脚本路由 ScriptRouter</strong> 和<strong>标签路由 TagRouter</strong>。</p>
<h4 id="条件路由（ConditionRouter）"><a href="#条件路由（ConditionRouter）" class="headerlink" title="条件路由（ConditionRouter）"></a>条件路由（ConditionRouter）</h4><h3 id="容错方案"><a href="#容错方案" class="headerlink" title="容错方案"></a>容错方案</h3><p><img src="/imgs/Dubbo/%E9%9B%86%E7%BE%A4%E5%AE%B9%E9%94%99.png" alt="集群容错" title="集群容错"><br>Dubbo 提供多种集群的容错方案，默认情况下为 Failover。<br><code>com.alibaba.dubbo.rpc.cluster.Cluster</code></p>
<h4 id="Failover"><a href="#Failover" class="headerlink" title="Failover"></a>Failover</h4><p>失败自动切换，当出现失败，重试其它服务器 （该配置为默认配置）。通常用于读操作，但重试会带来更长时间的延迟。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--配置集群容错模式为失败自动切换 --&gt;</span><br><span class="line">&lt;dubbo:reference cluster=&quot;failover&quot; /&gt;</span><br><span class="line">&lt;!-- 调用queryOrder方法如果失败共调3次，重试2次，如果成功则只调1次 --&gt;</span><br><span class="line">&lt;dubbo:reference&gt;</span><br><span class="line">    &lt;dubbo:method name=&quot;queryOrder&quot; retries=&quot;2&quot; /&gt;</span><br><span class="line">&lt;/dubbo:reference&gt;</span><br></pre></td></tr></table></figure>
<p>通常用于幂等操作，多次调用副作用相同，譬如只读请求，Failover 使用得较多，推荐使用，但重试会带来更长延迟，应用于消费者和提供者的服务调用。</p>
<h4 id="Failfast"><a href="#Failfast" class="headerlink" title="Failfast"></a>Failfast</h4><p>快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录和修改数据，Failfast 使用得较多，但如果有机器正在重启，可能会出现调用失败，应用于消费者和提供者的服务调用。</p>
<h4 id="Failsafe"><a href="#Failsafe" class="headerlink" title="Failsafe"></a>Failsafe</h4><p>失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作，Failsafe 使用得不多，但调用信息会丢失，应用于发送统计信息到监控中心。</p>
<h4 id="Failback"><a href="#Failback" class="headerlink" title="Failback"></a>Failback</h4><p>失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作，使用得很少，不可靠，重启会丢失，应用于注册服务到注册中心。</p>
<h4 id="Forking"><a href="#Forking" class="headerlink" title="Forking"></a>Forking</h4><p>并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，使用得很少，但需要浪费更多服务资源。</p>
<h4 id="Broadcast"><a href="#Broadcast" class="headerlink" title="Broadcast"></a>Broadcast</h4><p>广播调用所有提供者，逐个调用，任意一台报错则报错 。通常用于通知所有提供者更新缓存或日志等本地资源信息，速度慢，任意一台报错则报错，使用得很少。</p>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><h4 id="Random-LoadBalance"><a href="#Random-LoadBalance" class="headerlink" title="Random LoadBalance"></a>Random LoadBalance</h4><p>随机调用（默认配置），按权重设置随机概率，在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重，使用较多，推荐使用，但重试时，可能出现瞬间压力不均。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 服务端方法基本负载均衡设置 --&gt;</span><br><span class="line">&lt;dubbo:service interface=&quot;com.service.dubbo.queryOrder&quot;&gt;</span><br><span class="line">    &lt;dubbo:method name=&quot;queryOrder&quot; loadbalance=&quot;roundrobin&quot; /&gt;</span><br><span class="line">&lt;/dubbo:service&gt;</span><br></pre></td></tr></table></figure>
<h4 id="RoundRobin-LoadBalance"><a href="#RoundRobin-LoadBalance" class="headerlink" title="RoundRobin LoadBalance"></a>RoundRobin LoadBalance</h4><p>轮循调用，按公约后的权重设置轮循比率，存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上，极端情况可能产生雪崩。</p>
<h4 id="LeastActive-LoadBalance"><a href="#LeastActive-LoadBalance" class="headerlink" title="LeastActive LoadBalance"></a>LeastActive LoadBalance</h4><p>最少活跃数调用，相同活跃数的随机，活跃数指调用前后计数差，使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差（与时间有关）会越大，但不支持权重。</p>
<h4 id="ConsistentHash-LoadBalance"><a href="#ConsistentHash-LoadBalance" class="headerlink" title="ConsistentHash LoadBalance"></a>ConsistentHash LoadBalance</h4><p>一致性 Hash，相同参数的请求总是发到同一提供者，当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。缺省只对第一个参数 Hash，如果要修改，请配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:parameter key=&quot;hash.arguments&quot; value=&quot;0,1&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>缺省用 160 份虚拟节点，如果要修改，请配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:parameter key=&quot;hash.nodes&quot; value=&quot;320&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>由于是通过哈希算法分摊调用，有可能出现调用不均匀的情况</p>
<h2 id="远程通信-Transport"><a href="#远程通信-Transport" class="headerlink" title="远程通信 - Transport"></a>远程通信 - Transport</h2><p>提供对多种基于长连接的 NIO 框架抽象封装，包括多种线程模型，序列化，以及“请求-响应”模式的信息交换方式。<br>Dubbo 支持如下网络通信框架：</p>
<ul>
<li>Mina</li>
<li>Netty</li>
<li>Grizzly</li>
</ul>
<h2 id="序列化-Serialize"><a href="#序列化-Serialize" class="headerlink" title="序列化 - Serialize"></a>序列化 - Serialize</h2><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>通过缓存加载的 Class、setAccessible(false)去掉安全校验等来提高反射效率，或者使用反射包<strong>ReflectASM</strong>。</p>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>对性能敏感，对开发体验要求不高的内部系统 thrift 或 protobuf<br>对开发体验敏感，性能有要求的内外部系统 hessian2<br>对序列化后的数据要求有良好的可读性 jackson&#x2F;gson&#x2F;xml<br>对兼容性和性能要求较高的系统 protobuf 或 kryo ，它们的性能相差不多，但是 protobuf 有个缺点就是要传输的每一个类的结构都要生成对应的 proto 文件。</p>
<h2 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h2><p>ProtocolFilterWrapper#export：如果当前 protocol 不是 registry，则调用 buildInvokerChain<br>-&gt; ProtocolFilterWrapper#buildInvokerChain<br>-&gt; ExtensionLoader#getActivateExtension(URL url, String key, String group)：获取系统自动激活的 Filter 和用户自定义的 Filter，最后合并返回</p>
<h2 id="更多功能"><a href="#更多功能" class="headerlink" title="更多功能"></a>更多功能</h2><h3 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h3><p>限流最好配置在 Provider 端，因为 Consumer 可能有很多个服务器实例，如果他们同时发起对同一 Provider 实例的请求可能会超出机器的处理能力上限。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 限制接口OrderService里的每个方法，服务提供者端的执行线程不超过10个 --&gt;</span><br><span class="line">&lt;dubbo:service interface=&quot;com.bubbo.service.OrderService&quot; executes=&quot;10&quot; /&gt;</span><br><span class="line">&lt;!-- 限制接口OrderService里的queryOrderList方法，服务提供者端的执行线程不超过10个 --&gt;</span><br><span class="line">&lt;dubbo:service interface=&quot;com.bubbo.service.OrderService&quot;&gt;</span><br><span class="line">    &lt;dubbo:method name=&quot;queryOrderList&quot; executes=&quot;10&quot; /&gt;</span><br><span class="line">&lt;/dubbo:service&gt;</span><br><span class="line">&lt;!--限制使用dubbo协议时在服务提供者端启用的连接数不超过1000个--&gt;</span><br><span class="line">&lt;dubbo:provider protocol=&quot;dubbo&quot; accepts=&quot;1000&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>上述配置限制的是线程数，即并发连接数，Consumer 和 Provider 默认通过一条共享的 TCP 长连接通信，连接成功的情况下请求线程交由 IO 线程池异步读写数据，数据被反序列化后交由业务线程池处理具体业务，也就是对应的 Impl 实现类的具体方法。</p>
<h3 id="服务隔离"><a href="#服务隔离" class="headerlink" title="服务隔离"></a>服务隔离</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--当同一个接口有多个实现时，可以通过group来隔离  --&gt;</span><br><span class="line">&lt;!--服务提供者  --&gt;</span><br><span class="line">&lt;dubbo:service group=&quot;ImplA&quot; interface=&quot;com.bubbo.service.OrderService&quot;/&gt;</span><br><span class="line">&lt;dubbo:service group=&quot;ImplB&quot; interface=&quot;com.bubbo.service.OrderService&quot;/&gt;</span><br><span class="line">&lt;!--服务调用者  --&gt;</span><br><span class="line">&lt;dubbo:reference id=&quot;MethodA&quot; group=&quot;ImplA&quot; interface=&quot;com.bubbo.service.OrderService&quot;/&gt;</span><br><span class="line">&lt;dubbo:reference id=&quot;MethodB&quot; group=&quot;ImplB&quot; interface=&quot;com.bubbo.service.OrderService&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--当一个接口出现升级，新旧实现同时存在时，可以通过版本号来隔离，通常版本号隔离也用于联调阶段，不同版本号的服务无法调用，版本号相同的服务才能调用  --&gt;</span><br><span class="line">&lt;!--服务提供者  --&gt;</span><br><span class="line">&lt;dubbo:service interface=&quot;com.bubbo.service.OrderService&quot; version=&quot;new2.0.0&quot;/&gt;</span><br><span class="line">&lt;dubbo:service interface=&quot;com.bubbo.service.OrderService&quot; version=&quot;old1.0.0&quot;/&gt;</span><br><span class="line">&lt;!--服务调用者  --&gt;</span><br><span class="line">&lt;dubbo:reference id=&quot;NewMethodA&quot; interface=&quot;com.bubbo.service.OrderService&quot; version=&quot;new2.0.0&quot;/&gt;</span><br><span class="line">&lt;dubbo:reference id=&quot;OldMethodB&quot; interface=&quot;com.bubbo.service.OrderService&quot; version=&quot;old1.0.0&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p><strong>通过版本号，也可以实现消费者和提供者服务端直接连接</strong>，因为发起调用默认使用随机调用端负载均衡模式，当有多台提供者的时候，会随机选取，通常联调阶段都会调用指定服务进行联调，直连一般用在调试，开发阶段，只需要消费者和提供者 version 相同即可。</p>
<h3 id="灰度发布"><a href="#灰度发布" class="headerlink" title="灰度发布"></a>灰度发布</h3><p>有三台服务器 A、B、C 要上线，现在三台服务器都是旧版本代码，那首先从 Ngnix 负载均衡列表里移除 A 服务器的配置，切断对 A 的访问，然后在 A 服务器不受新的代码，重新把 A 配置进 Ngnix 负载均衡列表。如果在线使用没有问题，则继续升级 B、C 服务器，否则回滚，恢复旧版本代码，这是针对三端（PC 端，微信端，移动端）跟网关系统的。<br>如果是针对子系统，譬如用户系统、订单系统等，可以通过分组 group 来实现子系统的灰度发布。服务提供者有两组，One、Two，将新版本代码 group 改为 Two，旧版本 group 还是 One，将新版本的消费者 group 改为 Two，这时请求定位到新的消费者再调用新的提供者，而且旧的消费者还是请求旧的提供者，如果线上没有问题，那就把提供者 group 为 One 的组改为 Two，并部署新代码，旧的消费者也改成 Two 并部署新代码如果有问题，那消费端和提供端都回滚到旧版本。</p>
<h3 id="异步调用"><a href="#异步调用" class="headerlink" title="异步调用"></a>异步调用</h3><p>Dubbo 默认情况下是同步调用的，就是调用后立刻返回，但如果消费端调用服务端创建文件并转化成 PDF 格式的文件这种在 IO 密集操作时，消费端同步调用需要等待对方转换结束才返回，很消耗性能，这时选择异步调用和回调调用更合适。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">async=&quot;true&quot; 异步调用，调用后不用等待，继续往下执行</span><br><span class="line">onreturn =&quot;CallBack.onreturn&quot; 返回后调用自定义的类CallBack类的onreturn方法</span><br><span class="line">onthrow=&quot;CallBack.onthrow&quot; 调用后，提供者抛出异常后，返回调用自定义的类CallBack类的onthrow方法</span><br><span class="line">--&gt;    </span><br><span class="line">&lt;!--服务调用者  --&gt;</span><br><span class="line">&lt;dubbo:reference id=&quot;tranfromPDF&quot; interface=&quot;com.bubbo.service.OrderService&quot; &gt;</span><br><span class="line">    &lt;dubbo:method name=&quot;tranPDF&quot; async=&quot;true&quot; </span><br><span class="line">    onreturn =&quot;CallBack.onreturn&quot; </span><br><span class="line">    onthrow=&quot;CallBack.onthrow&quot;/&gt;</span><br><span class="line"> &lt;/dubbo:reference&gt;</span><br></pre></td></tr></table></figure>

<p>可以在 onthrow 事件里实现服务降级的方法，譬如遇到网络抖动，调用超时返回时可在 onthrow 里 return null。</p>
<ul>
<li>调用方  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testQueryOrder() &#123;</span><br><span class="line">    // 此时调用会立即拿到null值</span><br><span class="line">    List&lt;Order&gt; list = this.orderService.queryOrderList();</span><br><span class="line">    // 拿到Future的引用，在提供方返回结果后，结果值会被设置进Future</span><br><span class="line">    Future&lt;String&gt; orderFuture = RpcContext.getContext().getFuture();</span><br><span class="line">    try &#123;</span><br><span class="line">        // 该方法是阻塞方法，在拿到值之前一直等待，直到拿到值才会被唤醒，该方法会抛出异常，可以捕获</span><br><span class="line">        String returnValue = orderFuture.get();</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; catch (ExecutionException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>回调方  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 回调接口</span><br><span class="line">interface ICallBack &#123;</span><br><span class="line">    // 第一个参数是返回值，第二个参数是原参数</span><br><span class="line">    public void onreturn(String returnValue, String initParameter);</span><br><span class="line"></span><br><span class="line">    // 第一个参数是异常，第二个参数是原参数</span><br><span class="line">    public void onthrow(Throwable ex, String initParameter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实现类</span><br><span class="line">class CallBackImpl implements ICallBack &#123;</span><br><span class="line">    public void onreturn(String returnValue, String initParameter) &#123;</span><br><span class="line">        // do something</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    public void onthrow(Throwable ex, String initParameter) &#123;</span><br><span class="line">        // do something</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="/imgs/Dubbo/%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8.png" alt="异步调用" title="异步调用"><br>调用方有一个用户线程池用于处理调用请求（比如 Tomcat 里那个线程池），请求被转发到 IO 线程池，由 IO 线程来发起对提供方的调用，此时 IO 线程会新建一个 Future 对象进 RpcContext，用户线程可以继续继续自己的业务逻辑，然后在需要的时候调用 Future 的 get 方法阻塞等待，而服务端只需要将结果返回给 IO 线程，由 IO 线程调用 notify 方法唤醒阻塞等待中的用户线程。</p>
<h3 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h3><p>服务降级用于在服务高峰期将次要服务降级，仅保留关键服务，从而降低系统负载、提升可用性。比如，订单列表正常情况下展示所有订单，但是如果是在网站开展秒杀之类的大促活动时，就可以降级展示当月的订单而不是所有，再其次，如果服务器宕机了，也最好展示兜底页而不是 504。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:service interface=&quot;com.bubbo.service.OrderService&quot; mock=&quot;com.dubbo.service.MonthOderMock&quot;/&gt;</span><br></pre></td></tr></table></figure>

<h3 id="热点缓存"><a href="#热点缓存" class="headerlink" title="热点缓存"></a>热点缓存</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--服务调用者 --&gt;</span><br><span class="line">&lt;dubbo:reference id=&quot;queryCatalog&quot; interface=&quot;com.bubbo.service.CatalogService&quot;&gt;</span><br><span class="line">    &lt;dubbo:method name=&quot;queryCatalog&quot; cache=&quot;lru&quot; /&gt;</span><br><span class="line">&lt;/dubbo:reference&gt;</span><br><span class="line">&lt;dubbo:monitor protocol=&quot;registry&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>如果查询的对象改变很少但又数据量很大的时候，如首页目录，可以避免每次都频繁调用服务端，可以设置本地缓存，加快热点数据的访问，Dubbo 的缓存类型 LRU 缓存，最近最少使用的数据会被清除，使用频繁的数据被保留，Thredlocal 缓存，当前线程的缓存，假如当前线程有多次请求，每次请求都需要相同的用户信息，那就适用，避免每次都去查询用户基本信息。</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>环境配置比较简单，就是 zk-&gt;provider-&gt;consumer，在此不再赘述。</p>
<h3 id="失败重试"><a href="#失败重试" class="headerlink" title="失败重试"></a>失败重试</h3><p>Dubbo 中的失败重试机制比较丰富，基本考虑到常用的场景<br><a target="_blank" rel="noopener" href="http://dubbo.apache.org/zh-cn/docs/user/demos/fault-tolerent-strategy.html">http://dubbo.apache.org/zh-cn/docs/user/demos/fault-tolerent-strategy.html</a><br>FailoverClusterInvoker、FailfastClusterInvoker 等，以 FailoverClusterInvoker 为例：<br>FailoverClusterInvoker.doInvoke 重试几次，把失败的添加到 invoked 列表里<br>    -&gt; AbstractClusterInvoker.select 选一个可用的调用，如果是已经被选过或因为其他条件不可用则 reselect</p>
<h3 id="负载均衡-1"><a href="#负载均衡-1" class="headerlink" title="负载均衡"></a>负载均衡</h3><p><a target="_blank" rel="noopener" href="http://dubbo.apache.org/zh-cn/docs/user/demos/loadbalance.html">http://dubbo.apache.org/zh-cn/docs/user/demos/loadbalance.html</a></p>
<h3 id="幂等"><a href="#幂等" class="headerlink" title="幂等"></a>幂等</h3><p>Dubbo 没有提供幂等性检查功能，需要自定义。</p>
<h3 id="限流-1"><a href="#限流-1" class="headerlink" title="限流"></a>限流</h3><p>Dubbo 中的限流比较简单，采用的是<strong>计数器算法</strong>，单位时间内超出阈值的流量会被直接丢弃，而且只支持 PORVIDER 端的限流，而且为了让它生效还要搞复杂的 SPI 配置。<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/7112a8d3d869">https://www.jianshu.com/p/7112a8d3d869</a><br>入口：TpsLimitFilter.invoke<br>    -&gt; TPSLimiter.isAllowable 为每个 Service 创建一个计数器 StatItem（粒度是整个 Service 有没有太大了）</p>
<h3 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h3><p>Dubbo 里的降级比较水，即调用出错就改成调用 Mock 接口，没有 Hystrix 中那么复杂的逻辑：<br><a target="_blank" rel="noopener" href="http://dubbo.apache.org/zh-cn/docs/user/demos/service-downgrade.html">http://dubbo.apache.org/zh-cn/docs/user/demos/service-downgrade.html</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/java-zhao/p/8320519.html">https://www.cnblogs.com/java-zhao/p/8320519.html</a><br>入口：ReferenceConfig.createProxy 创建代理<br>    -&gt; ProxyFactory.getProxy<br>    -&gt; InvokerInvocationHandler.invoke<br>    -&gt; MockClusterInvoker.invoke 如果配置中有 fail 开头，则在远程调用失败后调用 doMockInvoke，大概逻辑是实例化一个 XxxServiceMock 服务然后调用</p>
<h3 id="优雅停机"><a href="#优雅停机" class="headerlink" title="优雅停机"></a>优雅停机</h3><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/6e4d1ecb0815">https://www.jianshu.com/p/6e4d1ecb0815</a></p>
<h2 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h2><h3 id="说一下你们怎么用-Dubbo-的（考对-Dubbo-的应用能力）"><a href="#说一下你们怎么用-Dubbo-的（考对-Dubbo-的应用能力）" class="headerlink" title="说一下你们怎么用 Dubbo 的（考对 Dubbo 的应用能力）"></a>说一下你们怎么用 Dubbo 的（考对 Dubbo 的应用能力）</h3><h3 id="说一下-Dubbo-的工作原理"><a href="#说一下-Dubbo-的工作原理" class="headerlink" title="说一下 Dubbo 的工作原理"></a>说一下 Dubbo 的工作原理</h3><p><img src="/imgs/Dubbo/Dubbo%E6%9E%B6%E6%9E%84.png" alt="Dubbo架构" title="Dubbo架构"><br>描述 Registry、Consumer、Provider 之间的关系。</p>
<h3 id="Dubbo-负载均衡策略和集群容错策略都有哪些"><a href="#Dubbo-负载均衡策略和集群容错策略都有哪些" class="headerlink" title="Dubbo 负载均衡策略和集群容错策略都有哪些"></a>Dubbo 负载均衡策略和集群容错策略都有哪些</h3><p>负载均衡策略和集群容错策略见上面的《集群》小节。</p>
<h3 id="Dubbo-的动态代理策略"><a href="#Dubbo-的动态代理策略" class="headerlink" title="Dubbo 的动态代理策略"></a>Dubbo 的动态代理策略</h3><p>javassist，类似 CGLIB，通过继承目标类以生成代理类。</p>
<h3 id="说一下服务注册（导出）过程"><a href="#说一下服务注册（导出）过程" class="headerlink" title="说一下服务注册（导出）过程"></a>说一下服务注册（导出）过程</h3><p>分本地暴露和远程暴露两种</p>
<h3 id="说一下服务消费（引入）过程"><a href="#说一下服务消费（引入）过程" class="headerlink" title="说一下服务消费（引入）过程"></a>说一下服务消费（引入）过程</h3><h3 id="服务的运行过程中，如果-ZooKeeper-挂掉了，这时还能正常请求吗？"><a href="#服务的运行过程中，如果-ZooKeeper-挂掉了，这时还能正常请求吗？" class="headerlink" title="服务的运行过程中，如果 ZooKeeper 挂掉了，这时还能正常请求吗？"></a>服务的运行过程中，如果 ZooKeeper 挂掉了，这时还能正常请求吗？</h3><h3 id="说一下-Dubbo-协议"><a href="#说一下-Dubbo-协议" class="headerlink" title="说一下 Dubbo 协议"></a>说一下 Dubbo 协议</h3><h3 id="Dubbo-有几种容错机制"><a href="#Dubbo-有几种容错机制" class="headerlink" title="Dubbo 有几种容错机制"></a>Dubbo 有几种容错机制</h3><h3 id="dubbo-有几种服务降级机制"><a href="#dubbo-有几种服务降级机制" class="headerlink" title="dubbo 有几种服务降级机制"></a>dubbo 有几种服务降级机制</h3><h3 id="dubbo-有几种服务降级机制-1"><a href="#dubbo-有几种服务降级机制-1" class="headerlink" title="dubbo 有几种服务降级机制"></a>dubbo 有几种服务降级机制</h3><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a target="_blank" rel="noopener" href="https://github.com/apache/incubator-dubbo">apache&#x2F;incubator-dubbo</a></li>
<li><a target="_blank" rel="noopener" href="http://dubbo.apache.org/en-us/docs/user/preface/background.html">Dubbo 文档</a></li>
<li><a target="_blank" rel="noopener" href="http://dubbo.apache.org/en-us/docs/user/demos/preflight-check.html">Dubbo 实例 Demos</a><br><a target="_blank" rel="noopener" href="http://dubbo.apache.org/zh-cn/docs/user/demos/preflight-check.html">中文版</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/j3t9z7h/article/details/81437570">设计 RPC 接口时，你有考虑过这些吗？</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/wolfcode_cn/article/details/81907241">解密 Dubbo:自己动手编写 RPC 框架</a></li>
</ol>
<h3 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h3><ol>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/j3T9Z7H/article/details/82836811">研究优雅停机时的一点思考</a><br><code>kill -9</code>与<code>kill -15</code>的区别，SpringBoot 的停机机制。</li>
<li><a target="_blank" rel="noopener" href="http://www.solves.com.cn/it/cxkf/bk/2019-10-14/6046.html">一文聊透 Dubbo 优雅停机</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1543749">一文聊透 Dubbo 优雅上线</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000015276158">Spring-boot+Dubbo 应用启停源码分析</a></li>
<li><a target="_blank" rel="noopener" href="http://dubbo.apache.org/zh-cn/docs/source_code_guide/export-service.html">服务导出</a></li>
<li><a target="_blank" rel="noopener" href="http://dubbo.apache.org/zh-cn/docs/source_code_guide/refer-service.html">服务引入</a></li>
</ol>
<h3 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h3><ol>
<li><a target="_blank" rel="noopener" href="http://dubbo.apache.org/zh-cn/docs/source_code_guide/dubbo-spi.html">Dubbo SPI</a></li>
<li><a target="_blank" rel="noopener" href="http://dubbo.apache.org/zh-cn/docs/source_code_guide/adaptive-extension.html">自适应拓展机制</a></li>
</ol>
<h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><ol>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/X5fnncxzq4/article/details/80729942">【RPC 专栏】深入理解 RPC 之协议篇</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43970890/article/details/103348778">Dubbo 在跨语言和协议穿透性方向的探索：支持 HTTP&#x2F;2 gRPC</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013815546/article/details/96364814">一文详细解读 Dubbo 中的 http 协议</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.itpub.net/31556476/viewspace-2375225/">聊聊 TCP 长连接和心跳那些事</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.itpub.net/31556476/viewspace-2305549/">Dubbo 中的 URL 统一模型</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnkirito.moe/network-interfaces/">研究网卡地址注册时的一点思考</a></li>
<li><a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc5234">RFC 5234 - Augmented BNF for Syntax Specifications: ABNF</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5cac08a26fb9a068996d5fb2">服务端经典的 C10k 问题(译)</a></li>
</ol>
<h3 id="心跳机制"><a href="#心跳机制" class="headerlink" title="心跳机制"></a>心跳机制</h3><ol>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_34175509/article/details/87997148">一种心跳，两种设计</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.itpub.net/31556476/viewspace-2375225/">聊聊 TCP 长连接和心跳那些事</a></li>
</ol>
<h3 id="序列化-1"><a href="#序列化-1" class="headerlink" title="序列化"></a>序列化</h3><ol>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/X5fnncxzq4/article/details/80333364">【RPC 专栏】深入理解 RPC 之序列化篇–总结篇</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/X5fnncxzq4/article/details/80276182">【RPC 专栏】深入理解 RPC 之序列化篇 —— Kryo</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/loveqishan/article/details/89531587">如何提高使用 Java 反射的效率？</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_26525215/article/details/82943040">Java 序列化框架性能比较</a></li>
</ol>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/bf6c261d.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tallate">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tallate">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/bf6c261d.html" class="post-title-link" itemprop="url">Dubbo的SPI原理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-09-07 18:51:58" itemprop="dateCreated datePublished" datetime="2019-09-07T18:51:58+08:00">2019-09-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-07 01:56:20" itemprop="dateModified" datetime="2025-07-07T01:56:20+08:00">2025-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Dubbo/" itemprop="url" rel="index"><span itemprop="name">Dubbo</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>



<h2 id="接口扩展策略注解-SPI"><a href="#接口扩展策略注解-SPI" class="headerlink" title="接口扩展策略注解 @SPI"></a>接口扩展策略注解 @SPI</h2><p>Dubbo中的很多扩展接口，如 Protocol、Transporter、Filter 等，都是通过 JDK 的 SPI 机制实现的，也就是说这些功能都可被用户自定义的扩展所替换，接口扩展点由注解<code>@SPI</code>定义。<br>JDK 中 SPI（Service Provider Interface）的设计与策略模式如出一辙，开发者可以替换掉 Dubbo 原扩展接口的默认实现，完成自定义需求，即可以自定义实现策略。<br>Dubbo 在 JDK 现有 SPI 实现的基础上做了如下改进：</p>
<ol>
<li>JDK 标准的 SPI 会一次性实例化扩展点所有实现，如果有扩展实现初始化很耗时，但如果没用上也加载，会很浪费资源。</li>
<li>如果扩展点加载失败，连扩展点的名称都拿不到了。比如：JDK 标准的 ScriptEngine，通过 getName();获取脚本类型的名称，但如果 RubyScriptEngine 因为所依赖的 jruby.jar 不存在，导致 RubyScriptEngine 类加载失败，这个失败原因被吃掉了，和 ruby 对应不起来，当用户执行 ruby 脚本时，会报不支持 ruby，而不是真正失败的原因。</li>
<li>增加了对扩展点 IoC 和 AOP 的支持，一个扩展点可以直接 setter 注入其它扩展点。</li>
</ol>
<p>那么 Dubbo 的 SPI 机制是怎么实现的呢？以协议扩展为例，Dubbo 中协议被抽象为 Protocol 接口。</p>
<h3 id="读取扩展点"><a href="#读取扩展点" class="headerlink" title="读取扩展点"></a>读取扩展点</h3><p>ServiceConfig#protocol</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension()</span><br></pre></td></tr></table></figure>

<p>Dubbo 使用 ExtensionLoader 实现扩展点加载。</p>
<ul>
<li>ExtensionLoader#getExtensionLoader()<br>获取 ExtensionLoader 实现，保证每种扩展点一个单例。</li>
<li>ExtensionLoader#getAdaptiveExtension()<br>根据不同的 SPI 扩展点，即不同的 interface，生成不同的 Adaptive 实例的代码。<br>-&gt; getAdaptiveExtensionClass()<br>-&gt; getExtensionClasses()<br>-&gt; loadExtensionClasses()<br>加载所有的扩展点实现，直到扩展点方法执行时才决定调用是一个扩展点实现，即从众多的实现策略中决定具体使用哪一个策略。<br>ExtensionLoader 会依次从<code>META-INF/dubbo/internal</code>（Dubbo 内部实现）、<code>META-INF/dubbo/</code>（开发者自定义策略）、<code>META-INF/services/</code>这几个目录下读取扩展点实现，目录下的同名文件配置了对应扩展点的实现策略，调用 loadFile 来加载对应的扩展策略。<br>-&gt; loadFile(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, String dir)</li>
</ul>
<h3 id="生成-Adaptive-实例"><a href="#生成-Adaptive-实例" class="headerlink" title="生成 Adaptive 实例"></a>生成 Adaptive 实例</h3><ul>
<li>ExtensionLoader#loadFile<br>-&gt; String fileName &#x3D; dir + type.getName()<br>拼接文件路径<br>-&gt; ClassLoader classLoader &#x3D; findClassLoader()<br>拿到 ExtensionLoader 的类加载器。<br>-&gt; Class&lt;?&gt; clazz &#x3D; Class.forName(line, true, classLoader);<br>文件每行是一个实现类的全路径名，通过反射加载并拿到具体类型。<br>-&gt; extensionClasses.put(n, clazz)<br>添加到 map 里返回。</li>
<li>ExtensionLoader#cachedClasses<br>-&gt; cachedClasses.set(classes)<br>添加到缓存。</li>
<li>ExtensionLoader#createAdaptiveExtensionClass<br>-&gt; ExtensionLoader#createAdaptiveExtensionClassCode<br>生成 Adaptive 类。<br>-&gt; compiler &#x3D; ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.common.compiler.Compiler.class).getAdaptiveExtension()<br>拿到编译接口扩展点的一个具体实现，dubbo 内部支持 jdk 和 javassist，默认是 javassist。<br>-&gt; compiler.compile(code, classLoader)<br>编译代码，生成 Adaptive 实例类。</li>
</ul>
<p>上面提到 Compiler 也是一个扩展点，同样也依赖这个流程来实例化，在运行时生成 Adaptive 实例的时候，需要生成 Compiler 接口的 Adaptive 实例，即运行生成 Adaptive 实例的时候需要先有一个 Compiler 接口的 Adaptive 实例，那这样岂不是陷入了死循环，这里就要提到显示指定 Adaptive 实例的情况。<code>@Adaptive</code>注解支持类级别和方法级别：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、类级别：只能拥有一个，注解打在接口实现类上，显示的注册一个Adaptive实例，在编译期就存在，如`AdaptiveCompiler`，解决了上面的死循环问题，由`AdaptiveCompiler`依据dubbo配置决定使用哪个编译类；</span><br><span class="line">2、方法级别：在运行期动态的生成Adaptive实例。</span><br></pre></td></tr></table></figure>

<h3 id="通过-URL-动态选择协议"><a href="#通过-URL-动态选择协议" class="headerlink" title="通过 URL 动态选择协议"></a>通过 URL 动态选择协议</h3><p>ExtensionLoader#createAdaptiveExtensionClassCode<br>生成的 Protocol 的 Adaptive 实例类，依据 URL 中 protocol key-value 的值，选择对应的 Protocol 策略来暴露和引用服务。<br>扩展点方法调用会有 URL 参数（或是参数有 URL 成员），这样依赖的扩展点可以从 URL 拿到配置信息，所有的扩展点自己定好配置的 Key 后，配置信息从 URL 上从最外层传入，URL 在配置传递上即是一条总线。<br>以 dubbo+zookeeper 为例，暴露和引用远程服务都是注册在 zookeeper 上的，服务注册在 zookeeper 上本质其实是一个 URL，远程服务调用的过程中依据 URL 的 key-value 来动态决定执行 Protocol、Filter 等接口扩展点的执行策略。<br>下面是 Provider 端暴露 HelloService 服务时在 zookeeper 上注册的 URL，在 zookeeper 上的路径为&#x2F;dubbo&#x2F;com.dubbo.test.service.HelloService&#x2F;providers，URL 表示了采用 dubbo 协议，接口为 com.dubbo.test.service.HelloService，方法为 say，要执行的 Filter 为 whiteFilter 等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zk： localhost：2181(CONNECTED) 1] Is /dubbo/com.dubbo.test.service.HelloService/providers</span><br><span class="line">[dubbo://127.0.0.1:2O881/com.dubbo.test.service.HelloService?anyhost=true&amp;application=dubbo-test-service&amp;dubbo=2.4.10&amp;group=test-prod&amp;interface=com.dubbo.test.service.HelloService&amp;methods=say&amp;pid=21242&amp;revision=l.0&amp;service.filter=whiteFilter&amp;side=providerxtamp=1495436105078&amp;version=l.0]</span><br></pre></td></tr></table></figure>

<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><ul>
<li>volatile Class&lt;~&gt; cachedAdaptiveClass<br>这个是缓存 AdaptiveClass，如果一个扩展类的类上面带有 @Adaptive 注解，那么这个类就会被缓存在这个地方，每一种类型的扩展类只有一个 AdaptiveClass，如果发现有多个，则会报错。另外，当通过 getAdaptiveExtensionClass 来获取自适应扩展类时，如果当前还没有 AdaptiveClass，则会自动创建一个（动态生成 Java 代码，再编译，典型的比如 Protocol$Adaptive 就是这么生成的）</li>
<li>Set&lt;~&gt; cachedWrapperClasses<br>这个是缓存包装类的，Dubbo 判断一个扩展类是否是包装类比较简单，通过构造函数来判断，如果这个扩展类有一个构造函数，其中参数是当前扩展类的类型，那么就是包装类，举个例子，ProtocolFilterWrapper 就是 protocol 扩展类的包装类，因为有这个构造函数：<code>public ProtocolFilterWrapper(Protocol protocol)</code></li>
<li>Map&lt;~&gt; cachedActivates<br>这个是缓存激活的扩展类，当然，@Activate 注解还可以规定激活的条件和时机</li>
<li>Holder&lt;~&gt; cachedClasses<br>这个是缓存 Adaptive 和 Wrapper 扩展类之外的普通扩展类</li>
</ul>
<p>扩展类被加载后会根据一定的规则放入以上 4 个缓存中，比如带有 @Adaptive 注解的会被放入 cachedAdaptiveClass。</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/459b2cfd.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tallate">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tallate">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/459b2cfd.html" class="post-title-link" itemprop="url">Dubbo的网络通信</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-09-07 18:51:58" itemprop="dateCreated datePublished" datetime="2019-09-07T18:51:58+08:00">2019-09-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-07 01:56:20" itemprop="dateModified" datetime="2025-07-07T01:56:20+08:00">2025-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Dubbo/" itemprop="url" rel="index"><span itemprop="name">Dubbo</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>

<p>Dubbo 支持多种协议，如下图所示：<br><img src="/imgs/Dubbo/Protocol%E6%89%A9%E5%B1%95.png" alt="Protocol扩展" title="Protocol扩展"><br>在通信过程中，不同的服务等级一般对应着不同的服务质量，那么选择合适的协议便是一件非常重要的事情，需要根据应用的特征来选择。例如，使用 RMI 协议，一般会受到防火墙的限制，所以对于外部与内部进行通信的场景，就不要使用 RMI 协议，而是基于 HTTP 协议或者 Hessian 协议。</p>
<h3 id="Hessian-协议"><a href="#Hessian-协议" class="headerlink" title="Hessian 协议"></a>Hessian 协议</h3><ul>
<li>连接个数：多连接</li>
<li>连接方式：短连接</li>
<li>传输协议：HTTP</li>
<li>传输方式：同步传输</li>
<li>序列化：Hessian 二进制序列化</li>
<li>适用范围：传入传出参数数据包较大，提供者比消费者个数多，提供者压力较大，可传文件。</li>
<li>适用场景：页面传输，文件传输，Hessian 是 Caucho 开源的一个 RPC 框架，其通讯效率高于 WebService 和 Java 自带的序列化，Hessian 底层采用 Http 通讯，采用 Servlet 暴露服务，Dubbo 缺省内嵌 Jetty 作为服务器实现。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--定义 hessian 协议 --&gt;</span><br><span class="line">&lt;dubbo:protocol name=&quot;hessian&quot; port=&quot;8080&quot; server=&quot;jetty&quot; /&gt;</span><br><span class="line">&lt;!--设置默认协议 --&gt;</span><br><span class="line">&lt;dubbo:service protocol=&quot;hessian&quot; /&gt;</span><br><span class="line">&lt;!--设置 service 协议 --&gt;</span><br><span class="line">&lt;dubbo:service protocol=&quot;hessian&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.caucho&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;hessian&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.0.33&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="Http-协议"><a href="#Http-协议" class="headerlink" title="Http 协议"></a>Http 协议</h3><ul>
<li>连接个数：多连接</li>
<li>连接方式：短连接</li>
<li>传输协议：HTTP</li>
<li>传输方式：同步传输</li>
<li>序列化：表单序列化</li>
<li>适用范围：传入传出参数数据包大小混合，提供者比消费者个数多，可用浏览器查看，可用表单或 URL 传入参数，暂不支持传文件。</li>
<li>适用场景：需同时给应用程序和浏览器 JS 使用的服务。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--配置协议 --&gt;</span><br><span class="line">&lt;dubbo:protocol name=&quot;http&quot; port=&quot;8080&quot; /&gt;</span><br></pre></td></tr></table></figure>

<h3 id="Thrift-协议"><a href="#Thrift-协议" class="headerlink" title="Thrift 协议"></a>Thrift 协议</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.thrift&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;libthrift&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.8.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dubbo:protocol name=&quot;thrift&quot; port=&quot;3030&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>Dubbo 使用的 Thrift 和原生的 Thrift 协议不兼容，在原生协议的基础上添加了一些额外的头信息，比如 service name，magic number 等。</p>
<h3 id="Rest-协议"><a href="#Rest-协议" class="headerlink" title="Rest 协议"></a>Rest 协议</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 用rest协议在8080端口暴露服务 --&gt;</span><br><span class="line">&lt;dubbo:protocol name=&quot;rest&quot; port=&quot;8080&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 声明需要暴露的服务接口 --&gt;</span><br><span class="line">&lt;dubbo:service interface=&quot;com.service.OrderService&quot; ref=&quot;orderService&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 和本地bean一样实现服务 --&gt;</span><br><span class="line">&lt;bean id=&quot;orderService&quot; class=&quot;com.service.OrderServiceImpl&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>在代码中需要通过注解指定访问路径：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class OrderService &#123;    </span><br><span class="line">   void createOrder(Order order);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Path(&quot;orders&quot;) // 访问Url的相对路径</span><br><span class="line">public class OrderServiceImpl implements OrderService &#123;</span><br><span class="line"></span><br><span class="line">    @POST</span><br><span class="line">    @Path(&quot;create&quot;) // 访问Url的相对路径</span><br><span class="line">    // 将传递过来的JSON数据反序列化为Order对象</span><br><span class="line">    @Consumes(&#123;MediaType.APPLICATION_JSON&#125;) </span><br><span class="line">    public void createOrder(Order order) &#123;</span><br><span class="line">        // create the order...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="长连接-OR-短连接"><a href="#长连接-OR-短连接" class="headerlink" title="长连接 OR 短连接"></a>长连接 OR 短连接</h3><p>Dubbo 协议缺省每服务每提供者每消费者使用单一长连接，如果数据量较大，可以使用多个连接。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 表示该服务使用 JVM 共享长连接 --&gt;</span><br><span class="line">&lt;dubbo:service connections=&quot;0&quot;&gt; </span><br><span class="line">&lt;dubbo:reference connections=&quot;0&quot;&gt;</span><br><span class="line">&lt;!-- 表示该服务使用独立长连接 --&gt;</span><br><span class="line">&lt;dubbo:service connections=&quot;1&quot;&gt; </span><br><span class="line">&lt;dubbo:reference connections=&quot;1&quot;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="为什么要消费者比提供者个数多"><a href="#为什么要消费者比提供者个数多" class="headerlink" title="为什么要消费者比提供者个数多"></a>为什么要消费者比提供者个数多</h3><p>因为 dubbo 协议采用单一长连接，假设网络为千兆网卡 3，根据测试经验数据每条连接最多只能压满 7MByte（不同的环境可能不一样），理论上 1 个服务提供者需要 20 个服务消费者才能压满网卡。</p>
<h3 id="为什么不能传大包"><a href="#为什么不能传大包" class="headerlink" title="为什么不能传大包"></a>为什么不能传大包</h3><p>因 dubbo 协议采用单一长连接，如果每次请求的数据包大小为 500KByte，假设网络为千兆网卡 3，每条连接最大 7MByte(不同的环境可能不一样，供参考)，单个服务提供者的 TPS(每秒处理事务数)最大为：128MByte &#x2F; 500KByte &#x3D; 262。单个消费者调用单个服务提供者的 TPS(每秒处理事务数)最大为：7MByte &#x2F; 500KByte &#x3D; 14。如果能接受，可以考虑使用，否则网络将成为瓶颈。</p>
<h3 id="为什么采用异步单一长连接"><a href="#为什么采用异步单一长连接" class="headerlink" title="为什么采用异步单一长连接"></a>为什么采用异步单一长连接</h3><p>因为服务的现状大都是服务提供者少，通常只有几台机器，而服务的消费者多，可能整个网站都在访问该服务，比如 Morgan 的提供者只有 6 台提供者，却有上百台消费者，每天有 1.5 亿次调用，如果采用常规的 hessian 服务，服务提供者很容易就被压跨，通过单一连接，保证单一消费者不会压死提供者，长连接，减少连接握手验证等，并使用异步 IO，复用线程池，防止 C10K 问题（服务器无法服务 1w 左右的并发连接）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 配置协议端口和服务提供方最大连接数，防止服务被压垮 --&gt;</span><br><span class="line">&lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot; accepts=&quot;1000&quot; /&gt;</span><br><span class="line">&lt;!--配置dubbo默认协议 --&gt;</span><br><span class="line">&lt;dubbo:provider protocol=&quot;dubbo&quot; /&gt;</span><br><span class="line">&lt;!--配置dubbo设置服务协议 --&gt;</span><br><span class="line">&lt;dubbo:service protocol=&quot;dubbo&quot; /&gt;</span><br></pre></td></tr></table></figure>

<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/b13b8cb6.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tallate">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tallate">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/b13b8cb6.html" class="post-title-link" itemprop="url">Docker 与常用中间件</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-09-07 18:51:58" itemprop="dateCreated datePublished" datetime="2019-09-07T18:51:58+08:00">2019-09-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-07 01:56:20" itemprop="dateModified" datetime="2025-07-07T01:56:20+08:00">2025-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Docker/" itemprop="url" rel="index"><span itemprop="name">Docker</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>





<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h3><ol>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/30940981/zookeeper-error-cannot-open-channel-to-x-at-election-address">Zookeeper error: Cannot open channel to X at election address</a></li>
</ol>
<h3 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h3><ol>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docker.html">Install Elasticsearch with Docker</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/sbsujjbcy/article/details/52335325">记一次 Docker 下安装 Logstash+Elasticsearch+Kibana 经历</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/40341346/kibana-on-docker-cannot-connect-to-elasticsearch">Kibana on Docker cannot connect to Elasticsearch</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/aubin/p/8012840.html">Elasticsearch 集群部署</a></li>
</ol>
<h3 id="Docker-MySQL"><a href="#Docker-MySQL" class="headerlink" title="Docker MySQL"></a>Docker MySQL</h3><ol>
<li><a target="_blank" rel="noopener" href="https://hub.docker.com/_/mysql/">Docker MySQL</a></li>
</ol>
<h3 id="Docker-MySQL-双机热备实现"><a href="#Docker-MySQL-双机热备实现" class="headerlink" title="Docker MySQL 双机热备实现"></a>Docker MySQL 双机热备实现</h3><ol>
<li><a target="_blank" rel="noopener" href="https://github.com/Junnplus/blog/issues/1">Mysql Master&#x2F;Slave Replication With Docker</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/huaweitman/article/details/50853075">Mysql 双机热备实现</a></li>
<li><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/linux-installation-docker.html">2.5.6 Deploying MySQL on Linux with Docker</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/boling_cavalry/article/details/71055159">让 docker 中的 mysql 启动时自动执行 sql</a></li>
<li><a target="_blank" rel="noopener" href="https://www.2cto.com/database/201503/386265.html">MySQL 主从复制资料汇总</a></li>
</ol>
<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><ol>
<li><a target="_blank" rel="noopener" href="https://github.com/docker-library/docs/tree/master/redis">docker redis</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/docker-library/redis/blob/master/4.0/Dockerfile">redis&#x2F;4.0&#x2F;Dockerfile</a></li>
<li><a target="_blank" rel="noopener" href="https://yq.aliyun.com/articles/57953">使用Docker Compose部署基于Sentinel的高可用Redis集群</a></li>
</ol>
<h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><ol>
<li><a target="_blank" rel="noopener" href="https://hub.docker.com/_/rabbitmq/">docker rabbitmq</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/bijukunjummen/docker-rabbitmq-cluster">bijukunjummen&#x2F;docker-rabbitmq-cluster</a></li>
<li><a target="_blank" rel="noopener" href="http://www.dockone.io/article/829">RabbitMQ集群 Docker一键部署</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhangningkid/article/details/75258444">Docker中实现RabbitMQ集群</a></li>
</ol>
<h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><ol>
<li><a target="_blank" rel="noopener" href="https://hub.docker.com/r/library/nginx/">docker nginx</a></li>
<li><a target="_blank" rel="noopener" href="https://www.nginx.com/blog/docker-swarm-load-balancing-nginx-plus/">Docker Swarm Load Balancing with NGINX and NGINX Plus</a></li>
</ol>
<h3 id="Visualizer"><a href="#Visualizer" class="headerlink" title="Visualizer"></a>Visualizer</h3><ol>
<li><a target="_blank" rel="noopener" href="https://github.com/ManoMarks/docker-swarm-visualizer?hmsr=toutiao.io&utm_medium=toutiao.io&utm_source=toutiao.io">docker-swarm-visualizer</a></li>
</ol>
<h3 id="ZooKeeper-1"><a href="#ZooKeeper-1" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h3><ol>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000006907443">使用 Docker 一步搞定 ZooKeeper 集群的搭建</a></li>
</ol>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/11/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/page/13/">13</a><span class="space">&hellip;</span><a class="page-number" href="/page/19/">19</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/13/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">tallate</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/tallate" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"version":"7.1.2","options":null,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.3.0/mermaid.min.js","integrity":"sha256-9y71g5Lz/KLsHjB8uXwnkuWDtAMDSzD/HdIbqhJfTAI="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>





  





</body>
</html>
