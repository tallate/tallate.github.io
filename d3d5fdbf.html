<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"tallate.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.18.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="与 Jedis 的区别 Jedis 提供了对 Redis-API 的简单封装，使用 Jedis 时，需要关注 Redis 服务器的部署细节，而 Redisson 屏蔽了这些细节，使得使用者可以将精力更集中地放到自己希望实现的功能上。 Jedis 只提供简单的 API 调用，并不关注用户如何使用这些 API，比如 string 可以实现原子变量，不过需要用户手动封装，而 Redisson 中已经">
<meta property="og:type" content="article">
<meta property="og:title" content="Redisson">
<meta property="og:url" content="https://tallate.github.io/d3d5fdbf.html">
<meta property="og:site_name" content="Tallate">
<meta property="og:description" content="与 Jedis 的区别 Jedis 提供了对 Redis-API 的简单封装，使用 Jedis 时，需要关注 Redis 服务器的部署细节，而 Redisson 屏蔽了这些细节，使得使用者可以将精力更集中地放到自己希望实现的功能上。 Jedis 只提供简单的 API 调用，并不关注用户如何使用这些 API，比如 string 可以实现原子变量，不过需要用户手动封装，而 Redisson 中已经">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://tallate.github.io/imgs/Redis/%E7%BA%A2%E9%94%81-%E7%9C%8B%E9%97%A8%E7%8B%97.png">
<meta property="og:image" content="https://tallate.github.io/imgs/Redis/%E7%BA%A2%E9%94%81-%E5%8F%AF%E9%87%8D%E5%85%A5%E6%80%A7.png">
<meta property="article:published_time" content="2019-10-25T05:21:48.000Z">
<meta property="article:modified_time" content="2025-07-06T17:56:20.901Z">
<meta property="article:author" content="tallate">
<meta property="article:tag" content="Redis">
<meta property="article:tag" content="Redisson">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tallate.github.io/imgs/Redis/%E7%BA%A2%E9%94%81-%E7%9C%8B%E9%97%A8%E7%8B%97.png">


<link rel="canonical" href="https://tallate.github.io/d3d5fdbf.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://tallate.github.io/d3d5fdbf.html","path":"/d3d5fdbf.html","title":"Redisson"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Redisson | Tallate</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Tallate</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">该吃吃该喝喝 啥事别往心里搁</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签<span class="badge">80</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="th fa-fw"></i>分类<span class="badge">25</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档<span class="badge">187</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8E-Jedis-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.</span> <span class="nav-text">与 Jedis 的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Sentinel-%E6%A8%A1%E5%BC%8F%E8%8E%B7%E5%8F%96%E8%BF%9E%E6%8E%A5"><span class="nav-number">2.</span> <span class="nav-text">Sentinel 模式获取连接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Cluster-%E6%A8%A1%E5%BC%8F%E8%8E%B7%E5%8F%96%E8%BF%9E%E6%8E%A5"><span class="nav-number">3.</span> <span class="nav-text">Cluster 模式获取连接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-number">4.</span> <span class="nav-text">分布式锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-number">4.1.</span> <span class="nav-text">锁的特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%EF%BC%88Reentrant-Lock%EF%BC%89"><span class="nav-number">4.2.</span> <span class="nav-text">可重入锁（Reentrant Lock）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81%EF%BC%88Fair-Lock%EF%BC%89"><span class="nav-number">4.3.</span> <span class="nav-text">公平锁（Fair Lock）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%81%94%E9%94%81%EF%BC%88MultiLock%EF%BC%89"><span class="nav-number">4.4.</span> <span class="nav-text">联锁（MultiLock）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%A2%E9%94%81%EF%BC%88RedLock%EF%BC%89"><span class="nav-number">4.5.</span> <span class="nav-text">红锁（RedLock）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%A2%E9%94%81%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">4.5.1.</span> <span class="nav-text">红锁执行流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%81%E7%BB%AD%E6%9C%9F-%E7%9C%8B%E9%97%A8%E7%8B%97"><span class="nav-number">4.5.2.</span> <span class="nav-text">锁续期 - 看门狗</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E6%80%A7"><span class="nav-number">4.5.3.</span> <span class="nav-text">可重入性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%A2%E9%94%81%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">4.5.4.</span> <span class="nav-text">红锁存在的问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E9%94%81%EF%BC%88ReadWriteLock%EF%BC%89"><span class="nav-number">4.6.</span> <span class="nav-text">读写锁（ReadWriteLock）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%88Semaphore%EF%BC%89"><span class="nav-number">4.7.</span> <span class="nav-text">信号量（Semaphore）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E8%BF%87%E6%9C%9F%E6%80%A7%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%88PermitExpirableSemaphore%EF%BC%89"><span class="nav-number">4.8.</span> <span class="nav-text">可过期性信号量（PermitExpirableSemaphore）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AD%E9%94%81%EF%BC%88CountDownLatch%EF%BC%89"><span class="nav-number">4.9.</span> <span class="nav-text">闭锁（CountDownLatch）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E6%83%85%E5%86%B5%E5%88%86%E6%9E%90"><span class="nav-number">4.10.</span> <span class="nav-text">异常情况分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">5.</span> <span class="nav-text">参考</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">tallate</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">187</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">80</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/d3d5fdbf.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tallate">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Redisson | Tallate">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Redisson
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-10-25 13:21:48" itemprop="dateCreated datePublished" datetime="2019-10-25T13:21:48+08:00">2019-10-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-07 01:56:20" itemprop="dateModified" datetime="2025-07-07T01:56:20+08:00">2025-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%93%E5%AD%98/" itemprop="url" rel="index"><span itemprop="name">缓存</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><span id="more"></span>

<h2 id="与-Jedis-的区别"><a href="#与-Jedis-的区别" class="headerlink" title="与 Jedis 的区别"></a>与 Jedis 的区别</h2><ol>
<li>Jedis 提供了对 Redis-API 的简单封装，使用 Jedis 时，需要关注 Redis 服务器的部署细节，而 Redisson 屏蔽了这些细节，使得使用者可以将精力更集中地放到自己希望实现的功能上。</li>
<li>Jedis 只提供简单的 API 调用，并不关注用户如何使用这些 API，比如 string 可以实现原子变量，不过需要用户手动封装，而 Redisson 中已经有了现成的 AtomicLong。</li>
<li>Jedis 不支持 Cluster 环境下的事务、Lua</li>
</ol>
<h2 id="Sentinel-模式获取连接"><a href="#Sentinel-模式获取连接" class="headerlink" title="Sentinel 模式获取连接"></a>Sentinel 模式获取连接</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">public class RedissonSentinelConnectionTest &#123;</span><br><span class="line"></span><br><span class="line">    RedissonClient redisson;</span><br><span class="line">    RedisSentinelConnection connection;</span><br><span class="line">    RedisRunner.RedisProcess master;</span><br><span class="line">    RedisRunner.RedisProcess slave1;</span><br><span class="line">    RedisRunner.RedisProcess slave2;</span><br><span class="line">    RedisRunner.RedisProcess sentinel1;</span><br><span class="line">    RedisRunner.RedisProcess sentinel2;</span><br><span class="line">    RedisRunner.RedisProcess sentinel3;</span><br><span class="line"></span><br><span class="line">    @Before</span><br><span class="line">    public void before() throws FailedToStartRedisException, IOException, InterruptedException &#123;</span><br><span class="line">        master = new RedisRunner()</span><br><span class="line">                .nosave()</span><br><span class="line">                .randomDir()</span><br><span class="line">                .run();</span><br><span class="line">        slave1 = new RedisRunner()</span><br><span class="line">                .port(6380)</span><br><span class="line">                .nosave()</span><br><span class="line">                .randomDir()</span><br><span class="line">                .slaveof(&quot;127.0.0.1&quot;, 6379)</span><br><span class="line">                .run();</span><br><span class="line">        slave2 = new RedisRunner()</span><br><span class="line">                .port(6381)</span><br><span class="line">                .nosave()</span><br><span class="line">                .randomDir()</span><br><span class="line">                .slaveof(&quot;127.0.0.1&quot;, 6379)</span><br><span class="line">                .run();</span><br><span class="line">        sentinel1 = new RedisRunner()</span><br><span class="line">                .nosave()</span><br><span class="line">                .randomDir()</span><br><span class="line">                .port(26379)</span><br><span class="line">                .sentinel()</span><br><span class="line">                .sentinelMonitor(&quot;myMaster&quot;, &quot;127.0.0.1&quot;, 6379, 2)</span><br><span class="line">                .run();</span><br><span class="line">        sentinel2 = new RedisRunner()</span><br><span class="line">                .nosave()</span><br><span class="line">                .randomDir()</span><br><span class="line">                .port(26380)</span><br><span class="line">                .sentinel()</span><br><span class="line">                .sentinelMonitor(&quot;myMaster&quot;, &quot;127.0.0.1&quot;, 6379, 2)</span><br><span class="line">                .run();</span><br><span class="line">        sentinel3 = new RedisRunner()</span><br><span class="line">                .nosave()</span><br><span class="line">                .randomDir()</span><br><span class="line">                .port(26381)</span><br><span class="line">                .sentinel()</span><br><span class="line">                .sentinelMonitor(&quot;myMaster&quot;, &quot;127.0.0.1&quot;, 6379, 2)</span><br><span class="line">                .run();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(5000);</span><br><span class="line"></span><br><span class="line">        Config config = new Config();</span><br><span class="line">        config.useSentinelServers()</span><br><span class="line">                .setLoadBalancer(new RandomLoadBalancer())</span><br><span class="line">                .addSentinelAddress(sentinel3.getRedisServerAddressAndPort()).setMasterName(&quot;myMaster&quot;);</span><br><span class="line">        redisson = Redisson.create(config);</span><br><span class="line"></span><br><span class="line">        RedissonConnectionFactory factory = new RedissonConnectionFactory(redisson);</span><br><span class="line">        connection = factory.getSentinelConnection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @After</span><br><span class="line">    public void after() &#123;</span><br><span class="line">        sentinel1.stop();</span><br><span class="line">        sentinel2.stop();</span><br><span class="line">        sentinel3.stop();</span><br><span class="line">        master.stop();</span><br><span class="line">        slave1.stop();</span><br><span class="line">        slave2.stop();</span><br><span class="line"></span><br><span class="line">        redisson.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testMasters() &#123;</span><br><span class="line">        Collection&lt;RedisServer&gt; masters = connection.masters();</span><br><span class="line">        assertThat(masters).hasSize(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testSlaves() &#123;</span><br><span class="line">        Collection&lt;RedisServer&gt; masters = connection.masters();</span><br><span class="line">        Collection&lt;RedisServer&gt; slaves = connection.slaves(masters.iterator().next());</span><br><span class="line">        assertThat(slaves).hasSize(2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testRemove() &#123;</span><br><span class="line">        Collection&lt;RedisServer&gt; masters = connection.masters();</span><br><span class="line">        connection.remove(masters.iterator().next());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testMonitor() &#123;</span><br><span class="line">        Collection&lt;RedisServer&gt; masters = connection.masters();</span><br><span class="line">        RedisServer master = masters.iterator().next();</span><br><span class="line">        master.setName(master.getName() + &quot;:&quot;);</span><br><span class="line">        connection.monitor(master);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testFailover() throws InterruptedException &#123;</span><br><span class="line">        Collection&lt;RedisServer&gt; masters = connection.masters();</span><br><span class="line">        connection.failover(masters.iterator().next());</span><br><span class="line"></span><br><span class="line">        Thread.sleep(10000);</span><br><span class="line"></span><br><span class="line">        RedisServer newMaster = connection.masters().iterator().next();</span><br><span class="line">        assertThat(masters.iterator().next().getPort()).isNotEqualTo(newMaster.getPort());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>确定 Sentinel 集群内的所有节点地址<br>创建连接管理器（ConnectionManager）时读取所有 Master、Slave 和 Sentinel 节点的地址（org.redisson.connection.SentinelConnectionManager#SentinelConnectionManager）<br>Sentinel 通过监听 master 可以得到所有节点的地址。<br>可以从<code>SentinelConnectionManager</code>中看到，客户端会定时（默认1秒）地刷新服务端状态，即使集群暂时不可用，也可以通过这种刷新来恢复连接。</li>
<li>尝试连接一个 Sentinel<br>只要有一个 Sentinel 能通过 PING-PONG 校验，则返回对该 Sentinel 的连接。</li>
<li>执行操作<br>获取连接（org.redisson.command.RedisExecutor#getConnection）。<br>如果是只读的操作，会从 slave 中通过负载均衡选一个操作（org.redisson.connection.MasterSlaveConnectionManager#connectionReadOp）；<br>如果是非只读操作，从 master 里选一个操作（org.redisson.connection.ConnectionManager#connectionWriteOp）。</li>
</ol>
<h2 id="Cluster-模式获取连接"><a href="#Cluster-模式获取连接" class="headerlink" title="Cluster 模式获取连接"></a>Cluster 模式获取连接</h2><ol>
<li>添加节点初始化 Redisson<br>对于客户端来说，Cluster 模式可以看做几个 Master、Slave 的组合（org.redisson.ClusterRunner#addNode）。</li>
<li>连接时从节点中选一个<br>以Buckets.get操作为例，跟踪代码直到<code>CommandAsyncService#readAsync(String key, Codec codec, RedisCommand&lt;T&gt; command, Object ... params)</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public int calcSlot(String key) &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    // slot的计算方法，注意这里的MAX_SLOT是固定的</span><br><span class="line">    int result = CRC16.crc16(key.getBytes()) % MAX_SLOT;</span><br><span class="line">    log.debug(&quot;slot &#123;&#125; for &#123;&#125;&quot;, result, key);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private NodeSource getNodeSource(String key) &#123;</span><br><span class="line">    // 计算该key属于哪个slot</span><br><span class="line">    int slot = connectionManager.calcSlot(key);</span><br><span class="line">    // 计算该slot属于哪个节点</span><br><span class="line">    MasterSlaveEntry entry = connectionManager.getEntry(slot);</span><br><span class="line">    return new NodeSource(entry);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public &lt;T, R&gt; RFuture&lt;R&gt; readAsync(String key, Codec codec, RedisCommand&lt;T&gt; command, Object... params) &#123;</span><br><span class="line">    RPromise&lt;R&gt; mainPromise = connectionManager.newPromise();</span><br><span class="line">    // 获取key所在的节点</span><br><span class="line">    NodeSource source = getNodeSource(key);</span><br><span class="line">    async(true, source, codec, command, params, mainPromise, 0);</span><br><span class="line">    return mainPromise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
先计算 key 属于哪个 slot（org.redisson.cluster.ClusterConnectionManager#calcSlot）；<br>再由 slot 计算应该请求哪对主从（org.redisson.connection.MasterSlaveConnectionManager#getEntry）。</li>
<li>重连<br>Redisson启动后会创建一个定时任务每5秒更新一次节点状态，所以就算节点挂掉了，之后重启时客户端是可以感知到服务器的启动的。<br><code>org.redisson.cluster.ClusterConnectionManager#scheduleClusterChangeCheck</code></li>
</ol>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>文档：<a target="_blank" rel="noopener" href="https://github.com/redisson/redisson/wiki/8.-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%92%8C%E5%90%8C%E6%AD%A5%E5%99%A8">8. 分布式锁和同步器</a><br>下面记录一下 Redisson 中对应功能所在的代码位置和基本思路。</p>
<h3 id="锁的特性"><a href="#锁的特性" class="headerlink" title="锁的特性"></a>锁的特性</h3><ul>
<li>互斥性<br>任意时刻，只会有一个客户端持有锁</li>
<li>不会发生死锁<br>即使客户端在持有锁期间崩溃而没有释放锁，也能保证其他客户端能获取到锁。</li>
<li>容错性<br>锁服务的某个节点不可用时，客户端还能继续加解锁。</li>
<li>可重入性<br>一个客户端可以重复加锁，期间其他客户端无法获取这个锁。</li>
</ul>
<h3 id="可重入锁（Reentrant-Lock）"><a href="#可重入锁（Reentrant-Lock）" class="headerlink" title="可重入锁（Reentrant Lock）"></a>可重入锁（Reentrant Lock）</h3><p>测试代码见：<code>org.redisson.RedissonLockTest#testGetHoldCount</code><br>源码主要为：<code>org.redisson.RedissonLock</code></p>
<p><strong>可重入性</strong>是通过加锁时传的 threadId 实现的，下面是 Redisson 中用于加锁的 lua 脚本（<code>org.redisson.RedissonLock#tryLockInnerAsync</code>）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">-- KEYS[1]: RedissonObject中的name字段，这里表示锁的名字</span><br><span class="line">-- ARGV[1]: leaseTime，过期时间，这里为30000</span><br><span class="line">-- ARGV[2]: 锁的value，这里为threadId</span><br><span class="line"></span><br><span class="line">-- 未加过锁的情况</span><br><span class="line">&quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then &quot; +</span><br><span class="line">    &quot;redis.call(&#x27;hset&#x27;, KEYS[1], ARGV[2], 1); &quot; +</span><br><span class="line">    &quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot; +</span><br><span class="line">    &quot;return nil; &quot; +</span><br><span class="line">&quot;end; &quot; +</span><br><span class="line">-- 当前线程已加过锁的情况</span><br><span class="line">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot; +</span><br><span class="line">    &quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot; +</span><br><span class="line">    &quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot; +</span><br><span class="line">    &quot;return nil; &quot; +</span><br><span class="line">&quot;end; &quot; +</span><br><span class="line">-- 其他线程加过锁的情况</span><br><span class="line">&quot;return redis.call(&#x27;pttl&#x27;, KEYS[1]);&quot;</span><br></pre></td></tr></table></figure>
<p>所有锁都保存在一个 key 为 lock 的 hash 对象下，第一次加锁时保存的结果为<code>&lt;lock, &#123;threadId&#125;, 1&gt;</code>，过期时间为 30s，同一线程第二次加锁时，更新为<code>&lt;lock, &#123;threadId&#125;, 2&gt;</code>，且过期时间被刷新。<br>当加锁成功时（包括同一线程调用重入多次）返回 null，而加锁失败时，返回锁的剩余过期时间，<strong>根据返回值是否为空可以判断加锁是否成功</strong>，当还未获取到锁时，客户端会轮询检查（<code>org.redisson.RedissonLock#lock(long leaseTime, TimeUnit unit, boolean interruptibly)</code>中的 while 循环），也就是说这种加锁方式并<strong>不是公平的</strong>。<br><strong>加锁监控</strong>保证了当业务执行时间超过加锁时间时，不会因为锁过期而让其他线程进入临界区，在 Redisson 中是通过一个 TimerTask 每隔 10s（即加锁时间 &#x2F; 3）刷新一次锁的过期时间来实现的（<code>org.redisson.RedissonLock#renewExpiration</code>）。</p>
<p>另外，由于加锁时保存了 threadId，<strong>unlock</strong>时同样会传 threadId、只能释放当前线程加上的锁，下面是用于释放锁的 lua 脚本（<code>org.redisson.RedissonLock#unlockInnerAsync</code>）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">-- KEYS[1]: &#123;lockName&#125;</span><br><span class="line">-- KEYS[2]: </span><br><span class="line">-- ARGS[1]: UNLOCK_MESSAGE</span><br><span class="line">-- ARGS[2]: 加锁时间，默认30s</span><br><span class="line">-- ARGS[3]: &#123;threadId&#125;</span><br><span class="line"></span><br><span class="line">-- 检查当前线程是否有加该锁</span><br><span class="line">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[3]) == 0) then &quot; +</span><br><span class="line">    &quot;return nil;&quot; +</span><br><span class="line">&quot;end; &quot; +</span><br><span class="line">-- 计数器-1</span><br><span class="line">&quot;local counter = redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[3], -1); &quot; +</span><br><span class="line">-- 如果计数器未减完，说明重入了多次，且这里刷新了一次过期时间</span><br><span class="line">&quot;if (counter &gt; 0) then &quot; +</span><br><span class="line">    &quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[2]); &quot; +</span><br><span class="line">    &quot;return 0; &quot; +</span><br><span class="line">-- 计数器减完，删除该锁，并通知其他正在等待的线程</span><br><span class="line">&quot;else &quot; +</span><br><span class="line">    &quot;redis.call(&#x27;del&#x27;, KEYS[1]); &quot; +</span><br><span class="line">    &quot;redis.call(&#x27;publish&#x27;, KEYS[2], ARGV[1]); &quot; +</span><br><span class="line">    &quot;return 1; &quot;+</span><br><span class="line">&quot;end; &quot; +</span><br><span class="line">&quot;return nil;&quot;</span><br></pre></td></tr></table></figure>

<h3 id="公平锁（Fair-Lock）"><a href="#公平锁（Fair-Lock）" class="headerlink" title="公平锁（Fair Lock）"></a>公平锁（Fair Lock）</h3><p>测试代码见：<code>org.redisson.RedissonFairLockTest#testIsLockedOtherThread</code><br>源码主要为：<code>org.redisson.RedissonFairLock</code></p>
<p><strong>公平性</strong>是通过队列实现的，（<code>org.redisson.RedissonFairLock#tryLockInnerAsync</code>）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">// remove stale threads</span><br><span class="line">&quot;while true do &quot; +</span><br><span class="line">    &quot;local firstThreadId2 = redis.call(&#x27;lindex&#x27;, KEYS[2], 0);&quot; +</span><br><span class="line">    &quot;if firstThreadId2 == false then &quot; +</span><br><span class="line">        &quot;break;&quot; +</span><br><span class="line">    &quot;end;&quot; +</span><br><span class="line"></span><br><span class="line">    &quot;local timeout = tonumber(redis.call(&#x27;zscore&#x27;, KEYS[3], firstThreadId2));&quot; +</span><br><span class="line">    &quot;if timeout &lt;= tonumber(ARGV[4]) then &quot; +</span><br><span class="line">        // remove the item from the queue and timeout set</span><br><span class="line">        // NOTE we do not alter any other timeout</span><br><span class="line">        &quot;redis.call(&#x27;zrem&#x27;, KEYS[3], firstThreadId2);&quot; +</span><br><span class="line">        &quot;redis.call(&#x27;lpop&#x27;, KEYS[2]);&quot; +</span><br><span class="line">    &quot;else &quot; +</span><br><span class="line">        &quot;break;&quot; +</span><br><span class="line">    &quot;end;&quot; +</span><br><span class="line">&quot;end;&quot; +</span><br><span class="line"></span><br><span class="line">// check if the lock can be acquired now</span><br><span class="line">&quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) &quot; +</span><br><span class="line">    &quot;and ((redis.call(&#x27;exists&#x27;, KEYS[2]) == 0) &quot; +</span><br><span class="line">        &quot;or (redis.call(&#x27;lindex&#x27;, KEYS[2], 0) == ARGV[2])) then &quot; +</span><br><span class="line"></span><br><span class="line">    // remove this thread from the queue and timeout set</span><br><span class="line">    &quot;redis.call(&#x27;lpop&#x27;, KEYS[2]);&quot; +</span><br><span class="line">    &quot;redis.call(&#x27;zrem&#x27;, KEYS[3], ARGV[2]);&quot; +</span><br><span class="line"></span><br><span class="line">    // decrease timeouts for all waiting in the queue</span><br><span class="line">    &quot;local keys = redis.call(&#x27;zrange&#x27;, KEYS[3], 0, -1);&quot; +</span><br><span class="line">    &quot;for i = 1, #keys, 1 do &quot; +</span><br><span class="line">        &quot;redis.call(&#x27;zincrby&#x27;, KEYS[3], -tonumber(ARGV[3]), keys[i]);&quot; +</span><br><span class="line">    &quot;end;&quot; +</span><br><span class="line"></span><br><span class="line">    // acquire the lock and set the TTL for the lease</span><br><span class="line">    &quot;redis.call(&#x27;hset&#x27;, KEYS[1], ARGV[2], 1);&quot; +</span><br><span class="line">    &quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]);&quot; +</span><br><span class="line">    &quot;return nil;&quot; +</span><br><span class="line">&quot;end;&quot; +</span><br><span class="line"></span><br><span class="line">// check if the lock is already held, and this is a re-entry</span><br><span class="line">&quot;if redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1 then &quot; +</span><br><span class="line">    &quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2],1);&quot; +</span><br><span class="line">    &quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]);&quot; +</span><br><span class="line">    &quot;return nil;&quot; +</span><br><span class="line">&quot;end;&quot; +</span><br><span class="line"></span><br><span class="line">// the lock cannot be acquired</span><br><span class="line">// check if the thread is already in the queue</span><br><span class="line">&quot;local timeout = redis.call(&#x27;zscore&#x27;, KEYS[3], ARGV[2]);&quot; +</span><br><span class="line">&quot;if timeout ~= false then &quot; +</span><br><span class="line">    // the real timeout is the timeout of the prior thread</span><br><span class="line">    // in the queue, but this is approximately correct, and</span><br><span class="line">    // avoids having to traverse the queue</span><br><span class="line">    &quot;return timeout - tonumber(ARGV[3]) - tonumber(ARGV[4]);&quot; +</span><br><span class="line">&quot;end;&quot; +</span><br><span class="line"></span><br><span class="line">// add the thread to the queue at the end, and set its timeout in the timeout set to the timeout of</span><br><span class="line">// the prior thread in the queue (or the timeout of the lock if the queue is empty) plus the</span><br><span class="line">// threadWaitTime</span><br><span class="line">&quot;local lastThreadId = redis.call(&#x27;lindex&#x27;, KEYS[2], -1);&quot; +</span><br><span class="line">&quot;local ttl;&quot; +</span><br><span class="line">&quot;if lastThreadId ~= false and lastThreadId ~= ARGV[2] then &quot; +</span><br><span class="line">    &quot;ttl = tonumber(redis.call(&#x27;zscore&#x27;, KEYS[3], lastThreadId)) - tonumber(ARGV[4]);&quot; +</span><br><span class="line">&quot;else &quot; +</span><br><span class="line">    &quot;ttl = redis.call(&#x27;pttl&#x27;, KEYS[1]);&quot; +</span><br><span class="line">&quot;end;&quot; +</span><br><span class="line">&quot;local timeout = ttl + tonumber(ARGV[3]) + tonumber(ARGV[4]);&quot; +</span><br><span class="line">&quot;if redis.call(&#x27;zadd&#x27;, KEYS[3], timeout, ARGV[2]) == 1 then &quot; +</span><br><span class="line">    &quot;redis.call(&#x27;rpush&#x27;, KEYS[2], ARGV[2]);&quot; +</span><br><span class="line">&quot;end;&quot; +</span><br><span class="line">&quot;return ttl;&quot;</span><br></pre></td></tr></table></figure>

<h3 id="联锁（MultiLock）"><a href="#联锁（MultiLock）" class="headerlink" title="联锁（MultiLock）"></a>联锁（MultiLock）</h3><p>源码位置：<code>org.redisson.RedissonMultiLock</code></p>
<p>联锁是对批量加锁的封装，其关键是如何实现<strong>死锁避免</strong>，其中的关键代码如下（<code>org.redisson.RedissonMultiLock#tryLock(long waitTime, long leaseTime, TimeUnit unit)</code>）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 将已经获取的锁释放掉</span><br><span class="line">unlockInner(acquiredLocks);</span><br><span class="line">if (waitTime == -1) &#123;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">failedLocksLimit = failedLocksLimit();</span><br><span class="line">acquiredLocks.clear();</span><br><span class="line">// 重置iterator，重新加一遍锁</span><br><span class="line">while (iterator.hasPrevious()) &#123;</span><br><span class="line">    iterator.previous();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="红锁（RedLock）"><a href="#红锁（RedLock）" class="headerlink" title="红锁（RedLock）"></a>红锁（RedLock）</h3><p>测试代码：<code>org.redisson.RedissonRedLockTest#testLockLeasetime</code><br>源码位置：<code>org.redisson.RedissonRedLock</code></p>
<p>红锁实际上是联锁的子类，原理基本一致，它和联锁的区别主要是：</p>
<ul>
<li>联锁不允许加锁失败（<code>org.redisson.RedissonMultiLock#failedLocksLimit</code>），而红锁允许少于半数次的加锁失败（<code>org.redisson.RedissonRedLock#failedLocksLimit</code>）。</li>
<li>使用时，红锁的加锁目标最好包含多个 Redis 实例，从而实现高可用。<blockquote>
<p>如果一个Redis实例加多次锁，那么这个Redis挂掉了就会导致全部加锁请求都失败了。</p>
</blockquote>
</li>
</ul>
<h4 id="红锁执行流程"><a href="#红锁执行流程" class="headerlink" title="红锁执行流程"></a>红锁执行流程</h4><ol>
<li>获取当前时间戳；</li>
<li>开始获取锁：Client按顺序从每台Redis实例上获取锁；<br>注意每台服务器都有一个获取的截止时间，超过一段时间获取不到就放弃，而且这个截止时间要比总的获取锁的TTL时间要短很多，避免由于等待部分已停机的Redis实例时间过长而导致获取锁失败了。<br>比如总TTL为5s，那么每台Redis实例的获取时间就可以定为1s。<br>因为是顺序获取的，所以每台实例上锁的过期时间也是不一样的。</li>
<li>怎么样算获取成功：过半数，且未超时<ul>
<li>过半数：比如总共有5个Redis实例的情况下，需要有至少3个实例成功获取到锁才算获取成功；</li>
<li>未超时：(总TTL) - (每台服务器获取锁花费的时间之和)需要大于0，如果获取成功，锁的真正有效时间就是这个时间差。</li>
</ul>
</li>
<li>获取失败释放锁<br>不满足获取成功条件的情况下，把之前获取过锁的Redis实例都给释放掉。</li>
</ol>
<h4 id="锁续期-看门狗"><a href="#锁续期-看门狗" class="headerlink" title="锁续期 - 看门狗"></a>锁续期 - 看门狗</h4><p>看门狗原理，下图来自于<a target="_blank" rel="noopener" href="https://www.cnblogs.com/wang-meng/p/12525029.html">这里</a><br><img src="/imgs/Redis/%E7%BA%A2%E9%94%81-%E7%9C%8B%E9%97%A8%E7%8B%97.png" alt="红锁-看门狗" title="红锁-看门狗"><br>加锁时启动定时任务刷新锁的过期时间：<br>org.redisson.RedissonLock#tryAcquireOnceAsync<br>-&gt; org.redisson.RedissonLock#scheduleExpirationRenewal<br>释放锁时关掉该定时任务：<br>org.redisson.RedissonLock#unlock<br>-&gt; org.redisson.RedissonLock#cancelExpirationRenewal</p>
<h4 id="可重入性"><a href="#可重入性" class="headerlink" title="可重入性"></a>可重入性</h4><p>可重入性原理，下图来自于<a target="_blank" rel="noopener" href="https://www.cnblogs.com/wang-meng/p/12525029.html">这里</a><br><img src="/imgs/Redis/%E7%BA%A2%E9%94%81-%E5%8F%AF%E9%87%8D%E5%85%A5%E6%80%A7.png" alt="红锁-可重入性" title="红锁-可重入性"></p>
<h4 id="红锁存在的问题"><a href="#红锁存在的问题" class="headerlink" title="红锁存在的问题"></a>红锁存在的问题</h4><ol>
<li>一般Redis集群都是多主多从，但是使用多主多从的情况下，锁是加到主服务器上的，而主从复制是异步完成的，如果在客户端获取到锁之后，主复制锁到从的过程中崩溃了，导致没有复制到从Redis中，那么之后即使再选举出一个从升级为主，主服务器里也是没有锁的，并且能够成功被获取到锁，导致互斥失效。<br><strong>所以，使用红锁时Redis集群一般都是单节点，而不是主从的。</strong></li>
<li>5主无从的情况下，如果一个客户端获取到锁之后，所有Redis重启，这时其他客户端又可以获取到锁了，显然违背了锁的互斥原则；如果Redis实例开启了AOF持久化存储，在持久化间隔时间内断电，照样会导致数据丢失。<blockquote>
<p>显然AOF不能开启Always（每个命令都同步到硬盘），这样会造成性能急剧下降。</p>
</blockquote>
</li>
</ol>
<h3 id="读写锁（ReadWriteLock）"><a href="#读写锁（ReadWriteLock）" class="headerlink" title="读写锁（ReadWriteLock）"></a>读写锁（ReadWriteLock）</h3><p>TODO</p>
<h3 id="信号量（Semaphore）"><a href="#信号量（Semaphore）" class="headerlink" title="信号量（Semaphore）"></a>信号量（Semaphore）</h3><p>TODO</p>
<h3 id="可过期性信号量（PermitExpirableSemaphore）"><a href="#可过期性信号量（PermitExpirableSemaphore）" class="headerlink" title="可过期性信号量（PermitExpirableSemaphore）"></a>可过期性信号量（PermitExpirableSemaphore）</h3><p>TODO</p>
<h3 id="闭锁（CountDownLatch）"><a href="#闭锁（CountDownLatch）" class="headerlink" title="闭锁（CountDownLatch）"></a>闭锁（CountDownLatch）</h3><p>TODO</p>
<h3 id="异常情况分析"><a href="#异常情况分析" class="headerlink" title="异常情况分析"></a>异常情况分析</h3><ul>
<li>因为主从同步导致锁被重复获取<br>Redis集群如果采用Cluster集群或Master-Slave主从复制的方式，就会存在key刚写完Master、但是在同步到Slave之前Master挂掉的情况，这时如果发生主从切换，就有可能会出现多个线程同时持有锁的情况。</li>
<li>因为GC导致锁被重复获取<br>如果出现GC停顿时间过长，或者其他情况导致客户端和Redis连接断开，也有可能出现多个线程同时持有一个锁的情况。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/rgcLOVEyaya/p/RGC_LOVE_YAYA_1003days.html">Redlock（redis分布式锁）原理分析</a></li>
</ol>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">
    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Redis/" rel="tag"># Redis</a>
              <a href="/tags/Redisson/" rel="tag"># Redisson</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/58b05574.html" rel="prev" title="Lettuce和Jedis">
                  <i class="fa fa-angle-left"></i> Lettuce和Jedis
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/6ce879b3.html" rel="next" title="规则引擎">
                  规则引擎 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">tallate</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/tallate" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"version":"7.1.2","options":null,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.3.0/mermaid.min.js","integrity":"sha256-9y71g5Lz/KLsHjB8uXwnkuWDtAMDSzD/HdIbqhJfTAI="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>





  





</body>
</html>
