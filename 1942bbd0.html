<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"tallate.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.18.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="缓存系统如何工作缓存的两个特征 在一个层次化的系统中，缓存一定是一个快速子系统，数据存在缓存中时，能避免每次从慢速子系统中存取数据。对应到互联网应用来说，Redis 就是快速子系统，而数据库就是慢速子系统了。 缓存系统的容量大小总是小于后端慢速系统的，我们不可能把所有数据都放在缓存系统中。  Redis作为旁路缓存作为缓存，我们在访问数据时可能会：  命中：直接将缓存中的数据返回； miss：">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis作为缓存系统">
<meta property="og:url" content="https://tallate.github.io/1942bbd0.html">
<meta property="og:site_name" content="Tallate">
<meta property="og:description" content="缓存系统如何工作缓存的两个特征 在一个层次化的系统中，缓存一定是一个快速子系统，数据存在缓存中时，能避免每次从慢速子系统中存取数据。对应到互联网应用来说，Redis 就是快速子系统，而数据库就是慢速子系统了。 缓存系统的容量大小总是小于后端慢速系统的，我们不可能把所有数据都放在缓存系统中。  Redis作为旁路缓存作为缓存，我们在访问数据时可能会：  命中：直接将缓存中的数据返回； miss：">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://tallate.github.io/imgs/Redis/Redis-LRU%E7%AE%97%E6%B3%95.png">
<meta property="og:image" content="https://tallate.github.io/imgs/Redis/%E6%97%81%E8%B7%AF%E7%BC%93%E5%AD%98%E7%9A%84%E9%9B%AA%E5%B4%A9%E3%80%81%E5%87%BB%E7%A9%BF%E3%80%81%E7%A9%BF%E9%80%8F%E9%97%AE%E9%A2%98.jpg">
<meta property="og:image" content="https://tallate.github.io/imgs/Redis/%E6%97%81%E8%B7%AF%E7%BC%93%E5%AD%98%E7%9A%84%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98.jpg">
<meta property="article:published_time" content="2020-11-09T14:42:14.000Z">
<meta property="article:modified_time" content="2025-07-06T17:56:20.901Z">
<meta property="article:author" content="tallate">
<meta property="article:tag" content="缓存系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tallate.github.io/imgs/Redis/Redis-LRU%E7%AE%97%E6%B3%95.png">


<link rel="canonical" href="https://tallate.github.io/1942bbd0.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://tallate.github.io/1942bbd0.html","path":"/1942bbd0.html","title":"Redis作为缓存系统"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Redis作为缓存系统 | Tallate</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Tallate</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">该吃吃该喝喝 啥事别往心里搁</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签<span class="badge">84</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="th fa-fw"></i>分类<span class="badge">25</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档<span class="badge">192</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C"><span class="nav-number">1.</span> <span class="nav-text">缓存系统如何工作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E7%9A%84%E4%B8%A4%E4%B8%AA%E7%89%B9%E5%BE%81"><span class="nav-number">1.1.</span> <span class="nav-text">缓存的两个特征</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E4%BD%9C%E4%B8%BA%E6%97%81%E8%B7%AF%E7%BC%93%E5%AD%98"><span class="nav-number">1.2.</span> <span class="nav-text">Redis作为旁路缓存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-%E5%8A%A0%E5%85%A5%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.3.</span> <span class="nav-text">Redis 加入秒杀系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E7%89%B9%E7%82%B9"><span class="nav-number">1.3.1.</span> <span class="nav-text">秒杀系统特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A7%92%E6%9D%80%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86"><span class="nav-number">1.3.2.</span> <span class="nav-text">秒杀流程梳理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E6%BB%A1%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="nav-number">2.</span> <span class="nav-text">缓存满了怎么办？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%EF%BC%88%E7%BC%93%E5%AD%98%E5%A4%B1%E6%95%88%E7%AD%96%E7%95%A5%E5%92%8C%E4%B8%BB%E9%94%AE%E5%A4%B1%E6%95%88%E6%9C%BA%E5%88%B6%EF%BC%89"><span class="nav-number">2.1.</span> <span class="nav-text">缓存淘汰（缓存失效策略和主键失效机制）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#key-%E7%9A%84%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%E6%8E%A7%E5%88%B6"><span class="nav-number">2.1.1.</span> <span class="nav-text">key 的过期时间控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#key-%E7%9A%84%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5"><span class="nav-number">2.1.2.</span> <span class="nav-text">key 的删除策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="nav-number">2.1.3.</span> <span class="nav-text">Redis 的数据淘汰策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="nav-number">2.1.4.</span> <span class="nav-text">自定义缓存淘汰策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.1.5.</span> <span class="nav-text">缓存淘汰的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-%E4%B8%AD%E7%9A%84-LRU-%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.1.6.</span> <span class="nav-text">Redis 中的 LRU 实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">3.</span> <span class="nav-text">缓存系统中存在的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="nav-number">3.1.</span> <span class="nav-text">缓存穿透</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="nav-number">3.2.</span> <span class="nav-text">缓存雪崩</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD"><span class="nav-number">3.3.</span> <span class="nav-text">缓存预热</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98"><span class="nav-number">3.4.</span> <span class="nav-text">缓存和数据库双写一致性问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%88%E5%A4%B1%E6%95%88%E7%BC%93%E5%AD%98-%E5%90%8E%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE"><span class="nav-number">3.4.1.</span> <span class="nav-text">先失效缓存 -&gt; 后更新数据库数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BB%B6%E6%97%B6%E5%8F%8C%E5%88%A0"><span class="nav-number">3.4.2.</span> <span class="nav-text">延时双删</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE-%E5%90%8E%E5%A4%B1%E6%95%88%E7%BC%93%E5%AD%98"><span class="nav-number">3.4.3.</span> <span class="nav-text">先更新数据库数据 -&gt; 后失效缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE-%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98"><span class="nav-number">3.4.4.</span> <span class="nav-text">更新数据库数据 -&gt; 更新缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98-%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE"><span class="nav-number">3.4.5.</span> <span class="nav-text">更新缓存 -&gt; 更新数据库数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE-%E5%AE%9A%E6%97%B6%E5%90%8C%E6%AD%A5%E5%88%B0%E7%BC%93%E5%AD%98"><span class="nav-number">3.4.6.</span> <span class="nav-text">更新数据库数据 -&gt; 定时同步到缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E6%80%BB%E7%BB%93"><span class="nav-number">3.4.7.</span> <span class="nav-text">缓存更新总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3-redis-%E7%9A%84%E5%B9%B6%E5%8F%91%E7%AB%9E%E4%BA%89-key-%E9%97%AE%E9%A2%98"><span class="nav-number">3.5.</span> <span class="nav-text">如何解决 redis 的并发竞争 key 问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E9%99%8D%E7%BA%A7"><span class="nav-number">3.6.</span> <span class="nav-text">缓存降级</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E6%B1%A1%E6%9F%93"><span class="nav-number">3.7.</span> <span class="nav-text">缓存污染</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB"><span class="nav-number">4.</span> <span class="nav-text">缓存数据迁移</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">tallate</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">192</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">84</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/1942bbd0.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tallate">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Redis作为缓存系统 | Tallate">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Redis作为缓存系统
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-11-09 22:42:14" itemprop="dateCreated datePublished" datetime="2020-11-09T22:42:14+08:00">2020-11-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-07 01:56:20" itemprop="dateModified" datetime="2025-07-07T01:56:20+08:00">2025-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%93%E5%AD%98/" itemprop="url" rel="index"><span itemprop="name">缓存</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><span id="more"></span>

<h1 id="缓存系统如何工作"><a href="#缓存系统如何工作" class="headerlink" title="缓存系统如何工作"></a>缓存系统如何工作</h1><h2 id="缓存的两个特征"><a href="#缓存的两个特征" class="headerlink" title="缓存的两个特征"></a>缓存的两个特征</h2><ol>
<li>在一个层次化的系统中，缓存一定是一个快速子系统，数据存在缓存中时，能避免每次从慢速子系统中存取数据。对应到互联网应用来说，Redis 就是快速子系统，而数据库就是慢速子系统了。</li>
<li>缓存系统的容量大小总是小于后端慢速系统的，我们不可能把所有数据都放在缓存系统中。</li>
</ol>
<h2 id="Redis作为旁路缓存"><a href="#Redis作为旁路缓存" class="headerlink" title="Redis作为旁路缓存"></a>Redis作为旁路缓存</h2><p>作为缓存，我们在访问数据时可能会：</p>
<ul>
<li>命中：直接将缓存中的数据返回；</li>
<li>miss：缓存缺失，回源到MySQL读取数据，加载到缓存中；</li>
</ul>
<p>这种情况下，Redis就作为旁路缓存使用，读取缓存、读取数据库和更新缓存的操作都需要在应用程序中来完成。</p>
<ul>
<li>如果是只读缓存，那么上述的旁路缓存设计就足够了；</li>
<li>如果是读写缓存，还有同步直写（写缓存的同时写DB）和异步写回（写缓存后异步写DB）这两种策略，各有优缺点。<br>同步直写效率低，但是一致性高；<br>异步写回效率高，但是一致性低。</li>
</ul>
<h2 id="Redis-加入秒杀系统"><a href="#Redis-加入秒杀系统" class="headerlink" title="Redis 加入秒杀系统"></a>Redis 加入秒杀系统</h2><h3 id="秒杀系统特点"><a href="#秒杀系统特点" class="headerlink" title="秒杀系统特点"></a>秒杀系统特点</h3><ol>
<li>瞬时并发量非常高<br>一般数据库并发能力是千级别，而Redis的并发能力是万级别甚至更高（加入Cluster以后会更高）。<br>所以Redis在秒杀系统中的主要作用就是拦截大部分的流量。</li>
<li>读多写少<br>用户秒杀下单前需要先检查商品是否还有库存，查询库存其实就是简单的键值对查询，而Redis最擅长的就是键值对的存储。</li>
</ol>
<h3 id="秒杀流程梳理"><a href="#秒杀流程梳理" class="headerlink" title="秒杀流程梳理"></a>秒杀流程梳理</h3><p>上面提到Redis的高并发、数据结构特性使得它很适合秒杀场景，但是具体是哪些功能会用到Redis呢？</p>
<ol>
<li>秒杀活动前<br>秒杀活动前的一段时间，用户会不断地刷新商品详情页，这个阶段一般会尽量把商品详情页的页面元素静态化，然后使用CDN或是浏览器把这些静态化元素缓存起来。<br>这个阶段已经有CDN和浏览器，还不需要Redis。</li>
<li>秒杀活动开始阶段<br>这时大量用户会不断刷新商品详情页并点击秒杀按钮，会产生大量并发请求查询库存，如果通过则触发库存扣减和订单处理。<br>这个阶段的主要压力在于库存的查验，可以使用Redis保存库存并用于查验。<br>这里库存的扣减也是放到Redis中执行的，如果放到数据库中，一方面同步数据库和缓存会带来额外的开销，另一方面如果下单量超过了实际库存可能出现超售。<br>库存的查验和扣减需要保证原子性，可以通过Redis的事务或Lua脚本来实现，或者使用分布式锁来同步。</li>
<li>秒杀活动结束后<br>这个阶段虽然还会有用户刷新（等待其他用户退单），但是请求已经变得很少了，服务端一般能应付。</li>
</ol>
<h1 id="缓存满了怎么办？"><a href="#缓存满了怎么办？" class="headerlink" title="缓存满了怎么办？"></a>缓存满了怎么办？</h1><h2 id="缓存淘汰（缓存失效策略和主键失效机制）"><a href="#缓存淘汰（缓存失效策略和主键失效机制）" class="headerlink" title="缓存淘汰（缓存失效策略和主键失效机制）"></a>缓存淘汰（缓存失效策略和主键失效机制）</h2><p>作为缓存系统都要定期清理无效数据，就需要一个主键失效和淘汰策略，比如 Redis 只能存 5G 数据，可是你写了 10G，那多出来的 5G 数据怎么删？你的数据已经设置了过期时间，但是时间到了，内存占用率还是比较高？这就需要深入到 Redis 的主键失效和淘汰策略中去了。</p>
<h3 id="key-的过期时间控制"><a href="#key-的过期时间控制" class="headerlink" title="key 的过期时间控制"></a>key 的过期时间控制</h3><p>在 Redis 当中，有生存期的 key 被称为 volatile。在创建缓存时，要为给定的 key 设置生存期，当 key 过期的时候（生存期为 0），它可能会被删除。</p>
<ol>
<li>影响生存时间的一些操作<br>生存时间可以通过使用 DEL 命令来删除整个 key 来移除，或者被 SET 和 GETSET 命令覆盖原来的数据，也就是说，修改 key 对应的 value 和使用另外相同的 key 和 value 来覆盖以后，当前数据的生存时间不同。<br>比如说，对一个 key 执行 INCR 命令，对一个列表进行 LPUSH 命令，或者对一个哈希表执行 HSET 命令，这类操作都不会修改 key 本身的生存时间。另一方面，如果使用 RENAME 对一个 key 进行改名，那么改名后的 key 的生存时间和改名前一样。<br>RENAME 命令的另一种可能是，尝试将一个带生存时间的 key 改名成另一个带生存时间的 another_key ，这时旧的 another_key (以及它的生存时间)会被删除，然后旧的 key 会改名为 another_key ，因此，新的 another_key 的生存时间也和原本的 key 一样。使用 PERSIST 命令可以在不删除 key 的情况下，移除 key 的生存时间，让 key 重新成为一个 persistent key 。</li>
<li>如何更新生存时间<br>可以对一个已经带有生存时间的 key 执行 EXPIRE 命令，新指定的生存时间会取代旧的生存时间。过期时间的精度已经被控制在 1ms 之内，主键失效的时间复杂度是 O（1），<br>EXPIRE 和 TTL 命令搭配使用，TTL 可以查看 key 的当前生存时间。设置成功返回 1；当 key 不存在或者不能为 key 设置生存时间时，返回 0 。</li>
<li>最大缓存配置<br>在 redis 中，允许用户设置最大使用内存大小 <code>server.maxmemory</code><br>默认为 0，没有指定最大缓存，如果有新的数据添加，超过最大内存，则会使 redis 崩溃，所以一定要设置。redis 内存数据集大小上升到一定大小的时候，就会实行数据淘汰策略。</li>
</ol>
<h3 id="key-的删除策略"><a href="#key-的删除策略" class="headerlink" title="key 的删除策略"></a>key 的删除策略</h3><p>redis 采用的是定期删除+惰性删除策略。</p>
<ol>
<li>为什么不用定时删除策略?<br>定时删除,用一个定时器来负责监视 key,过期则自动删除。虽然内存及时释放，但是十分消耗 CPU 资源。在大并发请求下，CPU 要将时间应用在处理请求，而不是删除 key,因此没有采用这一策略.</li>
<li>定期删除+惰性删除是如何工作的呢?<br>定期删除，redis 默认每个 100ms 检查，是否有过期的 key,有过期 key 则删除。需要说明的是，redis 不是每个 100ms 将所有的 key 检查一次，而是随机抽取进行检查(如果每隔 100ms,全部 key 进行检查，redis 岂不是卡死)。因此，如果只采用定期删除策略，会导致很多 key 到时间没有删除。<br>于是，惰性删除派上用场。也就是说在你获取某个 key 的时候，redis 会检查一下，这个 key 如果设置了过期时间那么是否过期了？如果过期了此时就会删除。</li>
<li>采用定期删除+惰性删除就没其他问题了么?<br>不是的，如果定期删除没删除 key。然后你也没即时去请求 key，也就是说惰性删除也没生效。这样，redis 的内存会越来越高。那么就应该采用内存淘汰机制。</li>
</ol>
<h3 id="Redis-的数据淘汰策略"><a href="#Redis-的数据淘汰策略" class="headerlink" title="Redis 的数据淘汰策略"></a>Redis 的数据淘汰策略</h3><p>在 redis.conf 中有一行配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># maxmemory-policy volatile-lru</span><br></pre></td></tr></table></figure>
<p>redis 提供 6种数据淘汰策略：</p>
<ol>
<li>no-enviction（驱逐）：禁止驱逐数据，当内存不足以容纳新写入数据时，新写入操作会报错（应该没人用）</li>
<li>volatile-lru：当内存不足以容纳新写入数据时，从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰（这种情况一般是把 redis 既当缓存，又做持久化存储的时候才用。不推荐）</li>
<li>volatile-ttl：当内存不足以容纳新写入数据时，从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰（不推荐）<br>可以在一些需要“置顶”的业务场景里采用，比如一些新闻、视频需要置顶，这些数据不需要设置过期时间，<code>volatile-ttl</code>就不会删除它们。</li>
<li>volatile-random：当内存不足以容纳新写入数据时，从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰（不推荐）</li>
<li>allkeys-lru：当内存不足以容纳新写入数据时，从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰（推荐）</li>
<li>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰</li>
</ol>
<p>注意这里的 6 种机制：</p>
<ul>
<li>volatile 和 allkeys 规定了是对已设置过期时间的数据集淘汰数据还是从全部数据集淘汰数据；</li>
<li>lru、ttl 以及 random 是三种不同的淘汰策略，ttl 和 random 比较容易理解、实现也会比较简单，lru 会对 key 按失效时间排序，然后取最先失效的 key 进行淘汰。</li>
<li>如果没有设置 expire 的 key, 不满足先决条件(prerequisites); 那么 volatile-lru, volatile-random 和 volatile-ttl 策略的行为, 和 noeviction(不删除) 基本上一致。</li>
</ul>
<p><strong>使用策略规则</strong></p>
<ol>
<li>如果数据呈现幂律分布，也就是一部分数据访问频率高，一部分数据访问频率低，则使用 allkeys-lru</li>
<li>如果数据呈现平等分布，也就是所有的数据访问频率都相同，则使用 allkeys-random</li>
</ol>
<h3 id="自定义缓存淘汰策略"><a href="#自定义缓存淘汰策略" class="headerlink" title="自定义缓存淘汰策略"></a>自定义缓存淘汰策略</h3><p>除了缓存服务器自带的缓存失效策略之外（Redis 默认有 6 种策略可选），我们还可以根据具体的业务需求自定义缓存淘汰策略，常见的策略有两种：</p>
<ol>
<li>定时去清除过期的缓存；</li>
<li>当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存；</li>
</ol>
<p>两种策略各有优劣，第一种的缺点是维护大量缓存的 key 是比较麻烦的，第二种的缺点是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂。需要根据应用场景的特点来权衡选择。</p>
<h3 id="缓存淘汰的实现"><a href="#缓存淘汰的实现" class="headerlink" title="缓存淘汰的实现"></a>缓存淘汰的实现</h3><ol>
<li>设置过期时间<br>过期时间到了后，Redis 会在读的时候判断是否过期并清除，或者由一个定时任务执行清除操作。</li>
<li>超过 maxmemory 回收<br>可以设置淘汰机制，比如 LRU、LFU。</li>
</ol>
<p>LRU 算法的一种简单实现<br>简单版本的 LRU 算法分两个部分：</p>
<ol>
<li>一个链表记录 key 的最终访问次序，比如最新访问的在链表头部，最久没访问的在链表末尾，LRU 淘汰机制就是删除链表末尾的节点；</li>
<li>一个散列表记录某个 key 是否存在，并可以找到其在链表中的位置；</li>
</ol>
<h3 id="Redis-中的-LRU-实现"><a href="#Redis-中的-LRU-实现" class="headerlink" title="Redis 中的 LRU 实现"></a>Redis 中的 LRU 实现</h3><p><img src="/imgs/Redis/Redis-LRU%E7%AE%97%E6%B3%95.png" alt="Redis-LRU算法" title="Redis-LRU算法"><br>代码位置：<code>evict.c/freeMemoryIfNeeded</code><br>Redis 中并没有直接使用上述的 LRU 算法，主要是因为维护LRU链表开销较大，而是退一步使用了<strong>抽样淘汰</strong>的机制：</p>
<ol>
<li>每次从缓存对象集合中随机取出一部分样本（20个key），进行下面的过期检测；</li>
<li>按 LRU 算法排序；</li>
<li>取 idle 值（评分）最小的淘汰；</li>
<li>如果有多于25%的key是过期了的，则重复步骤1。</li>
</ol>
<p>为了支持LRU，Redis中使用了一个全局的LRU时钟server.lruclock：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define REDIS_LRU_BITS 24</span><br><span class="line"></span><br><span class="line">// 最近一次使用时钟</span><br><span class="line">unsigned lruclock:REDIS_LRU_BITS; /* Clock for LRU eviction */</span><br></pre></td></tr></table></figure>

<p>Redis会在<code>serverCron()</code>中调用<code>updateLRUClock</code>来定期更新LRU时钟：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#define REDIS_LRU_CLOCK_MAX ((1&lt;&lt;REDIS_LRU_BITS)-1) /* Max value of obj-&gt;lru */</span><br><span class="line">#define REDIS_LRU_CLOCK_RESOLUTION 1000 /* LRU clock resolution in ms */</span><br><span class="line"></span><br><span class="line">int serverCron(struct aeEventLoop *eventLoop, long long id, void *clientData) &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    server.lruclock = getLRUClock();</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unsigned int getLRUClock(void) &#123;</span><br><span class="line">    return (mstime()/REDIS_LRU_CLOCK_RESOLUTION) &amp; REDIS_LRU_CLOCK_MAX;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>LRU 时间的精度可以通过修改 REDIS_LRU_CLOCK_RESOLUTION 常量来改变。</li>
<li>更新频率即serverCron被调用的频率，和hz参数有关，默认为100ms一次。</li>
</ul>
<p>计算一个key的最长没有访问时间时，需要注意时钟回卷的情况：<br><code>server.unixtime</code>是系统当前的unix时间戳，当lruclock的值超出REDIS_LRU_CLOCK_MAX时，会从头开始计算，所以在计算一个key的最长没有访问时间时，可能key本身保存的lru访问时间会比当前的lruclock还要大，这个时候需要计算额外时间：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 使用近似 LRU 算法，计算出给定对象的闲置时长</span><br><span class="line">unsigned long long estimateObjectIdleTime(robj *o) &#123;</span><br><span class="line">    unsigned long long lruclock = LRU_CLOCK();</span><br><span class="line">    if (lruclock &gt;= o-&gt;lru) &#123;</span><br><span class="line">        return (lruclock - o-&gt;lru) * REDIS_LRU_CLOCK_RESOLUTION;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return (lruclock + (REDIS_LRU_CLOCK_MAX - o-&gt;lru)) *</span><br><span class="line">                    REDIS_LRU_CLOCK_RESOLUTION;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Redis中和LRU相关的淘汰策略包括：</p>
<ul>
<li><code>volatile-lru</code>：设置了过期时间的key参与近似的lru淘汰策略；</li>
<li><code>allkeys-lru</code>：所有的key均参与近似的lru淘汰策略。<br>涉及淘汰的源码如下所示：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">int freeMemoryIfNeeded(void) &#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">            /* volatile-lru and allkeys-lru policy */</span><br><span class="line">            // 如果使用的是 LRU 策略，</span><br><span class="line">            // 那么从一集 sample 键中选出 IDLE 时间最长的那个键</span><br><span class="line">            else if (server.maxmemory_policy == REDIS_MAXMEMORY_ALLKEYS_LRU ||</span><br><span class="line">                server.maxmemory_policy == REDIS_MAXMEMORY_VOLATILE_LRU)</span><br><span class="line">            &#123;</span><br><span class="line">                struct evictionPoolEntry *pool = db-&gt;eviction_pool;</span><br><span class="line"></span><br><span class="line">                while(bestkey == NULL) &#123;</span><br><span class="line">                    evictionPoolPopulate(dict, db-&gt;dict, db-&gt;eviction_pool);</span><br><span class="line">                    /* Go backward from best to worst element to evict. */</span><br><span class="line">                    for (k = REDIS_EVICTION_POOL_SIZE-1; k &gt;= 0; k--) &#123;</span><br><span class="line">                        if (pool[k].key == NULL) continue;</span><br><span class="line">                        de = dictFind(dict,pool[k].key);</span><br><span class="line"></span><br><span class="line">                        /* Remove the entry from the pool. */</span><br><span class="line">                        sdsfree(pool[k].key);</span><br><span class="line">                        /* Shift all elements on its right to left. */</span><br><span class="line">                        memmove(pool+k,pool+k+1,</span><br><span class="line">                            sizeof(pool[0])*(REDIS_EVICTION_POOL_SIZE-k-1));</span><br><span class="line">                        /* Clear the element on the right which is empty</span><br><span class="line">                         * since we shifted one position to the left.  */</span><br><span class="line">                        pool[REDIS_EVICTION_POOL_SIZE-1].key = NULL;</span><br><span class="line">                        pool[REDIS_EVICTION_POOL_SIZE-1].idle = 0;</span><br><span class="line"></span><br><span class="line">                        /* If the key exists, is our pick. Otherwise it is</span><br><span class="line">                         * a ghost and we need to try the next element. */</span><br><span class="line">                        if (de) &#123;</span><br><span class="line">                            bestkey = dictGetKey(de);</span><br><span class="line">                            break;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            /* Ghost... */</span><br><span class="line">                            continue;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Redis会基于<code>server.maxmemory_samples</code>配置选取固定数目的key，然后比较它们的lru访问时间，然后淘汰最近最久没有访问的key，maxmemory_samples的值越大，Redis的近似LRU算法就越接近于严格LRU算法，但是相应消耗也会变高，对性能有一定影响，maxmemory_samples这个值默认为5。</li>
</ul>
<h1 id="缓存系统中存在的问题"><a href="#缓存系统中存在的问题" class="headerlink" title="缓存系统中存在的问题"></a>缓存系统中存在的问题</h1><p><img src="/imgs/Redis/%E6%97%81%E8%B7%AF%E7%BC%93%E5%AD%98%E7%9A%84%E9%9B%AA%E5%B4%A9%E3%80%81%E5%87%BB%E7%A9%BF%E3%80%81%E7%A9%BF%E9%80%8F%E9%97%AE%E9%A2%98.jpg" alt="旁路缓存的雪崩、击穿、穿透问题" title="旁路缓存的雪崩、击穿、穿透问题"><br><img src="/imgs/Redis/%E6%97%81%E8%B7%AF%E7%BC%93%E5%AD%98%E7%9A%84%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98.jpg" alt="旁路缓存的不一致问题" title="旁路缓存的不一致问题"></p>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>缓存穿透即即黑客故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常。这也是经常提的缓存命中率问题。<br>应付大规模缓存穿透的方案如下：</p>
<ol>
<li>利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试</li>
<li>采用异步更新策略，无论 key 是否取到值，都直接返回。value 值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存。需要做<strong>缓存预热</strong>(项目启动前，先加载缓存)操作。</li>
<li>提供一个能迅速判断请求是否有效的拦截机制，比如，利用<strong>布隆过滤器</strong>，内部维护一系列合法有效的 key，将这些数据 hash 到一个足够大的 bitmap 中。迅速判断出，请求所携带的 Key 是否合法有效。如果不合法，则直接返回。</li>
<li>如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过 5 分钟，通过这个直接设置的默认值存放到缓存，这样第二次到缓存中获取就有值了，而不会继续访问数据库，这种办法最简单粗暴。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public Object queryProduct() &#123;</span><br><span class="line">    int cacheTime = 30;</span><br><span class="line">    String cacheKey = &quot;product&quot;;</span><br><span class="line">    </span><br><span class="line">    String cacheValue = getFromRedis(cacheKey);</span><br><span class="line">    if (cacheValue != null) &#123;</span><br><span class="line">        return cacheValue;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 击穿到db</span><br><span class="line">        cacheValue = getFromDB();</span><br><span class="line">        if (cacheValue == null) &#123;</span><br><span class="line">            // 如果发现为空，则缓存个默认值</span><br><span class="line">            cacheValue = &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        putToRedis(cacheKey, cacheValue, cacheTime);</span><br><span class="line">        return cacheValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 把空结果也给缓存起来，这样下次同样的请求就可以直接返回空了，即可以避免当查询的值为空时引起的缓存穿透。同时也可以单独设置一个缓存区域存储空值，对要查询的key进行进行预先校验，然后再放行给后面的正常缓存处理逻辑。</li>
</ol>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>缓存雪崩即缓存同一时间大面积的失效（例如：我们设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期），这个时候又来了一波请求，结果请求都怼到数据库上，而对数据库 CPU 和内存造成巨大压力，从而导致数据库连接异常，严重的会造成数据库宕机，从而形成一系列连锁反应，造成整个系统崩溃。<br>缓存雪崩的解决方案如下：</p>
<ol>
<li>使用互斥锁，但是该方案吞吐量明显下降了，适用于并发量不是特别多的情况下。具体地来说，使用最多的方案是加锁排队，伪代码如下： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public Object queryProduct() &#123;</span><br><span class="line">    int cacheTime = 30;</span><br><span class="line">    String cacheKey = &quot;product&quot;;</span><br><span class="line">    String lockKey = cacheKey;</span><br><span class="line">    </span><br><span class="line">    String cacheValue = getFromRedis(cacheKey);</span><br><span class="line">    if (cacheValue != null) &#123;</span><br><span class="line">        return cacheValue;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        synchronized (lockKey) &#123;</span><br><span class="line">            cacheValue = getFromRedis(cacheKey);</span><br><span class="line">            if (cacheValue != null) &#123;</span><br><span class="line">                return cacheValue;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                cacheValue = getFromDB();</span><br><span class="line">                putToRedis(cacheKey, cacheValue, cacheTime);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return cacheValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 加锁排队只是为了减轻数据库的压力，并没有提高系统吞吐量。假设在高并发下，缓存重建期间key是锁着的，这时过来1000个请求、999个都在阻塞，同样会导致用户等待超时，属于治标不治本的方案，而且还需要解决分布式锁的问题。</li>
<li>设置过期标志更新缓存。给每一个缓存数据增加相应的缓存标记，记录缓存是否失效，如果缓存标记失效，则更新数据缓存，实现伪代码如下所示： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public Object queryProduct() &#123;</span><br><span class="line">    int cacheTime = 30;</span><br><span class="line">    String cacheKey = &quot;product&quot;;</span><br><span class="line">    // 缓存标记</span><br><span class="line">    String signKey = cacheKey + &quot;_sign&quot;;</span><br><span class="line"></span><br><span class="line">    String signValue = getFromRedis(signKey);</span><br><span class="line">    String cacheValue = getFromRedis(cacheKey);</span><br><span class="line">    if (signValue != null) &#123;</span><br><span class="line">        return cacheValue;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        putToRedis(signKey, &quot;1&quot;, cacheTime);</span><br><span class="line">        threadPool.submit(() -&gt; &#123;</span><br><span class="line">            cacheValue = getFromDB();</span><br><span class="line">            putToRedis(cacheKey, cacheValue, cacheTime * 2);</span><br><span class="line">        &#125;);</span><br><span class="line">        return cacheValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 缓存标记记录缓存数据是否过期，如果过期会触发通知另外的线程在后台去更新实际 key 的缓存。<br> 缓存数据的过期时间比缓存标记的时间延长 1 倍，例如：标记缓存时间 30 分钟，数据缓存 60 分钟，这样，当缓存标记 key 过期后，实际缓存还能把旧数据返回给调用端，直到另外的线程在后台更新完成后，才会返回新缓存。</li>
<li>给缓存的失效时间，加上一个随机值，避免集体失效。</li>
<li>双缓存。我们有两个缓存，缓存 A 和缓存 B。缓存 A 的失效时间为 20 分钟，缓存 B 不设失效时间。自己做缓存预热操作。然后细分以下几个小点：<ol>
<li>从缓存 A 读数据库，有则直接返回</li>
<li>A 没有数据，直接从 B 读数据，直接返回，并且异步启动一个更新线程。</li>
<li>更新线程同时更新缓存 A 和缓存 B。</li>
</ol>
</li>
</ol>
<h2 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h2><p>缓存预热就是系统上线后，提前将相关的缓存数据直接加载到缓存系统，避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题，用户可以直接查询事先被预热的缓存数据。常见的缓存预热方案包括：</p>
<ol>
<li>直接写个缓存刷新页面，上线时手工操作下；</li>
<li>数据量不大，可以在项目启动的时候自动进行加载；</li>
<li>定时刷新缓存。</li>
</ol>
<h2 id="缓存和数据库双写一致性问题"><a href="#缓存和数据库双写一致性问题" class="headerlink" title="缓存和数据库双写一致性问题"></a>缓存和数据库双写一致性问题</h2><p>一致性问题是分布式常见问题，讨论比较多的是最终一致性和强一致性。数据库和缓存双写，就必然会存在不一致的问题。<br>在回答这个问题前，必须先强调一个前提，就是<strong>如果对数据有强一致性要求，不能放缓存</strong>。我们所做的一切，只能保证最终一致性，从根本上来说，只是降低不一致发生的概率，无法完全避免，因此，我们说有强一致性要求的数据，不能放缓存。</p>
<ul>
<li>首先，采取正确更新策略，先更新数据库，再删缓存。</li>
<li>其次，因为可能存在删除缓存失败的问题，提供一个补偿措施即可，例如利用<strong>消息队列</strong>。</li>
</ul>
<p>具体的设计方案和优缺点可以参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/rjzheng/p/9041659.html">【原创】分布式之数据库和缓存双写一致性方案解析</a></p>
<p>下面是对所有策略的分析：</p>
<h3 id="先失效缓存-后更新数据库数据"><a href="#先失效缓存-后更新数据库数据" class="headerlink" title="先失效缓存 -&gt; 后更新数据库数据"></a>先失效缓存 -&gt; 后更新数据库数据</h3><ol>
<li>缺点<br>如果缓存失效失败,根据策略可能会影响后续的正常的数据更新操作<br>直接失效缓存会增加后续的一次缓存查询的 Miss</li>
<li>优点<br>避免数据库更新成功,缓存失效失败,导致缓存中是旧数据</li>
<li>场景<br>对缓存准确率要求比较高的业务</li>
<li>异常情况<br>线程 A 需要更新数据库数据，失效缓存；<br>线程 B 发现缓存没有命中，查询数据库中取出旧的值；<br>线程 A 更新数据库数据，提交事务，线程 A 将数据放入缓存。</li>
</ol>
<h3 id="延时双删"><a href="#延时双删" class="headerlink" title="延时双删"></a>延时双删</h3><p>在《先失效缓存 -&gt; 后更新数据库数据》这种方案的基础上，增加了一个延时过期的步骤。<br>即：过期Redis -&gt; 更新数据库 -&gt; 延迟一会再过期一次Redis<br>这样就可以缓解上边提到的脏读问题了。<br>但是缺点是过期两次，会占用更多的数据库资源。</p>
<h3 id="先更新数据库数据-后失效缓存"><a href="#先更新数据库数据-后失效缓存" class="headerlink" title="先更新数据库数据 -&gt; 后失效缓存"></a>先更新数据库数据 -&gt; 后失效缓存</h3><ol>
<li>缺点<br>如果数据更新成功,但是缓存失效失败,缓存中存放的是旧数据<br>直接失效缓存会增加一次缓存查询的 Miss</li>
<li>优点<br>更新数据不会强依赖缓存,就算失效缓存失败,也不会影响数据库的更新</li>
<li>场景<br>对缓存和数据库的一致性要求不是很高的场景</li>
<li>异常情况<br>在更新数据库数据和失效缓存之前的所有查询,查询到的都是旧数据</li>
</ol>
<h3 id="更新数据库数据-更新缓存"><a href="#更新数据库数据-更新缓存" class="headerlink" title="更新数据库数据 -&gt; 更新缓存"></a>更新数据库数据 -&gt; 更新缓存</h3><ol>
<li>优点<br>避免了一次额外的缓存查询 Miss<br>实时性比较高</li>
<li>缺点<br>数据库更新成功，但是更新缓存失败，缓存中存储的是旧数据<br>选择同步还是异步来更新缓存呢？如果是同步更新，更新磁盘成功了，但是更新缓存失败了，你是不是要反复重试来保证更新成功？如果多次重试都失败，那这次更新是算成功还是失败呢？如果是异步更新缓存，怎么保证更新的时序？<br>比如，我先把一个文件中的某个数据设置成 0，然后又设为 1，这个时候文件中的数据肯定是 1，但是缓存中的数据可不一定就是 1 了。因为把缓存中的数据更新为 0，和更新为 1 是两个并发的异步操作，不一定谁会先执行。<br>这些问题都会导致缓存的数据和磁盘中的数据不一致，而且，在下次更新这条数据之前，这个不一致的问题它是一直存在的。当然，这些问题也不是不能解决的，比如，你可以使用分布式事务来解决，只是付出的性能、实现复杂度等代价比较大。</li>
<li>场景<br>缓存粒度比较小,缓存的数据不需要经过计算(更新商品数据,但是缓存还需要用户数据)</li>
<li>异常情况<br>A 线程查询缓存发现缓存中没有数据,查询数据库；<br>B 线程更新数据库并且更新了缓存；<br>A 再把查询的数据放入缓存,缓存中将会是旧数据</li>
</ol>
<h3 id="更新缓存-更新数据库数据"><a href="#更新缓存-更新数据库数据" class="headerlink" title="更新缓存 -&gt; 更新数据库数据"></a>更新缓存 -&gt; 更新数据库数据</h3><ol>
<li>优点<br>避免了一次额外的缓存查询 Miss</li>
<li>缺点<br>缓存更新成功,但是数据库更新失败,导致缓存数据是旧数据;<br>并且更新缓存失败,根据策略可能导致更新数据库失败。</li>
<li>场景<br>缓存粒度比较小,缓存的数据不需要经过计算(更新商品数据,但是缓存还需要用户数据)</li>
<li>异常情况<br>在更新缓存成功和更新数据库数据之前拿到的缓存是和数据库不一致的(不过这种情况造成的负面影响很小)</li>
</ol>
<h3 id="更新数据库数据-定时同步到缓存"><a href="#更新数据库数据-定时同步到缓存" class="headerlink" title="更新数据库数据 -&gt; 定时同步到缓存"></a>更新数据库数据 -&gt; 定时同步到缓存</h3><ol>
<li>优点<br>实现简单、鲁棒性高<br>就算某次同步过程中发生了错误，等到下一个同步周期也会自动把数据纠正过来。</li>
<li>缺点<br>缓存更新不实时。<br>如果缓存的数据太大，更新速度慢到无法接受，可以选择增量更新，每次只更新从上次缓存同步至今这段时间内变化的数据，代价是实现起来会稍微有些复杂。</li>
</ol>
<h3 id="缓存更新总结"><a href="#缓存更新总结" class="headerlink" title="缓存更新总结"></a>缓存更新总结</h3><ul>
<li>如果对一致性要求没有那么高，一般是先更新数据库然后删除缓存。</li>
<li>如果对一致性要求比较高，那么在缓存删除失败后，需要把删除事件放到队列里消费。</li>
<li>如果对一致性要求更高点，那么需要将更新数据库、更新缓存、查询缓存的操作放到一个队列里消费</li>
</ul>
<h2 id="如何解决-redis-的并发竞争-key-问题"><a href="#如何解决-redis-的并发竞争-key-问题" class="headerlink" title="如何解决 redis 的并发竞争 key 问题"></a>如何解决 redis 的并发竞争 key 问题</h2><p>这个问题大致就是，同时有多个子系统去 set 一个 key。这个时候要注意什么呢？大家思考过么。百度上的答案基本都是推荐用 redis 事务机制，但这里<strong>不推荐使用 redis 的事务机制</strong>。因为我们的生产环境，基本都是 redis 集群环境，做了数据分片操作，你一个事务中有涉及到多个 key 操作的时候，这多个 key 不一定都存储在同一个 redis-server 上。因此，<strong>Redis 的事务机制，十分鸡肋</strong>。</p>
<ol>
<li>如果对这个 key 操作，<strong>不要求顺序</strong><br>这种情况下，准备一个分布式锁，大家去抢锁，抢到锁就做 set 操作即可，比较简单。</li>
<li>如果对这个 key 操作，<strong>要求顺序</strong><br>假设有一个 key1,系统 A 需要将 key1 设置为 valueA,系统 B 需要将 key1 设置为 valueB,系统 C 需要将 key1 设置为 valueC.<br>期望按照 key1 的 value 值按照 valueA–&gt;valueB–&gt;valueC 的顺序变化。这种时候我们在数据写入数据库的时候，需要保存一个时间戳。假设时间戳如下<br>系统 A key 1 {valueA 3:00}<br>系统 B key 1 {valueB 3:05}<br>系统 C key 1 {valueC 3:10}<br>那么，假设这会系统 B 先抢到锁，将 key1 设置为{valueB 3:05}。接下来系统 A 抢到锁，发现自己的 valueA 的时间戳早于缓存中的时间戳，那就不做 set 操作了。以此类推。<br>其他方法，比如利用队列，将 set 方法变成串行访问也可以。</li>
</ol>
<h2 id="缓存降级"><a href="#缓存降级" class="headerlink" title="缓存降级"></a>缓存降级</h2><p>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。<br>降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。<br>在进行降级之前要对系统进行梳理，看看哪些服务是必须誓死保护的、哪些是可降级的。比如可以参考日志级别设置预案：</p>
<ol>
<li>一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；</li>
<li>警告：有些服务在一段时间内成功率有波动（如在 95~100%之间），可以自动降级或人工降级，并发送告警；</li>
<li>错误：比如可用率低于 90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；</li>
<li>严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。</li>
</ol>
<h2 id="缓存污染"><a href="#缓存污染" class="headerlink" title="缓存污染"></a>缓存污染</h2><p>什么是缓存污染呢？在一些场景下，有些数据被访问的次数非常少，甚至只会被访问一次。当这些数据服务完访问请求后，如果还继续留存在缓存中的话，就只会白白占用缓存空间。这种情况，就是缓存污染。</p>
<p>我们来看一下各种过期策略是否能解决缓存污染问题：</p>
<ul>
<li>allkeys-random：对所有key进行随机的淘汰，因为不确定之后同一个key是否还会被访问到，所以这个策略会导致缓存缺失问题。</li>
<li>volatile-random：和allkeys-random类似。</li>
<li>volatile-ttl：针对的是设置了过期时间的数据，把这些数据中剩余存活时间最短的筛选出来并淘汰掉，这种策略并不能直接反映数据被再次访问的情况，也有导致缓存缺失的问题。<br>一般业务会根据数据生效时间范围来决定数据的过期时间，因此过期时间短的很有可能就是用一下就不用的数据，所以这种情况下volatile-ttl是可以缓解缓存污染问题的。</li>
<li>lru<br>把使用最少的淘汰掉。<br>但是使用LRU策略在处理扫描式单次查询操作时，无法解决缓存污染，因为这些key被扫描过一次后最近访问时间都是一样的。因为存在这种问题，因此Redis4.0增加了LRU淘汰策略。</li>
<li>lfu<br>与 LRU 策略相比，LFU 策略中会从两个维度来筛选并淘汰数据：一是，数据访问的时效性（访问时间离当前时间的远近）；二是，数据的被访问次数。<br>LFU 缓存策略是在 LRU 策略基础上，为每个数据增加了一个计数器，来统计这个数据的访问次数。当使用 LFU 策略筛选淘汰数据时，首先会根据数据的访问次数进行筛选，把访问次数最低的数据淘汰出缓存。如果两个数据的访问次数相同，LFU 策略再比较这两个数据的访问时效性，把距离上一次访问时间更久的数据淘汰出缓存。</li>
</ul>
<h1 id="缓存数据迁移"><a href="#缓存数据迁移" class="headerlink" title="缓存数据迁移"></a>缓存数据迁移</h1><p>什么时候会遇到要将Redis数据迁入、迁出的情况？比如要将Sentinel集群迁移到Cluster集群。<br>目前一个比较常用的Redis数据迁移工具是Redis-shake。<br>Redis-shake 的基本运行原理，是先启动 Redis-shake 进程，这个进程模拟了一个 Redis 实例。然后，Redis-shake 进程和数据迁出的源实例进行数据的全量同步。<br>源实例先把 RDB 文件传输给 Redis-shake，Redis-shake 会把 RDB 文件发送给目的实例，等到同步完毕后，源实例再将增量命令发送给Redis-shake，Redis-shake 负责把这些增量命令再同步给目的实例。</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">
    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%BC%93%E5%AD%98%E7%B3%BB%E7%BB%9F/" rel="tag"># 缓存系统</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/b4105807.html" rel="prev" title="《设计数据密集型应用》">
                  <i class="fa fa-angle-left"></i> 《设计数据密集型应用》
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/6a07ad6.html" rel="next" title="Redis 性能调优">
                  Redis 性能调优 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">tallate</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/tallate" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"version":"7.1.2","options":null,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.3.0/mermaid.min.js","integrity":"sha256-9y71g5Lz/KLsHjB8uXwnkuWDtAMDSzD/HdIbqhJfTAI="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>





  





</body>
</html>
