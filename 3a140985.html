<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"tallate.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.18.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="通过操作 Thread、Object 的 API 和内置锁我们可以解决大部分的线程协调问题，但这绝不是最优雅的方式，接下来我们就来见识一下 JUC 中的各种高效线程同步工具。">
<meta property="og:type" content="article">
<meta property="og:title" content="并发和同步策略">
<meta property="og:url" content="https://tallate.github.io/3a140985.html">
<meta property="og:site_name" content="Tallate">
<meta property="og:description" content="通过操作 Thread、Object 的 API 和内置锁我们可以解决大部分的线程协调问题，但这绝不是最优雅的方式，接下来我们就来见识一下 JUC 中的各种高效线程同步工具。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://tallate.github.io/imgs/%E5%B9%B6%E5%8F%91/MarkWord%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="https://tallate.github.io/imgs/%E5%B9%B6%E5%8F%91/%E9%94%81%E5%88%86%E9%85%8D%E5%92%8C%E8%86%A8%E8%83%80%E8%BF%87%E7%A8%8B.png">
<meta property="og:image" content="https://tallate.github.io/imgs/%E5%B9%B6%E5%8F%91/synchronized%E9%94%81%E8%86%A8%E8%83%80%E7%9A%84%E7%AE%80%E5%8C%96%E7%89%88%E8%BF%87%E7%A8%8B.png">
<meta property="og:image" content="https://tallate.github.io/imgs/%E5%B9%B6%E5%8F%91/ReentrantLock%E7%B1%BB%E5%9B%BE.png">
<meta property="og:image" content="https://tallate.github.io/imgs/%E5%B9%B6%E5%8F%91/ReentrantLock%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png">
<meta property="og:image" content="https://tallate.github.io/imgs/%E5%B9%B6%E5%8F%91/ReentrantReadWriteLock%E7%B1%BB%E5%9B%BE.png">
<meta property="og:image" content="https://tallate.github.io/imgs/%E5%B9%B6%E5%8F%91/AQS%E7%B1%BB%E5%9B%BE.png">
<meta property="og:image" content="https://tallate.github.io/imgs/%E5%B9%B6%E5%8F%91/AQS%E5%A4%A7%E8%87%B4%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="https://tallate.github.io/imgs/%E5%B9%B6%E5%8F%91/CountDownLatch%E7%B1%BB%E5%9B%BE.png">
<meta property="og:image" content="https://tallate.github.io/imgs/%E5%B9%B6%E5%8F%91/CyclicBarrier%E7%B1%BB%E5%9B%BE.png">
<meta property="og:image" content="https://tallate.github.io/imgs/%E5%B9%B6%E5%8F%91/Semaphore%E7%B1%BB%E5%9B%BE.png">
<meta property="og:image" content="https://tallate.github.io/imgs/%E5%B9%B6%E5%8F%91/ThreadLocal%E7%B1%BB%E5%9B%BE.png">
<meta property="og:image" content="https://tallate.github.io/imgs/%E5%B9%B6%E5%8F%91/ThreadLocalRandom%E7%B1%BB%E5%9B%BE.png">
<meta property="og:image" content="https://tallate.github.io/imgs/%E5%B9%B6%E5%8F%91/LongAdder%E7%B1%BB%E5%9B%BE.png">
<meta property="article:published_time" content="2019-09-24T15:54:49.000Z">
<meta property="article:modified_time" content="2025-07-06T17:56:20.869Z">
<meta property="article:author" content="tallate">
<meta property="article:tag" content="并发">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tallate.github.io/imgs/%E5%B9%B6%E5%8F%91/MarkWord%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png">


<link rel="canonical" href="https://tallate.github.io/3a140985.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://tallate.github.io/3a140985.html","path":"/3a140985.html","title":"并发和同步策略"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>并发和同步策略 | Tallate</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Tallate</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">该吃吃该喝喝 啥事别往心里搁</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签<span class="badge">83</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="th fa-fw"></i>分类<span class="badge">25</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档<span class="badge">191</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%81%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">1.</span> <span class="nav-text">锁的原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E5%92%8C%E9%94%81"><span class="nav-number">1.1.</span> <span class="nav-text">线程同步和锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81"><span class="nav-number">1.2.</span> <span class="nav-text">乐观锁和悲观锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-number">1.3.</span> <span class="nav-text">死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="nav-number">1.3.1.</span> <span class="nav-text">死锁产生的条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E9%81%BF%E5%85%8D"><span class="nav-number">1.3.2.</span> <span class="nav-text">死锁避免</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E9%94%81"><span class="nav-number">1.4.</span> <span class="nav-text">阻塞锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8B%AC%E5%8D%A0%E9%94%81%E5%92%8C%E5%85%B1%E4%BA%AB%E9%94%81"><span class="nav-number">1.5.</span> <span class="nav-text">独占锁和共享锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AC%E5%B9%B3%E6%80%A7"><span class="nav-number">1.6.</span> <span class="nav-text">公平性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E6%80%A7"><span class="nav-number">1.7.</span> <span class="nav-text">可重入性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E5%8E%9F%E7%90%86"><span class="nav-number">1.7.1.</span> <span class="nav-text">可重入锁原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized%EF%BC%88%E7%9B%91%E8%A7%86%E5%99%A8%E9%94%81%EF%BC%89%E6%98%AF%E5%8F%AF%E9%87%8D%E5%85%A5%E7%9A%84"><span class="nav-number">1.7.2.</span> <span class="nav-text">synchronized（监视器锁）是可重入的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ReentrantLock-%E6%98%AF%E5%8F%AF%E9%87%8D%E5%85%A5%E7%9A%84"><span class="nav-number">1.7.3.</span> <span class="nav-text">ReentrantLock 是可重入的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ReentrantReadWriteLock"><span class="nav-number">1.7.4.</span> <span class="nav-text">ReentrantReadWriteLock</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%A2%E5%8D%A0"><span class="nav-number">1.8.</span> <span class="nav-text">抢占</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SpinLock%EF%BC%88%E8%87%AA%E6%97%8B%E9%94%81%EF%BC%89"><span class="nav-number">1.9.</span> <span class="nav-text">SpinLock（自旋锁）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81%E7%AE%97%E6%B3%95-CLHLock%EF%BC%88Craig-Landin-and-Hagersten-locks%EF%BC%89"><span class="nav-number">1.10.</span> <span class="nav-text">锁算法 - CLHLock（Craig, Landin, and Hagersten locks）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81%E7%AE%97%E6%B3%95-MCSLock"><span class="nav-number">1.11.</span> <span class="nav-text">锁算法 - MCSLock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81%E7%AE%97%E6%B3%95-TicketLock"><span class="nav-number">1.12.</span> <span class="nav-text">锁算法 - TicketLock</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E7%BD%AE%E9%94%81-synchronized"><span class="nav-number">2.</span> <span class="nav-text">内置锁 - synchronized</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E6%97%8B%E9%94%81"><span class="nav-number">2.1.</span> <span class="nav-text">自旋锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E9%80%82%E5%BA%94%E8%87%AA%E6%97%8B%E9%94%81"><span class="nav-number">2.2.</span> <span class="nav-text">自适应自旋锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="nav-number">2.3.</span> <span class="nav-text">轻量级锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%81%8F%E5%90%91%E9%94%81"><span class="nav-number">2.4.</span> <span class="nav-text">偏向锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81"><span class="nav-number">2.5.</span> <span class="nav-text">重量级锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81%E7%B2%97%E5%8C%96"><span class="nav-number">2.6.</span> <span class="nav-text">锁粗化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81%E5%88%86%E9%85%8D%E5%92%8C%E8%86%A8%E8%83%80%E7%AD%96%E7%95%A5"><span class="nav-number">2.7.</span> <span class="nav-text">锁分配和膨胀策略</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81-ReentrantLock"><span class="nav-number">3.</span> <span class="nav-text">可重入锁 - ReentrantLock</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ReentrantLock-vs-synchronized"><span class="nav-number">3.0.1.</span> <span class="nav-text">ReentrantLock vs synchronized</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%AC%E5%B9%B3%E6%80%A7-1"><span class="nav-number">3.0.2.</span> <span class="nav-text">公平性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="nav-number">3.0.3.</span> <span class="nav-text">获取非公平锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%85%AC%E5%B9%B3%E9%94%81"><span class="nav-number">3.0.4.</span> <span class="nav-text">获取公平锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#lockInterruptibly-%E5%AF%B9%E4%B8%AD%E6%96%AD%E7%9A%84%E5%93%8D%E5%BA%94"><span class="nav-number">3.0.5.</span> <span class="nav-text">lockInterruptibly 对中断的响应</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tryLock-%E5%B0%9D%E8%AF%95%E8%8E%B7%E5%8F%96%E9%94%81"><span class="nav-number">3.0.6.</span> <span class="nav-text">tryLock 尝试获取锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#unlock-%E9%87%8A%E6%94%BE%E9%94%81"><span class="nav-number">3.0.7.</span> <span class="nav-text">unlock 释放锁</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E9%94%81-ReentrantReadWriteLock"><span class="nav-number">4.</span> <span class="nav-text">读写锁 - ReentrantReadWriteLock</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#writeLock-lock-%E8%8E%B7%E5%8F%96%E5%86%99%E9%94%81"><span class="nav-number">4.0.1.</span> <span class="nav-text">writeLock.lock 获取写锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#writeLock-lockInterruptibly"><span class="nav-number">4.0.2.</span> <span class="nav-text">writeLock.lockInterruptibly</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#writeLock-tryLock"><span class="nav-number">4.0.3.</span> <span class="nav-text">writeLock.tryLock</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#writeLock-tryLock-long-timeout-TimeUnit-unit"><span class="nav-number">4.0.4.</span> <span class="nav-text">writeLock.tryLock(long timeout, TimeUnit unit)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#writeLock-unlock"><span class="nav-number">4.0.5.</span> <span class="nav-text">writeLock.unlock</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ReadLock-lock"><span class="nav-number">4.0.6.</span> <span class="nav-text">ReadLock.lock</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ReadLock-lockInterruptibly"><span class="nav-number">4.0.7.</span> <span class="nav-text">ReadLock.lockInterruptibly</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ReadLock-tryLock"><span class="nav-number">4.0.8.</span> <span class="nav-text">ReadLock.tryLock</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ReadLock-tryLock-long-timeout-TimeUnit-unit"><span class="nav-number">4.0.9.</span> <span class="nav-text">ReadLock.tryLock(long timeout, TimeUnit unit)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ReadLock-unlock"><span class="nav-number">4.0.10.</span> <span class="nav-text">ReadLock.unlock</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Condition-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="nav-number">4.0.11.</span> <span class="nav-text">Condition - 条件变量</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#StampedLock-%E7%AD%BE%E9%94%81"><span class="nav-number">5.</span> <span class="nav-text">StampedLock - 签锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5"><span class="nav-number">5.0.1.</span> <span class="nav-text">不可重入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%AC%E5%B9%B3%E6%80%A7-2"><span class="nav-number">5.0.2.</span> <span class="nav-text">公平性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#StampedLock-vs-ReentrantReadWriteLock"><span class="nav-number">5.0.3.</span> <span class="nav-text">StampedLock vs ReentrantReadWriteLock</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B9%90%E8%A7%82%E8%AF%BB%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">5.0.4.</span> <span class="nav-text">乐观读锁的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B-%E4%B9%90%E8%A7%82%E8%AF%BB%E9%94%81%E3%80%81%E8%AF%BB%E9%94%81%E3%80%81%E5%86%99%E9%94%81%E5%8F%8A%E5%8D%87%E7%BA%A7"><span class="nav-number">5.0.5.</span> <span class="nav-text">实例 - 乐观读锁、读锁、写锁及升级</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6-%E5%92%8C-LockSupport"><span class="nav-number">6.</span> <span class="nav-text">线程调度 和 LockSupport</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#void-park"><span class="nav-number">6.0.1.</span> <span class="nav-text">void park()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#void-unpark-Thread-thread"><span class="nav-number">6.0.2.</span> <span class="nav-text">void unpark(Thread thread)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#void-parkNanos-long-nanos"><span class="nav-number">6.0.3.</span> <span class="nav-text">void parkNanos(long nanos)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#void-park-Object-blocker"><span class="nav-number">6.0.4.</span> <span class="nav-text">void park(Object blocker)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#void-parkNanos-Object-blocker-long-nanos"><span class="nav-number">6.0.5.</span> <span class="nav-text">void parkNanos(Object blocker, long nanos)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#void-parkUntil-Object-blocker-long-deadline"><span class="nav-number">6.0.6.</span> <span class="nav-text">void parkUntil(Object blocker, long deadline)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-LockSupport-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E4%BA%92%E6%96%A5%E9%94%81"><span class="nav-number">6.0.7.</span> <span class="nav-text">使用 LockSupport 实现一个互斥锁</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AbstractQueuedSynchronizer%EF%BC%88AQS%EF%BC%89-JUC-%E9%94%81%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%9F%BA%E7%A1%80"><span class="nav-number">7.</span> <span class="nav-text">AbstractQueuedSynchronizer（AQS） - JUC 锁实现的基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AQS-%E7%BB%93%E6%9E%84"><span class="nav-number">7.1.</span> <span class="nav-text">AQS 结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#state"><span class="nav-number">7.2.</span> <span class="nav-text">state</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#state%E5%92%8C%E7%8B%AC%E5%8D%A0%E6%A8%A1%E5%BC%8F"><span class="nav-number">7.3.</span> <span class="nav-text">state和独占模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#state%E5%92%8C%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%BC%8F"><span class="nav-number">7.3.1.</span> <span class="nav-text">state和共享模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD"><span class="nav-number">7.3.2.</span> <span class="nav-text">中断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%9F%E5%88%97"><span class="nav-number">7.3.3.</span> <span class="nav-text">队列</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ConditionObject-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="nav-number">7.4.</span> <span class="nav-text">ConditionObject - 条件变量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#await"><span class="nav-number">7.4.1.</span> <span class="nav-text">await</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#signal"><span class="nav-number">7.4.2.</span> <span class="nav-text">signal</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Condition%E5%92%8Cwait-notify%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">7.4.3.</span> <span class="nav-text">Condition和wait&#x2F;notify之间的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B-Condition-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">7.4.4.</span> <span class="nav-text">实例 - Condition 的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Condition%E5%8D%8F%E8%B0%83%E4%B8%A4%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%A7%E8%A1%8C"><span class="nav-number">7.4.5.</span> <span class="nav-text">使用Condition协调两个线程交替执行</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="nav-number">8.</span> <span class="nav-text">同步工具类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AD%E9%94%81-CountDownLatch"><span class="nav-number">8.1.</span> <span class="nav-text">闭锁 - CountDownLatch</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E8%A6%81%E8%BF%99%E4%B9%88%E5%81%9A"><span class="nav-number">8.1.1.</span> <span class="nav-text">不要这么做</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%9B%BE"><span class="nav-number">8.1.2.</span> <span class="nav-text">类图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">8.1.3.</span> <span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#void-await"><span class="nav-number">8.1.4.</span> <span class="nav-text">void await()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#boolean-await-long-timeout-TimeUnit-unit"><span class="nav-number">8.1.5.</span> <span class="nav-text">boolean await(long timeout, TimeUnit unit)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#void-countDown"><span class="nav-number">8.1.6.</span> <span class="nav-text">void countDown()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#long-getCount"><span class="nav-number">8.1.7.</span> <span class="nav-text">long getCount()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B-%E6%A8%A1%E6%8B%9F%E5%B9%B6%E5%8F%91%E8%AF%B7%E6%B1%82"><span class="nav-number">8.1.8.</span> <span class="nav-text">实例 - 模拟并发请求</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%85%E6%A0%8F-CyclicBarrier"><span class="nav-number">8.2.</span> <span class="nav-text">栅栏 - CyclicBarrier</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E8%A6%81%E8%BF%99%E4%B9%88%E5%81%9A-1"><span class="nav-number">8.2.1.</span> <span class="nav-text">不要这么做</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CyclicBarrier%E7%BB%93%E6%9E%84"><span class="nav-number">8.2.2.</span> <span class="nav-text">CyclicBarrier结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#await-1"><span class="nav-number">8.2.3.</span> <span class="nav-text">await</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#await-long-timeout-TimeUnit-unit"><span class="nav-number">8.2.4.</span> <span class="nav-text">await(long timeout, TimeUnit unit)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dowait"><span class="nav-number">8.2.5.</span> <span class="nav-text">dowait</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Semaphore"><span class="nav-number">8.3.</span> <span class="nav-text">Semaphore</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%AC%E5%B9%B3%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3"><span class="nav-number">8.3.1.</span> <span class="nav-text">公平和非公平</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%9E%E5%85%AC%E5%B9%B3-acquire"><span class="nav-number">8.3.2.</span> <span class="nav-text">非公平 acquire</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%AC%E5%B9%B3%E7%89%88-acquire"><span class="nav-number">8.3.3.</span> <span class="nav-text">公平版 acquire</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#acquire-int-permits"><span class="nav-number">8.3.4.</span> <span class="nav-text">acquire(int permits)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#acquireUninterruptibly"><span class="nav-number">8.3.5.</span> <span class="nav-text">acquireUninterruptibly</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#acquireUninterruptibly-int-permits"><span class="nav-number">8.3.6.</span> <span class="nav-text">acquireUninterruptibly(int permits)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#release"><span class="nav-number">8.3.7.</span> <span class="nav-text">release</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#release-int-permits"><span class="nav-number">8.3.8.</span> <span class="nav-text">release(int permits)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Phase"><span class="nav-number">8.4.</span> <span class="nav-text">Phase</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9A%94%E7%A6%BB%E5%8F%AF%E5%8F%98%E6%80%A7"><span class="nav-number">9.</span> <span class="nav-text">隔离可变性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocal%EF%BC%88%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E5%8F%98%E9%87%8F%EF%BC%89"><span class="nav-number">9.1.</span> <span class="nav-text">ThreadLocal（线程本地变量）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8-ThreadLocal"><span class="nav-number">9.1.1.</span> <span class="nav-text">为什么要使用 ThreadLocal</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ThreadLocal-%E5%8E%9F%E7%90%86"><span class="nav-number">9.1.2.</span> <span class="nav-text">ThreadLocal 原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ThreadLocal%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E9%97%AE%E9%A2%98"><span class="nav-number">9.1.3.</span> <span class="nav-text">ThreadLocal的内存泄露问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#InheritableThreadLocal"><span class="nav-number">9.2.</span> <span class="nav-text">InheritableThreadLocal</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8-InheritableThreadLocal"><span class="nav-number">9.2.1.</span> <span class="nav-text">为什么要使用 InheritableThreadLocal</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E7%90%86"><span class="nav-number">9.2.2.</span> <span class="nav-text">原理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocalRandom"><span class="nav-number">9.3.</span> <span class="nav-text">ThreadLocalRandom</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Random-%E7%B1%BB%E5%8F%8A%E5%85%B6%E5%B1%80%E9%99%90%E6%80%A7"><span class="nav-number">9.3.1.</span> <span class="nav-text">Random 类及其局限性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E7%90%86-1"><span class="nav-number">9.3.2.</span> <span class="nav-text">原理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7%E6%93%8D%E4%BD%9C"><span class="nav-number">10.</span> <span class="nav-text">原子性操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="nav-number">10.1.</span> <span class="nav-text">原子性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E5%AD%90%E6%80%A7%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-number">10.2.</span> <span class="nav-text">实现原子性的几种方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">10.3.</span> <span class="nav-text">原子表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CAS%EF%BC%88Compare-and-Swap%EF%BC%89"><span class="nav-number">10.4.</span> <span class="nav-text">CAS（Compare and Swap）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ABA%E9%97%AE%E9%A2%98"><span class="nav-number">10.5.</span> <span class="nav-text">ABA问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AtomicXxx"><span class="nav-number">10.6.</span> <span class="nav-text">AtomicXxx</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#getAndIncrement"><span class="nav-number">10.6.1.</span> <span class="nav-text">getAndIncrement</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Unsafe"><span class="nav-number">10.7.</span> <span class="nav-text">Unsafe</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#compareAndSwapLong-Object-obj-long-valueOffset-long-expect-long-update"><span class="nav-number">10.7.1.</span> <span class="nav-text">compareAndSwapLong(Object obj,long valueOffset,long expect, long update)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#objectFieldOffset-Field-field"><span class="nav-number">10.7.2.</span> <span class="nav-text">objectFieldOffset(Field field)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Unsafe"><span class="nav-number">10.7.3.</span> <span class="nav-text">使用Unsafe</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LongAdder"><span class="nav-number">10.8.</span> <span class="nav-text">LongAdder</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Cell"><span class="nav-number">10.8.1.</span> <span class="nav-text">Cell</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sum"><span class="nav-number">10.8.2.</span> <span class="nav-text">sum</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#reset"><span class="nav-number">10.8.3.</span> <span class="nav-text">reset</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sumThenReset"><span class="nav-number">10.8.4.</span> <span class="nav-text">sumThenReset</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#longValue"><span class="nav-number">10.8.5.</span> <span class="nav-text">longValue</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#add-long-x"><span class="nav-number">10.8.6.</span> <span class="nav-text">add(long x)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LongAccumulator"><span class="nav-number">10.9.</span> <span class="nav-text">LongAccumulator</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#QA"><span class="nav-number">11.</span> <span class="nav-text">QA</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">12.</span> <span class="nav-text">参考</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E7%BD%AE%E9%94%81"><span class="nav-number">12.1.</span> <span class="nav-text">内置锁</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">tallate</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">191</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">83</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tallate.github.io/3a140985.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tallate">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tallate">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="并发和同步策略 | Tallate">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          并发和同步策略
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-09-24 23:54:49" itemprop="dateCreated datePublished" datetime="2019-09-24T23:54:49+08:00">2019-09-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-07 01:56:20" itemprop="dateModified" datetime="2025-07-07T01:56:20+08:00">2025-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>通过操作 Thread、Object 的 API 和内置锁我们可以解决大部分的线程协调问题，但这绝不是最优雅的方式，接下来我们就来见识一下 JUC 中的各种高效线程同步工具。</p>
<span id="more"></span>

<h2 id="锁的原理"><a href="#锁的原理" class="headerlink" title="锁的原理"></a>锁的原理</h2><h3 id="线程同步和锁"><a href="#线程同步和锁" class="headerlink" title="线程同步和锁"></a>线程同步和锁</h3><p>线程同步不是必须的，但是不同步的情况下很有可能会导致数据不一致或其他不可预料的问题。<br>线程同步是让线程之间互相协调的机制，协调的前提是互相知道对方的存在，以计算机的角度来看，就是选定一块多线程均可访问的存储空间，或者令它们以某种机制互相通信。按存储区域的类别来分，有以下几种同步机制：</p>
<ul>
<li>内存<br>共享内存（进程内存）、锁（Lock）、互斥量（Mutex）、原子变量（Atomic）、阻塞队列（BlockingQueue）等。</li>
<li>磁盘<br>共享文件、消息队列等。</li>
<li>网络<br>Socket 等。</li>
</ul>
<p>像 Java 中 Thread 的 wait、notify 的实现基本也可以使用内存共享来解释，只不过它们是 native 方法，实现由平台说了算；volatile 关键字不能算是同步机制，因为它实际上无法保证线程安全性。</p>
<h3 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h3><p>乐观锁和悲观锁是在数据库中使用的名词。</p>
<ul>
<li>悲观锁<br>悲观锁指对数据被外界修改持保守态度，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制，数据库中实现是对数据记录操作前给记录加<strong>排它锁</strong>。如果获取锁失败，则说明数据正在被其它线程修改，则等待或者抛出异常。如果加锁成功，则获取记录，对其修改，然后事务提交后释放排它锁。<br>使用悲观锁的一个常用的例子： <code>select * from 表 where .. for update;</code>。</li>
<li>乐观锁<br>乐观锁是相对悲观锁来说的，它认为数据一般情况下不会造成冲突，所以在访问记录前不会加排它锁，而是在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测。具体说是根据 update 返回的行数让用户决定如何去做。<br>例如：<code>update 表 set comment=&#39;***&#39;,status=&#39;operator&#39;,version=version+1 where version = 1 and id = 1;</code><br>乐观锁并不会使用数据库提供的锁机制，一般在表添加 version 字段或者使用业务状态来做。乐观锁直到提交的时候才去锁定，所以不会产生任何锁和死锁。</li>
</ul>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的互相等待的现象，在无外力作用的情况下，这些线程会一直相互等待而无法继续运行下去。</p>
<h4 id="死锁产生的条件"><a href="#死锁产生的条件" class="headerlink" title="死锁产生的条件"></a>死锁产生的条件</h4><p>死锁的产生必须满足以下 4 个必要条件：</p>
<ul>
<li><strong>互斥条件</strong>：指线程对已经获取到的资源进行排它性使用，即该资源同时只由一个线程占用。如果此时还有其它进行请求获取该资源，则请求者只能等待，直至占有资源的线程用毕释放。</li>
<li><strong>请求并持有条件</strong>：指一个线程已经持有了至少一个资源，但又提出了新的资源请求，而新资源已被其其它线程占有，所以当前线程会被阻塞，但阻塞的同时并不释放自己已经获取的资源。</li>
<li><strong>不可剥夺条件</strong>：指线程获取到的资源在自己使用完之前不能被其它线程抢占，只有在自己使用完毕后由自己释放。</li>
<li><strong>环路等待条件</strong>：指在发生死锁时，必然存在一个线程——资源的环形链，即线程集合{T0，T1，T2，···，Tn}中的 T0 正在等待一个 T1 占用的资源；T1 正在等待 T2 占用的资源，……Tn 正在等待已被 T0 占用的资源。</li>
</ul>
<p>举个形象的例子，两辆车在窄道上相向而行，他们占着道不肯退开，又希望对方能让开，最终形成了死锁。<br>例 1 - 死锁：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">线程A：</span><br><span class="line">synchronized(resourceA) &#123;</span><br><span class="line">    sleep(1s)</span><br><span class="line">    synchronized(resourceB) &#123;</span><br><span class="line">        // do sth...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">线程B：</span><br><span class="line">synchronized(resourceB) &#123;</span><br><span class="line">    sleep(1s)</span><br><span class="line">    synchronized(resourceA) &#123;</span><br><span class="line">        // do sth...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先资源 resourceA 和 resourceB 都是互斥资源，当线程 A 调用 synchronized(resourceA) 获取到 resourceA 上的监视器锁后释放前，线程 B 在调用 synchronized(resourceA) 尝试获取该资源会被阻塞，只有线程 A 主动释放该锁，线程 B 才能获得，这满足了<strong>资源互斥条件</strong>。<br>线程 A 首先通过 synchronized(resourceA) 获取到 resourceA 上的监视器锁资源，然后通过 synchronized(resourceB) 等待获取到 resourceB 上的监视器锁资源，这就满足了<strong>持有并等待</strong>。<br>线程 A 在获取 resourceA 上的监视器锁资源后，不会被线程 B 掠夺走，只有线程 A 自己主动释放 resourceA 的资源时候，才会放弃对该资源的持有权，这满足了资源的<strong>不可剥夺条件</strong>。<br>线程 A 持有 objectA 资源并等待获取 objectB 资源，而线程 B 持有 objectB 资源并等待 objectA 资源，这满足了<strong>循环等待条件</strong>。<br>所以线程 A 和 B 就形成了死锁状态。</p>
<h4 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h4><p>要想避免死锁，需要破坏构造死锁必要条件的至少一个即可，但是目前只有持有并等待和循环等待是可以被破坏的。<br>其实，实现死锁避免最简单的方案就是控制资源申请的有序性。</p>
<h3 id="阻塞锁"><a href="#阻塞锁" class="headerlink" title="阻塞锁"></a>阻塞锁</h3><p>阻塞锁，可以说是让线程进入阻塞状态进行等待，当获得相应的信号（唤醒，时间） 时，才可以进入线程的准备就绪状态，准备就绪状态的所有线程，通过竞争，进入运行状态。<br>JAVA 中，能够进入\退出、阻塞状态或包含阻塞锁的方法有：synchronized 关键字（其中的重量锁）, ReentrantLock, Object.wait() &#x2F; notify(), LockSupport.park() &#x2F; unpart()</p>
<p>阻塞锁的优势在于，阻塞的线程不会占用 cpu 时间，不会导致 CPU 占用率过高，但进入时间以及恢复时间都要比自旋锁略慢。<br>在竞争激烈的情况下阻塞锁的性能要明显高于自旋锁。<br>理想的情况：在线程竞争不激烈的情况下使用自旋锁，竞争激烈的情况下使用阻塞锁。</p>
<h3 id="独占锁和共享锁"><a href="#独占锁和共享锁" class="headerlink" title="独占锁和共享锁"></a>独占锁和共享锁</h3><p>根据锁只能被单个线程持有还是能被多个线程共同持有，锁分为独占锁和共享锁。<br>独占锁保证任何时候都只有一个线程能得到锁，ReentrantLock 就是以独占方式实现的。共享锁则同时有多个线程可以持有，例如 ReadWriteLock 读写锁，它允许一个资源可以被多线程同时进行读操作。<br>独占锁是一种悲观锁，每次访问资源都先加上互斥锁，这限制了并发性，因为读操作并不会影响数据一致性，而独占锁只允许同时一个线程读取数据，其它线程必须等待当前线程释放锁才能进行读取。<br>共享锁则是一种乐观锁，它放宽了加锁的条件，允许多个线程同时进行读操作。</p>
<h3 id="公平性"><a href="#公平性" class="headerlink" title="公平性"></a>公平性</h3><p>锁有公平和非公平之分：</p>
<ul>
<li>公平锁：每个线程按调用 lock 的顺序来获取锁，不可插队；</li>
<li>非公平锁：每个线程获取锁的顺序不确定，存在插队的问题。</li>
</ul>
<p>平时使用的 ReentrantLock 默认的 lock()就是非公平锁，它会先尝试用 CAS 获取一次锁，若获取不到才进入一个队列等待锁的释放。<br>Semaphore 中，tryAcquire 是非公平的而 acquire 是公平的。<br>在没有公平性需求的前提下尽量使用非公平锁，因为公平锁会带来性能开销。</p>
<h3 id="可重入性"><a href="#可重入性" class="headerlink" title="可重入性"></a>可重入性</h3><p>当一个线程要获取一个被其它线程持有的独占锁时候，该线程会被阻塞，那么当一个线程再次获取它自己已经获取的锁时是否会被阻塞呢？如果不被阻塞，那么我们说该锁是可重入的，也就是只要该线程获取了该锁，那么可以无限制次数（高级篇我们会知道严格来说是有限次数）进入被该锁锁住的代码。</p>
<h4 id="可重入锁原理"><a href="#可重入锁原理" class="headerlink" title="可重入锁原理"></a>可重入锁原理</h4><p>可重入锁的原理是在锁内部维护了一个线程标示，用来标示该锁目前被那个线程占用，然后关联一个计数器。一开始计数器值为 0，说明该锁没有被任何线程占用，当一个线程获取了该锁，计数器会变成 1，其它线程在获取该锁时候发现锁的所有者不是自己就会被阻塞挂起。<br>但是当获取该锁的线程再次获取锁时候发现锁拥有者是自己，就会把计数器值+1， 当释放锁后计数器会-1，当计数器为 0 时候，锁里面的线程标示重置为 null，这时候阻塞的线程会获取被唤醒来竞争获取该锁。</p>
<h4 id="synchronized（监视器锁）是可重入的"><a href="#synchronized（监视器锁）是可重入的" class="headerlink" title="synchronized（监视器锁）是可重入的"></a>synchronized（监视器锁）是可重入的</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object lock = new Object();</span><br><span class="line">synchronized (lock) &#123;</span><br><span class="line">    synchronized (lock) &#123;</span><br><span class="line">        System.out.println(&quot;reentranted!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ReentrantLock-是可重入的"><a href="#ReentrantLock-是可重入的" class="headerlink" title="ReentrantLock 是可重入的"></a>ReentrantLock 是可重入的</h4><blockquote>
<p>废话，名字里 Reentrant 就是可重入的意思。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock lock = new ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line">lock.lock();</span><br><span class="line">System.out.println(&quot;reentranted!&quot;);</span><br><span class="line">lock.unlock();</span><br><span class="line">lock.unlock();</span><br></pre></td></tr></table></figure>
<h4 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h4><p>加锁分三种情况：</p>
<ul>
<li>读锁本身定义就支持重入；</li>
<li>写锁支持重入  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ReentrantReadWriteLock rwlock = new ReentrantReadWriteLock();</span><br><span class="line">rwlock.writeLock().lock();</span><br><span class="line">rwlock.writeLock().lock();</span><br><span class="line">System.out.println(&quot;reentranted!&quot;);</span><br><span class="line">rwlock.writeLock().unlock();</span><br><span class="line">rwlock.writeLock().unlock();</span><br></pre></td></tr></table></figure></li>
<li>读锁和写锁同时使用会死锁  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ReentrantReadWriteLock rwlock = new ReentrantReadWriteLock();</span><br><span class="line">rwlock.readLock().lock();</span><br><span class="line">rwlock.writeLock().lock();</span><br><span class="line">System.out.println(&quot;reentranted!&quot;);</span><br><span class="line">rwlock.writeLock().unlock();</span><br><span class="line">rwlock.readLock().unlock();</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="抢占"><a href="#抢占" class="headerlink" title="抢占"></a>抢占</h3><p>TODO</p>
<h3 id="SpinLock（自旋锁）"><a href="#SpinLock（自旋锁）" class="headerlink" title="SpinLock（自旋锁）"></a>SpinLock（自旋锁）</h3><p>自旋锁是采用让当前线程不停地的在循环体内执行实现的，当循环的条件被其他线程改变时才能进入临界区。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class SpinLock &#123;</span><br><span class="line">    private AtomicReference&lt;Thread&gt; sign = new AtomicReference&lt;&gt;();</span><br><span class="line">    public void lock()&#123;</span><br><span class="line">        final Thread current = Thread.currentThread();</span><br><span class="line">        // 当sign的值为null时才设置为current</span><br><span class="line">        while(!sign.compareAndSet(null, current))&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void unlock ()&#123;</span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        sign.compareAndSet(current, null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class LockTest &#123;</span><br><span class="line">    SpinLock spinLock = new SpinLock();</span><br><span class="line">    @Test</span><br><span class="line">    public void test() &#123;</span><br><span class="line">        Runnable runnable = () -&gt; &#123;</span><br><span class="line">            spinLock.lock();</span><br><span class="line">            Random random = new Random();</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            spinLock.unlock();</span><br><span class="line">        &#125;;</span><br><span class="line">        new Thread(runnable).start();</span><br><span class="line">        new Thread(runnable).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于自旋锁只是将当前线程不停地执行循环体，不进行线程状态的改变，所以响应速度更快。<br>但当线程数不停增加时，性能下降明显，因为每个线程都需要执行，占用 CPU 时间。<br>如果线程竞争不激烈，并且保持锁的时间短，适合使用自旋锁。<br>该例子为非公平锁，获得锁的先后顺序不会按照进入 lock 的先后顺序进行。</p>
<h3 id="锁算法-CLHLock（Craig-Landin-and-Hagersten-locks）"><a href="#锁算法-CLHLock（Craig-Landin-and-Hagersten-locks）" class="headerlink" title="锁算法 - CLHLock（Craig, Landin, and Hagersten locks）"></a>锁算法 - CLHLock（Craig, Landin, and Hagersten locks）</h3><p>使用链表协调每个线程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class CLHLock &#123;</span><br><span class="line"></span><br><span class="line">    public static class CLHNode &#123;</span><br><span class="line">        // 刚开始当前线程是锁住的</span><br><span class="line">        private volatile Thread isLocked;</span><br><span class="line">        // boolean方案、private volatile boolean isLocked = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&quot;unused&quot;)</span><br><span class="line">    private volatile CLHNode tail;</span><br><span class="line">    private static final ThreadLocal&lt;CLHNode&gt; LOCAL = new ThreadLocal&lt;&gt;();</span><br><span class="line">    private static final AtomicReferenceFieldUpdater&lt;CLHLock, CLHNode&gt; UPDATER =</span><br><span class="line">            AtomicReferenceFieldUpdater.newUpdater(CLHLock.class, CLHNode.class, &quot;tail&quot;);</span><br><span class="line"></span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        CLHNode node = new CLHNode();</span><br><span class="line">        LOCAL.set(node);</span><br><span class="line">        // 原子更新当前CLHLock对应的值，并返回旧值</span><br><span class="line">        // getAndSet使自己成为队列的尾部，同时获取其前驱节点的引用</span><br><span class="line">        // 如果是第一个调用lock的，直接返回，如果不是，则等待上一个unlock</span><br><span class="line">        CLHNode preNode = UPDATER.getAndSet(this, node);</span><br><span class="line">        if (preNode != null) &#123;</span><br><span class="line">            // boolean方案：while(preNode.isLocked) &#123;&#125;</span><br><span class="line">            preNode.isLocked = Thread.currentThread();</span><br><span class="line">            LockSupport.park(this);</span><br><span class="line">            preNode = null;</span><br><span class="line">            LOCAL.set(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        CLHNode node = LOCAL.get();</span><br><span class="line">        if (!UPDATER.compareAndSet(this, node, null)) &#123;</span><br><span class="line">            // boolean方案：node.isLocked = false;</span><br><span class="line">            System.out.println(&quot;unlock\t&quot; + node.isLocked.getName());</span><br><span class="line">            LockSupport.unpark(node.isLocked);</span><br><span class="line">        &#125;</span><br><span class="line">        node = null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中注明了另一种 boolean 实现方案，boolean 方案看起来会直观一点。</p>
<p>JUC ReentrantLock 默认内部使用的锁 即是 CLH 锁（有很多改进的地方，将自旋锁换成了阻塞锁等等）。<br>CLH 队列锁的优点是空间复杂度低（如果有 n 个线程，L 个锁，每个线程每次只获取一个锁，那么需要的存储空间是 O(L+n)，n 个线程有 n 个 Node，L 个锁有 L 个 tail），CLH 的一种变体被应用在了 JAVA 并发框架中（AbstractQueuedSynchronizer.Node）。<br>CLH 在 SMP 系统结构下是非常有效的，但在 NUMA 系统结构下，每个线程有自己的内存，而 CLHLock 会不停地查询前驱变量，如果前趋结点的内存位置比较远，自旋判断前趋结点的 locked 域，性能将大打折扣，一种解决 NUMA 系统结构的思路是 MCS 队列锁。</p>
<h3 id="锁算法-MCSLock"><a href="#锁算法-MCSLock" class="headerlink" title="锁算法 - MCSLock"></a>锁算法 - MCSLock</h3><p>MCSLock 则是对本地变量的节点进行循环，不会出现 CLHLock 的问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class MCSLock &#123;</span><br><span class="line"></span><br><span class="line">    public static class MCSNode &#123;</span><br><span class="line"></span><br><span class="line">        volatile MCSNode next;</span><br><span class="line">        volatile boolean isLocked = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static final ThreadLocal&lt;MCSNode&gt; NODE = new ThreadLocal&lt;MCSNode&gt;();</span><br><span class="line">    @SuppressWarnings(&quot;unused&quot;)</span><br><span class="line">    private volatile MCSNode queue;</span><br><span class="line">    private static final AtomicReferenceFieldUpdater&lt;MCSLock, MCSNode&gt; UPDATER = AtomicReferenceFieldUpdater.newUpdater(MCSLock.class,</span><br><span class="line">            MCSNode.class, &quot;queue&quot;);</span><br><span class="line"></span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        MCSNode currentNode = new MCSNode();</span><br><span class="line">        NODE.set(currentNode);</span><br><span class="line">        MCSNode preNode = UPDATER.getAndSet(this, currentNode);</span><br><span class="line">        if (preNode != null) &#123;</span><br><span class="line">            preNode.next = currentNode;</span><br><span class="line">            while (currentNode.isLocked) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        MCSNode currentNode = NODE.get();</span><br><span class="line">        if (currentNode.next == null) &#123;</span><br><span class="line">            if (!UPDATER.compareAndSet(this, currentNode, null)) &#123;</span><br><span class="line">                while (currentNode.next == null) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            currentNode.next.isLocked = false;</span><br><span class="line">            currentNode.next = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CLH 的队列是隐式的队列，没有真实的后继结点属性。<br>MCS 的队列是显式的队列，有真实的后继结点属性。</p>
<h3 id="锁算法-TicketLock"><a href="#锁算法-TicketLock" class="headerlink" title="锁算法 - TicketLock"></a>锁算法 - TicketLock</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class TicketLock &#123;</span><br><span class="line"></span><br><span class="line">    private AtomicInteger serviceNum = new AtomicInteger();</span><br><span class="line">    private AtomicInteger ticketNum = new AtomicInteger();</span><br><span class="line">    private static final ThreadLocal&lt;Integer&gt; LOCAL =</span><br><span class="line">            new ThreadLocal&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        // 得到门票</span><br><span class="line">        int myticket = ticketNum.getAndIncrement();</span><br><span class="line">        LOCAL.set(myticket);</span><br><span class="line">        // 如果当前叫票和自己的票号不同</span><br><span class="line">        while (myticket != serviceNum.get()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        int myticket = LOCAL.get();</span><br><span class="line">        // compareAndSet内部会循环判断当前值是否为myticket，然后才执行赋值操作</span><br><span class="line">        serviceNum.compareAndSet(myticket, myticket + 1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Test</span><br><span class="line">    public void test() throws InterruptedException &#123;</span><br><span class="line">        // TicketLock保存在主线程内，子线程每次lock拿到一张票，</span><br><span class="line">        // 此时别的线程unlock，直到票数增长到自己的票号</span><br><span class="line">        TicketLock ticketLock = new TicketLock();</span><br><span class="line">        Runnable runnable = () -&gt; &#123;</span><br><span class="line">            ticketLock.lock();</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            ticketLock.unlock();</span><br><span class="line">        &#125;;</span><br><span class="line">        for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">            // 线程的执行顺序和每个线程调用lock的顺序相同</span><br><span class="line">            new Thread(runnable).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TicketLock，主要解决的是访问顺序的问题，主要的问题是在多核 cpu 上。<br>缺点是每次都要查询一个 serviceNum 服务号，影响性能（必须要到主内存读取，并阻止其他 cpu 修改）。</p>
<h2 id="内置锁-synchronized"><a href="#内置锁-synchronized" class="headerlink" title="内置锁 - synchronized"></a>内置锁 - synchronized</h2><p>内置锁在Java中被抽象为<strong>监视器锁（monitor）</strong>。在 JDK 1.6 之前，监视器锁可以认为直接对应底层操作系统中的<strong>互斥量（mutex）</strong>。<br>在JDK1.6之前，内置锁的成本较高，包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等，因此被称为<strong>重量级锁</strong>，但是 JDK1.6 内置锁引入了升级策略。</p>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>优势：减少了线程阻塞时的线程上下文切换开销，锁的粒度越小这种性能提升会越明显，因为锁阻塞造成线程切换的时间与锁持有的时间相当。<br>缺点：自旋锁会额外占用CPU，如果是<strong>计算密集型</strong>任务，这一优化通常会得不偿失，线程多而处理器少的时候尤其如此。<br>如果锁粒度较大且竞争激烈，会导致长时间的自旋等待，白白浪费自旋占用的 CPU 时间。</p>
<blockquote>
<p>使用-XX:-UseSpinning 参数关闭自旋锁优化；-XX:PreBlockSpin 参数修改默认的自旋次数。</p>
</blockquote>
<h3 id="自适应自旋锁"><a href="#自适应自旋锁" class="headerlink" title="自适应自旋锁"></a>自适应自旋锁</h3><p>普通自旋锁的自旋时间是固定的，但有时可以做些调整，比如一个锁之前被成功加锁成功过那么这次也很有可能被自旋获取成功。<br>自适应意味着自旋的时间不再固定，而是由前一次在同一个锁上的自旋时间及锁持有者的状态来决定的：</p>
<ul>
<li>如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间，比如100个循环。</li>
<li>相反的，如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能减少自旋时间甚至省略自旋过程，以避免浪费处理器资源。</li>
</ul>
<p>优势：解决了锁竞争时间不确定的问题，自适应自旋假定不同线程持有同一个锁对象的时间基本相当，即竞争程度趋于稳定，因此可以根据上一次自旋的时间与结果调整下一次自旋的时间。<br>缺点：自适应自旋没能彻底解决锁竞争时间不确定的问题，如果默认的自旋次数设置不合理，那么自适应的过程将很难收敛到合适的值。</p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>自旋锁的目标是降低线程切换的成本，如果锁竞争激烈，则不得不依赖重量级锁，但是还有一种情况锁竞争并不激烈，只是锁被持有的时间较长，导致其他线程自旋获取锁的时间较长，此时并没有实际的锁竞争，轻量级锁的目标就是在这种情况下，减少使用重量级锁产生的性能消耗，包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等。<br>轻量级锁是相对于重量级锁而言的。使用轻量级锁时，不需要申请互斥量，仅仅将对象头<strong>Mark Word</strong>中的部分字节通过 CAS 更新成指向线程栈中的 Lock Record，如果更新成功，则轻量级锁获取成功，记录锁状态为轻量级锁；否则，说明已经有线程获得了轻量级锁，目前发生了锁竞争（不适合继续使用轻量级锁），接下来膨胀为重量级锁。<br>优势：在不存在锁竞争的场景下，减少使用重量级锁产生的性能消耗。<br>缺点：如果锁竞争激烈，那么轻量级锁很快会膨胀为重量级锁，这种情况下维持轻量级锁的开销就浪费了。</p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>在没有实际竞争的情况下，还能够针对部分场景继续优化：自始至终都只有一个线程尝试获取该锁。轻量级锁每次申请、释放锁都至少需要一次 CAS，但偏向锁只有初始化时需要一次 CAS，在 Mark Word 中 CAS 记录 owner，如果记录成功，则偏向锁获取成功，记录锁状态为偏向锁，以后<strong>当前线程等于owner就可以零成本的直接获得锁</strong>；否则，说明有其他线程竞争，膨胀为轻量级锁。<br>优势：减少了轻量级锁执行CAS的开销。<br>缺陷：如果明显存在其他线程申请同一个锁，那么偏向锁将很快膨胀为轻量级锁。</p>
<blockquote>
<p>如果需要，可以使用参数-XX:-UseBiasedLocking禁止偏向锁优化（默认打开）。</p>
</blockquote>
<h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>重量级锁可以作为降级方案，在自旋几次后使用重量级锁阻塞，既减少了线程切换，又不会因为长时间自旋导致 CPU 被打满。</p>
<h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>大部分情况下我们都倾向于将同步块的作用范围限制得尽可能小——只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数尽可能少，当发生锁竞争时等待锁的线程能尽可能快地拿到锁。<br>但是如果一系列的操作都对同一个对象反复加锁和释放，甚至这样的情况是发生在<strong>循环体</strong>中的，那么即使没有线程竞争，频繁地进行加锁也会导致不必要的性能损耗。虚拟机如果探测到有这样一串零碎的操作都对同一个对象加锁，就会将加锁同步的范围<strong>粗化</strong>到整个操作序列的外面。</p>
<h3 id="锁分配和膨胀策略"><a href="#锁分配和膨胀策略" class="headerlink" title="锁分配和膨胀策略"></a>锁分配和膨胀策略</h3><p>总而言之，内置锁具有一下三种加锁策略：</p>
<ul>
<li>偏向锁：无实际竞争，且将来只有第一个申请锁的线程会使用锁。</li>
<li>轻量级锁：无实际竞争，多个线程交替使用锁；允许短时间的锁竞争。</li>
<li>重量级锁：有实际竞争，且锁竞争时间长。</li>
</ul>
<p>如果锁竞争时间短，可以使用自旋锁进一步优化轻量级锁、重量级锁的性能，减少线程切换。<br>如果锁竞争程度逐渐提高（缓慢），那么从偏向锁逐步膨胀到重量锁，能够提高系统的整体性能。<br>但是<strong>内置锁不存在反向的“收缩”过程</strong>，这基于JVM的另一个假定，“一旦破坏了上一级锁的假定，就认为该假定以后也必不成立”。</p>
<p>内置锁的实现基于对象头，对象头主要包含两部分数据：<strong>Mark Word（标记字段）</strong>和<strong>Class Pointer（类型指针）</strong>：</p>
<ul>
<li>Class Pointer是对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象属于哪个类的实例；</li>
<li>Mark Word用于存储对象自身的运行时数据，它是实现轻量级锁和偏向锁的关键。<br><img src="/imgs/%E5%B9%B6%E5%8F%91/MarkWord%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" alt="MarkWord存储结构" title="MarkWord存储结构"></li>
</ul>
<p>内置锁的分配策略是膨胀式的，偏向锁、轻量级锁、重量级锁，下图来源网上，对内置锁的加锁流程描述比较全：<br><img src="/imgs/%E5%B9%B6%E5%8F%91/%E9%94%81%E5%88%86%E9%85%8D%E5%92%8C%E8%86%A8%E8%83%80%E8%BF%87%E7%A8%8B.png" alt="锁分配和膨胀过程" title="锁分配和膨胀过程"><br>上图来自参考<code>[1]</code>，由图可知锁膨胀的具体历程：</p>
<ol>
<li>从偏向锁到轻量级锁<br>判断锁状态，刚开始是偏向锁（值为 01），这时就可以通过 CAS 设置线程 ID 到对象头。<br>刚开始只有第一个申请偏向锁的线程能够申请成功，并在对象头处设置 owner 属性，后续的线程尝试通过 CAS 操作设置 owner 都是必然失败的，因此不能获取成功。<br>线程申请偏向锁并执行结束后，会重新将对象头中的线程 ID 清除，之后其他线程就又可以重新获取偏向锁了。<br>当尝试 CAS 设置线程 ID 失败时会开始执行锁升级，升级到轻量级锁。</li>
<li>从轻量级锁到重量级锁<br>锁升级时可能此时正有另一个线程正持有偏向锁，这时我们要记对应线程为锁的持有者：先在持有线程的栈中分配锁记录，然后设置对象头中的锁记录指针指向该锁记录。<br>锁竞争就是CAS设置对象头中的锁记录指针指向当前线程的锁记录。<br>锁释放就是清除对象头中的锁记录指针，之后唤醒其他正在等待的线程。<br>当锁竞争经过一定自旋次数后仍然没有获取成功时，将锁升级为重量级锁。</li>
</ol>
<p><img src="/imgs/%E5%B9%B6%E5%8F%91/synchronized%E9%94%81%E8%86%A8%E8%83%80%E7%9A%84%E7%AE%80%E5%8C%96%E7%89%88%E8%BF%87%E7%A8%8B.png" alt="synchronized锁膨胀的简化版过程" title="synchronized锁膨胀的简化版过程"></p>
<h2 id="可重入锁-ReentrantLock"><a href="#可重入锁-ReentrantLock" class="headerlink" title="可重入锁 - ReentrantLock"></a>可重入锁 - ReentrantLock</h2><p>ReentrantLock 是可重入的独占锁，同时获取锁的线程中只有一个能获取成功，其余的线程会被阻塞后放入该锁的 AQS 阻塞队列里。<br><img src="/imgs/%E5%B9%B6%E5%8F%91/ReentrantLock%E7%B1%BB%E5%9B%BE.png" alt="ReentrantLock类图" title="ReentrantLock类图"><br><img src="/imgs/%E5%B9%B6%E5%8F%91/ReentrantLock%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="ReentrantLock执行流程" title="ReentrantLock执行流程"></p>
<h4 id="ReentrantLock-vs-synchronized"><a href="#ReentrantLock-vs-synchronized" class="headerlink" title="ReentrantLock vs synchronized"></a>ReentrantLock vs synchronized</h4><ul>
<li>粒度和灵活度：ReentrantLock 优于 synchronized；</li>
<li>性能：ReentrantLock 的原理是自旋锁，通过循环 CAS 操作来加锁。随着 JDK 后来版本的优化，synchronized 同样引入了偏向锁和轻量级锁（自旋锁），两者性能相差不多。<blockquote>
<p>这种优化减少了线程在用户态和内核态之间的切换。</p>
</blockquote>
</li>
<li>ReentrantLock 可以指定是公平锁还是非公平锁。而 synchronized 只能是非公平锁。</li>
<li>ReenTrantLock 提供了一个 Condition（条件）类，用来实现分组唤醒需要唤醒的线程们，而不是像 synchronized 要么随机唤醒一个线程要么唤醒全部线程。</li>
<li>ReenTrantLock 提供了一种能够中断等待锁的线程的机制，通过 lock.lockInterruptibly()来实现这个机制。</li>
</ul>
<h4 id="公平性-1"><a href="#公平性-1" class="headerlink" title="公平性"></a>公平性</h4><p>ReentrantLock 支持两种获取锁的方式，一种是公平模型，一种是非公平模型。<br>默认情况下，ReentrantLock 是非公平的，可以通过构造方法来构建公平的锁。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public ReentrantLock() &#123;</span><br><span class="line">    sync = new NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line">public ReentrantLock(boolean fair) &#123;</span><br><span class="line">    sync = fair ? new FairSync() : new NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>NonfairSync</code>和<code>FairSync</code>都是AQS的实现，分别实现了公平和非公平策略。<br>在这里 AQS 的状态值 <code>state</code> 代表线程获取该锁的可重入次数，默认情况下 state 的值为 0 标示当前锁没有被任何线程持有，当一个线程第一次获取该锁时候会使用尝试使用 CAS 设置 state 的值为 1，如果 CAS 成功则当前线程获取了该锁，然后记录该锁的持有者为当前线程，在该线程没有释放锁第二次获取改锁后状态值被为 2，这就是可重入次数，在该线程释放该锁的时候，会尝试使用 CAS 让状态值减一，如果减一后状态值为 0 则当前线程释放该锁。</p>
<h4 id="获取非公平锁"><a href="#获取非公平锁" class="headerlink" title="获取非公平锁"></a>获取非公平锁</h4><p>ReentrantLock.lock：默认获取<strong>非公平锁</strong><br>-&gt; ReentrantLock.NonfairSync.lock CAS 设置锁状态（state），设置锁的持有者为当前线程，然后调用 AQS acquire</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">final void lock() &#123;</span><br><span class="line">  //（1）CAS设置状态值</span><br><span class="line">  if (compareAndSetState(0, 1))</span><br><span class="line">      setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">  else</span><br><span class="line">  //（2）调用AQS的acquire方法</span><br><span class="line">      acquire(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>-&gt; AbstractQueuedSynchronizer.acquire：tryAcquire 尝试获取锁，获取失败则 acquireQueued 添加到 AQS 队列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    // 调用ReentrantLock重写的tryAcquire方法</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        // tryAcquire返回false会把当前线程放入AQS阻塞队列</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>-&gt; ReentrantLock.NonfairSync.tryAcquire：tryAcquire需要子类重写，在ReentrantLock中其主要功能是修改state</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">    return nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final boolean nonfairTryAcquire(int acquires) &#123;</span><br><span class="line">    final Thread current = Thread.currentThread();</span><br><span class="line">    int c = getState();</span><br><span class="line">    // 当前AQS状态值为0，说明锁是空闲的</span><br><span class="line">    if (c == 0) &#123;</span><br><span class="line">        // CAS尝试将state修改为1</span><br><span class="line">        if (compareAndSetState(0, acquires)) &#123;</span><br><span class="line">            // 设置当前锁的持有者为当前线程</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 当前线程已是该锁持有者</span><br><span class="line">    else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        // 状态值增加1</span><br><span class="line">        int nextc = c + acquires;</span><br><span class="line">        if (nextc &lt; 0) // overflow</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的非公平策略在获取锁的时候并没有考虑AQS队列中是否已经存在等待中的线程。</p>
<h4 id="获取公平锁"><a href="#获取公平锁" class="headerlink" title="获取公平锁"></a>获取公平锁</h4><p>ReentrantLock.lock(true)：显式指定采用公平策略。<br>-&gt; ReentrantLock.FairSync.lock<br>-&gt; AbstractQueuedSynchronizer.acquire<br>-&gt; ReentrantLock.FairSync.tryAcquire</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">    final Thread current = Thread.currentThread();</span><br><span class="line">    int c = getState();</span><br><span class="line">    if (c == 0) &#123;</span><br><span class="line">        // 公平策略：队列中没有线程已在等待</span><br><span class="line">        if (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            // CAS修改state，即加锁</span><br><span class="line">            compareAndSetState(0, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 当前线程是该锁的持有者</span><br><span class="line">    else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        int nextc = c + acquires;</span><br><span class="line">        if (nextc &lt; 0)</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 这个方法用于保证公平性</span><br><span class="line"> * 但是仍不能排除竞争的情况，比如这个方法返回false后立刻就有另一个线程入队了</span><br><span class="line"> */</span><br><span class="line">public final boolean hasQueuedPredecessors() &#123;</span><br><span class="line">    // The correctness of this depends on head being initialized</span><br><span class="line">    // before tail and on head.next being accurate if the current</span><br><span class="line">    // thread is first in queue.</span><br><span class="line">    Node t = tail; // Read fields in reverse initialization order</span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    // h==t说明当前队列为空</span><br><span class="line">    return h != t &amp;&amp;</span><br><span class="line">        // s==null说明有一个元素将作为AQS的首节点入队，或者s.thread != Thread.currentThread() 说明队列里已经有线程在等待</span><br><span class="line">        ((s = h.next) == null || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="lockInterruptibly-对中断的响应"><a href="#lockInterruptibly-对中断的响应" class="headerlink" title="lockInterruptibly 对中断的响应"></a>lockInterruptibly 对中断的响应</h4><p>ReentrantLock 提供了可中断的加锁 API，比如 lockInterruptibly 能够在当前线程被其他线程调用 interrupt 方法中断后直接返回：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void lockInterruptibly() throws InterruptedException &#123;</span><br><span class="line">    sync.acquireInterruptibly(1);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">public final void acquireInterruptibly(int arg)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    // 检查中断标志位，已中断则直接抛出异常</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    // 尝试获取资源</span><br><span class="line">    if (!tryAcquire(arg))</span><br><span class="line">        // AQS的可被中断方法</span><br><span class="line">        doAcquireInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="tryLock-尝试获取锁"><a href="#tryLock-尝试获取锁" class="headerlink" title="tryLock 尝试获取锁"></a>tryLock 尝试获取锁</h4><p>tryLock 和 lock 接口的主要区别是 tryLock 是非阻塞的，它尝试获取锁失败后，并不会将线程放入队列中等待。<br>具体代码和 lock 差别不大，这里不再赘述。<br>tryLock 还有一个可以设置最长等待时间的接口，每次尝试获取锁失败后，会通过<code>LockSupport.parkNanos</code>来挂起指定时间，当条件变量释放或锁被释放时会调用<code>LockSupport.unpark</code>来尝试唤醒。</p>
<h4 id="unlock-释放锁"><a href="#unlock-释放锁" class="headerlink" title="unlock 释放锁"></a>unlock 释放锁</h4><p>尝试释放锁，如果当前线程持有该锁，调用该方法会让该线程对该线程持有的 AQS 状态值减一，如果减去 1 后当前状态值为 0 则当前线程会释放对该锁的持有，否则仅仅减一。如果当前线程没有持有该锁调用了该方法则会抛出 IllegalMonitorStateException 异常。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public void unlock() &#123;</span><br><span class="line">    sync.release(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">    // 如果不是锁持有者调用unlock则抛出异常。</span><br><span class="line">    int c = getState() - releases;</span><br><span class="line">    if (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        throw new IllegalMonitorStateException();</span><br><span class="line">    boolean free = false;</span><br><span class="line">    // 如果当前可重入次数为0，则清空锁持有线程</span><br><span class="line">    if (c == 0) &#123;</span><br><span class="line">        free = true;</span><br><span class="line">        setExclusiveOwnerThread(null);</span><br><span class="line">    &#125;</span><br><span class="line">    // 设置可重入次数为原始值-1</span><br><span class="line">    setState(c);</span><br><span class="line">    return free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="读写锁-ReentrantReadWriteLock"><a href="#读写锁-ReentrantReadWriteLock" class="headerlink" title="读写锁 - ReentrantReadWriteLock"></a>读写锁 - ReentrantReadWriteLock</h2><p><img src="/imgs/%E5%B9%B6%E5%8F%91/ReentrantReadWriteLock%E7%B1%BB%E5%9B%BE.png" alt="ReentrantReadWriteLock类图" title="ReentrantReadWriteLock类图"></p>
<ul>
<li>firstReader 用来记录第一个获取到读锁的线程；</li>
<li>firstReaderHoldCount 则记录第一个获取到读锁的线程获取读锁的可重入数；</li>
<li>cachedHoldCounter 用来记录最后一个获取读锁的线程获取读锁的可重入次数。  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static final class HoldCounter &#123;</span><br><span class="line">    int count = 0;</span><br><span class="line">    // Use id, not reference, to avoid garbage retention</span><br><span class="line">    final long tid = getThreadId(Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>readHolds 是 ThreadLocal 变量，用来存放除去第一个获取读锁线程外的其它线程获取读锁的可重入数, 可知 ThreadLocalHoldCounter 继承了 ThreadLocal，里面 initialValue 方法返回一个 HoldCounter 对象。  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static final class ThreadLocalHoldCounter</span><br><span class="line">    extends ThreadLocal&lt;HoldCounter&gt; &#123;</span><br><span class="line">    public HoldCounter initialValue() &#123;</span><br><span class="line">        return new HoldCounter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>AQS 只维护了一个 state 状态变量，ReentrantReadWriteLock 利用其高 16 位表示读状态也就是获取该读锁的线程个数，低 16 位表示获取到写锁的线程的可重入次数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static final int SHARED_SHIFT   = 16;</span><br><span class="line"></span><br><span class="line">// 共享锁（读锁）状态单位值65536 </span><br><span class="line">static final int SHARED_UNIT    = (1 &lt;&lt; SHARED_SHIFT);</span><br><span class="line">// 共享锁线程最大个数65535</span><br><span class="line">static final int MAX_COUNT      = (1 &lt;&lt; SHARED_SHIFT) - 1;</span><br><span class="line"></span><br><span class="line">// 排它锁(写锁)掩码 二进制 15个1</span><br><span class="line">static final int EXCLUSIVE_MASK = (1 &lt;&lt; SHARED_SHIFT) - 1;</span><br><span class="line"></span><br><span class="line">// 返回读锁线程数</span><br><span class="line">static int sharedCount(int c)    &#123; return c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br><span class="line">// 返回写锁可重入个数</span><br><span class="line">static int exclusiveCount(int c) &#123; return c &amp; EXCLUSIVE_MASK; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="writeLock-lock-获取写锁"><a href="#writeLock-lock-获取写锁" class="headerlink" title="writeLock.lock 获取写锁"></a>writeLock.lock 获取写锁</h4><p>写锁是个独占锁，同时只有一个线程可以获取该锁。 如果当前没有线程获取到读锁和写锁则当前线程可以获取到写锁然后返回。如果当前已经有线程取到读锁和写锁则当前线程则当前请求写锁线程会被阻塞挂起。<br>另外写锁是<strong>可重入</strong>锁，如果当前线程已经获取了该锁，再次获取的只是简单的把可重入次数加1后直接返回。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public void lock() &#123;</span><br><span class="line">   sync.acquire(1);</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * AbstractQueuedSynchronizer.acquire</span><br><span class="line"> */</span><br><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    // sync重写的tryAcquire方法</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * ReentrantReadWriteLock.Sync.tryAcquire</span><br><span class="line"> */</span><br><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line"></span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    // AQS的state变量</span><br><span class="line">    int c = getState();</span><br><span class="line">    // 写锁已被获取的次数</span><br><span class="line">    int w = exclusiveCount(c);</span><br><span class="line">    // c!=0说明读锁或者写锁已经被某线程获取</span><br><span class="line">    if (c != 0) &#123;</span><br><span class="line">        // w=0说明已经有线程获取了读锁或者w!=0并且当前线程不是写锁拥有者，则返回false</span><br><span class="line">        if (w == 0 || current != getExclusiveOwnerThread())</span><br><span class="line">            return false;</span><br><span class="line">        // 说明某线程获取了写锁，判断可重入个数</span><br><span class="line">        if (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line"></span><br><span class="line">        // 设置可重入数量</span><br><span class="line">        setState(c + acquires);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 此时没有线程获取到读锁和写锁</span><br><span class="line">    if (writerShouldBlock() ||</span><br><span class="line">        !compareAndSetState(c, c + acquires))</span><br><span class="line">        return false;</span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于非公平锁来说，获取写锁时不需要阻塞，writerShouldBlock的实现为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">final boolean writerShouldBlock() &#123;</span><br><span class="line">    return false; // writers can always barge</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>公平锁中的实现为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">final boolean writerShouldBlock() &#123;</span><br><span class="line">    // 当前线程节点是否有前驱节点</span><br><span class="line">    return hasQueuedPredecessors();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="writeLock-lockInterruptibly"><a href="#writeLock-lockInterruptibly" class="headerlink" title="writeLock.lockInterruptibly"></a>writeLock.lockInterruptibly</h4><p>可中断的，如果其他线程调用了当前线程的<code>interrupt</code>方法，则当前线程抛出<code>InterruptedException</code>异常。</p>
<h4 id="writeLock-tryLock"><a href="#writeLock-tryLock" class="headerlink" title="writeLock.tryLock"></a>writeLock.tryLock</h4><p>尝试获取写锁：</p>
<ul>
<li>如果当前线程已经持有了该写锁则简单增加 AQS 的状态值后直接返回 true；</li>
<li>如果当前没有其它线程持有写锁或者读锁，则当前线程获取写锁会成功；</li>
<li>如果当前已经其它线程持有写锁或者读锁则获取失败，当前线程并不会被阻塞。</li>
</ul>
<h4 id="writeLock-tryLock-long-timeout-TimeUnit-unit"><a href="#writeLock-tryLock-long-timeout-TimeUnit-unit" class="headerlink" title="writeLock.tryLock(long timeout, TimeUnit unit)"></a>writeLock.tryLock(long timeout, TimeUnit unit)</h4><ul>
<li>尝试获取一次写锁，如果获取失败则等待一段时间后再尝试获取一次，如果失败则返回false；</li>
<li>可以响应中断，被<code>interrupt</code>中断后抛出<code>InterruptedException</code>异常。</li>
</ul>
<h4 id="writeLock-unlock"><a href="#writeLock-unlock" class="headerlink" title="writeLock.unlock"></a>writeLock.unlock</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public void unlock() &#123;</span><br><span class="line">    sync.releaseShared(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">    if (tryRelease(arg)) &#123;</span><br><span class="line">        // 激活队列里下一个线程</span><br><span class="line">        Node h = head;</span><br><span class="line">        if (h != null &amp;&amp; h.waitStatus != 0)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">    // 是否是写锁调用的unlock（exclusively表示互斥的）</span><br><span class="line">    if (!isHeldExclusively())</span><br><span class="line">        throw new IllegalMonitorStateException();</span><br><span class="line">    // 写锁负责state的低16位，表示可重入值，这里没有考虑高16位，因为写锁时候读锁状态值肯定为0</span><br><span class="line">    int nextc = getState() - releases;</span><br><span class="line">    boolean free = exclusiveCount(nextc) == 0;</span><br><span class="line">    // 如果写锁可重入值为0则释放锁，否则只是简单更新状态值</span><br><span class="line">    if (free)</span><br><span class="line">        setExclusiveOwnerThread(null);</span><br><span class="line">    setState(nextc);</span><br><span class="line">    return free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ReadLock-lock"><a href="#ReadLock-lock" class="headerlink" title="ReadLock.lock"></a>ReadLock.lock</h4><p>读锁是共享锁，多个线程可以同时获取读锁，因此为了计算每个线程的重入次数，不能单纯使用state计数，而是另外用一个<code>ThreadLocal</code>类型的<code>readHolds</code>来记录每个线程获取读锁的次数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">public void lock() &#123;</span><br><span class="line">    sync.acquireShared(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final void acquireShared(int arg) &#123;</span><br><span class="line">    // 调用ReentrantReadWriteLock中的sync的tryAcquireShared方法</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">        // 调用AQS的doAcquireShared方法，把当前线程放入阻塞队列</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected final int tryAcquireShared(int unused) &#123;</span><br><span class="line"></span><br><span class="line">    // 获取当前状态值</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    int c = getState();</span><br><span class="line"></span><br><span class="line">    // 判断是否写锁被占用</span><br><span class="line">    if (exclusiveCount(c) != 0 &amp;&amp;</span><br><span class="line">        getExclusiveOwnerThread() != current)</span><br><span class="line">        return -1;</span><br><span class="line"></span><br><span class="line">    // 获取读锁计数</span><br><span class="line">    int r = sharedCount(c);</span><br><span class="line">    // 尝试获取锁，readerShouldBlock返回true表示有线程正在获取写锁，多个读线程只有一个会成功，不成功的进入下面fullTryAcquireShared进行重试</span><br><span class="line">    if (!readerShouldBlock() &amp;&amp;</span><br><span class="line">        // 当前获取读锁线程是否达到了最大值</span><br><span class="line">        r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">        // 设置state的高16位值增加1</span><br><span class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">        // 第一个线程获取读锁</span><br><span class="line">        if (r == 0) &#123;</span><br><span class="line">            firstReader = current;</span><br><span class="line">            firstReaderHoldCount = 1;</span><br><span class="line">        // 当前线程是第一个获取读锁的线程，并统计该线程获取读锁的可重入数</span><br><span class="line">        &#125; else if (firstReader == current) &#123;</span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 记录最后一个获取读锁的线程并同时cachedHoldCounter记录其获取读锁的可重入数（表示最后一个获取到读锁的线程的可重入数）</span><br><span class="line">            HoldCounter rh = cachedHoldCounter;</span><br><span class="line">            if (rh == null || rh.tid != current.getId())</span><br><span class="line">                cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">            else if (rh.count == 0)</span><br><span class="line">                // readHolds记录当前线程获取读锁的可重入数</span><br><span class="line">                readHolds.set(rh);</span><br><span class="line">            rh.count++;</span><br><span class="line">        &#125;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    // 类似tryAcquireShared，但是是自旋获取</span><br><span class="line">    return fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final boolean readerShouldBlock() &#123;</span><br><span class="line">    return apparentlyFirstQueuedIsExclusive();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如果队列里面存在一个元素，则判断第一个元素是不是正在尝试获取写锁</span><br><span class="line">final boolean apparentlyFirstQueuedIsExclusive() &#123;</span><br><span class="line">Node h, s;</span><br><span class="line">return (h = head) != null &amp;&amp;</span><br><span class="line">    (s = h.next)  != null &amp;&amp;</span><br><span class="line">    !s.isShared()         &amp;&amp;</span><br><span class="line">    s.thread != null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final int fullTryAcquireShared(Thread current) &#123;</span><br><span class="line">             HoldCounter rh = null;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int c = getState();</span><br><span class="line">        if (exclusiveCount(c) != 0) &#123;</span><br><span class="line">            if (getExclusiveOwnerThread() != current)</span><br><span class="line">                return -1;</span><br><span class="line">            // else we hold the exclusive lock; blocking here</span><br><span class="line">            // would cause deadlock.</span><br><span class="line">        &#125; else if (readerShouldBlock()) &#123;</span><br><span class="line">            // Make sure we&#x27;re not acquiring read lock reentrantly</span><br><span class="line">            if (firstReader == current) &#123;</span><br><span class="line">                // assert firstReaderHoldCount &gt; 0;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (rh == null) &#123;</span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                    if (rh == null || rh.tid != getThreadId(current)) &#123;</span><br><span class="line">                        rh = readHolds.get();</span><br><span class="line">                        if (rh.count == 0)</span><br><span class="line">                            readHolds.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (rh.count == 0)</span><br><span class="line">                    return -1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (sharedCount(c) == MAX_COUNT)</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        if (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">            if (sharedCount(c) == 0) &#123;</span><br><span class="line">                firstReader = current;</span><br><span class="line">                firstReaderHoldCount = 1;</span><br><span class="line">            &#125; else if (firstReader == current) &#123;</span><br><span class="line">                firstReaderHoldCount++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (rh == null)</span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                if (rh == null || rh.tid != getThreadId(current))</span><br><span class="line">                    rh = readHolds.get();</span><br><span class="line">                else if (rh.count == 0)</span><br><span class="line">                    readHolds.set(rh);</span><br><span class="line">                rh.count++;</span><br><span class="line">                cachedHoldCounter = rh; // cache for release</span><br><span class="line">            &#125;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ReadLock-lockInterruptibly"><a href="#ReadLock-lockInterruptibly" class="headerlink" title="ReadLock.lockInterruptibly"></a>ReadLock.lockInterruptibly</h4><p>可响应中断，被调用<code>interrupt</code>后会抛出<code>InterruptedException</code>。</p>
<h4 id="ReadLock-tryLock"><a href="#ReadLock-tryLock" class="headerlink" title="ReadLock.tryLock"></a>ReadLock.tryLock</h4><ul>
<li>尝试获取读锁，如果当前没有其它线程持有写锁，则当前线程获取写锁会成功，然后返回 true</li>
<li>如果当前已经其它线程持有写锁则该方法直接返回 false，当前线程并不会被阻塞。</li>
<li>如果其它获取当前线程已经持有了该读锁则简单增加 AQS 的状态值高 16 位后直接返回 true。</li>
</ul>
<h4 id="ReadLock-tryLock-long-timeout-TimeUnit-unit"><a href="#ReadLock-tryLock-long-timeout-TimeUnit-unit" class="headerlink" title="ReadLock.tryLock(long timeout, TimeUnit unit)"></a>ReadLock.tryLock(long timeout, TimeUnit unit)</h4><p>与 tryLock（）不同在于多了超时时间的参数，如果尝试获取读锁失败则会把当前线程挂起指定时间，待超时时间到后当前线程被激活，如果还是没有获取到读锁则返回 false。另外该方法对中断响应, 也就是当其它线程调用了该线程的 interrupt() 方法中断了当前线程，当前线程会抛出异常 <code>InterruptedException</code></p>
<h4 id="ReadLock-unlock"><a href="#ReadLock-unlock" class="headerlink" title="ReadLock.unlock"></a>ReadLock.unlock</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public void unlock() &#123;</span><br><span class="line">    sync.releaseShared(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">    if (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected final boolean tryReleaseShared(int unused) &#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    // 如果当前线程是第一个获取读锁线程</span><br><span class="line">    if (firstReader == current) &#123;</span><br><span class="line">        // 如果可重入次数为1</span><br><span class="line">        if (firstReaderHoldCount == 1)</span><br><span class="line">            firstReader = null;</span><br><span class="line">        else</span><br><span class="line">        // 否则可重入次数减去1</span><br><span class="line">            firstReaderHoldCount--;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 如果当前线程不是最后一个获取读锁线程，则从threadlocal里面获取</span><br><span class="line">        HoldCounter rh = cachedHoldCounter;</span><br><span class="line">        if (rh == null || rh.tid != current.getId())</span><br><span class="line">            rh = readHolds.get();</span><br><span class="line">        // 如果可重入次数&lt;=1则清除threadlocal</span><br><span class="line">        int count = rh.count;</span><br><span class="line">        if (count &lt;= 1) &#123;</span><br><span class="line">            readHolds.remove();</span><br><span class="line">            if (count &lt;= 0)</span><br><span class="line">                throw unmatchedUnlockException();</span><br><span class="line">        &#125;</span><br><span class="line">        // 可重入次数减去一</span><br><span class="line">        --rh.count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 循环直到自己的读计数-1，cas更新成功</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int c = getState();</span><br><span class="line">        int nextc = c - SHARED_UNIT;</span><br><span class="line">        if (compareAndSetState(c, nextc))</span><br><span class="line"></span><br><span class="line">            return nextc == 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Condition-条件变量"><a href="#Condition-条件变量" class="headerlink" title="Condition - 条件变量"></a>Condition - 条件变量</h4><p>ReentrantReadWriteLock 的 WriteLock 类似 ReentrantLock，提供了条件变量的支持，但是 ReadLock 并不支持，如果调用<code>ReentrantReadWriteLock.ReadLock.newCondition</code>获取状态变量会抛出<code>UnsupportedOperationException</code>异常。</p>
<h2 id="StampedLock-签锁"><a href="#StampedLock-签锁" class="headerlink" title="StampedLock - 签锁"></a>StampedLock - 签锁</h2><p>StampedLock 包含了三种并发控制模式：</p>
<ul>
<li>writeLock（写锁），是个排它锁或者叫独占锁，同时只有一个线程可以获取该锁，当一个线程获取该锁后，其它请求读锁和写锁的线程必须等待，类似于 ReentrantReadWriteLock 的写锁（不同在于这里的写锁是不可重入锁）；当目前没有线程持有读锁或者写锁的时候才可以获取到该锁，请求该锁成功后会返回一个 stamp 票据变量用来表示该锁的版本，当释放该锁时候需要调用 unlockWrite 方法并传递获取锁时候的 stamp 参数。并且提供了非阻塞的 tryWriteLock 方法。</li>
<li>readLock（悲观读锁），是个共享锁，在没有线程获取独占写锁的情况下，同时多个线程可以获取该锁; 如果已经有线程持有写锁，其它线程请求获取该读锁会被阻塞，这类似 ReentrantReadWriteLock 的读锁（不同在于这里的读锁是不可重入锁）。这里说的悲观是指在具体操作数据前悲观的认为其它线程可能要对自己操作的数据进行修改，所以需要先对数据加锁，这是在读少写多的情况下的一种考虑, 请求该锁成功后会返回一个 stamp 票据变量用来表示该锁的版本，当释放该锁时候需要 unlockRead 并传递参数 stamp。并且提供了非阻塞的 tryReadLock。</li>
<li>tryOptimisticRead（乐观读锁），是相对于悲观锁来说的，在操作数据前并没有通过 CAS 设置锁的状态，仅仅是通过位运算测试；如果当前没有线程持有写锁，则简单的返回一个非 0 的 stamp 版本信息，获取该 stamp 后在具体操作数据前还需要调用 validate 验证下该 stamp 是否已经不可用，也就是看当调用 tryOptimisticRead 返回 stamp 后，到当前时间间是否有其它线程持有了写锁，如果是那么 validate 会返回 0，否则就可以使用该 stamp 版本的锁对数据进行操作。由于 tryOptimisticRead 并没有使用 CAS 设置锁状态，所以不需要显示的释放该锁。该锁的一个特点是适用于读多写少的场景，因为获取读锁只是使用位操作进行检验，不涉及 CAS 操作，所以效率会高很多，但是同时由于没有使用真正的锁，在保证数据一致性上需要拷贝一份要操作的变量到方法栈，并且在操作数据时候可能其它写线程已经修改了数据，而我们操作的是方法栈里面的数据，也就是一个快照，所以最多返回的不是最新的数据，但是一致性还是得到保障的。</li>
</ul>
<p>提供了锁的升级策略，<code>long tryConvertToWriteLock(long stamp)</code>期望把 stamp 标示的锁升级为写锁，这个函数会在下面几种情况下返回一个有效的 stamp（也就是晋升写锁成功）：</p>
<ul>
<li>当前锁已经是写锁模式了。</li>
<li>当前锁处于读锁模式，并且没有其他线程是读锁模式</li>
<li>当前处于乐观读模式，并且当前写锁可用。</li>
</ul>
<p>stamp 标识了一个锁：</p>
<ul>
<li>会在每次调用加锁方法时返回；</li>
<li>其中 try 系列获取锁的函数，当获取锁失败后会返回为 0 的 stamp 值；</li>
<li>当调用释放锁和转换锁的方法时候需要传入获取锁时候返回的 stamp 值</li>
</ul>
<h4 id="不可重入"><a href="#不可重入" class="headerlink" title="不可重入"></a>不可重入</h4><p>StampedLock 的读写锁都是不可重入锁，所以同一线程不应重复获取同一个锁，以避免产生死锁。</p>
<h4 id="公平性-2"><a href="#公平性-2" class="headerlink" title="公平性"></a>公平性</h4><p>StampedLock 没有使用AQS，而是自己内部维护了一个双向阻塞队列。</p>
<h4 id="StampedLock-vs-ReentrantReadWriteLock"><a href="#StampedLock-vs-ReentrantReadWriteLock" class="headerlink" title="StampedLock vs ReentrantReadWriteLock"></a>StampedLock vs ReentrantReadWriteLock</h4><p>StampedLock 与 ReentrantReadWriteLock 的主要区别是乐观读锁，因为 StampedLock 的乐观读写只是检测 stamp 状态、不需要通过 CAS 修改锁的状态，所以在多线程多读的情况下能提供更好的性能。</p>
<h4 id="乐观读锁的使用"><a href="#乐观读锁的使用" class="headerlink" title="乐观读锁的使用"></a>乐观读锁的使用</h4><p>乐观读锁的使用容易出错，需要保证按照如下的顺序获取：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 非阻塞获取版本信息</span><br><span class="line">long stamp = lock.tryOptimisticRead();</span><br><span class="line">// 拷贝变量到线程本地堆栈</span><br><span class="line">copyVaraibale2ThreadMemory();</span><br><span class="line">// 校验</span><br><span class="line">if(!lock.validate(stamp))&#123;</span><br><span class="line">    // 获取读锁</span><br><span class="line">    long stamp = lock.readLock();</span><br><span class="line">    try &#123;</span><br><span class="line">        // 拷贝变量到线程本地堆栈</span><br><span class="line">        copyVaraibale2ThreadMemory();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // 释放悲观锁</span><br><span class="line">        lock.unlock(stamp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// 使用线程本地堆栈里面的数据进行操作</span><br><span class="line">useThreadMemoryVarables();</span><br></pre></td></tr></table></figure>

<h4 id="实例-乐观读锁、读锁、写锁及升级"><a href="#实例-乐观读锁、读锁、写锁及升级" class="headerlink" title="实例 - 乐观读锁、读锁、写锁及升级"></a>实例 - 乐观读锁、读锁、写锁及升级</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    加锁的语义保证了内存可见性，因此成员变量不必声明为volatile</span><br><span class="line">    private double x, y;</span><br><span class="line"></span><br><span class="line">    private final StampedLock sl = new StampedLock();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取写锁</span><br><span class="line">     */</span><br><span class="line">    void move(double deltaX, double deltaY) &#123;</span><br><span class="line">        // 写锁（排他锁）</span><br><span class="line">        long stamp = sl.writeLock();</span><br><span class="line">        try &#123;</span><br><span class="line">            x += deltaX;</span><br><span class="line">            y += deltaY;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            sl.unlockWrite(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 尝试获取乐观读锁</span><br><span class="line">     */</span><br><span class="line">    double distanceFromOrigin() &#123;</span><br><span class="line">        // 尝试获取乐观读锁</span><br><span class="line">        long stamp = sl.tryOptimisticRead();</span><br><span class="line">        // 将全部变量拷贝到方法栈内</span><br><span class="line">        double currentX = x, currentY = y;</span><br><span class="line">        // 检查stamp，确认没有被其他写线程占用写锁，因为并发读写可能会导致上边获取到的x、y不一致</span><br><span class="line">        if (!sl.validate(stamp)) &#123;</span><br><span class="line">            // 如果被抢占则获取一个悲观读锁，如果此时其他线程持有写锁则当前线程会阻塞直到写锁被释放</span><br><span class="line">            stamp = sl.readLock();</span><br><span class="line">            try &#123;</span><br><span class="line">                // 将全部变量拷贝到方法栈内</span><br><span class="line">                currentX = x;</span><br><span class="line">                currentY = y;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                // 释放共享读锁</span><br><span class="line">                sl.unlockRead(stamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 返回计算结果，使用的是方法栈中的变量值，成员变量x、y可能已经被其他线程修改</span><br><span class="line">        return Math.sqrt(currentX * currentX + currentY * currentY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 尝试获取悲观读锁，并尝试转换为写锁</span><br><span class="line">     */</span><br><span class="line">    void moveIfAtOrigin(double newX, double newY) &#123;</span><br><span class="line">        // 这里可以使用乐观读锁替换</span><br><span class="line">        long stamp = sl.readLock();</span><br><span class="line">        try &#123;</span><br><span class="line">            // 如果当前点在原点则移动</span><br><span class="line">            while (x == 0.0 &amp;&amp; y == 0.0) &#123;</span><br><span class="line">                // 尝试将获取的读锁升级为写锁</span><br><span class="line">                long ws = sl.tryConvertToWriteLock(stamp);</span><br><span class="line">                // 升级成功，则更新票据，并设置坐标值，然后退出循环</span><br><span class="line">                if (ws != 0L) &#123;</span><br><span class="line">                    stamp = ws;</span><br><span class="line">                    x = newX;</span><br><span class="line">                    y = newY;</span><br><span class="line">                    break;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // 读锁升级写锁失败，说明已被其他线程升级成功，则释放读锁，显示获取独占写锁，然后循环重试</span><br><span class="line">                    sl.unlockRead(stamp);</span><br><span class="line">                    stamp = sl.writeLock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // 释放锁</span><br><span class="line">            sl.unlock(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="线程调度-和-LockSupport"><a href="#线程调度-和-LockSupport" class="headerlink" title="线程调度 和 LockSupport"></a>线程调度 和 LockSupport</h2><p>挂起和唤醒是线程调度中和锁的实现最密切的操作，juc 中通过一个 LockSupport 来抽象这两种操作，它是创建锁和其它同步类的基础。</p>
<ul>
<li>LockSupport 内部使用 Unsafe 类实现；</li>
<li>LockSupport 类与每个使用它的线程都会关联一个许可证，park实际上就是消耗许可的过程，unpark则是释放许可的过程。</li>
</ul>
<p>相对Object中的wait&#x2F;notify来说，LockSupport有以下优点：</p>
<ol>
<li>使用wait&#x2F;notify前必须先使用synchronized获取锁，LockSupport.park没有这个限制；</li>
<li>使用notify只能随机唤醒一个线程，LockSupport可以指定唤醒某个线程。</li>
</ol>
<h4 id="void-park"><a href="#void-park" class="headerlink" title="void park()"></a>void park()</h4><p>调用线程会被禁止参与线程的调度，也就是会被阻塞挂起</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;begin park&quot;);</span><br><span class="line">LockSupport.park();</span><br><span class="line">System.out.println(&quot;end park&quot;);</span><br></pre></td></tr></table></figure>
<ul>
<li>可重入：如果调用 park() 的线程已经拿到了与 LockSupport 关联的<strong>permit（许可证）</strong>，则调用 LockSupport.park() 会马上返回。</li>
<li>在其它线程调用 unpark(Thread thread)方法并且当前线程作为参数时候，调用 park 方法被阻塞的线程会返回；</li>
<li>其他线程调用 interrupt()设置中断标识后可以返回，不会抛出 InterruptedException 异常；<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Thread thread = new Thread(() -&gt; &#123;</span><br><span class="line">    System.out.println(&quot;child thread begin park!&quot;);</span><br><span class="line">    // 调用park方法，挂起自己</span><br><span class="line">    LockSupport.park();</span><br><span class="line">    System.out.println(&quot;child thread unpark!&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">thread.start();</span><br><span class="line">Thread.sleep(1000);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>由于线程的虚假唤醒也会导致阻塞的线程返回，park 方法返回的时候不会告知调用者返回的原因，所以调用 park()最好也用循环条件判断方式。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class ParkTest &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread child = new Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;child thread park&quot;);</span><br><span class="line">            while (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                System.out.println(&quot;child thread parking&quot;);</span><br><span class="line">                LockSupport.park();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;child thread unpark&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">        child.start();</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        System.out.println(&quot;main thread interrupt&quot;);</span><br><span class="line">        child.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">child thread park</span><br><span class="line">child thread parking</span><br><span class="line">main thread interrupt</span><br><span class="line">child thread unpark</span><br></pre></td></tr></table></figure>
调用子线程的 interrupt 方法后，子线程中的 park 调用会返回，然后检查线程的中断标识，当然此时已中断因此 isInterrupted 为 true，于是退出循环、结束线程任务。这个例子中，如果 main 线程单纯只是调用 unpark(child)是无法让子线程退出的。</li>
</ul>
<h4 id="void-unpark-Thread-thread"><a href="#void-unpark-Thread-thread" class="headerlink" title="void unpark(Thread thread)"></a>void unpark(Thread thread)</h4><ul>
<li>如果 thread 之前调用了 park() 被挂起，则调用 unpark 后，该线程会被唤醒；<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Thread thread = new Thread(() -&gt; &#123;</span><br><span class="line">    System.out.println(&quot;child thread begin park!&quot;);</span><br><span class="line">    // 调用 park 方法，挂起自己</span><br><span class="line">    LockSupport.park();</span><br><span class="line">    System.out.println(&quot;child thread unpark!&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">thread.start();</span><br><span class="line">Thread.sleep(1000);</span><br><span class="line">System.out.println(&quot;main thread begin unpark!&quot;);</span><br><span class="line">//调用 unpark 让 thread 线程持有许可证，然后 park 方法会返回</span><br><span class="line">LockSupport.unpark(thread);</span><br></pre></td></tr></table></figure></li>
<li>如果 thread 之前没有调用 park，则调用 unPark 方法后，在调用 park() 方法，会立刻返回，且让该线程持有一个，可供下次调用 park 时获取。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main( String[] args ) &#123;</span><br><span class="line">        System.out.println( &quot;begin park!&quot; );</span><br><span class="line">        //使当前线程获取到许可证</span><br><span class="line">        LockSupport.unpark(Thread.currentThread());</span><br><span class="line">        //再次调用 park</span><br><span class="line">        LockSupport.park();</span><br><span class="line">        System.out.println( &quot;end park!&quot; );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="void-parkNanos-long-nanos"><a href="#void-parkNanos-long-nanos" class="headerlink" title="void parkNanos(long nanos)"></a>void parkNanos(long nanos)</h4><p>和 park()差不多，只是在等待 nanos 时间后若还是没有拿到 permit 则 parkNanos 会直接返回。</p>
<h4 id="void-park-Object-blocker"><a href="#void-park-Object-blocker" class="headerlink" title="void park(Object blocker)"></a>void park(Object blocker)</h4><p>blocker 可以记录线程调用 park 后被阻塞挂起的原因，这个对象是保存到当前线程 Thread 对象里的（Thread.parkBlocker），可以通过 LockSupport#getBlocker(Thread)获取。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void park(Object blocker) &#123;</span><br><span class="line">    // 获取调用线程</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    // 设置该线程的 blocker 变量</span><br><span class="line">    setBlocker(t, blocker);</span><br><span class="line">    // 挂起线程</span><br><span class="line">    UNSAFE.park(false, 0L);</span><br><span class="line">    // 线程被激活后清除 blocker 变量，因为一般都是线程阻塞时候才分析原因</span><br><span class="line">    setBlocker(t, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>普通park()挂起后，查看线程堆栈如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;main&quot; #1 prio=5 os_prio=31 tid=0x00007fc0f0800800 nid=0x1303 waiting on condition [0x000070000ee42000]</span><br><span class="line">   java.lang.Thread.State: WAITING (parking)</span><br><span class="line">        at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:304)</span><br><span class="line">        at com.tallate.localcache.ParkTest.main(ParkTest.java:9)</span><br></pre></td></tr></table></figure>
<p>而使用 park(this)挂起后，查看线程堆栈如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;main&quot; #1 prio=5 os_prio=31 tid=0x00007ff1f6011000 nid=0x2603 waiting on condition [0x000070000ecba000]</span><br><span class="line">   java.lang.Thread.State: WAITING (parking)</span><br><span class="line">        at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">        - parking to wait for  &lt;0x00000007956f1ef0&gt; (a java.lang.Class)</span><br><span class="line">        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)</span><br><span class="line">        at com.tallate.localcache.ParkTest.main(ParkTest.java:9)</span><br></pre></td></tr></table></figure>
<p>可见，线程堆栈还提供了 blocker 对象的地址，这个 blocker 可以通过<code>getBlocker(Thread)</code>获取到，一些诊断工具可以通过这个对象来获取阻塞的具体原因。</p>
<h4 id="void-parkNanos-Object-blocker-long-nanos"><a href="#void-parkNanos-Object-blocker-long-nanos" class="headerlink" title="void parkNanos(Object blocker, long nanos)"></a>void parkNanos(Object blocker, long nanos)</h4><p>相对 park(Object blocker)多了个超时时间</p>
<h4 id="void-parkUntil-Object-blocker-long-deadline"><a href="#void-parkUntil-Object-blocker-long-deadline" class="headerlink" title="void parkUntil(Object blocker, long deadline)"></a>void parkUntil(Object blocker, long deadline)</h4><p>最多等待到某个时间就直接返回，deadline 的计算是从 1970 年开始的，比如如果要等待 1 秒钟，可以这么写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(System.currentTimeMillis());</span><br><span class="line">LockSupport.parkUntil(System.currentTimeMillis() - new Date(0).getTime() + 1000);</span><br><span class="line">System.out.println(System.currentTimeMillis());</span><br></pre></td></tr></table></figure>
<p>内部是通过 UNSAFE.park 实现的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// isAbsolute=true,time=deadline;表示到 deadline 时间时候后返回</span><br><span class="line">UNSAFE.park(true, deadline);</span><br></pre></td></tr></table></figure>
<h4 id="使用-LockSupport-实现一个互斥锁"><a href="#使用-LockSupport-实现一个互斥锁" class="headerlink" title="使用 LockSupport 实现一个互斥锁"></a>使用 LockSupport 实现一个互斥锁</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class FIFOLock &#123;</span><br><span class="line">    private final AtomicBoolean locked = new AtomicBoolean(false);</span><br><span class="line">    private final Queue&lt;Thread&gt; waiters = new ConcurrentLinkedQueue&lt;Thread&gt;();</span><br><span class="line"></span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        boolean wasInterrupted = false;</span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        // 刚开始将当前线程放入队列中排队获取锁</span><br><span class="line">        waiters.add(current);</span><br><span class="line"></span><br><span class="line">        // 只有队首的线程可以获取锁，如果当前线程不在队首则继续等待</span><br><span class="line">        // 使用CAS操作加锁</span><br><span class="line">        while (waiters.peek() != current || !locked.compareAndSet(false, true)) &#123;</span><br><span class="line">            // 挂起，等待其他线程调用unpark来唤醒当前线程</span><br><span class="line">            LockSupport.park(this);</span><br><span class="line">            // 注意中断也可以令park返回，如果被其他线程中断了，在中断标识还保留的情况下park是无法正常挂起的，所以这里需要先重置中断标识</span><br><span class="line">            if (Thread.interrupted()) &#123;</span><br><span class="line">                wasInterrupted = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        waiters.remove();</span><br><span class="line">        // 其实意思是其它线程中断了该线程，虽然我对中断信号不感兴趣，但是不代表其它线程对该标志不感兴趣，所以需要恢复</span><br><span class="line">        if (wasInterrupted) &#123;</span><br><span class="line">            current.interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        locked.set(false);</span><br><span class="line">        LockSupport.unpark(waiters.peek());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="AbstractQueuedSynchronizer（AQS）-JUC-锁实现的基础"><a href="#AbstractQueuedSynchronizer（AQS）-JUC-锁实现的基础" class="headerlink" title="AbstractQueuedSynchronizer（AQS） - JUC 锁实现的基础"></a>AbstractQueuedSynchronizer（AQS） - JUC 锁实现的基础</h2><p>AQS 本质上是一个双向队列，不仅仅是锁，AQS 其实是 JUC 中大部分并发安全组件的实现基础。<br>AQS主要包含了两部分功能：</p>
<ul>
<li>基于CAS的同步控制功能；</li>
<li>基于LockSupport的通知功能。</li>
</ul>
<h3 id="AQS-结构"><a href="#AQS-结构" class="headerlink" title="AQS 结构"></a>AQS 结构</h3><p><img src="/imgs/%E5%B9%B6%E5%8F%91/AQS%E7%B1%BB%E5%9B%BE.png" alt="AQS类图" title="AQS类图"><br><img src="/imgs/%E5%B9%B6%E5%8F%91/AQS%E5%A4%A7%E8%87%B4%E7%BB%93%E6%9E%84.png" alt="AQS大致结构" title="AQS大致结构"><br>AQS 是一个 FIFO 的<strong>双向队列</strong>，内部通过节点 <code>head</code> 和 <code>tail</code> 记录队首和队尾元素，队列元素类型为 <code>Node</code>。</p>
<ul>
<li>其中 Node 中 <code>thread</code> 变量用来存放进入 AQS 队列里面的线程，在ReentrantLock里即锁的持有者；</li>
<li>Node 节点内部 <code>SHARED</code> 用来标记该线程是获取共享资源时候被阻塞挂起后放入 AQS 队列，<code>EXCLUSIVE</code> 标示线程是获取独占资源时候被挂起后放入 AQS 队列；</li>
<li><code>waitStatus</code> 记录当前线程等待状态，分别为 <code>CANCELLED</code>（线程被取消了），<code>SIGNAL</code>（线程需要被唤醒），<code>CONDITION</code>（线程在条件队列里面等待），<code>PROPAGATE</code>（释放共享资源时候需要通知其它节点）；</li>
<li><code>prev</code> 记录当前节点的前驱节点，<code>next</code> 记录当前节点后继节点。</li>
</ul>
<h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><p>AQS 中维持了一个单一的状态信息 <code>state</code>, 可以通过 getState, setState, compareAndSetState 函数修改其值，在不同的同步工具类中，这个<code>state</code>可能代表了不同的含义，需要自定义tryAcquire、tryRelease如何修改state的值来达到自己需要的目的：</p>
<ul>
<li>对于 <code>ReentrantLock</code> 的实现来说，state 可以用来表示当前线程获取锁的可重入次数，定义当 status 为 0 的时候标示锁空闲，为 1 的时候标示锁已经被占用。<br>在重写 <code>tryAcquire</code> 时候，内部需要使用 CAS 算法看当前 status 是否为 0，如果为 0 则使用 CAS 设置为 1，并设置当前线程的持有者为当前线程，并返回 true, 如果 CAS 失败则 返回 false；<br>实现 <code>tryRelease</code> 时候，内部需要使用 CAS 算法把当前 status 值从 1 修改为 0，并设置当前锁的持有者为 null，然后返回 true, 如果 cas 失败则返回 false。</li>
<li>对应读写锁 <code>ReentrantReadWriteLock</code> 来说 state 的高 16 位表示读状态也就是获取该读锁的次数，低 16 位表示获取到写锁的线程的可重入次数；<br>读写锁里面的读锁重写 <code>tryAcquireShared</code> 时候，首先看写锁是否被其它线程持有，如果是则直接返回 false，否则使用 cas 递增 status 的高 16 位，在 ReentrantReadWriteLock 中 status 的高 16 为获取读锁的次数。<br>读锁在重写 tryReleaseShared 时候，内部需要使用 CAS 算法把当前 status 值的高 16 位减一，然后返回 true, 如果 cas 失败则返回 false。<blockquote>
<p>锁除了需要重写<code>tryAcquire</code>和<code>tryRelease</code>之外，还需要重写<code>isHeldExclusively</code>以用来判断锁是被当前线程独占还是被共享。</p>
</blockquote>
</li>
<li>对于 <code>Semaphore</code> 来说 state 用来表示当前可用信号的个数；</li>
<li>对于 <code>FutuerTask</code> 来说，state 用来表示任务状态（例如还没开始，运行，完成，取消）；<blockquote>
<p>1.8 版本中 FutuerTask 取消了对 AQS 的依赖，改为通过 CAS 跟踪状态、Treiber stack 管理等待中的线程，是因为通过 AQS 的实现存在，这篇文章的最后提到了这个问题：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/16d6f0a22111">线程阻塞(三)，FutureTask</a>，官方有一个Bug Report：<a target="_blank" rel="noopener" href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=8016247">JDK-8016247 : ThreadPoolExecutor may interrupt the wrong task</a>。</p>
</blockquote>
</li>
<li>对 <code>CountDownlatch</code> 和 <code>CyclicBarrier</code> 来说 state 用来表示计数器当前的值。</li>
</ul>
<p>对于 AQS 来说线程同步的关键是对状态值 state 进行操作，根据 state 是否属于一个线程，操作 state 的方式分为<strong>独占模式</strong>和<strong>共享模式</strong>。</p>
<h3 id="state和独占模式"><a href="#state和独占模式" class="headerlink" title="state和独占模式"></a>state和独占模式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 独占模式</span><br><span class="line">void acquire(int arg)</span><br><span class="line">void acquireInterruptibly(int arg)</span><br><span class="line">boolean release(int arg)</span><br></pre></td></tr></table></figure>
<p>对于独占方式获取的资源是<strong>与具体线程绑定</strong>的，就是说如果一个线程获取到了资源，就会标记是那个线程获取到了，其它线程尝试操作 state 获取资源时候发现当前该资源不是自己持有的，就会获取失败后被阻塞。<br>比如独占锁 ReentrantLock 的实现，当一个线程获取了 ReentrantLock 的锁后，AQS 内部会首先使用 CAS 操作把 state 状态值从 0 变为 1，然后设置当前锁的持有者为当前线程，当该线程再次获取锁时候发现当前线程就是锁的持有者则会把状态值从 1 变为 2 也就是设置可重入次数，当另外一个线程获取锁的时候发现自己并不是该锁的持有者就会被放入 AQS 阻塞队列后挂起。</p>
<ol>
<li><strong>获取</strong>。当一个线程调用 acquire(int arg) 方法获取独占资源时候，会首先使用 tryAcquire 尝试获取资源，具体是设置状态变量 state 的值，成功则直接返回。失败则将当前线程封装为类型为 Node.EXCLUSIVE 的 Node 节点后插入到 AQS 阻塞队列尾部，并调用 LockSupport.park(this) 挂起当前线程。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>释放</strong>。当一个线程调用 release(int arg) 时候会尝试使用 tryRelease 操作释放资源，这里是设置状态变量 state 的值，然后调用 LockSupport.unpark(thread) 激活 AQS 队列里面最早被阻塞的线程 (thread)。被激活的线程则使用 tryAcquire 尝试看当前状态变量 state 的值是否能满足自己的需要，满足则该线程被激活然后继续向下运行，否则还是会被放入 AQS 队列并被挂起。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">    if (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        if (h != null &amp;&amp; h.waitStatus != 0)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="state和共享模式"><a href="#state和共享模式" class="headerlink" title="state和共享模式"></a>state和共享模式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 共享模式</span><br><span class="line">void acquireShared(int arg)</span><br><span class="line">void acquireSharedInterruptibly(int arg)</span><br><span class="line">boolean releaseShared(int arg)</span><br></pre></td></tr></table></figure>
<p>共享模式下资源是与具体线程不相关的，多个线程去请求资源时候是通过 CAS 方式竞争获取资源，当一个线程获取到了资源后，另外一个线程再次获取时候如果当前资源还能满足它的需要，则当前线程只需要使用 CAS 方式进行获取即可，共享模式下并不需要记录那个线程获取了资源。<br>比如 Semaphore 信号量，当一个线程通过 acquire() 方法获取一个信号量时候，会首先看当前信号量个数是否满足需要，不满足则把当前线程放入阻塞队列，如果满足则通过自旋 CAS 获取信号量。</p>
<ol>
<li><strong>获取</strong>。当线程调用 acquireShared(int arg) 获取共享资源时候，会首先使用 tryAcquireShared 尝试获取资源，具体是设置状态变量 state 的值，成功则直接返回。失败则将当前线程封装为类型为 Node.SHARED 的 Node 节点后插入到 AQS 阻塞队列尾部，并使用 LockSupport.park(this) 挂起当前线程。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public final void acquireShared(int arg) &#123;</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>释放</strong>。当一个线程调用 releaseShared(int arg) 时候会尝试使用, tryReleaseShared 操作释放资源，这里是设置状态变量 state 的值，然后使用 LockSupport.unpark（thread）激活 AQS 队列里面最早被阻塞的线程 (thread)。被激活的线程则使用 tryReleaseShared 尝试看当前状态变量 state 的值是否能满足自己的需要，满足则该线程被激活然后继续向下运行，否则还是会被放入 AQS 队列并被挂起。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">    if (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void acquire(int arg)</span><br><span class="line">void acquireInterruptibly(int arg)</span><br><span class="line">void acquireShared(int arg) </span><br><span class="line">void acquireSharedInterruptibly(int arg)</span><br></pre></td></tr></table></figure>
<p>不带Interruptibly后缀的方法不会响应中断，也就是说在获取资源的时候或者获取资源失败被挂起的时候，被别的线程中断（interrupt），那么该线程就会抛出InterruptedException异常。</p>
<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>AQS的队列基础是一个双向链表。</p>
<ul>
<li>入队：当一个线程获取锁失败后该线程会被转换为 Node 节点，然后就会使用 enq(final Node node) 方法插入该节点到 AQS 的阻塞队列  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private Node enq(final Node node) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        // 指向队尾节点</span><br><span class="line">        Node t = tail;</span><br><span class="line">        // 队列为空，则初始化设置哨兵节点</span><br><span class="line">        if (t == null) &#123; // Must initialize</span><br><span class="line">            // 通过CAS设置一个哨兵节点为头节点</span><br><span class="line">            if (compareAndSetHead(new Node()))</span><br><span class="line">                // 设置成功，让队尾节点也指向哨兵节点</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 设置node的前驱节点为队尾节点</span><br><span class="line">            node.prev = t;</span><br><span class="line">            // 通过CAS设置node节点为队尾节点</span><br><span class="line">            if (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                // 设置原来的队尾节点的后继节点为node</span><br><span class="line">                t.next = node;</span><br><span class="line">                return t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="ConditionObject-条件变量"><a href="#ConditionObject-条件变量" class="headerlink" title="ConditionObject - 条件变量"></a>ConditionObject - 条件变量</h3><p>AQS 有个内部类 <code>ConditionObject</code> 是用来结合锁实现线程同步，ConditionObject 可以直接访问 AQS 对象内部的变量，比如 state 状态值和 AQS 队列。<br>类似于共享变量的notify和wait需要先通过synchronized获取内置锁，条件变量的signal和await也需要配合AQS实现的锁来使用，如果在没有获取锁的情况下调用条件变量的await或signal方法就会抛出<code>IllegalMonitorStateException</code>异常。下面以ReentrantLock为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock lock = new ReentrantLock();</span><br><span class="line">Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">lock.lock();</span><br><span class="line">try &#123;</span><br><span class="line">    System.out.println(&quot;begin wait&quot;);</span><br><span class="line">    condition.await();</span><br><span class="line">    System.out.println(&quot;end wait&quot;);</span><br><span class="line"></span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line"></span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">lock.lock();</span><br><span class="line">try &#123;</span><br><span class="line">    System.out.println(&quot;begin signal&quot;);</span><br><span class="line">    condition.signal();</span><br><span class="line">    System.out.println(&quot;end signal&quot;);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line"></span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ConditionObject 是条件变量，每个条件变量对应着一个**条件队列 (单向链表队列)**，用来存放调用条件变量的 await() 方法后被阻塞的线程，注意这个条件队列和AQS队列不是一回事，这个条件队列的头尾元素分别为 <code>firstWaiter</code> 和 <code>lastWaiter</code>。</p>
<h4 id="await"><a href="#await" class="headerlink" title="await"></a>await</h4><p>当线程调用了条件变量的 <code>await()</code> 方法时候（事先必须先调用了锁的 <code>lock()</code> 方法获取锁），内部会构造一个类型为 <code>Node.CONDITION</code> 的 node 节点，然后插入该节点到条件队列末尾，然后当前线程会释放获取的锁（也就是会操作锁对应的 status 变量的值），并被阻塞挂起。<br>这时候如果有其它线程调用了 <code>lock.lock()</code> 尝试获取锁时候，就会有一个线程获取到锁，如果获取到锁的线程又调用了条件变量的 <code>await()</code>方法，则该线程也会被放入条件变量的阻塞队列，然后释放获取到的锁，阻塞到 await() 方法处。</p>
<blockquote>
<p>当多个线程同时调用 lock.lock() 获取锁的时候，同时只有一个线程获取到了该锁，其他线程会被转换为 Node 节点插入到 lock 锁对应的 AQS 阻塞队列里面，并做自旋 CAS 尝试获取锁，这个和ReentrantLock的具体实现有关。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public final void await() throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    // 创建新的node,并插入到Condition的等待队列末尾</span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    // 释放在AQS中设置的state，相当于释放当前线程获取的锁</span><br><span class="line">    int savedState = fullyRelease(node);</span><br><span class="line">    int interruptMode = 0;</span><br><span class="line">    // 判断当前线程是否在AQS队列中</span><br><span class="line">    while (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        // 调用park方法阻塞挂起当前线程</span><br><span class="line">        LockSupport.park(this);</span><br><span class="line">        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果在AQS队列中，则排队等待</span><br><span class="line">    if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    if (node.nextWaiter != null) // clean up if cancelled</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    if (interruptMode != 0)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br><span class="line">private Node addConditionWaiter() &#123;</span><br><span class="line">    Node t = lastWaiter;</span><br><span class="line">    ...</span><br><span class="line">    // 创建一个Node.CONDITION类型的节点</span><br><span class="line">    Node node = new Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">    // 向条件队列尾部插入节点</span><br><span class="line">    if (t == null)</span><br><span class="line">        firstWaiter = node;</span><br><span class="line">    else</span><br><span class="line">        t.nextWaiter = node;</span><br><span class="line">    lastWaiter = node;</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从源码中可知await：</p>
<ol>
<li>当前线程获取锁后调用了该锁创建的条件变量，那么线程会释放获取到的锁；</li>
<li>当前线程会被转换为<code>Node</code>节点后插入到对应条件变量的<strong>条件队列</strong>；</li>
<li>之后AQS阻塞队列中其他线程就有机会获取到该锁了。</li>
</ol>
<h4 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h4><p>当另外一个线程调用了条件变量的 signal 方法时候（事先必须先调用了锁的 lock() 方法获取锁），内部会把条件队列里面队头的一个线程节点从条件队列里面移除后放入到 AQS 的阻塞队列里面，然后激活这个线程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 通知等待最久的线程</span><br><span class="line"> */</span><br><span class="line">public final void signal() &#123;</span><br><span class="line">    if (!isHeldExclusively())</span><br><span class="line">        throw new IllegalMonitorStateException();</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    if (first != null)</span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br><span class="line">private void doSignal(Node first) &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        if ( (firstWaiter = first.nextWaiter) == null)</span><br><span class="line">            lastWaiter = null;</span><br><span class="line">        first.nextWaiter = null;</span><br><span class="line">    &#125; while (!transferForSignal(first) &amp;&amp;</span><br><span class="line">             (first = firstWaiter) != null);</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 将节点从条件队列转移到同步队列</span><br><span class="line"> */</span><br><span class="line">final boolean transferForSignal(Node node) &#123;</span><br><span class="line">    /*</span><br><span class="line">     * If cannot change waitStatus, the node has been cancelled.</span><br><span class="line">     */</span><br><span class="line">    if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Splice onto queue and try to set waitStatus of predecessor to</span><br><span class="line">     * indicate that thread is (probably) waiting. If cancelled or</span><br><span class="line">     * attempt to set waitStatus fails, wake up to resync (in which</span><br><span class="line">     * case the waitStatus can be transiently and harmlessly wrong).</span><br><span class="line">     */</span><br><span class="line">    Node p = enq(node);</span><br><span class="line">    int ws = p.waitStatus;</span><br><span class="line">    if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Condition和wait-notify之间的区别"><a href="#Condition和wait-notify之间的区别" class="headerlink" title="Condition和wait&#x2F;notify之间的区别"></a>Condition和wait&#x2F;notify之间的区别</h4><p>为什么已经有了Object的wait方法和notify方法还需要Condition呢？因为Condition更灵活。<br>synchronized方式对应的wait、notify不能有多个谓词条件，而Condition则可以有多个谓词条件。<br>比如生产者生产一个元素后需要唤醒一个消费者线程，notify只能随机唤醒一个线程，如果当前有一个生产者正在通过synchronized上的wait等待，则可能会唤醒这个生产者线程；<br>如果是Condition方式，我们可以定义多个谓词条件，比如notEmpty、notFull，可以令所有消费者在notEmpty上等待，令所有生产者在notFull上等待，当队列满的时候所有的生产者线程阻塞，添加元素之后则通过notEmpty唤醒某个消费者线程，这样就不用担心会唤醒消费者线程。</p>
<h4 id="实例-Condition-的使用"><a href="#实例-Condition-的使用" class="headerlink" title="实例 - Condition 的使用"></a>实例 - Condition 的使用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Lock l = new ReentrantLock();</span><br><span class="line">Condition c = l.newCondition();</span><br><span class="line">c.await(); // 信号量-1</span><br><span class="line">c.signal(); // 信号量+1</span><br><span class="line">c.signalAll(); // 所有信号量+1</span><br><span class="line">System.out.println();</span><br></pre></td></tr></table></figure>
<p>实例 - 多线程下的缓冲区</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class BoundedBuffer &#123;</span><br><span class="line"></span><br><span class="line">    final Lock lock = new ReentrantLock();//锁对象</span><br><span class="line">    final Condition notFull = lock.newCondition();//写线程条件</span><br><span class="line">    final Condition notEmpty = lock.newCondition();//读线程条件</span><br><span class="line"></span><br><span class="line">    final Object[] items = new Object[100]; //缓存队列</span><br><span class="line">    int putptr/*写索引*/, takeptr/*读索引*/, count/*队列中存在的数据个数*/;</span><br><span class="line"></span><br><span class="line">    public void put(Object x) throws InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (count == items.length)//如果队列满了   </span><br><span class="line">            &#123;</span><br><span class="line">                notFull.await();//阻塞写线程  </span><br><span class="line">            &#125;</span><br><span class="line">            items[putptr] = x;//赋值   </span><br><span class="line">            if (++putptr == items.length) &#123;</span><br><span class="line">                putptr = 0;//如果写索引写到队列的最后一个位置了，那么置为0  </span><br><span class="line">            &#125;</span><br><span class="line">            ++count;//个数++  </span><br><span class="line">            notEmpty.signal();//唤醒读线程  </span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object take() throws InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (count == 0)//如果队列为空  </span><br><span class="line">            &#123;</span><br><span class="line">                notEmpty.await();//阻塞读线程  </span><br><span class="line">            &#125;</span><br><span class="line">            Object x = items[takeptr];//取值   </span><br><span class="line">            if (++takeptr == items.length) &#123;</span><br><span class="line">                takeptr = 0;//如果读索引读到队列的最后一个位置了，那么置为0  </span><br><span class="line">            &#125;</span><br><span class="line">            --count;//个数--  </span><br><span class="line">            notFull.signal();//唤醒写线程  </span><br><span class="line">            return x;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际使用中，Condition 必须放在 Lock 的 lock 和 unlock 方法之间，主要用于模拟线程间的协调：</p>
<blockquote>
<p>如果不放在 lock 内，Condition 的 await 会释放 lock 的 state，如果还有别的地方使用到了该 lock，相当于直接被释放掉了。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">final Lock lock=new ReentrantLock();</span><br><span class="line">final Condition condition=lock.newCondition();</span><br><span class="line"></span><br><span class="line">public static void main(String[]args)&#123;</span><br><span class="line">    ConTest test=new ConTest();</span><br><span class="line">    Producer producer=test.new Producer();</span><br><span class="line">    Consumer consumer=test.new Consumer();</span><br><span class="line"></span><br><span class="line">    consumer.start();</span><br><span class="line">    producer.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Consumer extends Thread &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        consume();</span><br><span class="line">    &#125;</span><br><span class="line">    private void consume() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(&quot;我在等一个新信号&quot; + this.currentThread().getName());</span><br><span class="line">            condition.await();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            System.out.println(&quot;拿到一个信号&quot; + this.currentThread().getName());</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Producer extends Thread &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        produce();</span><br><span class="line">    &#125;</span><br><span class="line">    private void produce() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(&quot;我拿到锁&quot; + this.currentThread().getName());</span><br><span class="line">            condition.signalAll();</span><br><span class="line">            System.out.println(&quot;我发出了一个信号：&quot; + this.currentThread().getName());</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用Condition协调两个线程交替执行"><a href="#使用Condition协调两个线程交替执行" class="headerlink" title="使用Condition协调两个线程交替执行"></a>使用Condition协调两个线程交替执行</h4><p>问题：第一个线程输出奇数，第二个线程输出偶数，要求交替输出有序的结果：<code>1、2、3、4、5...</code>。<br>交替执行这种需求需要两个线程互相通知对方执行，使用基础的wait&#x2F;notify方法无法实现，需要使用Condition、LockSupport这种可以直接指定通知某个线程的API。<br>第一次写时我就犯了错，下面的代码执行到一半会发生死锁，输出到一半就不再继续输出了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 会发生死锁</span><br><span class="line"> * 原因：</span><br><span class="line"> * signal是瞬时的，线程2通知线程1的时候，线程1可能还没运行到await的地方</span><br><span class="line"> */</span><br><span class="line">public class OneByOneDeadLockTest &#123;</span><br><span class="line"></span><br><span class="line">    private static final Lock LOCK = new ReentrantLock();</span><br><span class="line">    private static final Condition ODD = LOCK.newCondition();</span><br><span class="line">    private static final Condition EVEN = LOCK.newCondition();</span><br><span class="line"></span><br><span class="line">    static class OddPrinter extends Thread &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            int num = 1;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                LOCK.lock();</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(&quot;await1&quot;);</span><br><span class="line">                    ODD.await();</span><br><span class="line">                    System.out.println(num);</span><br><span class="line">                    num += 2;</span><br><span class="line">                    System.out.println(&quot;signal1&quot;);</span><br><span class="line">                    EVEN.signal();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    LOCK.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class EvenPrinter extends Thread &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            int num = 2;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                LOCK.lock();</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(&quot;await2&quot;);</span><br><span class="line">                    EVEN.await();</span><br><span class="line">                    System.out.println(num);</span><br><span class="line">                    num += 2;</span><br><span class="line">                    System.out.println(&quot;signal2&quot;);</span><br><span class="line">                    ODD.signal();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    LOCK.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        OddPrinter oddPrinter = new OddPrinter();</span><br><span class="line">        EvenPrinter evenPrinter = new EvenPrinter();</span><br><span class="line">        oddPrinter.start();</span><br><span class="line">        evenPrinter.start();</span><br><span class="line">        LOCK.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            ODD.signal();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            LOCK.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过优化得到下面的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 生产者消费者交替执行</span><br><span class="line"> */</span><br><span class="line">public class OneByOneTest &#123;</span><br><span class="line"></span><br><span class="line">    private static final Lock LOCK = new ReentrantLock();</span><br><span class="line">    private static final Condition ODD = LOCK.newCondition();</span><br><span class="line">    private static final Condition EVEN = LOCK.newCondition();</span><br><span class="line">    private static volatile int CUR = 1;</span><br><span class="line"></span><br><span class="line">    static class OddPrinter extends Thread &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            int num = 1;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                LOCK.lock();</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(&quot;await1&quot;);</span><br><span class="line">                    while(CUR != 1) &#123;</span><br><span class="line">                        ODD.await();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(num);</span><br><span class="line">                    num += 2;</span><br><span class="line">                    System.out.println(&quot;signal1&quot;);</span><br><span class="line">                    CUR = 2;</span><br><span class="line">                    EVEN.signal();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    LOCK.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class EvenPrinter extends Thread &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            int num = 2;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                LOCK.lock();</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(&quot;await2&quot;);</span><br><span class="line">                    while(CUR != 2) &#123;</span><br><span class="line">                        EVEN.await();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(num);</span><br><span class="line">                    num += 2;</span><br><span class="line">                    System.out.println(&quot;signal2&quot;);</span><br><span class="line">                    CUR = 1;</span><br><span class="line">                    ODD.signal();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    LOCK.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        OddPrinter oddPrinter = new OddPrinter();</span><br><span class="line">        EvenPrinter evenPrinter = new EvenPrinter();</span><br><span class="line">        oddPrinter.start();</span><br><span class="line">        evenPrinter.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="同步工具类"><a href="#同步工具类" class="headerlink" title="同步工具类"></a>同步工具类</h2><p>JDK1.5 之前 Java 中如果需要令多个线程互相协作，必须使用<code>wait/notify/join</code>方法簇，这些 API 容易出错（比如虚假唤醒）而且可扩展性差，所以后来 JDK 提供了更多的工具类来处理线程协作的场景。</p>
<h3 id="闭锁-CountDownLatch"><a href="#闭锁-CountDownLatch" class="headerlink" title="闭锁 - CountDownLatch"></a>闭锁 - CountDownLatch</h3><p>日常开发中经常会遇到需要在主线程中开启多线程去并行执行任务，并且主线程需要等待所有子线程执行完毕后在进行汇总的场景，在 CountDownLatch 出现之前一般都是使用线程的 join() 方法来实现，但是 join 不够灵活，不能够满足不同场景的需要。</p>
<blockquote>
<p>join 相对 CountDownLatch 来说有以下两点劣势：<br>调用一个线程的 join 后，该线程会一直被阻塞直到该线程运行完毕，而 CountDownLatch 则可以在子线程运行完毕或运行过程中递减计数器，从而让 await 返回。<br>另外，使用线程池来管理线程时候一般都是直接添加一个 Runable 实例到线程池，这时就不方便再调用线程的 join 方法了。</p>
</blockquote>
<h4 id="不要这么做"><a href="#不要这么做" class="headerlink" title="不要这么做"></a>不要这么做</h4><p>CountDownLatch本身做的是线程间协调的工作，但是如果出现问题，就会有线程一直阻塞着执行不下去的风险，使用时需要尤为注意：</p>
<ul>
<li>finally中<code>countDown</code>，避免抛出异常后无法继续执行；</li>
<li><code>await</code>最好设置超时时间，避免由于意外情况无法释放。</li>
</ul>
<h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p><img src="/imgs/%E5%B9%B6%E5%8F%91/CountDownLatch%E7%B1%BB%E5%9B%BE.png" alt="CountDownLatch类图" title="CountDownLatch类图"></p>
<ul>
<li>CountDownLatch 是公平的，其实现基础同样是 AQS。</li>
</ul>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>构造方法中初始化 Sync 时把计数器的值赋值给了 AQS 的状态值 state，也就是这里 AQS 的状态值来表示计数器值。</p>
<h4 id="void-await"><a href="#void-await" class="headerlink" title="void await()"></a>void await()</h4><p>挂起当前线程，直到下面情况之一发生时才返回：</p>
<ul>
<li>当所有线程都调用了 CountDownLatch 对象的 <code>countDown()</code> 方法后，也就是计时器值为 0 的时候；</li>
<li>其它线程调用了当前线程的 <code>interrupt()</code> 方法中断了当前线程，当前线程会抛出 InterruptedException 异常后返回</li>
</ul>
<p>CountDownLatch.await()<br>    -&gt; AbstractQueuedSynchronizer.acquireSharedInterruptibly：获取共享资源，且可中断<br>    &gt; 为什么是acquireSharedInterruptibly而不是获取独占资源的acquireInterruptibly？因为这里状态值需要的并不是非 0 即 1 的效果，而是和初始化时候指定的计数器值有关系，比如你初始化时候计数器值为 8，那么 state 的值应该就有 0 到 8 的状态，而不是只有 0 和 1 的情况下的独占效果。plainplain<br>    1. 先调用Thread.interrupted()判断一下线程的中断状态，若被中断则抛出异常<br>    1. 尝试看当前是否计数值为0，为0则直接返回，否则进入AQS的队列等待<br>-&gt; AbstractQueuedSynchronizer.doAcquireSharedInterruptibly</p>
<h4 id="boolean-await-long-timeout-TimeUnit-unit"><a href="#boolean-await-long-timeout-TimeUnit-unit" class="headerlink" title="boolean await(long timeout, TimeUnit unit)"></a>boolean await(long timeout, TimeUnit unit)</h4><p>比起 await 多了个返回条件：</p>
<ul>
<li>超时后返回 false。</li>
</ul>
<h4 id="void-countDown"><a href="#void-countDown" class="headerlink" title="void countDown()"></a>void countDown()</h4><p>递减计数器的值，递减后如果计数器为 0 则会唤醒所有调用 await 方法而被阻塞的线程。</p>
<p>CountDownLatch.countDown<br>-&gt; AbstractQueuedSynchronizer.releaseShared<br>-&gt; CountDownLatch.Sync.tryReleaseShared：循环 CAS 设置状态值，返回值表示当前线程是否为第一个将状态值设置为 0 的，当前状态值已经为 0 则返回 false，或者当前线程成功完成 cas 使计数值（状态值 state）减一并更新到 state 并返回，如果当前状态值为 0 返回 true<br>-&gt; AbstractQueuedSynchronizer.doReleaseShared</p>
<h4 id="long-getCount"><a href="#long-getCount" class="headerlink" title="long getCount()"></a>long getCount()</h4><p>获取当前计数器的值，也就是 AQS 的 state 的值，一般在 debug 测试时候使用。</p>
<h4 id="实例-模拟并发请求"><a href="#实例-模拟并发请求" class="headerlink" title="实例 - 模拟并发请求"></a>实例 - 模拟并发请求</h4><p>如果要用 Java 模拟并发请求，最基本的方案就是创建多个线程然后一一启动，但是如此一来请求就会带上先后顺序了，一种解决办法是通过 CountDownLatch 来同步多个线程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">CountDownLatch start = new CountDownLatch(1);</span><br><span class="line">CountDownLatch end = new CountDownLatch(10);</span><br><span class="line">for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    new Thread(() -&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            start.await();</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                end.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line">start.countDown();</span><br><span class="line">end.await();</span><br></pre></td></tr></table></figure>

<h3 id="栅栏-CyclicBarrier"><a href="#栅栏-CyclicBarrier" class="headerlink" title="栅栏 - CyclicBarrier"></a>栅栏 - CyclicBarrier</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CyclicBarrier cyclicBarrier = new CyclicBarrier(3);</span><br><span class="line">ExecutorService threadPool = Executors.newFixedThreadPool(3);</span><br><span class="line">for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">    threadPool.submit(() -&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            cyclicBarrier.await(1000, TimeUnit.MILLISECONDS);</span><br><span class="line">            System.out.println(&quot;x&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">threadPool.shutdown();</span><br><span class="line">threadPool.awaitTermination(3000, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure>
<h4 id="不要这么做-1"><a href="#不要这么做-1" class="headerlink" title="不要这么做"></a>不要这么做</h4><p>对CyclicBarrier的使用注意和CountDownLatch有点类似，都是需要避免永久等待的情况：</p>
<ul>
<li>发令枪不要报错否则全部阻塞；</li>
<li><code>await</code>最好设置一个等待时间，否则可能出现某个线程出错导致所有线程都执行不下去的情况。</li>
</ul>
<h4 id="CyclicBarrier结构"><a href="#CyclicBarrier结构" class="headerlink" title="CyclicBarrier结构"></a>CyclicBarrier结构</h4><p><img src="/imgs/%E5%B9%B6%E5%8F%91/CyclicBarrier%E7%B1%BB%E5%9B%BE.png" alt="CyclicBarrier类图" title="CyclicBarrier类图"></p>
<ul>
<li>parties：记录线程个数，用来表示需要多少线程先调用 await 后，所有线程才会冲破屏障继续往下运行；</li>
<li>count：count 一开始等于 parties，每当线程调用 await 方法后就递减 1，当为 0 时候就表示所有线程都到了屏障点；<blockquote>
<p>用两个变量而不是一个的原因是CyclicBarrier可以复用，parties始终用来记录总线程个数，当count计数器变为0后，会使用parties赋值给count，达到复用的目的。</p>
</blockquote>
</li>
<li>lock：lock保证了<code>await</code>方法的线程安全性，更新计数器<code>count</code>的时候可以保证原子性；</li>
<li>trip：条件变量，支持线程间使用notify、wait操作进行同步。</li>
<li>generation：generation 内部就一个变量 broken 用来记录当前屏障是否被打破，另外注意这里 broken 并没有被声明为 volatile，是因为锁内使用变量不需要。  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private static class Generation &#123;</span><br><span class="line">    boolean broken = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="await-1"><a href="#await-1" class="headerlink" title="await"></a>await</h4><p>当线程调用<code>await</code>方法时线程会被阻塞，直到满足以下条件之一：</p>
<ul>
<li><code>parties</code> 个线程都调用了 <code>await</code> 函数，也就是线程都到了屏障点；</li>
<li>其它线程调用了当前线程的 <code>interrupt</code>方法中断了当前线程，则当前线程会抛出 <code>InterruptedException</code> 异常返回；</li>
<li>当前屏障点关联的 <code>Generation</code> 对象的 broken 标志被设置为 true 时候，会抛出 <code>BrokenBarrierException</code> 异常。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public int await() throws InterruptedException, BrokenBarrierException &#123;</span><br><span class="line">   try &#123;</span><br><span class="line">       return dowait(false, 0L);</span><br><span class="line">   &#125; catch (TimeoutException toe) &#123;</span><br><span class="line">       throw new Error(toe); // cannot happen</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="await-long-timeout-TimeUnit-unit"><a href="#await-long-timeout-TimeUnit-unit" class="headerlink" title="await(long timeout, TimeUnit unit)"></a>await(long timeout, TimeUnit unit)</h4><p>除了上边<code>await</code>的三个条件之外：</p>
<ul>
<li>到达了设置的超时时间后也会直接返回false；</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public int await(long timeout, TimeUnit unit)</span><br><span class="line">    throws InterruptedException,</span><br><span class="line">           BrokenBarrierException,</span><br><span class="line">           TimeoutException &#123;</span><br><span class="line">    return dowait(true, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="dowait"><a href="#dowait" class="headerlink" title="dowait"></a>dowait</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">private int dowait(boolean timed, long nanos)</span><br><span class="line">    throws InterruptedException, BrokenBarrierException,</span><br><span class="line">           TimeoutException &#123;</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        final Generation g = generation;</span><br><span class="line"></span><br><span class="line">        if (g.broken)plain</span><br><span class="line">            throw new BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">        if (Thread.interrupted()) &#123;</span><br><span class="line">            breakBarrier();</span><br><span class="line">            throw new InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 如果index==0说明所有线程都到到了屏障点，则执行初始化时候传递的任务</span><br><span class="line">        int index = --count;</span><br><span class="line">        if (index == 0) &#123;  // tripped</span><br><span class="line">            boolean ranAction = false;</span><br><span class="line">            try &#123;</span><br><span class="line">                // 执行任务</span><br><span class="line">                final Runnable command = barrierCommand;</span><br><span class="line">                if (command != null)</span><br><span class="line">                    command.run();</span><br><span class="line">                ranAction = true;</span><br><span class="line">                // 激活其它调用await而被阻塞的线程，并重置CyclicBarrier</span><br><span class="line">                nextGeneration();</span><br><span class="line">                return 0;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                if (!ranAction)</span><br><span class="line">                    breakBarrier();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 轮询等待</span><br><span class="line">        // loop until tripped, broken, interrupted, or timed out</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                // 没有设置爱超时时间</span><br><span class="line">                if (!timed)</span><br><span class="line">                    trip.await();</span><br><span class="line">                // 设置了超时时间</span><br><span class="line">                else if (nanos &gt; 0L)</span><br><span class="line">                    // 当前线程被放入条件变量trip的阻塞队列，当前线程会被挂起并释放lock</span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; catch (InterruptedException ie) &#123;</span><br><span class="line">                if (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    throw ie;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // We&#x27;re about to finish waiting even if we had not</span><br><span class="line">                    // been interrupted, so this interrupt is deemed to</span><br><span class="line">                    // &quot;belong&quot; to subsequent execution.</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (g.broken)</span><br><span class="line">                throw new BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">            if (g != generation)</span><br><span class="line">                return index;</span><br><span class="line"></span><br><span class="line">            if (timed &amp;&amp; nanos &lt;= 0L) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                throw new TimeoutException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void nextGeneration() &#123;</span><br><span class="line">    // 唤醒条件队列里面阻塞线程</span><br><span class="line">    trip.signalAll();</span><br><span class="line">    // 重置CyclicBarrier</span><br><span class="line">    count = parties;</span><br><span class="line">    generation = new Generation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>Semaphore 信号量也是 Java 中一个同步器，与 CountDownLatch 和 CycleBarrier 不同在于它内部的计数器是递增的。<br><img src="/imgs/%E5%B9%B6%E5%8F%91/Semaphore%E7%B1%BB%E5%9B%BE.png" alt="Semaphore类图" title="Semaphore类图"></p>
<h4 id="公平和非公平"><a href="#公平和非公平" class="headerlink" title="公平和非公平"></a>公平和非公平</h4><p>类似ReentrantLock，Semaphore也提供了公平和非公平两套API：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public Semaphore(int permits) &#123;</span><br><span class="line">    sync = new NonfairSync(permits);</span><br><span class="line">&#125;</span><br><span class="line">public Semaphore(int permits, boolean fair) &#123;</span><br><span class="line">    sync = fair ? new FairSync(permits) : new       </span><br><span class="line">    NonfairSync(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，参数permits为信号量个数，这里最终会赋值给AQS的state。</p>
<h4 id="非公平-acquire"><a href="#非公平-acquire" class="headerlink" title="非公平 acquire"></a>非公平 acquire</h4><p>当前线程调用该方法时候目的是希望获取一个信号量资源，如果当前信号量计数个数大于 0，并且当前线程获取到了一个信号量则该方法直接返回，当前信号量的计数会减少 1. 否则会被放入 AQS 的阻塞队列，当前线程被挂起，直到其它线程调用了 release 方法释放了信号量，并且当前线程通过竞争获取到了该信号量。<br>可中断的：当前线程被其它线程调用了 interrupt() 方法中断后，当前线程会抛出 InterruptedException 异常然后返回。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public void acquire() throws InterruptedException &#123;</span><br><span class="line">    // 传递参数为 1，说明要获取 1 个信号量资源</span><br><span class="line">    sync.acquireSharedInterruptibly(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final void acquireSharedInterruptibly(int arg)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    // 如果线程被中断，则抛出中断异常</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    // 否则调用 sync 子类方法尝试获取,这里根据构造函数确定使用公平策略，tryAcquireShared 返回小于 0 说明剩余信号量已不够本次请求</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">        // 获取失败，放入阻塞队列，然后再次尝试如果失败则调用 park 方法挂起当前线程</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">    return nonfairTryAcquireShared(acquires);</span><br><span class="line">&#125;</span><br><span class="line">final int nonfairTryAcquireShared(int acquires) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        // 获取当前信号量值</span><br><span class="line">        int available = getState();</span><br><span class="line">        // 计算当前剩余值</span><br><span class="line">        int remaining = available - acquires;</span><br><span class="line">        // 如果当前剩余小于0或者CAS设置成功则返回</span><br><span class="line">        if (remaining &lt; 0 ||</span><br><span class="line">                compareAndSetState(available, remaining))</span><br><span class="line">            return remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见，非公平版本的实现的核心是nonfairTryAcquireShared中的循环。</p>
<h4 id="公平版-acquire"><a href="#公平版-acquire" class="headerlink" title="公平版 acquire"></a>公平版 acquire</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        if (hasQueuedPredecessors())</span><br><span class="line">            return -1;</span><br><span class="line">        int available = getState();</span><br><span class="line">        int remaining = available - acquires;</span><br><span class="line">        if (remaining &lt; 0 ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            return remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>公平版本的核心是<code>hasQueuedPredecessors</code>判断AQS中是否有前驱节点。</p>
<h4 id="acquire-int-permits"><a href="#acquire-int-permits" class="headerlink" title="acquire(int permits)"></a>acquire(int permits)</h4><h4 id="acquireUninterruptibly"><a href="#acquireUninterruptibly" class="headerlink" title="acquireUninterruptibly"></a>acquireUninterruptibly</h4><h4 id="acquireUninterruptibly-int-permits"><a href="#acquireUninterruptibly-int-permits" class="headerlink" title="acquireUninterruptibly(int permits)"></a>acquireUninterruptibly(int permits)</h4><h4 id="release"><a href="#release" class="headerlink" title="release"></a>release</h4><p>该方法作用的把当前 semaphore 对象的信号量值增加 1，如果当前有线程因为调用 aquire 方法被阻塞放入了 AQS 的阻塞队列，则会根据公平策略选择一个线程进行激活，激活的线程会尝试获取刚增加的信号量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public void release() &#123;</span><br><span class="line">    // 默认释放 1 个</span><br><span class="line">    sync.releaseShared(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line"></span><br><span class="line">    // 尝试释放资源</span><br><span class="line">    if (tryReleaseShared(arg)) &#123;</span><br><span class="line"></span><br><span class="line">        // 资源释放成功则调用park唤醒AQS队列里面最先挂起的线程</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected final boolean tryReleaseShared(int releases) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line"></span><br><span class="line">        // 获取当前信号量值</span><br><span class="line">        int current = getState();</span><br><span class="line"></span><br><span class="line">        // 当前信号量值增加releases，这里为增加1</span><br><span class="line">        int next = current + releases;</span><br><span class="line">        if (next &lt; current) // 移除处理</span><br><span class="line">            throw new Error(&quot;Maximum permit count exceeded&quot;);</span><br><span class="line"></span><br><span class="line">        // 使用cas保证更新信号量值的原子性</span><br><span class="line">        if (compareAndSetState(current, next))</span><br><span class="line">            return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="release-int-permits"><a href="#release-int-permits" class="headerlink" title="release(int permits)"></a>release(int permits)</h4><h3 id="Phase"><a href="#Phase" class="headerlink" title="Phase"></a>Phase</h3><p>TODO<br>相对 CountDownLatch 和 CyclicBarrier 来说，Phase 支持多阶段协同；</p>
<ul>
<li>Phase 表示当前阶段，最多可以有(2^32 - 1)个阶段；</li>
<li>Parties 表示参与此次过程的参与者（不一定是线程）数量，最多 65535 个。</li>
</ul>
<h2 id="隔离可变性"><a href="#隔离可变性" class="headerlink" title="隔离可变性"></a>隔离可变性</h2><p>引起线程安全问题的原因无非如下两点：</p>
<ol>
<li>多个线程在临界区的竞争。</li>
<li>对象本身是可变的。</li>
</ol>
<p>其中，如何解决竞争问题我们讨论过了，可变性的管理有两种策略：</p>
<ol>
<li>杜绝可变性，即控制变量为不可变的，需要控制对象所有字段为 final，并且还要保证不会有一些乱来的反射代码去强行写入这些字段；</li>
<li>隔离可变性，令变量永远只由一个线程来操作，最常见的实现方式是 ThreadLocal。</li>
</ol>
<h3 id="ThreadLocal（线程本地变量）"><a href="#ThreadLocal（线程本地变量）" class="headerlink" title="ThreadLocal（线程本地变量）"></a>ThreadLocal（线程本地变量）</h3><p>不同于锁，ThreadLocal 的思路不是同步，而是规避了同步必要，因为每个线程都只操作属于自己的变量。</p>
<h4 id="为什么要使用-ThreadLocal"><a href="#为什么要使用-ThreadLocal" class="headerlink" title="为什么要使用 ThreadLocal"></a>为什么要使用 ThreadLocal</h4><ol>
<li>在同一线程中方法与方法，类与类之间的共享内容传输（也是官方创建 ThreadLocal 的本意）。</li>
<li>利用 ThreadLocal 规避线程安全问题，这种方式已经大量应用，如 Spring mvc 在 Controller 中注入全局 HttpSession 对象。</li>
</ol>
<h4 id="ThreadLocal-原理"><a href="#ThreadLocal-原理" class="headerlink" title="ThreadLocal 原理"></a>ThreadLocal 原理</h4><p><img src="/imgs/%E5%B9%B6%E5%8F%91/ThreadLocal%E7%B1%BB%E5%9B%BE.png" alt="ThreadLocal类图" title="ThreadLocal类图"><br>注意 ThreadLocal 中的 set、setInitialValue、set 方法，及 Thread 中的 ThreadLocalMap（不是 HashMap）类型的 threadLocals 变量。<br>每个线程维持一个 ThreadLocalMap 用于保存当前线程的所有 ThreadLocal 变量，ThreadLocalMap 保存的键值对，每个线程在第一次调用 set()或 get()时会初始化之。<br>key 为什么是 ThreadLocal？线程执行时可能创建多个 ThreadLocal，我们可以重定义它的 hashCode 来定位到散列表的不同槽位（实际上 ThreadLocal 并没有重定义 hashCode 方法，而是使用成员变量 threadLocalHashCode 来表示，大概是想用自定义的素数来得到更小的碰撞概率吧）。<br>这样每个线程相当于都有自己的一个局部变量表，不同线程的表又是完全隔离的。</p>
<h4 id="ThreadLocal的内存泄露问题"><a href="#ThreadLocal的内存泄露问题" class="headerlink" title="ThreadLocal的内存泄露问题"></a>ThreadLocal的内存泄露问题</h4><p>ThreadLocal使用ThreadLocalMap来保存值，ThreadLocalMap中每个key都是弱引用，弱引用本身会在内存不足时被回收，但是value并不是弱引用，因此value会一直留在原地导致泄漏，除非该位置被重新hash。</p>
<h3 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a>InheritableThreadLocal</h3><h4 id="为什么要使用-InheritableThreadLocal"><a href="#为什么要使用-InheritableThreadLocal" class="headerlink" title="为什么要使用 InheritableThreadLocal"></a>为什么要使用 InheritableThreadLocal</h4><p>若父线程（比如 main 线程）中设置了一个 ThreadLocal 值，子线程中是无法获得的，因为它们处于不同的线程内。InheritableThreadLocal 就是用于解决子线程中获取不到父线程中设置的 ThreadLocal 变量的值的问题的。<br>例 1 - 使用 InheritableThreadLocal：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class InheritableThreadLocalTest &#123;</span><br><span class="line">  private InheritableThreadLocal&lt;String&gt; itl = new InheritableThreadLocal&lt;&gt;();</span><br><span class="line">  @Test</span><br><span class="line">  public void test() &#123;</span><br><span class="line">    itl.set(&quot;hello&quot;);</span><br><span class="line">    new Thread(() -&gt; &#123;</span><br><span class="line">      System.out.println(itl.get());</span><br><span class="line">    &#125;).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一些应用场景如：</p>
<ol>
<li>存放用户登录信息的 threadlocal 变量，很有可能子线程中也需要使用用户登录信息</li>
<li>一些中间件需要用统一的追踪 ID 把整个调用链路记录下来的情景。</li>
</ol>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>InheritableThreadLocal 继承了 ThreadLocal 并对以下三个方法进行了重写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">实例化每个线程的 ThreadLocalMap 时，会根据这个方法来获取父线程中的值，在初始化子线程时保存了父线程线程隔离变量的一份拷贝。</span><br><span class="line">具体的，看 ThreadLocalMap 的构造方法 ThreadLocalMap(parentMap)中对 childValue()的使用</span><br><span class="line">调用链是这样的：Thread.init() -&gt; ThreadLocal.createInheritedMap(parentMap) -&gt; ThreadLocalMap(parentMap)</span><br><span class="line">*/</span><br><span class="line">protected T childValue (T parentValue)&#123;</span><br><span class="line">  return parentValue;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">ThreadLocal 中的 CRUD 操作都会调用 getMap(Thread.currentThread())来获取实现，如果是对 InheritableThreadLocal 调用的就会获取 inheritableThreadLocals</span><br><span class="line">具体的，看 ThreadLocal 中的 get()、set()、remove()等 CRUD 方法</span><br><span class="line">*/</span><br><span class="line">ThreadLocalMap getMap (Thread t)&#123;</span><br><span class="line">  return t.inheritableThreadLocals;</span><br><span class="line">&#125;</span><br><span class="line">void createMap (Thread t, T firstValue)&#123;</span><br><span class="line">  t.inheritableThreadLocals = new ThreadLocalMap(this, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ThreadLocalRandom"><a href="#ThreadLocalRandom" class="headerlink" title="ThreadLocalRandom"></a>ThreadLocalRandom</h3><p>ThreadLocalRandom 类是 JDK7 在 JUC 包下新增的随机数生成器，它解决了 Random 类在多线程下的不足。</p>
<h4 id="Random-类及其局限性"><a href="#Random-类及其局限性" class="headerlink" title="Random 类及其局限性"></a>Random 类及其局限性</h4><p>Random 中对 seed（随机数种子）的更新是通过 CAS 操作完成的，随机数即种子值的末尾几位，如下代码所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">protected int next(int bits) &#123;</span><br><span class="line">    long oldseed, nextseed;</span><br><span class="line">    AtomicLong seed = this.seed;</span><br><span class="line">    do &#123;</span><br><span class="line">        oldseed = seed.get();</span><br><span class="line">        nextseed = (oldseed * multiplier + addend) &amp; mask;</span><br><span class="line">    &#125; while (!seed.compareAndSet(oldseed, nextseed));</span><br><span class="line">    return (int)(nextseed &gt;&gt;&gt; (48 - bits));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么要使用 CAS？实际上 seed 在多线程环境下是可能会产生线程安全问题的，多个线程在根据同一个老种子计算新种子时候，第一个线程的新种子计算出来后，第二个线程要丢弃自己老的种子，要使用第一个线程的新种子来计算自己的新种子，依次类推，只有保证了这个，才能保证多线程下产生的随机数是随机的。也就是说需要进行同步，CAS 相对 synchronized 等基于锁的方案来说更高效。<br>多线程下使用单个 Random 实例生成随机数时候，多个线程同时计算新的种子时候会竞争同一个原子变量的更新操作，由于原子变量的更新是 CAS 操作，同时只有一个线程会成功，所以会造成大量线程进行自旋重试，这是会降低并发性能的，所以 ThreadLocalRandom 应运而生。</p>
<h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p><img src="/imgs/%E5%B9%B6%E5%8F%91/ThreadLocalRandom%E7%B1%BB%E5%9B%BE.png" alt="ThreadLocalRandom类图" title="ThreadLocalRandom类图"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">// 初始化 UNSAFE</span><br><span class="line">private static final sun.misc.Unsafe UNSAFE;</span><br><span class="line">private static final long SEED;</span><br><span class="line">private static final long PROBE;</span><br><span class="line">private static final long SECONDARY;</span><br><span class="line">static &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        //获取 unsafe 实例</span><br><span class="line">        UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">        Class&lt;?&gt; tk = Thread.class;</span><br><span class="line">        // ThreadLocalRandom 中没有种子，而是使用 Thread 中的 threadLocalRandomSeed 变量来代替</span><br><span class="line">        // 获取 Thread 类里面 threadLocalRandomSeed 变量在 Thread 实例里面偏移量</span><br><span class="line">        SEED = UNSAFE.objectFieldOffset</span><br><span class="line">            (tk.getDeclaredField(&quot;threadLocalRandomSeed&quot;));</span><br><span class="line">        //获取 Thread 类里面 threadLocalRandomProbe 变量在 Thread 实例里面偏移量</span><br><span class="line">        PROBE = UNSAFE.objectFieldOffset</span><br><span class="line">            (tk.getDeclaredField(&quot;threadLocalRandomProbe&quot;));</span><br><span class="line">        //获取 Thread 类里面 threadLocalRandomProbe 变量在 Thread 实例里面偏移量，这个值在后面讲解的 LongAdder 里面会用到</span><br><span class="line">        SECONDARY = UNSAFE.objectFieldOffset</span><br><span class="line">            (tk.getDeclaredField(&quot;threadLocalRandomSecondarySeed&quot;));</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        throw new Error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 单例变量</span><br><span class="line">static final ThreadLocalRandom instance = new ThreadLocalRandom();</span><br><span class="line"></span><br><span class="line">final long nextSeed() &#123;</span><br><span class="line">    Thread t; long r; // read and update per-thread seed</span><br><span class="line">    U.putLong(t = Thread.currentThread(), SEED,</span><br><span class="line">              r = U.getLong(t, SEED) + GAMMA);</span><br><span class="line">    return r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int nextInt() &#123;</span><br><span class="line">    return mix32(nextSeed());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static final void localInit() &#123;</span><br><span class="line">    // seeder 和 probeGenerator 是两个原子性变量，在初始化调用线程的种子和探针变量时候用到，每个线程只会使用一次</span><br><span class="line">    // 根据 probeGenerator 计算当前线程中 threadLocalRandomProbe 的初始化值</span><br><span class="line">    int p = probeGenerator.addAndGet(PROBE_INCREMENT);</span><br><span class="line">    int probe = (p == 0) ? 1 : p; // skip 0</span><br><span class="line">    // 然后根据 seeder 计算当前线程的初始化种子</span><br><span class="line">    long seed = mix64(seeder.getAndAdd(SEEDER_INCREMENT));</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    // 设置到当前线程</span><br><span class="line">    U.putLong(t, SEED, seed);</span><br><span class="line">    U.putInt(t, PROBE, probe);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 通过 UNSAFE 运算获取 ThreadLocalRandom 实例，调用 localInit()初始化 Thread 中的 threadLocalRandomSeed 和 threadLocalRandomProbe 变量</span><br><span class="line">public static ThreadLocalRandom current() &#123;</span><br><span class="line">    // 延迟初始化：当前线程中的 threadLocalRandomProbe 值为 0 的情况，说明是第一次调用 current 方法，需要调用 localInit 初始化</span><br><span class="line">    // 初始化逻辑：计算当前线程的初始化种子变量</span><br><span class="line">    if (U.getInt(Thread.currentThread(), PROBE) == 0)</span><br><span class="line">        localInit();</span><br><span class="line">    return instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 计算当前线程的下一个随机数</span><br><span class="line">public int nextInt(int bound) &#123;</span><br><span class="line">    if (bound &lt;= 0)</span><br><span class="line">        throw new IllegalArgumentException(BadBound);</span><br><span class="line">    int r = mix32(nextSeed());</span><br><span class="line">    int m = bound - 1;</span><br><span class="line">    if ((bound &amp; m) == 0) // power of two</span><br><span class="line">        r &amp;= m;</span><br><span class="line">    else &#123; // reject over-represented candidates</span><br><span class="line">        for (int u = r &gt;&gt;&gt; 1;</span><br><span class="line">             u + m - (r = u % bound) &lt; 0;</span><br><span class="line">             u = mix32(nextSeed()) &gt;&gt;&gt; 1)</span><br><span class="line">            ;</span><br><span class="line">    &#125;</span><br><span class="line">    return r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final long nextSeed() &#123;</span><br><span class="line">    Thread t; long r;</span><br><span class="line">    // 使用 UNSAFE 的 putLong 方法把新种子放入当前线程的 threadLocalRandomSeed 变量</span><br><span class="line">    UNSAFE.putLong(t = Thread.currentThread(), SEED,</span><br><span class="line">                   // 获取当前线程中 threadLocalRandomSeed 变量的值，然后在种子的基础上累加 GAMMA 值作为新种子</span><br><span class="line">                   r = UNSAFE.getLong(t, SEED) + GAMMA);</span><br><span class="line">    return r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="原子性操作"><a href="#原子性操作" class="headerlink" title="原子性操作"></a>原子性操作</h2><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>多个线程执行一个操作时，其中任何一个线程要么完全执行完此操作，要么没有执行此操作的任何步骤，那么这个操作就是原子的。<br>要程序的最终结果等同于它在严格的顺序化环境下的结果，那么指令的执行顺序就可能与代码的顺序不一致，比如多线程是在一个CPU上执行的，多个线程的指令需要进行<strong>重排</strong>，再按顺序执行。<br>如果动作B要看到动作A的执行结果（无论A&#x2F;B是否在同一个线程里面执行），那么A&#x2F;B就需要满足 <strong>happens-before</strong> 关系。  </p>
<h3 id="实现原子性的几种方式"><a href="#实现原子性的几种方式" class="headerlink" title="实现原子性的几种方式"></a>实现原子性的几种方式</h3><ol>
<li>互斥锁：如synchronized、Lock、Condition、ReadWriteLock等。</li>
<li>线程隔离变量：如ThreadLocal等。</li>
<li>线性化：将线程任务丢到一个单线程的线程池中调度执行（比如<code>Executors.newSingleThreadExecutor</code>）。</li>
<li>CAS：包括<code>AtomicInteger</code>等现成的工具类，或者可以使用<code>Unsafe</code>自行实现，另外，JDK8还提供了高并发下性能更优的<code>LongAdder</code>。</li>
</ol>
<h3 id="原子表达式"><a href="#原子表达式" class="headerlink" title="原子表达式"></a>原子表达式</h3><p>在设计计数器时候一般都是先读取当前值，然后+1，然后更新，这个过程是读 -&gt; 改 -&gt; 写的过程，如果不能保证这个过程是原子性，那么就会出现线程安全问题。如下代码是线程不安全的，因为不能保证 ++value 是原子性操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadNotSafeCount &#123;</span><br><span class="line">    private Long value;</span><br><span class="line">    public Long getCount() &#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">    public void inc() &#123;</span><br><span class="line">        ++value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过使用 <code>Javap -c</code> 查看汇编代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void inc();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0       </span><br><span class="line">       1: dup           </span><br><span class="line">       2: getfield #2 // Field value:J</span><br><span class="line">       5: lconst_1      </span><br><span class="line">       6: ladd          </span><br><span class="line">       7: putfield #2 // Field value:J</span><br><span class="line">      10: return       </span><br></pre></td></tr></table></figure>
<p>可知简单的 ++value有 2，5，6，7 组成，其中2是获取当前 value 的值并放入栈顶，5是把常量1放入栈顶，6是把当前栈顶中2个值相加并把结果放入栈顶，7则是把栈顶结果赋值会 value 变量，可知 Java 中简单的一句 ++value 转换为汇编后就不具有原子性了。</p>
<h3 id="CAS（Compare-and-Swap）"><a href="#CAS（Compare-and-Swap）" class="headerlink" title="CAS（Compare and Swap）"></a>CAS（Compare and Swap）</h3><p>在 Java 中锁在并发处理中占据了一席之地，但是使用锁不好的地方是当一个线程没有获取到锁后会被阻塞挂起，这会导致线程上下文的切换和重新调度的开销。<br>Java 中提供了非阻塞的 volatile 关键字来解决共享变量的可见性问题，这在一定程度上弥补了锁所在带来的开销，但是 volatile 只能保证共享变量的可见性问题，但是还是不能解决例如读 -&gt; 改 -&gt; 写等的原子性问题。<br>CAS 即 Compare And Swap，是 JDK 提供的非阻塞原子性操作，它通过硬件保证了比较-更新操作的原子性。在set之前先比较该值有没有变化，只有在没变的情况下才对其赋值。</p>
<h3 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h3><p><strong>ABA</strong> 问题：变量a经过A-&gt;B-&gt;A的修改变回了原来的值，此时CAS会认为a的值没有发生变化，但它确实发生了变化。ABA的解决办法很多，基本上是另外使用一个变量来标志这个a是否发生了变化。<br>在Java中已经有现成的工具类解决了ABA问题：<code>AtomicMarkableReference</code>和<code>AtomicStampedReference</code>。</p>
<ul>
<li>AtomicMarkableReference：通过引入一个 boolean变量来反映中间有没有变过；</li>
<li>AtomicStampedReference：通过引入一个 int 来累加来反映中间有没有变过。</li>
</ul>
<h3 id="AtomicXxx"><a href="#AtomicXxx" class="headerlink" title="AtomicXxx"></a>AtomicXxx</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int addAndGet(int delta)：以原子方式将给定值与当前值相加。 实际上就是等于线程安全版本的 i =i+delta 操作。</span><br><span class="line">boolean compareAndSet(int expect, int update)：如果当前值 == 预期值，则以原子方式将该值设置为给定的更新值。 如果成功就返回 true，否则返回 false，并且不修改原值。</span><br><span class="line">int decrementAndGet()：以原子方式将当前值减 1。 相当于线程安全版本的–i 操作。</span><br><span class="line">int getAndAdd(int delta)：以原子方式将给定值与当前值相加。 相当于线程安全版本的 t=i;i+=delta;return t;操作。</span><br><span class="line">int getAndDecrement()：以原子方式将当前值减 1。 相当于线程安全版本的 i–操作。</span><br><span class="line">int getAndIncrement()：以原子方式将当前值加 1。 相当于线程安全版本的 i++操作。</span><br><span class="line">int getAndSet(int newValue)：以原子方式设置为给定值，并返回旧值。 相当于线程安全版本的 t=i;i=newValue;return t;操作。</span><br><span class="line">int incrementAndGet()：以原子方式将当前值加 1。 相当于线程安全版本的++i 操作。</span><br></pre></td></tr></table></figure>

<p>JUC中的原子性工具类包括 AtomicInteger，AtomicLong，AtomicBoolean，其内部使用 Unsafe 来实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class AtomicLong extends Number implements java.io.Serializable &#123;</span><br><span class="line">    // 获取 Unsafe 实例</span><br><span class="line">    private static final Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line"></span><br><span class="line">    // 存放变量value的偏移量plain</span><br><span class="line">    private static final long valueOffset;</span><br><span class="line"></span><br><span class="line">    // 判断JVM是否支持Long类型无锁CAS</span><br><span class="line">    static final boolean VM_SUPPORTS_LONG_CAS = VMSupportsCS8();</span><br><span class="line">    private static native boolean VMSupportsCS8();</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 获取value在AtomicLong中偏移量</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicLong.class.getDeclaredField(&quot;value&quot;));</span><br><span class="line">        &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 实际变量值，volatile保证了多线程下的内存可见性</span><br><span class="line">    private volatile long value;</span><br><span class="line"></span><br><span class="line">    public AtomicLong(long initialValue) &#123;</span><br><span class="line">        value = initialValue;</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="getAndIncrement"><a href="#getAndIncrement" class="headerlink" title="getAndIncrement"></a>getAndIncrement</h4><p>在JDK7中的实现逻辑为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public final long getAndIncrement() &#123;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        long current = get();</span><br><span class="line">        long next = current + 1;</span><br><span class="line">        if (compareAndSet(current, next))</span><br><span class="line">            return current;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而 JDK 8 将CAS操作抽取到了<code>Unsafe</code>中，<code>getAndIncrement</code>的实现被修改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final long getAndIncrement() &#123;</span><br><span class="line">    return unsafe.getAndAddLong(this, valueOffset, 1L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h3><h4 id="compareAndSwapLong-Object-obj-long-valueOffset-long-expect-long-update"><a href="#compareAndSwapLong-Object-obj-long-valueOffset-long-expect-long-update" class="headerlink" title="compareAndSwapLong(Object obj,long valueOffset,long expect, long update)"></a>compareAndSwapLong(Object obj,long valueOffset,long expect, long update)</h4><p>compareAndSwap 的意思也就是比较并交换，四个操作数分别为：对象内存位置，对象中的变量的偏移量，变量预期值 expect，新的值 update。<br>操作含义是如果对象 obj 中内存偏移量为 valueOffset 位置的变量值为 expect 则使用新的值 update 替换旧的值 expect。这个是处理器提供的一个原子性指令。<br>JDK 的 rt.jar 包中的 Unsafe 类提供了硬件级别的原子操作，Unsafe 里面的方法都是 native 方法，通过使用 JNI 的方式来访问本地 C++ 实现库。</p>
<h4 id="objectFieldOffset-Field-field"><a href="#objectFieldOffset-Field-field" class="headerlink" title="objectFieldOffset(Field field)"></a>objectFieldOffset(Field field)</h4><p>返回指定的变量在所属类的内存偏移地址，偏移地址仅仅在该 Unsafe 函数中访问指定字段时候使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicLong.class.getDeclaredField(&quot;value&quot;));</span><br><span class="line">        &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他一些方法如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int arrayBaseOffset(Class arrayClass) 方法 获取数组中第一个元素的地址</span><br><span class="line">int arrayIndexScale(Class arrayClass) 方法 获取数组中单个元素占用的字节数</span><br><span class="line">boolean compareAndSwapLong(Object obj, long offset, long expect, long update) 方法 比较对象 obj 中偏移量为 offset 的变量的值是不是和 expect 相等，相等则使用 update 值更新，然后返回 true，否者返回 false</span><br><span class="line">public native long getLongVolatile(Object obj, long offset) 方法 获取对象 obj 中偏移量为 offset 的变量对应的 volatile 内存语义的值。</span><br><span class="line">void putLongVolatile(Object obj, long offset, long value) 方法 设置 obj 对象中内存偏移为 offset 的 long 型变量的值为 value，支持 volatile 内存语义。</span><br><span class="line">void putOrderedLong(Object obj, long offset, long value) 方法 设置 obj 对象中 offset 偏移地址对应的 long 型 field 的值为 value。这是有延迟的 putLongVolatile 方法，并不保证值修改对其它线程立刻可见。变量只有使用 volatile 修饰并且期望被意外修改的时候使用才有用。</span><br><span class="line">void park(boolean isAbsolute, long time) 阻塞当前线程，其中参数 isAbsolute 等于 false 时候，time 等于 0 表示一直阻塞，time 大于 0 表示等待指定的 time 后阻塞线程会被唤醒，这个 time 是个相对值，是个增量值，也就是相对当前时间累加 time 后当前线程就会被唤醒。 如果 isAbsolute 等于 true，并且 time 大于 0 表示阻塞后到指定的时间点后会被唤醒，这里 time 是个绝对的时间，是某一个时间点换算为 ms 后的值。另外当其它线程调用了当前阻塞线程的 interrupt 方法中断了当前线程时候，当前线程也会返回，当其它线程调用了 unpark 方法并且把当前线程作为参数时候当前线程也会返回。</span><br><span class="line">void unpark(Object thread) 唤醒调用 park 后阻塞的线程，参数为需要唤醒的线程。</span><br></pre></td></tr></table></figure>
<p>JDK8中新增了一些方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">long getAndSetLong(Object obj, long offset, long update) 方法 获取对象 obj 中偏移量为 offset 的变量 volatile 语义的值，并设置变量 volatile 语义的值为 update。</span><br><span class="line">long getAndAddLong(Object obj, long offset, long addValue) 方法 获取对象 obj 中偏移量为 offset 的变量 volatile 语义的值，并设置变量值为原始值 +addValue。</span><br></pre></td></tr></table></figure>

<h4 id="使用Unsafe"><a href="#使用Unsafe" class="headerlink" title="使用Unsafe"></a>使用Unsafe</h4><p>Unsafe不能直接使用，因为Unsafe是rt.jar包内的，由Bootstrap类加载器加载，而我们自定义的类是由AppClassLoader加载的，<code>getUnsafe</code>中包含对类的加载方式的鉴权：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private static final Unsafe theUnsafe = new Unsafe();</span><br><span class="line"></span><br><span class="line">public static Unsafe getUnsafe() &#123;</span><br><span class="line">    // 调用者的类</span><br><span class="line">    Class localClass = Reflection.getCallerClass();</span><br><span class="line"></span><br><span class="line">    // 类加载器鉴权plain</span><br><span class="line">    if (!VM.isSystemDomainLoader(localClass.getClassLoader())) &#123;</span><br><span class="line">      throw new SecurityException(&quot;Unsafe&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return theUnsafe;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 判断 paramClassLoader 是不是 BootStrap 类加载器</span><br><span class="line">public static boolean isSystemDomainLoader(ClassLoader paramClassLoader) &#123;</span><br><span class="line">    return paramClassLoader == null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果没有这里的鉴权，我们就可以随意使用Unsafe了，而Unsafe可以直接操作内存，非常不安全，因此需要做这个限制。<br>如果一定要使用Unsafe，可以采用反射的方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class UnsafeTest &#123;</span><br><span class="line"></span><br><span class="line">    static final Unsafe unsafe;</span><br><span class="line"></span><br><span class="line">    static final long stateOffset;</span><br><span class="line"></span><br><span class="line">    private volatile long state = 0;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 反射获取 Unsafe 的成员变量 theUnsafe</span><br><span class="line">            Field field = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);</span><br><span class="line">            field.setAccessible(true);</span><br><span class="line">            unsafe = (Unsafe) field.get(null);</span><br><span class="line"></span><br><span class="line">            //获取 state 在 TestUnSafe 中的偏移量</span><br><span class="line">            stateOffset = unsafe.objectFieldOffset(UnsafeTest.class.getDeclaredField(&quot;state&quot;));</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">            System.out.println(ex.getLocalizedMessage());</span><br><span class="line">            throw new Error(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        UnsafeTest test = new UnsafeTest();</span><br><span class="line">        Boolean sucess = unsafe.compareAndSwapInt(test, stateOffset, 0, 1);</span><br><span class="line">        System.out.println(sucess);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="LongAdder"><a href="#LongAdder" class="headerlink" title="LongAdder"></a>LongAdder</h3><p>高并发下AtomicLong的性能并不能让人接受，因为大量线程会同时尝试获取-修改的流程，而只有一个线程可以修改成功，其他线程进入下一次轮询尝试修改（自旋），这大大降低了CPU的利用率。<br>LongAdder采用分治的方式来提升效率：</p>
<ul>
<li>将对同一个变量的竞争划分为对多个Cell的竞争；</li>
<li>而且多个线程如果争夺同一个Cell失败，不会自旋CAS重试，而是尝试获取其他原子变量的锁；</li>
<li>最后获取当前值时候是把所有变量的值累加后在加上 base 返回的。</li>
</ul>
<p><img src="/imgs/%E5%B9%B6%E5%8F%91/LongAdder%E7%B1%BB%E5%9B%BE.png" alt="LongAdder类图" title="LongAdder类图"></p>
<ul>
<li>分治<br>LongAdder 维护了一个延迟初始化的原子性更新数组和一个基值变量<code>base</code>。数组的大小保持是 2 的 N 次方大小，数组表的下标使用每个线程的 hashcode 值的掩码表示，数组里面的变量实体是 <code>Cell</code> 类型。<br>LongAdder 继承自 Striped64 类，Striped64 内部维护着三个变量，LongAdder 的真实值其实是 base 的值与 Cell 数组里面所有 Cell元素值的累加，base 是个基础值默认是 0，cellsBusy 用来实现自旋锁，当创建 Cell 元素或者扩容 Cell 数组时候用来进行线程间的同步。</li>
<li>伪共享：Cell改进了AtomicLong，让原子性数组元素相邻存放，可以经常共享缓存行，以提高性能。</li>
<li>惰性加载：由于 Cells 占用内存相对比较大，所以并不会在应用启动时立刻创建，而是在需要时候在创建，也就是惰性加载，当一开始没有空间时候，所有的更新都是操作base变量。</li>
</ul>
<h4 id="Cell"><a href="#Cell" class="headerlink" title="Cell"></a>Cell</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@sun.misc.Contended static final class Cell &#123;</span><br><span class="line">    volatile long value;</span><br><span class="line">    Cell(long x) &#123; value = x; &#125;</span><br><span class="line">    final boolean cas(long cmp, long val) &#123;</span><br><span class="line">        return UNSAFE.compareAndSwapLong(this, valueOffset, cmp, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Unsafe mechanics</span><br><span class="line">    private static final sun.misc.Unsafe UNSAFE;</span><br><span class="line">    private static final long valueOffset;</span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; ak = Cell.class;</span><br><span class="line">            valueOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                (ak.getDeclaredField(&quot;value&quot;));</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="sum"><a href="#sum" class="headerlink" title="sum"></a>sum</h4><p>内部操作是累加所有 Cell 内部的 value 的值后累加 base。因为统计所有Cell时可能正好有部分Cell正被修改，或者数组进行了扩容，所以sum的值并不是精确的。</p>
<h4 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h4><p>重置操作：</p>
<ul>
<li>把base置为0；</li>
<li>如果 Cell 数组有元素，则元素值重置为 0。</li>
</ul>
<h4 id="sumThenReset"><a href="#sumThenReset" class="headerlink" title="sumThenReset"></a>sumThenReset</h4><p>sum 的改造版本，在计算 sum 累加对应的 cell 值后，把当前 cell 的值重置为 0，base 重置为 0。当多线程调用该方法时候会有问题，比如考虑第一个调用线程会清空 Cell 的值，后一个线程调用时候累加时候累加的都是 0 值。</p>
<h4 id="longValue"><a href="#longValue" class="headerlink" title="longValue"></a>longValue</h4><p>同sum。</p>
<h4 id="add-long-x"><a href="#add-long-x" class="headerlink" title="add(long x)"></a>add(long x)</h4><p>累加增量 x 到原子变量，这个过程是原子性的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void add(long x) &#123;</span><br><span class="line">    Cell[] as; long b, v; int m; Cell a;</span><br><span class="line">    // 尝试设置 base+=x，如果设置成功则直接返回</span><br><span class="line">    if ((as = cells) != null || !casBase(b = base, b + x)) &#123;</span><br><span class="line">        // 如果多个线程同时执行 casBase 可能会失败，此时尝试设置 cell+=x</span><br><span class="line">        boolean uncontended = true;</span><br><span class="line">        if (as == null || (m = as.length - 1) &lt; 0 || // 判断 cells 数组长度是否为 0</span><br><span class="line">                (a = as[getProbe() &amp; m]) == null || // 获取当前线程对应的 cell</span><br><span class="line">                !(uncontended = a.cas(v = a.value, v + x))) // 设置 cell+=x</span><br><span class="line">            // 如果 cells 长度为 0、cell 为 null 或 CAS 设置 cell 的值失败，则进行数组扩充和初始化</span><br><span class="line">            longAccumulate(x, null, uncontended);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// CAS 设置 base 的值为 val</span><br><span class="line">final boolean casBase(long cmp, long val) &#123;</span><br><span class="line">    return UNSAFE.compareAndSwapLong(this, BASE, cmp, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LongAccumulator"><a href="#LongAccumulator" class="headerlink" title="LongAccumulator"></a>LongAccumulator</h3><p>LongAdder 类是 LongAccumulator 的一个特例：</p>
<ul>
<li>LongAccumulator 相比于 LongAdder 可以提供累加器初始非 0 值，后者只能默认为0；</li>
<li>LongAccumulator可以指定累加规则，比如不是累加而是相乘，只需要在构造 LongAccumulator 时传入自定义的双目运算器；</li>
</ul>
<p>比如按下面这样初始化的LongAccumulator可以起到和LongAdder一样的作用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LongAccumulator accumulator = new LongAccumulator(new LongBinaryOperator() &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public long applyAsLong(long left, long right) &#123;</span><br><span class="line">        return left + right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, 0);</span><br></pre></td></tr></table></figure>



<h2 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h2><ol>
<li><p>Java中内置锁synchronized的原理？<br>synchronized怎么使用的（修饰代码块、静态方法、方法）。<br>synchronized涉及到的内存结构：<br> *<br> *<br>synchronized</p>
</li>
<li><p>什么是 Java 中原子性操作？<br>原子性操作保证了原子性，即操作要么全部发生要么全部不发生，中间不会被线程调度机制打断，也不会发生任何上下文切换，在Java中是通过CAS实现的。</p>
</li>
<li><p>什么是 Java 中的 CAS 操作，AtomicLong 的实现原理？</p>
</li>
<li><p>乐观锁相对悲观锁的优势？加锁的开销是什么？<br>乐观锁没有加锁的开销。<br>加锁开销主要在于用户态和内核态之间的切换：申请锁时，从用户态进入内核态，申请成功后从内核态返回用户态，没有申请到时阻塞在内核态；使用完资源后释放锁，从用户态进入内核态，唤醒其他正在阻塞等待锁的进程，返回用户态。<br>竞争锁的线程变多，会间接导致线程上下文切换变得频繁，这个开销主要包括CPU寄存器保存和加载。</p>
</li>
<li><p>CAS有什么问题？如何解决ABA问题？<br>CAS操作存在ABA问题，简而言之，就是一个值为A的变量被改成B后又被改回来了。解决办法是给该变量加版本号，每次修改的同时增加该版本号，并且需要保证写入和修改版本号这两个操作是原子的，<strong>AtomicStampedReference</strong>提供了这种特性，其中保存的值类型是<code>Pair&lt;reference, stamp&gt;</code>，通过<code>UNSAFE.compareAndSwapObject</code>来修改这个值。</p>
</li>
<li><p>原子变量在性能上有什么问题？<br>原子变量的原理是使用CAS操作自旋判断值是否与期望的一致，如果并发线程特别多就会出现空轮询，导致浪费大量CPU资源，解决办法是采用<code>LongAdder</code>，<code>LongAdder</code>的原理是分治，将由原来对一个变量的自旋操作改成了对多个变量的自旋操作，如果其中一个获取失败则转而获取另一个，可以减少冲突，增加加锁成功的几率，打个比方，就像原来只有一台服务器提供web服务，随着并发量的增长，需要增加几台服务器来均衡负载。</p>
</li>
<li><p>什么是可重入锁、乐观锁、悲观锁、公平锁、非公平锁、独占锁、共享锁？</p>
</li>
<li><p>抽象同步队列 AQS (AbstractQueuedSynchronizer) 概述，AQS 是实现同步的基础组件，并发包中锁的实现底层就是使用 AQS 实现，虽然大多数开发者可能从来不会直接用到 AQS，但是知道其原理对于架构设计还是很有帮助的。<br>AQS主要结构包含一个state和一个双向队列：</p>
<ul>
<li>state在不同的并发工具中有不同的含义，比如，ReentrantLock中，state记录了锁的重入次数，而在ReentrantReadWriteLock中，state的高16位记录了读线程的数量，而低16位记录了写线程的重入次数；</li>
<li>双向队列中的Node保存的是线程，一般用于实现公平锁。<br>AQS的主要操作包含获取和释放资源：</li>
<li>线程获取资源——比如ReentrantLock中的lock，会设置状态变量state的值，如果没有获取成功则会调用LockSupport.park(thread)挂起，如果是公平锁，还需要先将当前线程插入到一个双向队列中。</li>
<li>线程释放资源——比如ReentrantLock中的unlock，就是设置状态变量 state 的值，然后调用 LockSupport.unpark(thread) 激活 AQS 队列里面最早被阻塞的线程 (thread)。被激活的线程则尝试看当前状态变量 state 的值是否能满足自己的需要，满足则该线程被激活然后继续向下运行，否则还是会被放入 AQS 队列并被挂起。</li>
</ul>
</li>
<li><p>AQS中的state变量为什么是volatile的？<br>因为AQS需要通过CAS操作state从而保证原子性，CAS操作需要变量具有可见性。</p>
</li>
<li><p>AQS中用到的LockSupport是什么？<br>LockSupport是一个同步工具类，主要用于替代Object中的wait和notify方法，相对wait&#x2F;notify来说更易用：</p>
<ul>
<li>wait&#x2F;notify必须在加锁状态下才能使用，而LockSupport没有这个要求；</li>
<li>LockSupport可以指定某个线程唤醒，而notify只能随机唤醒一个线程；</li>
<li>notify后wait会死锁，而LockSupport.unpark后park不会死锁（因为LockSupport控制的是许可证）</li>
</ul>
</li>
<li><p>独占锁 ReentrantLock 原理探究，ReentrantLock 是可重入的独占锁或者叫做排它锁，同时只能有一个线程可以获取该锁，其实现分为公平与非公平的独占锁。</p>
</li>
<li><p>ReentrantLock怎么实现公平和非公平锁？<br>非公平锁每次获取时直接通过CAS操作设置state，而公平锁在设置失败后会先将当前线程插入一个双向队列中排队，当检查state&#x3D;0时还需要判断队列中没有其他线程才可以获取锁成功。</p>
</li>
<li><p>读写锁 ReentrantReadWriteLock 原理，ReentrantLock 是独占锁，同时只有一个线程可以获取该锁，而实际情况下会有写少读多的场景，显然 ReentrantLock 满足不了需求，所以 ReentrantReadWriteLock 应运而生，本文来介绍读写分离锁的实现。</p>
<ul>
<li>读锁，加锁前会额外检查是否写锁被人占用，加锁成功后，如果当前线程是第一次加该读锁，则state高16位+1，如果是第二次加读锁则不会修改state而是修改一个ThreadLocal变量+1；</li>
<li>读锁，释放锁后，判断state归零则唤醒AQS队列中下一个线程；</li>
<li>写锁，加锁前检查state是否为0（为0表示读锁和写锁都没有被占用）；</li>
<li>写锁，释放锁后，唤醒AQS队列中下一个线程。</li>
</ul>
</li>
<li><p>ReentrantReadWriteLock是可重入的，但是同一个线程又加读锁又加写锁为什么会死锁？<br>这个与可重入无关，因为读锁和写锁分别使用的是state的高16位和低16位，计算可重入时并不会互相影响。</p>
</li>
<li><p>Condition的实现原理？<br>Condition相当于一个0-1信号量，主要用于模拟线程间的协调。可以通过lock.newCondition()来创建，使用时需要先使用lock加锁，condition.await会释放原lock里的state，然后其他线程lock就可以进入临界区了。</p>
</li>
<li><p>JUC 中倒数计数器 CountDownLatch 的使用与原理分析，当需要等待多个线程执行完毕后在做一件事情时候 CountDownLatch 是比调用线程的 join 方法更好的选择，CountDownLatch 与 线程的 join 方法区别是什么？<br>join相对CountDownLatch来说不够灵活：</p>
<ul>
<li>调用一个线程的 join 后，该线程会一直被阻塞直到该线程运行完毕，而 CountDownLatch 则可以在子线程运行完毕或运行过程中递减计数器，从而让 await 返回。</li>
<li>另外，使用线程池来管理线程时候一般都是直接添加一个 Runnable 实例到线程池，这时就不方便再调用线程的 join 方法了。<br>CountDownLatch的原理简而言之，就是把AQS的state当做一个计数器，countDown时-1，await就是一直在等待state变0。</li>
</ul>
</li>
<li><p>JUC 中 回环屏障 CyclicBarrier 的使用与分析，它也可以实现像 CountDownLatch 一样让一组线程全部到达一个状态后再全部同时执行，但是 CyclicBarrier 可以被复用。那么 CyclicBarrier 内部的实现与 CountDownLatch 有何不同那？</p>
</li>
<li><p>ThreadLocal 的实现原理，ThreadLocal 作为变量的线程隔离方式，其内部是如何做的？</p>
</li>
<li><p>InheritableThreadLocal 的实现原理，InheritableThreadLocal 是如何弥补 ThreadLocal 不支持继承的特性？</p>
</li>
<li><p>经常使用的随机数生成器 Random 类的原理是什么？及其局限性是什么？ThreadLocalRandom 是如何利用 ThreadLocal 的原理来解决 Random 的局限性？</p>
</li>
<li><p>ThreadLocal 的一个使用场景，Spring 框架中 Scope 作用域 Bean 的实现原理。</p>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="内置锁"><a href="#内置锁" class="headerlink" title="内置锁"></a>内置锁</h3><ol>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/36eedeb3f912">浅谈偏向锁、轻量级锁、重量级锁</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35190492/article/details/106180781">死磕Synchronized底层实现</a></li>
</ol>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.6.0/dist/mindmap.min.css">
    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag"># 并发</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/3b3d260d.html" rel="prev" title="并发和中间件">
                  <i class="fa fa-angle-left"></i> 并发和中间件
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/e94a0a.html" rel="next" title="Redis 应用">
                  Redis 应用 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">tallate</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/tallate" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"version":"7.1.2","options":null,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.3.0/mermaid.min.js","integrity":"sha256-9y71g5Lz/KLsHjB8uXwnkuWDtAMDSzD/HdIbqhJfTAI="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>





  





</body>
</html>
